---
edit_url: "https://github.com/dhis2/dhis2-docs/blob/2.35/src/commonmark/en/content/developer/web-api.md"
revision_date: '2020-12-27'
template: single.html
---

# Web API { #webapi } 

<!--DHIS2-SECTION-ID:webapi-->

L'API Web est un composant qui permet aux systèmes externes d'accéder 
aux données stockées dans une instance DHIS2 et de les manipuler. Plus 
précisément, elle fournit une interface programmatique à un large éventail de 
données exposées et de méthodes de service pour des applications telles que des clients 
logiciels tiers, des portails web et des modules DHIS2 internes.

## Introduction { #webapi_introduction } 

<!--DHIS2-SECTION-ID:webapi_introduction-->

The Web API adheres to many of the principles behind the REST
architectural style. To mention some few and important ones:

1.  Les éléments fondamentaux sont appelés *ressources*. Une 
    ressource peut être tout ce qui est exposé sur le web, d'un document à un 
    processus d'entreprise - tout ce avec quoi un client peut vouloir interagir.
    Les aspects informatifs d'une ressource peuvent être récupérés ou échangés 
    par le biais de *représentations* de la ressource. Une représentation est une vue de 
    resource's state at any given time. For instance, the *reportTable*
    resource in DHIS2 represents a tabular report of aggregated data for
    un certain ensemble de paramètres. Cette ressource peut être récupérée dans 
    variety of representation formats including HTML, PDF, and MS Excel.

2.  Toutes les ressources peuvent être identifiées de manière unique par un *URI* (également 
    appelé *URL*). Toutes les ressources ont une représentation par défaut. Vous pouvez 
    indiquer que vous êtes intéressé par une représentation spécifique en 
    fournissant un en-tête HTTP *Accept*, une extension de fichier ou un paramètre de requête *format*. 
    query parameter. So in order to retrieve the PDF representation of a
    report table you can supply an *Accept: application/pdf* header or
    append *.pdf* or *?format=pdf* to your request URL.

3.  Les interactions avec l'API nécessitent l'utilisation correcte des *méthodes* ou 
    *verbes* HTTP. Cela implique que pour une ressource, vous devez émettre une requête *GET* 
    lorsque vous souhaitez la récupérer, une requête *POST* lorsque vous souhaitez 
    en créer une, une requête *PUT* lorsque vous souhaitez la mettre à jour et une requête *DELETE* lorsque 
    you want to remove it. So if you want to retrieve the default
    representation of a report table you can send a GET request to e.g.
    */reportTable/iu8j/hYgF6t*, where the last part is the report table
    identifier.

4.  Resource representations are *linkable*, meaning that
    representations advertise other resources which are relevant to the
    current one by embedding links into itself (please be aware that you
    need to request *href* in your field filter to have this working.
    This feature greatly improves the usability and robustness of the
    API as we will see later. For instance, you can easily navigate to
    the indicators which are associated with a report table from the
    *reportTable* resource through the embedded links using your
    preferred representation format.

While all of this might sound complicated, the Web API is actually very
simple to use. We will proceed with a few practical examples in a
minute.

## Authentification { #webapi_authentication } 

<!--DHIS2-SECTION-ID:webapi_authentication-->

The DHIS2 Web API supports two protocols for authentication, Basic
Authentication and OAuth 2. You can verify and get information about the
currently authenticated user by making a GET request to the following
URL:

    /api/33/me

Et plus d'informations sur les autorisations (et si un utilisateur a une certaine 
autorisation) en utilisant les points d'extrémité :

    /api/33/me/authorities
    /api/33/me/authorities/ALL

### L'authentification de base { #webapi_basic_authentication } 

<!--DHIS2-SECTION-ID:webapi_basic_authentication-->

L'API Web DHIS2 prend en charge *l'authentification de base*. L'authentification de base 
est une technique permettant aux clients d'envoyer des informations d'identification par HTTP à un 
serveur web. Techniquement parlant, le nom d'utilisateur est suivi de deux points et 
le mot de passe, encodé en Base64, est préfixé par Basic et fourni en tant que valeur 
de l'en-tête HTTP *Autorisation*. De manière plus formelle, il s'agit de : 

    Autorisation : Basic base64encode( nom d'utilisateur:mot de passe)

Most network-aware development environments provide support for Basic 
authentication, such as *Apache HttpClient* and *Spring RestTemplate*. 
An important note is that this authentication scheme provides no security 
since the username and password are sent in plain text and can be easily 
observed by an attacker. Using Basic is recommended only if the server is 
using SSL/TLS (HTTPS) to encrypt communication with clients. Consider this 
a hard requirement in order to provide secure interactions with the Web 
API.

### Authentification à deux facteurs { #webapi_2fa } 

<!--DHIS2-SECTION-ID:webapi_2fa-->

DHIS2 supports two-factor authentication. This can be enabled per user.
When enabled, users will be asked to enter a 2FA code when logging in. You 
can read more about 2FA [here](https://www.google.com/landing/2step/).

### OAuth2 { #webapi_oauth2 } 

<!--DHIS2-SECTION-ID:webapi_oauth2-->

DHIS2 supporte le protocole d'authentification *OAuth2*. OAuth2 est une norme 
ouverte d'autorisation qui permet aux clients tiers de se 
connecter au nom d'un utilisateur DHIS2 et d'obtenir un *jeton porteur* réutilisable 
pour les demandes ultérieures à l'API Web. DHIS2 ne prend pas en charge les rôles 
OAuth2 à granularité fine, mais fournit aux applications un accès basé sur les rôles 
de l'utilisateur DHIS2.

Chaque client pour lequel vous souhaitez autoriser l'authentification OAuth 2 doit être
enregistré dans DHIS2. Pour ajouter un nouveau client OAuth2, allez dans `Applications > Paramètres > Clients OAuth2`
dans l'interface utilisateur, cliquez sur *Ajouter nouveau* et entrez le nom du client souhaité et les types de subventions.

#### Ajouter un client à l'aide de l'API Web { #adding-a-client-using-the-web-api } 

Un client OAuth2 peut être ajouté via l'API Web. Par exemple, nous pouvons
envoyer une charge utile comme celle-ci :

```json
{
  "name": "OAuth2 Demo Client",
  "cid": "demo",
  "secret": "1e6db50c-0fee-11e5-98d0-3c15c2c6caf6",
  "grantTypes": [
    "password",
    "refresh_token",
    "authorization_code"
  ],
  "redirectUris": [
    "http://www.example.org"
  ]
}
```

La charge utile peut être envoyée avec la commande suivante :

```bash
SERVER="https://play.dhis2.org/dev"
curl -X POST -H "Content-Type: application/json" -d @client.json
  -u admin:district "$SERVER/api/oAuth2Clients"
```

Nous utiliserons ce client comme base pour nos prochains exemples de types de subventions.

#### Mot de passe du type d'octroi { #webapi_oauth2_password } 

<!--DHIS2-SECTION-ID:webapi_oauth2_password-->

Le type d'octroi le plus simple est le type d'octroi *mot de passe*. Ce 
type d'octroi est similaire à l'authentification de base en ce sens qu'il 
exige du client qu'il recueille le nom d'utilisateur et le mot de passe de l'utilisateur. Prenons 
l'exemple de notre serveur de démonstration :

```bash
SERVER="https://play.dhis2.org/dev"
SECRET="1e6db50c-0fee-11e5-98d0-3c15c2c6caf6"

curl -X POST -H "Accept: application/json" -u demo:$SECRET "$SERVER/uaa/oauth/token"
  -d grant_type=password -d username=admin -d password=district
```

Vous obtiendrez une réponse similaire à ceci :

```json
{
  "expires_in": 43175,
  "scope": "ALL",
  "access_token": "07fc551c-806c-41a4-9a8c-10658bd15435",
  "refresh_token": "a4e4de45-4743-481d-9345-2cfe34732fcc",
  "token_type": "bearer"
}
```

Pour l'instant, nous allons nous concentrer sur le `access_token`, qui 
sera utilisé comme jeton d'authentification (porteur). A titre d'exemple, nous allons obtenir 
tous les éléments de données en utilisant notre jeton :

```bash
SERVER="https://play.dhis2.org/dev"
curl -H "Authorization: Bearer 07fc551c-806c-41a4-9a8c-10658bd15435" "$SERVER/api/33/dataElements.json"
```

#### Type d'octroi rafraîchir\_jeton { #webapi_refresh_token } 

<!--DHIS2-SECTION-ID:webapi_refresh_token-->

En général, les jetons d'accès ont une validité limitée. Vous pouvez jeter un coup d'oeil 
à la propriété `expires_in` ( expire en) de la réponse dans l'exemple précédent 
pour comprendre quand un jeton expire. Pour obtenir un nouveau `access_token` (jeton d'accès), vous 
pouvez faire un autre aller-retour vers le serveur et utiliser `refresh_token` (rafraîchir le jeton) 
qui vous permet d'obtenir un jeton mis à jour sans avoir besoin de demander les 
informations d'identification de l'utilisateur une fois de plus.

```bash
SERVER="https://play.dhis2.org/dev"
SECRET="1e6db50c-0fee-11e5-98d0-3c15c2c6caf6"
REFRESH_TOKEN="a4e4de45-4743-481d-9345-2cfe34732fcc"

curl -X POST -H "Accept: application/json" -u demo:$SECRET "$SERVER/uaa/oauth/token"
  -d "grant_type=refresh_token" -d "refresh_token=$REFRESH_TOKEN"
```

La réponse sera exactement la même que lorsque vous obtenez un jeton au départ.

#### Type de subvention code_d'autorisation { #webapi_authorization_code } 

<!--DHIS2-SECTION-ID:webapi_authorization_code-->

Le type de subvention « code autorisé » est l'approche recommandée si vous ne souhaitez 
pas stocker les informations d'identification de l'utilisateur en externe. Elle permet au DHIS2 de collecter le 
nom d'utilisateur et le mot de passe directement auprès de l'utilisateur au lieu que le client 
les collecte et s'authentifie ensuite au nom de l'utilisateur. Veuillez noter 
que cette approche utilise la partie `redirectUris` de la charge utile du 
client.

Step 1: Visit the following URL using a web browser. If you have more than one
redirect URIs, you might want to add `&redirect_uri=http://www.example.org` 
to the URL:

```bash
SERVER="https://play.dhis2.org/dev"
$SERVER/uaa/oauth/authorize?client_id=demo&response_type=code
```

Étape 2 : Une fois que l'utilisateur s'est connecté avec succès et a accepté votre accès client
il sera redirigé vers votre uri de redirection comme suit :

    http://www.example.org/?code=XYZ

Étape 3 : Cette étape est similaire à celle de l'octroi du mot de passe,
en utilisant le code fourni, nous allons maintenant demander un jeton d'accès :

```bash
SERVER="https://play.dhis2.org/dev"
SECRET="1e6db50c-0fee-11e5-98d0-3c15c2c6caf6"

curl -X POST -u demo:$SECRET -H "Accept: application/json" $SERVER/uaa/oauth/token
-d "grant_type=authorization_code" -d "code=XYZ"
```

## Messages d'erreur et d'information { #webapi_error_info_messages } 

<!--DHIS2-SECTION-ID:webapi_error_info_messages-->

L'API Web utilise un format cohérent pour tous les messages d'erreur, d'avertissement et 
d'information :

```json
{
  "httpStatus": "Forbidden",
  "message": "Vous n'avez pas la permission de lire ce type d'objet.",
  "httpStatusCode": 403,
  "status": "ERROR"
}
```

Here we can see from the message that the user tried to access a
resource I did not have access to. It uses the http status code 403, the
http status message *forbidden* and a descriptive message.

<table>
<caption>WebMessage properties</caption>
<colgroup>
<col style="width: 13%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>httpStatus</td>
<td>HTTP Status message for this response, see RFC 2616 (Section 10) for more information.</td>
</tr>
<tr class="even">
<td>httpStatusCode</td>
<td>HTTP Status code for this response, see RFC 2616 (Section 10) for more information.</td>
</tr>
<tr class="odd">
<td>status</td>
<td>DHIS2 status, possible values are <em>OK</em> | <em>WARNING</em> | <em>ERROR</em>, where `OK` means everything was successful, `ERROR` means that operation did not complete and `WARNING` means the operation was partially successful, if the message contains a `response` property, please look there for more information.</td>
</tr>
<tr class="even">
<td>message</td>
<td>A user-friendly message telling whether the operation was a success or not.</td>
</tr>
<tr class="odd">
<td>devMessage</td>
<td>A more technical, developer-friendly message (not currently in use).</td>
</tr>
<tr class="even">
<td>response</td>
<td>Extension point for future extension to the WebMessage format. This will be documented when it starts being used.</td>
</tr>
</tbody>
</table>

## Format de la date et de la période { #webapi_date_perid_format } 

<!--DHIS2-SECTION-ID:webapi_date_perid_format-->

Tout au long de l'API Web, nous faisons référence à des dates et à des périodes. Le format de la date
est le suivant :

    aaaa-MM-jj

Par exemple, si vous voulez exprimer le 20 mars 2014, vous devez utiliser
*2014-03-20*.

Le format de la période est décrit dans le tableau suivant (également disponible sur 
le point d'extrémité de l'API `/api/periodTypes`)

<table style="width:100%;">
<caption>Period format</caption>
<colgroup>
<col style="width: 24%" />
<col style="width: 21%" />
<col style="width: 18%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr class="header">
<th>Interval</th>
<th>Format</th>
<th>Example</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Day</td>
<td><em>yyyyMMdd</em></td>
<td>20040315</td>
<td>March 15, 2004</td>
</tr>
<tr class="even">
<td>Week</td>
<td><em>yyyy</em>W<em>n</em></td>
<td>2004W10</td>
<td>Week 10 2004</td>
</tr>
<tr class="odd">
<td>Week Wednesday</td>
<td><em>yyyy</em>WedW<em>n</em></td>
<td>2015WedW5</td>
<td>Week 5 with start Wednesday</td>
</tr>
<tr class="even">
<td>Week Thursday</td>
<td><em>yyyy</em>ThuW<em>n</em></td>
<td>2015ThuW6</td>
<td>Week 6 with start Thursday</td>
</tr>
<tr class="odd">
<td>Week Saturday</td>
<td><em>yyyy</em>SatW<em>n</em></td>
<td>2015SatW7</td>
<td>Week 7 with start Saturday</td>
</tr>
<tr class="even">
<td>Week Sunday</td>
<td><em>yyyy</em>SunW<em>n</em></td>
<td>2015SunW8</td>
<td>Week 8 with start Sunday</td>
</tr>
<tr class="odd">
<td>Bi-week</td>
<td><em>yyyy</em>BiW<em>n</em></td>
<td>2015BiW1</td>
<td>Week 1-2 20015</td>
</tr>
<tr class="even">
<td>Month</td>
<td><em>yyyyMM</em></td>
<td>200403</td>
<td>March 2004</td>
</tr>
<tr class="odd">
<td>Bi-month</td>
<td><em>yyyyMM</em>B</td>
<td>200401B</td>
<td>January-February 2004</td>
</tr>
<tr class="even">
<td>Quarter</td>
<td><em>yyyy</em>Q<em>n</em></td>
<td>2004Q1</td>
<td>January-March 2004</td>
</tr>
<tr class="odd">
<td>Six-month</td>
<td><em>yyyy</em>S<em>n</em></td>
<td>2004S1</td>
<td>January-June 2004</td>
</tr>
<tr class="even">
<td>Six-month April</td>
<td><em>yyyy</em>AprilSn</td>
<td>2004AprilS1</td>
<td>April-September 2004</td>
</tr>
<tr class="odd">
<td>Year</td>
<td>yyyy</td>
<td>2004</td>
<td>2004</td>
</tr>
<tr class="even">
<td>Financial Year April</td>
<td>yyyyApril</td>
<td>2004April</td>
<td>Apr 2004-Mar 2005</td>
</tr>
<tr class="odd">
<td>Financial Year July</td>
<td>yyyyJuly</td>
<td>2004July</td>
<td>July 2004-June 2005</td>
</tr>
<tr class="even">
<td>Financial Year Oct</td>
<td>yyyyOct</td>
<td>2004Oct</td>
<td>Oct 2004-Sep 2005</td>
</tr>
</tbody>
</table>


### Périodes relatives { #webapi_date_relative_period_values } 

<!--DHIS2-SECTION-ID:webapi_date_relative_period_values-->


Dans certaines parties de l'API, comme pour la ressource analytique, vous pouvez 
utiliser des périodes relatives en plus des périodes fixes (définies ci-dessus). 
Les périodes relatives sont relatives à la date actuelle et permettent, par exemple, 
de créer des rapports dynamiques. Les valeurs disponibles pour les périodes relatives sont les suivantes :

    THIS_WEEK, LAST_WEEK, LAST_4_WEEKS, LAST_12_WEEKS, LAST_52_WEEKS,
    THIS_MONTH, LAST_MONTH, THIS_BIMONTH, LAST_BIMONTH, THIS_QUARTER, LAST_QUARTER,
    THIS_SIX_MONTH, LAST_SIX_MONTH, MONTHS_THIS_YEAR, QUARTERS_THIS_YEAR,
    THIS_YEAR, MONTHS_LAST_YEAR, QUARTERS_LAST_YEAR, LAST_YEAR, LAST_5_YEARS, LAST_12_MONTHS,
    LAST_3_MONTHS, LAST_6_BIMONTHS, LAST_4_QUARTERS, LAST_2_SIXMONTHS, THIS_FINANCIAL_YEAR,
    LAST_FINANCIAL_YEAR, LAST_5_FINANCIAL_YEARS

## Schémas d'identification { #webapi_identifier_schemes } 

<!--DHIS2-SECTION-ID:webapi_identifier_schemes-->

This section provides an explanation of the identifier scheme concept.
Identifier schemes are used to map metadata objects to other metadata
during import, and to render metadata as part of exports. Please note
that not all schemes work for all API calls, and not all
schemes can be used for both input and output. This is outlined in the
sections explaining the various Web APIs.

Tous les types d'objets disponibles pour le schéma d'identification sont énumérés ci-dessous. Sont fournis les noms des propriétés à utiliser dans les requêtes :

  - idScheme

  - dataElementIdScheme (Schéma d'identifiant d'élément de données)

  - categoryOptionComboIdScheme (Schéma de l'identifiant de la combinaison d'options de catégorie)

  - orgUnitIdScheme (Schéma de l'identifiant de l'unité d'organisation)

  - programIdScheme (Schéma d'identification du programme)

  - programmeStageIdScheme (Schéma d'identification de l'étape de programme)

  - trackedEntityIdScheme (schéma d'identification de l'entité suivie)

  - trackedEntityAttributeIdScheme (schéma d'identification de l'attribut d'entité suivie)

Le schéma d'identification général (idScheme) s'applique à tous les types d'objets. Il peut être remplacé par des types d'objets spécifiques.

Le schéma par défaut pour tous les paramètres est UID (identifiants stables de DHIS2). Les schémas d'identification pris en charge sont décrits dans le tableau ci-dessous.

<table>
<caption>Scheme Values</caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>Scheme</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ID, UID</td>
<td>Match on DHIS2 stable Identifier, this is the default id scheme.</td>
</tr>
<tr class="even">
<td>CODE</td>
<td>Match on DHIS2 Code, mainly used to exchange data with an external system.</td>
</tr>
<tr class="odd">
<td>NAME</td>
<td>Match on DHIS2 Name, please note that this uses what is available as <em>object.name</em>, and not the translated name. Also note that names are not always unique, and in that case, they can not be used.</td>
</tr>
<tr class="even">
<td>ATTRIBUTE:ID</td>
<td>Match on metadata attribute, this attribute needs to be assigned to the type you are matching on, and also that the unique property is set to <em>true</em>. The main usage of this is also to exchange data with external systems, it has some advantages over <em>CODE</em> since multiple attributes can be added, so it can be used to synchronize with more than one system.</td>
</tr>
</tbody>
</table>

Note that identifier schemes is not an independent feature but needs to
be used in combination with resources such as data value import and metadata import.

Par exemple, pour spécifier CODE comme schéma d'identification général et le remplacer par UID pour le schéma d'identification de l'unité d'organisation, vous pouvez utiliser les requêtes suivantes : 

    ?idScheme=CODE&orgUnitIdScheme=UID

Autre exemple, pour spécifier un attribut pour le schéma d'identification de l'unité d'organisation, un code pour le schéma d'identification de l'élément de données et utiliser le schéma d'identification par défaut UID pour tous les autres objets, vous pouvez utiliser les paramètres suivants :

    ?orgUnitIdScheme=ATTRIBUTE:j38fk2dKFsG&dataElementIdScheme=CODE

## Navigation dans l'API Web { #webapi_browsing_the_web_api } 

<!--DHIS2-SECTION-ID:webapi_browsing_the_web_api-->

The entry point for browsing the Web API is `/api`. This resource
provides links to all available resources. Four resource representation
formats are consistently available for all resources: HTML, XML, JSON, 
and JSONP. Some resources will have other formats available, like MS
Excel, PDF, CSV, and PNG. To explore the API from a web browser, navigate
to the `/api` entry point and follow the links to your desired
resource, for instance `/api/dataElements`. For all resources which
return a list of elements certain query parameters can be used to modify
the response:

<table style="width:100%;">
<caption>Query parameters</caption>
<colgroup>
<col style="width: 11%" />
<col style="width: 20%" />
<col style="width: 12%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="header">
<th>Param</th>
<th>Option values</th>
<th>Default option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>paging</td>
<td>true | false</td>
<td>true</td>
<td>Indicates whether to return lists of elements in pages.</td>
</tr>
<tr class="even">
<td>page</td>
<td>number</td>
<td>1</td>
<td>Defines which page number to return.</td>
</tr>
<tr class="odd">
<td>pageSize</td>
<td>number</td>
<td>50</td>
<td>Defines the number of elements to return for each page.</td>
</tr>
<tr class="even">
<td>order</td>
<td>property:asc/iasc/desc/idesc</td>
<td></td>
<td>Order the output using a specified order, only properties that are both persisted and simple (no collections, idObjects etc) are supported. iasc and idesc are case insensitive sorting.</td>
</tr>
</tbody>
</table>

Voici un exemple de comment ces paramètres peuvent être utilisés pour obtenir une liste complète de groupes d'éléments de données dans un format de réponse XML :

    /api/dataElementGroups.xml?links=false&paging=false

Vous pouvez rechercher des éléments à partir de la propriété "nom" au lieu de renvoyer toute une liste d'éléments à l'aide de la variable de requête *query*. Dans cet exemple, nous recherchons tous les éléments de données dont le nom contient le mot "anémie" :

    /api/dataElements?query=anaemia

Vous pouvez obtenir des pages spécifiques et des tailles de page pour des objets en utilisant la requête suivante :

    /api/dataElements.json?page=2&pageSize=20

Vous pouvez désactiver complètement la pagination à l'aide de cette requête :

    /api/indicatorGroups.json?paging=false

Pour que le résultat soit ordonné selon une propriété spécifique :

    /api/indicators.json?order=shortName:desc

La ressource *identifiableObjects* vous permet de rechercher tout objet à partir de son identifiant, quel que soit son type :

    /api/identifiableObjects/<id>

### Traduction { #webapi_translation } 

<!--DHIS2-SECTION-ID:webapi_translation-->

DHIS2 supports translations of database content, such as data elements,
indicators, and programs. All metadata objects in the Web API have
properties meant to be used for display / UI purposes, which include
*displayName*, *displayShortName* and *displayDescription*.

<table>
<caption>Translate options</caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 16%" />
<col style="width: 62%" />
</colgroup>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Values</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>translate</td>
<td>true | false</td>
<td>Translate display* properties in metadata output (displayName, displayShortName, displayDescription, and displayFormName for data elements). Default value is true.</td>
</tr>
<tr class="even">
<td>locale</td>
<td>Locale to use</td>
<td>Translate metadata output using a specified locale (requires translate=true).</td>
</tr>
</tbody>
</table>

### API de traduction { #webapi_translation_api } 

<!--DHIS2-SECTION-ID:webapi_translation_api-->

Les traductions d'un objet sont rendues comme faisant partie de l'objet lui-même dans le tableau *traductions*. Le tableau *traductions* qui figure dans les charges JSON/XML est normalement préfiltré pour vous, ce qui signifie qu'il ne peut pas être utilisé directement pour importer/exporter des traductions (car cela aurait pour effet de remplacer les langues autres que celles des utilisateurs actuellement connectés).

Exemple d'élément de données dont le tableau de traduction est filtré sur la langue de l'utilisateur :

```json
{
  "id": "FTRrcoaog83",
  "displayName": "Accute French",
  "translations": [
    {
      "property": "SHORT_NAME",
      "locale": "fr",
      "value": "Accute French"
    },
    {
      "property": "NAME",
      "locale": "fr",
      "value": "Accute French"
    }
  ]
}
```

Exemple d'élément de données dont les traductions sont désactivées :

```json
{
  "id": "FTRrcoaog83",
  "displayName": "Accute Flaccid Paralysis (Deaths < 5 yrs)",
  "translations": [
    {
      "property": "FORM_NAME",
      "locale": "en_FK",
      "value": "aa"
    },
    {
      "property": "SHORT_NAME",
      "locale": "en_GB",
      "value": "Accute Flaccid Paral"
    },
    {
      "property": "SHORT_NAME",
      "locale": "fr",
      "value": "Accute French"
    },
    {
      "property": "NAME",
      "locale": "fr",
      "value": "Accute French"
    },
    {
      "property": "NAME",
      "locale": "en_FK",
      "value": "aa"
    },
    {
      "property": "DESCRIPTION",
      "locale": "en_FK",
      "value": "aa"
    }
  ]
}
```

Notez que même si vous obtenez un résultat non filtré, et que vous utilisez le type de point d'extrémité approprié, c'est-à-dire `/api/dataElements`, nous n'autorisons pas les mises à jour, car cela pourrait facilement entraîner des erreurs et remplacer les autres langues disponibles.

Pour lire et mettre à jour les traductions, vous pouvez utiliser le point d'extrémité spécial "traductions" pour chaque ressource d'objet. Vous pouvez y accéder en utilisant *GET* ou *PUT* sur le point d'extrémité `/api/<object-type>/<object-id>/translations` approprié.

As an example, for a data element with identifier `FTRrcoaog83`, you could use
`/api/dataElements/FTRrcoaog83/translations` to get and update
translations. The fields available are `property` with options *NAME*,
*SHORT_NAME*, *DESCRIPTION*, `locale` which supports any valid
locale ID and the translated property `value`.

Exemple de propriété NOM pour la langue française :

```json
{
  "property": "NAME",
  "locale": "fr",
  "value": "Paralysie Flasque Aiguë (Décès <5 ans)"
}
```

Cette charge est ensuite ajoutée à un tableau de traduction et renvoyée au point d'extrémité approprié :

```json
{
  "translations": [
    {
      "property": "NAME",
      "locale": "fr",
      "value": "Paralysie Flasque Aiguë (Décès <5 ans)"
    }
  ]
}
```

Pour un élément de données dont l'ID est *FTRrcoaog83*, vous pouvez effectuer une requête *PUT* comme suit : `/api/dataElements/FTRrcoaog83/translations`. Assurez-vous d'envoyer toutes les traductions disponibles pour cet objet et pas seulement pour une langue (sinon vous risquez de remplacer les langues existantes par d'autres langues).

### Versions de l'API Web { #webapi_api_versions } 

<!--DHIS2-SECTION-ID:webapi_api_versions-->

L'API Web est versionnée à partir de DHIS 2.25. La version de l'API suit la numérotation des versions majeures de DHIS2. Par exemple, la version de l'API pour DHIS 2.33 est `33`.

Vous pouvez accéder à une version spécifique de l'API en incluant le numéro de version après `/api`, comme dans l'exemple suivant :

    /api/33/dataElements

Si vous omettez la partie version de l'URL, le système utilisera la version actuelle de l'API. Par exemple, pour DHIS 2.25, si vous omettez la partie de l'API, le système utilisera la version 25 de l'API. Lors du développement de clients API, il est recommandé d'utiliser des versions API explicites (plutôt que d'omettre la version de l'API), car cela protégera le client contre les modifications imprévues de l'API.

Les trois dernières versions de l'API seront prises en charge. Par exemple, la version 2.27 de DHIS va prendre en charge les versions 27, 26 et 25 de l'API.

Notez que le modèle de métadonnées n'est pas versionné et que des changements peuvent survenir, par exemple dans les associations entre objets. Ces changements seront documentés dans les notes de mise à jour de la version principale de DHIS2.

## Filtre sur les objets de métadonnées { #webapi_metadata_object_filter } 

<!--DHIS2-SECTION-ID:webapi_metadata_object_filter-->

To filter the metadata there are several filter operations that can be
applied to the returned list of metadata. The format of the filter
itself is straight-forward and follows the pattern
*property:operator:value*, where *property* is the property on the
metadata you want to filter on, *operator* is the comparison operator
you want to perform and *value* is the value to check against (not all
operators require value). Please see the *schema* section to discover
which properties are available. Recursive filtering, ie. filtering on
associated objects or collection of objects, is supported as well.

<table>
<caption>Available Operators</caption>
<thead>
<tr class="header">
<th>Operator</th>
<th>Types</th>
<th>Value required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>eq</td>
<td>string | boolean | integer | float | enum | collection (checks for size) | date</td>
<td>true</td>
<td>Equality</td>
</tr>
<tr class="even">
<td>!eq</td>
<td>string | boolean | integer | float | enum | collection (checks for size) | date</td>
<td>true</td>
<td>Inequality</td>
</tr>
<tr class="odd">
<td>ne</td>
<td>string | boolean | integer | float | enum | collection (checks for size) | date</td>
<td>true</td>
<td>Inequality</td>
</tr>
<tr class="even">
<td>like</td>
<td>string</td>
<td>true</td>
<td>Case sensitive string, match anywhere</td>
</tr>
<tr class="odd">
<td>!like</td>
<td>string</td>
<td>true</td>
<td>Case sensitive string, not match anywhere</td>
</tr>
<tr class="even">
<td>\$like</td>
<td>string</td>
<td>true</td>
<td>Case sensitive string, match start</td>
</tr>
<tr class="odd">
<td>!\$like</td>
<td>string</td>
<td>true</td>
<td>Case sensitive string, not match start</td>
</tr>
<tr class="even">
<td>like\$</td>
<td>string</td>
<td>true</td>
<td>Case sensitive string, match end</td>
</tr>
<tr class="odd">
<td>!like\$</td>
<td>string</td>
<td>true</td>
<td>Case sensitive string, not match end</td>
</tr>
<tr class="even">
<td>ilike</td>
<td>string</td>
<td>true</td>
<td>Case insensitive string, match anywhere</td>
</tr>
<tr class="odd">
<td>!ilike</td>
<td>string</td>
<td>true</td>
<td>Case insensitive string, not match anywhere</td>
</tr>
<tr class="even">
<td>\$ilike</td>
<td>string</td>
<td>true</td>
<td>Case insensitive string, match start</td>
</tr>
<tr class="odd">
<td>!\$ilike</td>
<td>string</td>
<td>true</td>
<td>Case insensitive string, not match start</td>
</tr>
<tr class="even">
<td>ilike\$</td>
<td>string</td>
<td>true</td>
<td>Case insensitive string, match end</td>
</tr>
<tr class="odd">
<td>!ilike\$</td>
<td>string</td>
<td>true</td>
<td>Case insensitive string, not match end</td>
</tr>
<tr class="even">
<td>gt</td>
<td>string | boolean | integer | float | collection (checks for size) | date</td>
<td>true</td>
<td>Greater than</td>
</tr>
<tr class="odd">
<td>ge</td>
<td>string | boolean | integer | float | collection (checks for size) | date</td>
<td>true</td>
<td>Greater than or equal</td>
</tr>
<tr class="even">
<td>lt</td>
<td>string | boolean | integer | float | collection (checks for size) | date</td>
<td>true</td>
<td>Less than</td>
</tr>
<tr class="odd">
<td>le</td>
<td>string | boolean | integer | float | collection (checks for size) | date</td>
<td>true</td>
<td>Less than or equal</td>
</tr>
<tr class="even">
<td>null</td>
<td>all</td>
<td>false</td>
<td>Property is null</td>
</tr>
<tr class="odd">
<td>!null</td>
<td>all</td>
<td>false</td>
<td>Property is not null</td>
</tr>
<tr class="even">
<td>empty</td>
<td>collection</td>
<td>false</td>
<td>Collection is empty</td>
</tr>
<tr class="odd">
<td>token</td>
<td>string</td>
<td>true</td>
<td>Match on multiple tokens in search property</td>
</tr>
<tr class="even">
<td>!token</td>
<td>string</td>
<td>true</td>
<td>Not match on multiple tokens in search property</td>
</tr>
<tr class="odd">
<td>in</td>
<td>string | boolean | integer | float | date</td>
<td>true</td>
<td>Find objects matching 1 or more values</td>
</tr>
<tr class="even">
<td>!in</td>
<td>string | boolean | integer | float | date</td>
<td>true</td>
<td>Find objects not matching 1 or more values</td>
</tr>
</tbody>
</table>

Operators will be applied as logical *and* query, if you need a *or*
query, you can have a look at our *in* filter (also have a look at the
section below). The filtering mechanism allows for recursion. See below
for some examples.

Obtenir des éléments de données avec la propriété ID1 ou ID2 :

    /api/dataElements?filter=id:eq:ID1&filter=id:eq:ID2

Get all data elements which have the dataSet with id ID1:

    /api/dataElements?filter=dataSetElements.dataSet.id:eq:ID1

Get all data elements with aggregation operator "sum" and value type
"int":

    /api/dataElements.json?filter=aggregationOperator:eq:sum&filter=type:eq:int

You can do filtering within collections, e.g. to get data elements which
are members of the "ANC" data element group you can use the following
query using the id property of the associated data element groups:

    /api/dataElements.json?filter=dataElementGroups.id:eq:qfxEYY9xAl6

Étant donné que tous les opérateurs sont *et* par défaut, vous ne pouvez pas trouver un élément de données correspondant à plus d'un identifiant. Pour ce faire, vous pouvez utiliser l'opérateur *dans*.

    /api/dataElements.json?filter=id:in:[fbfJHSPpUQD,cYeuwXTCPkU]

### Opérateurs logiques { #webapi_metadata_logical_operator } 

<!--DHIS2-SECTION-ID:webapi_metadata_logical_operator-->

Comme indiqué dans la section précédente, l'opérateur logique par défaut appliqué aux filtres est *ET*, ce qui signifie que tous les filtres d'objets doivent trouver une correspondance. Cependant, dans certains cas, l'utilisateur peut vouloir utiliser un seul filtre parmi plusieurs (par exemple le champ de l'identifiant et du code). Dans ce cas, il est possible de changer l'opérateur logique racine de *ET* à *OU* à l'aide du paramètre *rootJunction*.

Exemple : Filtrage normal où l'identifiant et le code doivent correspondre pour que le résultat soit renvoyé.

    /api/dataElements.json?filter=id:in:[id1,id2]&filter=code:eq:code1

Exemple : Filtrage où l'opérateur logique a été remplacé par OU, ce qui fait qu'un seul des filtres doit trouver une correspondance pour que le résultat soit renvoyé.

    /api/dataElements.json?filter=id:in:[id1,id2]&filter=code:eq:code1&rootJunction=OR

### Identifiable token filter { #identifiable-token-filter } 

Outre le filtrage spécifique basé sur les propriétés mentionné ci-dessus, nous disposons également d'un filtrage *ET* basé sur *token* à travers un ensemble de propriétés : identifiant, code et nom (ainsi que 'nom court' s'il est disponible). Ces propriétés sont généralement appelées *identifiables*. L'idée est de filtrer les métadonnées dont l'identifiant, le nom, le code ou le nom court contiennent des informations.

Exemple : Filtrage de tous les éléments de données contenant *2em* dans l'un des éléments suivants : identifiant, nom, code et nom court.

    /api/dataElements.json?filter=identifiable:token:2nd

Il est également possible de spécifier plusieurs valeurs de filtrage.

Exemple : Obtenir tous les éléments de données où *visite CPN* se trouve dans l'une des propriétés *identifiables*. Le système renvoie tous les éléments de données dans lesquels les deux unités lexicales (CPN et visite) se trouvent quelque part dans les propriétés identifiables.

    /api/dataElements.json?filter=identifiable:token:ANC visit

Il est également possible de combiner le filtre identifiable avec le filtre basé sur les propriétés et de s'attendre à ce que le paramètre *rootJunction* soit appliqué.

    /api/dataElements.json?filter=identifiable:token:ANC visit&filter=displayName:ilike:tt1

    /api/dataElements.json?filter=identifiable:token:ANC visit
      &filter=displayName:ilike:tt1&rootJunction=OR

### Capture Scope filter { #capture-scope-filter } 

In addition to the filtering mentioned above, we have a special filtering query parameter named *restrictToCaptureScope*. If *restrictToCaptureScope* is set to true, only those metadata objects that are either unassigned to any organisation units or those that are assigned explicitly to the logged in users capture scope org units will be returned in the response. In addition to filtering the metadata object lists, an additional filtering of the associated organisation units to only include the capture scoped organisation units will be done. This filtering parameter can be used for Program and CategoryOption listing APIs.

This feature is generally beneficial to reduce the payload size if there are large number of organisation units associated to various metadata objects. 

Some examples

    /api/categoryOptions.json?restrictToCaptureScope=true&fields=*

    /api/programs.json?restrictToCaptureScope=true&fields=*

All existing filters will work in addition to the capture scope filter.

    /api/categoryOptions.json?restrictToCaptureScope=true&fields=*&filter=displayName:ilike:11

## Metadata field filter { #webapi_metadata_field_filter } 

<!--DHIS2-SECTION-ID:webapi_metadata_field_filter-->

In many situations, the default views of the metadata can be too
verbose. A client might only need a few fields from each object and want
to remove unnecessary fields from the response. To discover which fields
are available for each object please see the *schema* section.

The format for include/exclude allows for infinite recursion. To filter 
at the "root" level you can just use the name of the field, 
i.e. `?fields=id,name` which would only display the `id` and
`name` fields for every object. For objects that are either collections or
complex objects with properties on their own, you can use the format
`?fields=id,name,dataSets[id,name]` which would return `id`, `name` of
the root, and the `id` and `name` of every data set on that object.
Negation can be done with the exclamation operator, and we have a set of
presets of field select. Both XML and JSON are supported.

**Exemple** : Obtenir l'`id` et le `nom` à partir de la ressource d'indicateurs :

    /api/indicators?fields=id,name

**Example**: Get `id` and `name` from dataElements, and `id` and `name`
from the dataSets on dataElements:

    /api/dataElements?fields=id,name,dataSets[id,name]

Pour exclure un champ de la sortie, vous pouvez utiliser l'opérateur d'exclamation `!`. Ceci est autorisé à n'importe quel emplacement dans la requête et cette propriété ne sera pas incluse tout simplement car elle pourrait avoir été insérée dans des options prédéfinies.

Quelques options prédéfinies (groupes de champs sélectionnés) sont disponibles et peuvent être appliqués à l'aide de l'opérateur `:`.

<table>
<caption>Property operators</caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 74%" />
</colgroup>
<thead>
<tr class="header">
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&lt;field-name&gt;</td>
<td>Include property with name, if it exists.</td>
</tr>
<tr class="even">
<td>&lt;object&gt;[&lt;field-name&gt;, ...]</td>
<td>Includes a field within either a collection (will be applied to every object in that collection), or just on a single object.</td>
</tr>
<tr class="odd">
<td>!&lt;field-name&gt;, &lt;object&gt;[!&lt;field-name&gt;</td>
<td>Do not include this field name, it also works inside objects/collections. Useful when you use a preset to include fields.</td>
</tr>
<tr class="even">
<td>*, &lt;object&gt;[*]</td>
<td>Include all fields on a certain object, if applied to a collection, it will include all fields on all objects on that collection.</td>
</tr>
<tr class="odd">
<td>:&lt;preset&gt;</td>
<td>Alias to select multiple fields. Three presets are currently available, see the table below for descriptions.</td>
</tr>
</tbody>
</table>

<table>
<caption>Field presets</caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 74%" />
</colgroup>
<thead>
<tr class="header">
<th>Preset</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>all</td>
<td>All fields of the object</td>
</tr>
<tr class="even">
<td>*</td>
<td>Alias for all</td>
</tr>
<tr class="odd">
<td>identifiable</td>
<td>Includes id, name, code, created and lastUpdated fields</td>
</tr>
<tr class="even">
<td>nameable</td>
<td>Includes id, name, shortName, code, description, created and lastUpdated fields</td>
</tr>
<tr class="odd">
<td>persisted</td>
<td>Returns all persisted property on an object, does not take into consideration if the object is the owner of the relation.</td>
</tr>
<tr class="even">
<td>owner</td>
<td>Returns all persisted property on an object where the object is the owner of all properties, this payload can be used to update through the API.</td>
</tr>
</tbody>
</table>

**Example**: Include all fields from dataSets except organisationUnits:

    /api/dataSets?fields=:all,!organisationUnits

**Exemple** : Inclure uniquement l'identifiant, le nom et la collection d'unités d'organisation d'un ensemble de données, mais exclure l'identifiant des unités d'organisation :

    /api/dataSets/BfMAe6Itzgt?fields=id,name,organisationUnits[:all,!id]

**Exemple** : Inclure les propriétés nommables de tous les indicateurs :

    /api/indicators.json?fields=:nameable

### Transformateurs de champ { #webapi_field_transformers } 

<!--DHIS2-SECTION-ID:webapi_field_transformers-->

In DHIS2.17 we introduced field transformers, the idea is to allow
further customization of the properties on the server-side.

    /api/dataElements/ID?fields=id~rename(i),name~rename(n)

La propriété *id* sera renommée *i* et la propriété *nom* sera renommée *n*.

Multiple transformers can be used by repeating the transformer syntax:

    /api/dataElementGroups.json?fields=id,displayName,dataElements~isNotEmpty~rename(haveDataElements)

<table>
<caption>Available Transformers</caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 21%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Arguments</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>size</td>
<td></td>
<td>Gives sizes of strings (length) and collections</td>
</tr>
<tr class="even">
<td>isEmpty</td>
<td></td>
<td>Is string or collection empty</td>
</tr>
<tr class="odd">
<td>isNotEmpty</td>
<td></td>
<td>Is string or collection not empty</td>
</tr>
<tr class="even">
<td>rename</td>
<td>Arg1: name</td>
<td>Renames the property name</td>
</tr>
<tr class="odd">
<td>paging</td>
<td>Arg1: page,Arg2: pageSize</td>
<td>Pages a collection, default pageSize is 50.</td>
</tr>
<tr class="even">
<td>pluck</td>
<td>Optional Arg1: fieldName</td>
<td>Converts an array of objects to an array of a selected field of that object. By default, the first field that is returned by the collection is used (normally the ID).</td>
</tr>
</tbody>
</table>

#### Exemples { #webapi_field_transformers_examples } 

<!--DHIS2-SECTION-ID:webapi_field_transformers_examples-->

Examples of transformer usage.

```
/api/dataElements?fields=dataSets~size

/api/dataElements?fields=dataSets~isEmpty

/api/dataElements?fields=dataSets~isNotEmpty

/api/dataElements/ID?fields=id~rename(i),name~rename(n)

/api/dataElementGroups?fields=id,displayName,dataElements~paging(1;20)

# Include array with IDs of organisation units: { #include-array-with-ids-of-organisation-units } 
/api/categoryOptions.json?fields=id,organisationUnits~pluck

# Include array with names of organisation units (collection only returns field name): { #include-array-with-names-of-organisation-units-collection-only-returns-field-name } 
/api/categoryOptions.json?fields=id,organisationUnits~pluck[name]
```

## Création, lecture, mise à jour, suppression et validation de métadonnées { #webapi_metadata_crud } 

<!--DHIS2-SECTION-ID:webapi_metadata_crud-->

Toutes les entités de métadonnées dans DHIS2 ont leur propre point d'extrémité API qui prend en charge les opérations *CRUD* (création, lecture, mise à jour et suppression). Les URL des points d'extrémité suivent le format suivant :

    /api/<entityName>

Le _nom de l'entité_ utilise la notation camel case. Par exemple, le point d'extrémité pour les _éléments de données_ est :

    /api/dataElements

### Création et mise à jour des paramètres { #webapi_metadata_create_update } 

<!--DHIS2-SECTION-ID:webapi_metadata_create_update-->

Les paramètres de requête suivants sont disponibles pour tous les points d'extrémité de métadonnées.

<table>
<caption>Available Query Filters</caption>
<thead>
<tr class="header">
<th>Param</th>
<th>Type</th>
<th>Required</th>
<th>Options (default first)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>preheatCache</td>
<td>boolean</td>
<td>false</td>
<td>true | false</td>
<td>Turn cache-map preheating on/off. This is on by default, turning this off will make initial load time for importer much shorter (but will make the import itself slower). This is mostly used for cases where you have a small XML/JSON file you want to import, and don't want to wait for cache-map preheating.</td>
</tr>
<tr class="even">
<td>strategy</td>
<td>enum</td>
<td>false</td>
<td>CREATE_AND_UPDATE | CREATE | UPDATE | DELETE</td>
<td>Import strategy to use, see below for more information.</td>
</tr>
<tr class="odd">
<td>mergeMode</td>
<td>enum</td>
<td>false</td>
<td>REPLACE, MERGE</td>
<td>Strategy for merging of objects when doing updates. REPLACE will just overwrite the property with the new value provided, MERGE will only set the property if it is not null (only if the property was provided).</td>
</tr>
</tbody>
</table>

### Création et mise à jour d'objets { #webapi_creating_updating_objects } 

<!--DHIS2-SECTION-ID:webapi_creating_updating_objects-->

Pour créer de nouveaux objets, vous devrez connaître le point d'extrémité, le format du type d'objet et vous assurer que vous disposez des autorisations nécessaires. À titre d'exemple, nous allons créer et mettre à jour une *constante*. Pour connaître le format, nous pouvons utiliser le nouveau point d'extrémité *schéma* pour obtenir la description du format. Nous allons donc commencer par l'obtention de cette information :

    http://<server>/api/schemas/constant.json

À partir de la sortie, vous pouvez voir que les autorités requises pour la création sont `F_CONSTANT_ADD`, et que les propriétés importantes sont : *nom* et *valeur*. En nous basant sur ces informations, nous pouvons créer une charge JSON et la sauvegarder dans un fichier appelé constant.json :

```json
{
  "name": "PI",
  "value": "3.14159265359"
}
```

Le même contenu qu'une charge XML :

```xml
<constant name="PI" xmlns="http://dhis2.org/schema/dxf/2.0">
  <value>3.14159265359</value>
</constant>
```

We are now ready to create the new *constant* by sending a POST request to
the *constants*endpoint with the JSON payload using curl:

```bash
curl -d @constant.json "http://server/api/constants" -X POST
  -H "Content-Type: application/json" -u user:password
```

A specific example of posting the constant to the demo
    server:

```bash
curl -d @constant.json "https://play.dhis2.org/api/constants" -X POST
  -H "Content-Type: application/json" -u admin:district
```

Si tout s'est bien passé, vous devriez obtenir le résultat suivant :

```json
{
  "status": "SUCCESS",
  "importCount": {
    "imported": 1,
    "updated": 0,
    "ignored": 0,
    "deleted": 0
  },
  "type": "Constant"
}
```

Le processus sera exactement le même pour la mise à jour, vous apportez vos modifications à la charge JSON/XML, vous trouvez l'*ID* de la constante, puis vous envoyez une requête PUT au point d'extrémité en incluant l'ID :

```bash
curl -X PUT -d @pi.json -H "Content-Type: application/json"
  -u user:password "http://server/api/constants/ID"
```

### Suppression d'objets { #webapi_deleting_objects } 

<!--DHIS2-SECTION-ID:webapi_deleting_objects-->

La suppression d'objets est très simple. Vous devez connaître l'*ID* et le point d'extrémité du type d'objet que vous voulez supprimer. Reprenons l'exemple de la dernière section et utilisons une *constante*. Supposons que l'identifiant soit *abc123*, tout ce que vous avez à faire est d'envoyer la requête DELETE (supprimer) au point d'extrémité + Id :

```bash
curl -X DELETE -u user:password "http://server/api/constants/ID"
```

Une suppression réussie doit renvoyer le statut HTTP 204 (pas de contenu).

### Ajout et suppression d'objets dans les collections { #webapi_adding_removing_objects_collections } 

<!--DHIS2-SECTION-ID:webapi_adding_removing_objects_collections-->

La ressource des collections vous permet de modifier des collections d'objets.

#### Ajout ou suppression d'objets uniques{ #webapi_collections_adding_removing_single_objects } 

<!--DHIS2-SECTION-ID:webapi_collections_adding_removing_single_objects-->

Pour ajouter ou supprimer des objets dans une collection d'objets, vous pouvez utiliser le modèle suivant :

    /api/{collection-object}/{collection-object-id}/{collection-name}/{object-id}

Vous devez utiliser la méthode POST pour ajouter un objet et la méthode DELETE pour le supprimer. Lorsqu'il existe une relation entre plusieurs objets, vous devez d'abord déterminer quel objet est propriétaire de la relation. Si cet objet n'est pas clairement identifiable, essayez les deux méthodes d'appel pour voir laquelle fonctionne.

Les éléments du modèle sont les suivants :

  - objet de la collection : Le type d'objets qui possède la collection que vous
    voulez modifier.

  - id de l'objet de collection : L'identifiant de l'objet qui possède la
    collection que vous voulez modifier.

  - nom de la collection : le nom de la collection que vous voulez modifier.

  - Identifiant d'objet : L'identifiant de l'objet que vous voulez ajouter ou supprimer
    de la collection.

Par exemple, pour supprimer un élément de données avec pour identifiant IDB d'un groupe d'éléments de données dont l'identifiant est IDA, vous pouvez effectuer une requête DELETE :

    DELETE /api/dataElementGroups/IDA/dataElements/IDB

Pour ajouter une option de catégorie avec pour identifiant IDB à une catégorie dont l'identifiant est IDA, vous pouvez effectuer une requête POST :

    POST /api/categories/IDA/categoryOptions/IDB

#### Ajout ou suppression de plusieurs objets { #webapi_collections_adding_removing_multiple_objects } 

<!--DHIS2-SECTION-ID:webapi_collections_adding_removing_multiple_objects-->

Vous pouvez ajouter ou supprimer plusieurs objets d'une collection dans une même requête, en utilisant la charge suivante :

```json
{
  "identifiableObjects": [{
      "id": "IDA"
    }, {
      "id": "IDB"
    }, {
      "id": "IDC"
    }
  ]
}
```

Cette charge utile permet d'ajouter, de remplacer ou de supprimer des éléments :

*Ajouter des éléments:*

    POST /api/categories/IDA/categoryOptions

*Rempld'éléments:*

    PUT /api/categories/IDA/categoryOptions

*Supprimer des éléments :*

    DELETE /api/categories/IDA/categoryOptions

#### Ajout et suppression d'objets dans une même requête { #webapi_collections_adding_removing_objects_single_request } 

<!--DHIS2-SECTION-ID:webapi_collections_adding_removing_objects_single_request-->

Vous pouvez ajouter et supprimer des objets d'une collection dans une même requête POST, en utilisant l'URL suivante :

    POST /api/categories/IDA/categoryOptions

Le format de la charge est le suivant :

```json
{
  "additions": [{
      "id": "IDA"
    }, {
      "id": "IDB"
    }, {
      "id": "IDC"
    }
  ],
  "deletions": [{
      "id": "IDD"
    }, {
      "id": "IDE"
    }, {
      "id": "IDF"
    }
  ]
}
```

### Validation des charges { #webapi_validating_payloads } 

<!--DHIS2-SECTION-ID:webapi_validating_payloads-->

DHIS 2 supports system wide validation of metadata payloads, which means 
that create and update operations on the API endpoints will be checked for 
valid payload before allowing changes to be made. To find out what validations 
are in place for a specific endpoint, have a look at the `/api/schemas` 
endpoint, i.e. to figure out which constraints a data element have, you 
would go to `/api/schemas/dataElement`.

Vous pouvez également valider votre charge manuellement en l'envoyant au point d'extrémité du schéma approprié. Si vous vouliez valider la constante dans la section de création précédente, vous devriez l'envoyer comme ceci :

    POST /api/schemas/constant

Voici un exemple simple (sans validation) :

```bash
curl -X POST -d "{\"name\": \"some name\"}" -H "Content-Type: application/json"
  -u admin:district "https://play.dhis2.org/dev/api/schemas/dataElement"
```

Which would yield the result:

```json
[
   {
      "message" : "Required property missing.",
      "property" : "type"
   },
   {
      "property" : "aggregationOperator",
      "message" : "Required property missing."
   },
   {
      "property" : "domainType",
      "message" : "Required property missing."
   },
   {
      "property" : "shortName",
      "message" : "Required property missing."
   }
]
```

### Mises à jour partielles { #webapi_partial_updates } 

<!--DHIS2-SECTION-ID:webapi_partial_updates-->

For cases where you don't want or need to update all properties on a
object (which means downloading a potentially huge payload, change one
property, then upload again) we now support partial update, for one or
more properties.

The payload for doing partial updates are the same as when you are
doing a full update, the only difference is that you only include the
properties you want to update, i.e.:

```json
{
  "name": "Updated Name",
  "zeroIsSignificant": true
}
```

Voici un exemple de commande curl :

```bash
curl -X PATCH -d @file.json -H "Content-Type: application/json"
  -u admin:district "https://play.dhis2.org/dev/api/dataElements/fbfJHSPpUQD"
```

## Exportation de métadonnées { #webapi_metadata_export } 

<!--DHIS2-SECTION-ID:webapi_metadata_export-->

Cette section décrit l'API de métadonnées qui est disponible ici : `/api/metadata`. Les représentations des ressources XML et JSON sont prises en charge.

    /api/metadata

Les paramètres les plus courants sont décrits dans le tableau "Paramètres d'exportation" ci-dessous. Vous pouvez également appliquer ceci à tous les types disponibles en utilisant `type:fields=<filter>` et `type:filter=<filter>`. Vous pouvez également activer/désactiver l'exportation de certains types à travers ceci : `type=true|false`.

<table>
<caption>Export Parameter</caption>
<colgroup>
<col style="width: 17%" />
<col style="width: 21%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Options</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>fields</td>
<td>Same as metadata field filter</td>
<td>Default field filter to apply for all types, default is `:owner`.</td>
</tr>
<tr class="even">
<td>filter</td>
<td>Same as metadata object filter</td>
<td>Default object filter to apply for all types, default is `none`.</td>
</tr>
<tr class="odd">
<td>order</td>
<td>Same as metadata order</td>
<td>Default order to apply to all types, default is `name` if available, or `created` if not.</td>
</tr>
<tr class="even">
<td>translate</td>
<td>false/true</td>
<td>Enable translations. Be aware that this is turned off by default (in other endpoints this is on by default).</td>
</tr>
<tr class="odd">
<td>locale</td>
<td>&lt;locale&gt;</td>
<td>Change from user locale, to your own custom locale.</td>
</tr>
<tr class="even">
<td>defaults</td>
<td>INCLUDE/EXCLUDE</td>
<td>Should auto-generated category object be included or not in the payload. If you are moving metadata between 2 non-synced instances, it might make sense to set this to EXCLUDE to ease the handling of these generated objects.</td>
</tr>
<tr class="odd">
<td>skipSharing</td>
<td>false/true</td>
<td>Enabling this will strip the sharing properties from the exported objects. This includes <em>user</em>, <em>publicAccess</em>, <em>userGroupAccesses</em>, <em>userAccesses</em>, and <em>externalAccess</em>.</td>
</tr>
<tr class="odd">
<td>download</td>
<td>false/true</td>
<td>Enabling this will add HTTP header Content-Disposition that specifies that the data should be handled as an attachment and will be offered by web browsers as a download.</td>
</tr>
</tbody>
</table>

### Exemples d'exportation de métadonnées { #webapi_metadata_export_examples } 

<!--DHIS2-SECTION-ID:webapi_metadata_export_examples-->

Exporter toutes les métadonnées. Attention, la réponse peut être très volumineuse en fonction de la configuration des métadonnées :

    /api/metadata

Exporter toutes les métadonnées classées par ordre décroissant en prenant en compte la dernière mise à jour :

    /api/metadata?defaultOrder=lastUpdated:desc

Exporter uniquement les métadonnées qui contiennent des indicateurs et des groupes d'indicateurs :

    /api/metadata?indicators=true&indicatorGroups=true

Exporter l'identifiant et le nom d'affichage de tous les éléments de données, classés par nom d'affichage :

    /api/metadata?dataElements:fields=id,name&dataElements:order=displayName:desc

Exporter les éléments de données et les indicateurs dont le nom commence par "CPN" :

    /api/metadata?filter=name:^like:ANC&dataElements=true&indicators=true

### Exportation de métadonnées avec des dépendances { #webapi_dataset_program_export_dependencies } 

<!--DHIS2-SECTION-ID:webapi_dataset_program_export_dependencies-->

When you want to exchange metadata for a data set, program or category combo
from one DHIS2 instance to another instance there are three dedicated endpoints available:

```
/api/dataSets/{id}/metadata.json

/api/programs/{id}/metadata.json

/api/categoryCombos/{id}/metadata.json

/api/dashboards/{id}/metadata.json
```

Ces éléments exportés peuvent ensuite être importés en utilisant ceci `/api/metadata`.

Ces points d'extrémité prennent également en charge les paramètres suivants :

<table>
<caption>Export Parameter</caption>
<colgroup>
<col style="width: 17%" />
<col style="width: 21%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Options</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>skipSharing</td>
<td>false/true</td>
<td>Enabling this will strip the sharing properties from the exported objects. This includes <em>user</em>, <em>publicAccess</em>, <em>userGroupAccesses</em>, <em>userAccesses</em>, and <em>externalAccess</em>.</td>
</tr>
<tr class="odd">
<td>download</td>
<td>false/true</td>
<td>Enabling this will add HTTP header Content-Disposition that specifies that the data should be handled as an attachment and will be offered by web browsers as a download.</td>
</tr>
</tbody>
</table>

## Importation de métadonnées { #webapi_metadata_import } 

<!--DHIS2-SECTION-ID:webapi_metadata_import-->

This section explains the metadata import API. XML and JSON resource 
representations are supported. Metadata can be imported using a *POST* request. 

    /api/metadata

L'importateur vous permet d'importer des charges de métadonnées qui peuvent inclure plusieurs entités et un nombre quelconque d'objets par entité. Les éléments de métadonnées exportés via l'API d'exportation de métadonnées peuvent être importés directement.

The metadata import endpoint support a variety of parameters, which are 
listed below.

<table>
<caption>Import Parameter</caption>
<colgroup>
<col style="width: 17%" />
<col style="width: 21%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Options (first is default)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>importMode</td>
<td>COMMIT, VALIDATE</td>
<td>Sets overall import mode, decides whether or not to only `VALIDATE` or also `COMMIT` the metadata, this has similar functionality as our old dryRun flag.</td>
</tr>
<tr class="even">
<td>identifier</td>
<td>UID, CODE, AUTO</td>
<td>Sets the identifier scheme to use for reference matching. `AUTO` means try `UID` first, then `CODE`.</td>
</tr>
<tr class="odd">
<td>importReportMode</td>
<td>ERRORS, FULL, DEBUG</td>
<td>Sets the `ImportReport` mode, controls how much is reported back after the import is done. `ERRORS` only includes <em>ObjectReports</em> for object which has errors. `FULL` returns an <em>ObjectReport</em> for all objects imported, and `DEBUG` returns the same plus a name for the object (if available).</td>
</tr>
<tr class="even">
<td>preheatMode</td>
<td>REFERENCE, ALL, NONE</td>
<td>Sets the preheater mode, used to signal if preheating should be done for `ALL` (as it was before with <em>preheatCache=true</em>) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to `NONE` is not recommended.</td>
</tr>
<tr class="odd">
<td>importStrategy</td>
<td>CREATE_AND_UPDATE, CREATE, UPDATE, DELETE</td>
<td>Sets import strategy, `CREATE_AND_UPDATE` will try and match on identifier, if it doesn't exist, it will create the object.</td>
</tr>
<tr class="even">
<td>atomicMode</td>
<td>ALL, NONE</td>
<td>Sets atomic mode, in the old importer we always did a <em>best effort</em> import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the `NONE` mode emulated the old behavior.</td>
</tr>
<tr class="odd">
<td>mergeMode</td>
<td>REPLACE, MERGE</td>
<td>Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, `MERGE` mode will only overwrite the old property if the new one is not-null, for `REPLACE` mode all properties are overwritten regardless of null or not.</td>
</tr>
<tr class="even">
<td>flushMode</td>
<td>AUTO, OBJECT</td>
<td>Sets the flush mode, which controls when to flush the internal cache. It is <em>strongly</em> recommended to keep this to `AUTO` (which is the default). Only use `OBJECT` for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).</td>
</tr>
<tr class="odd">
<td>skipSharing</td>
<td>false, true</td>
<td>Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.</td>
</tr>
<tr class="even">
<td>skipValidation</td>
<td>false, true</td>
<td>Skip validation for import. `NOT RECOMMENDED`.</td>
</tr>
<tr class="odd">
<td>async</td>
<td>false, true</td>
<td>Asynchronous import, returns immediately with a <em>Location</em> header pointing to the location of the <em>importReport</em>. The payload also contains a json object of the job created.</td>
</tr>
<tr class="even">
<td>inclusionStrategy</td>
<td>NON_NULL, ALWAYS, NON_EMPTY</td>
<td><em>NON_NULL</em> includes properties which are not null, <em>ALWAYS</em> include all properties, <em>NON_EMPTY</em> includes non empty properties (will not include strings of 0 length, collections of size 0, etc.)</td>
</tr>
<tr class="odd">
<td>userOverrideMode</td>
<td>NONE, CURRENT, SELECTED</td>
<td>Allows you to override the user property of every object you are importing, the options are NONE (do nothing), CURRENT (use import user), SELECTED (select a specific user using overrideUser=X)</td>
</tr>
<tr class="even">
<td>overrideUser</td>
<td>User ID</td>
<td>If userOverrideMode is SELECTED, use this parameter to select the user you want override with.</td>
</tr>
</tbody>
</table>

Voici un exemple de charge d'importation de métadonnées. Vous remarquerez que chaque type d'entité possède sa propre propriété avec un tableau d'objets :

```json
{
  "dataElements": [
    {
      "name": "EPI - IPV 3 doses given",
      "shortName": "EPI - IPV 3 doses given",
      "aggregationType": "SUM",
      "domainType": "AGGREGATE",
      "valueType": "INTEGER_ZERO_OR_POSITIVE"
    },
    {
      "name": "EPI - IPV 4 doses given",
      "shortName": "EPI - IPV 4 doses given",
      "aggregationType": "SUM",
      "domainType": "AGGREGATE",
      "valueType": "INTEGER_ZERO_OR_POSITIVE"
    }
  ],
  "indicators": [
    {
      "name": "EPI - ADS stock used",
      "shortName": "ADS stock used",
      "numerator": "#{LTb8XeeqeqI}+#{Fs28ZQJET6V}-#{A3mHIZd2tPg}",
      "numeratorDescription": "ADS 0.05 ml used",
      "denominator": "1",
      "denominatorDescription": "1",
      "annualized": false,
      "indicatorType": {
        "id": "kHy61PbChXr"
      }
    }
  ]
}
```

Lors de l'envoi de cette charge au point d'extrémité des métadonnées, la réponse contiendra des informations sur les paramètres utilisés lors de l'importation et un récapitulatif par type d'entité, lequel contiendra le nombre d'objets créés, mis à jour, supprimés et ignorés :

```json
{
  "importParams": {
    "userOverrideMode": "NONE",
    "importMode": "COMMIT",
    "identifier": "UID",
    "preheatMode": "REFERENCE",
    "importStrategy": "CREATE_AND_UPDATE",
    "atomicMode": "ALL",
    "mergeMode": "REPLACE",
    "flushMode": "AUTO",
    "skipSharing": false,
    "skipTranslation": false,
    "skipValidation": false,
    "metadataSyncImport": false,
    "firstRowIsHeader": true,
    "username": "UNICEF_admin"
  },
  "status": "OK",
  "typeReports": [
    {
      "klass": "org.hisp.dhis.dataelement.DataElement",
      "stats": {
        "created": 2,
        "updated": 0,
        "deleted": 0,
        "ignored": 0,
        "total": 2
      }
    },
    {
      "klass": "org.hisp.dhis.indicator.Indicator",
      "stats": {
        "created": 1,
        "updated": 0,
        "deleted": 0,
        "ignored": 0,
        "total": 1
      }
    }
  ],
  "stats": {
    "created": 3,
    "updated": 0,
    "deleted": 0,
    "ignored": 0,
    "total": 3
  }
}
```

## Metadata audit { #webapi_metadata_audit } 

<!--DHIS2-SECTION-ID:webapi_metadata_audit-->

If you need information about who created, edited, or deleted DHIS2
metadata objects you can enable metadata audit. There are two
configuration options (dhis.conf) you can enable to support this:

```properties
metadata.audit.log = on
```

This enables additional log output in your servlet container (e.g.
tomcat catalina.log) which contains full information about the object
created, object edited, or object deleted including full JSON payload,
date of audit event, and the user who did the action.

```properties
metadata.audit.persist = on
```

This enables persisted audits, i.e. audits saved to the database. The
information stored is the same as with audit log; however this
information is now placed into the *metadataaudit* table in the
database.

We do not recommended enabling these options on a empty database if you
intend to bootstrap your system, as it slows down the import and the
audit might not be that useful.

### Metadata audit query { #webapi_metadata_audit_query } 

<!--DHIS2-SECTION-ID:webapi_metadata_audit_query-->

If you have enabled persisted metadata audits on your DHIS2 instance,
you can access metadata audits at the following endpoint:

    /api/33/metadataAudits

The endpoints supports the following query parameters:

<table>
<caption>Metadata audit API query parameters</caption>
<colgroup>
<col style="width: 22%" />
<col style="width: 27%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Values</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>uid</td>
<td></td>
<td>Object uid to query by (can be more than one)</td>
</tr>
<tr class="even">
<td>code</td>
<td></td>
<td>Object code to query by (can be more than one)</td>
</tr>
<tr class="odd">
<td>klass</td>
<td></td>
<td>Object class to query by (can be more than one), please note that the full java package name is required here (to avoid name collisions)</td>
</tr>
<tr class="even">
<td>createdAt</td>
<td></td>
<td>Query by creation date</td>
</tr>
<tr class="odd">
<td>createdBy</td>
<td></td>
<td>Query by who made the change (username)</td>
</tr>
<tr class="even">
<td>type</td>
<td>CREATE, UPDATE, DELETE</td>
<td>Query by audit type</td>
</tr>
</tbody>
</table>

## Render type (Experimental) { #webapi_render_type } 

<!--DHIS2-SECTION-ID:webapi_render_type-->

Certains types de métadonnées ont une propriété appelée *renderType* (type de rendu). Cette propriété établit une correspondance entre un *appareil* et un *type de restitution* (renderingType). Les applications peuvent utiliser ces informations pour savoir comment l'objet doit être rendu sur un appareil spécifique. Par exemple, le rendu d'un élément de données sur un appareil mobile peut être différent de celui d'un ordinateur de bureau.

Il existe actuellement deux types de restitution :

1.  Restitution du type de valeur

2.  Restitution des sections d'étape de programme

Il existe également deux types d'appareils :

1.  MOBILE

2.  DESKTOP

Le tableau suivant énumère les types de métadonnées et de restitution disponibles.
La restitution du type de valeur a des contraintes supplémentaires basées sur la configuration des métadonnées. Elles seront présentées dans un second tableau.

<table>
<caption>Metadata and RenderingType overview</caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Metadata type</th>
<th>Available RenderingTypes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Program Stage Section</td>
<td><ul>
<li><p>LISTING (default)</p></li>
<li><p>SEQUENTIAL</p></li>
<li><p>MATRIX</p></li>
</ul></td>
</tr>
<tr class="even">
<td>Data element</td>
<td><ul>
<li><p>DEFAULT</p></li>
<li><p>DROPDOWN</p></li>
<li><p>VERTICAL_RADIOBUTTONS</p></li>
<li><p>HORIZONTAL_RADIOBUTTONS</p></li>
<li><p>VERTICAL_CHECKBOXES</p></li>
<li><p>HORIZONTAL_CHECKBOXES</p></li>
<li><p>SHARED_HEADER_RADIOBUTTONS</p></li>
<li><p>ICONS_AS_BUTTONS</p></li>
<li><p>SPINNER</p></li>
<li><p>ICON</p></li>
<li><p>TOGGLE</p></li>
<li><p>VALUE</p></li>
<li><p>SLIDER</p></li>
<li><p>LINEAR_SCALE</p></li>
</ul></td>
</tr>
</tbody>
</table>

Étant donné que la gestion de la restitution par défaut des éléments de données et des attributs d'entités suivies dépend du type de valeur de l'objet, il existe également un type DEFAULT pour indiquer au client qu'il doit être traité normalement. La section des étapes de programme est définie sur LISTING par défaut.

<table>
<caption>RenderingTypes allowed based on value types</caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Value type</th>
<th>Is object an optionset?</th>
<th>RenderingTypes allowed</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>TRUE_ONLY</td>
<td>No</td>
<td>DEFAULT, VERTICAL_RADIOBUTTONS, HORIZONTAL_RADIOBUTTONS, VERTICAL_CHECKBOXES, HORIZONTAL_CHECKBOXES, TOGGLE</td>
</tr>
<tr class="even">
<td>BOOLEAN</td>
<td>No</td>
<td></td>
</tr>
<tr class="odd">
<td>-</td>
<td>Yes</td>
<td>DEFAULT, DROPDOWN, VERTICAL_RADIOBUTTONS, HORIZONTAL_RADIOBUTTONS, VERTICAL_CHECKBOXES, HORIZONTAL_CHECKBOXES, SHARED_HEADER_RADIOBUTTONS, ICONS_AS_BUTTONS, SPINNER, ICON</td>
</tr>
<tr class="even">
<td>INTEGER</td>
<td>No</td>
<td>DEFAULT, VALUE, SLIDER, LINEAR_SCALE, SPINNER</td>
</tr>
<tr class="odd">
<td>INTEGER_POSITIVE</td>
<td>No</td>
<td></td>
</tr>
<tr class="even">
<td>INTEGER_NEGATIVE</td>
<td>No</td>
<td></td>
</tr>
<tr class="odd">
<td>INTEGER_ZERO_OR_POSITIVE</td>
<td>No</td>
<td></td>
</tr>
<tr class="even">
<td>NUMBER</td>
<td>No</td>
<td></td>
</tr>
<tr class="odd">
<td>UNIT_INTERVAL</td>
<td>No</td>
<td></td>
</tr>
<tr class="even">
<td>PERCENTAGE</td>
<td>No</td>
<td></td>
</tr>
</tbody>
</table>

Vous pouvez également récupérer une référence complète du tableau précédent en utilisant le point d'extrémité suivant :

    GET /api/staticConfiguration/renderingOptions

Quelques propriétés supplémentaires peuvent être définies pour la restitution du type de valeur ; ce qui est souvent nécessaire lors de la restitution de certains types spécifiques :

<table>
<caption>renderType object properties</caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Property</th>
<th>Description</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>type</td>
<td>The RenderingType of the object, as seen in the first table. This property is the same for both value type and program stage section, but is the only property available for program stage section.</td>
<td>Enum (See list in the Metadata and Rendering Type table)</td>
</tr>
<tr class="even">
<td>min</td>
<td>Only for value type rendering. Represents the minimum value this field can have.</td>
<td>Integer</td>
</tr>
<tr class="odd">
<td>max</td>
<td>Only for value type rendering. Represents the maximum value this field can have.</td>
<td>Integer</td>
</tr>
<tr class="even">
<td>step</td>
<td>Only for value type rendering. Represents the size of the steps the value should increase, for example for SLIDER og LINEAR_SCALE</td>
<td>Integer</td>
</tr>
<tr class="odd">
<td>decimalPoints</td>
<td>Only for value type rendering. Represents the number of decimal points the value should use.</td>
<td>Integer</td>
</tr>
</tbody>
</table>

Le *type de restitution* peut être défini lors de la création ou de la mise à jour des métadonnées énumérées dans le premier tableau. Voici un exemple de charge pour le type de restitution de la section des étapes de programme :

```json
{
  "renderingType": {
    "type": "MATRIX"
  }
}
```

Pour les éléments de données et les attributs d'entités suivies :

```json
{
  "renderingType": {
    "type": "SLIDER",
    "min": 0,
    "max": 1000,
    "step": 50,
    "decimalPoints": 0
  }
}
```

## Style d'objet { #webapi_object_style } 

<!--DHIS2-SECTION-ID:webapi_object_style-->

La plupart des métadonnées ont une propriété "style". Cette propriété peut être utilisée par les clients pour représenter l'objet d'une certaine manière. Les propriétés actuellement prises en charge par le style sont les suivantes :

<table>
<caption>Style properties</caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Property</th>
<th>Description</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>color</td>
<td>A color, represented by a hexadecimal.</td>
<td>String (#000000)</td>
</tr>
<tr class="even">
<td>icon</td>
<td>An icon, represented by a icon-name.</td>
<td>String</td>
</tr>
</tbody>
</table>

Actuellement, il n'existe pas de liste officielle ni de bibliothèques d'icônes. Il revient donc au client de les fournir. La liste suivante présente tous les objets qui prennent en charge le style :

  - Élément de données

  - Option de catégorie d'éléments de données

  - Ensemble de données

  - Indicateurs

  - Option

  - Programme

  - Indicateur de programme

  - Section du programme

  - Étape du programme

  - Section des étapes de programme

  - Relation (Tracker)

  - Attribut d’entité suivi

  - Type d'entité suivie

Lors de la création ou de la mise à jour de l'un de ces objets, vous pouvez inclure la charge suivante pour modifier le style :

```json
{
  "style": {
    "color": "#ffffff",
    "icon": "my-beautiful-icon"
  }
}
```

## ActiveMQ Artemis / AMQP 1.0 integration { #webapi_amqp_integration } 

<!--DHIS2-SECTION-ID:webapi_amqp_integration-->

By default DHIS2 will start up an embedded instance of ActiveMQ Artemis when the
instance is booting up. For most use-cases, you do not need to configure anything
to make use of this, but if your infrastructure have an existing AMQP 1.0 compliant
service you want to use, you can change the defaults in your *dhis.conf* file using
the keys in the table down below.

<table>
  <caption>
    AMQP Configuration Keys
  </caption>
  <colgroup>
    <col style="width: 15%" />
    <col style="width: 30%" />
    <col style="width: 55%" />
  </colgroup>
  <thead>
    <tr class="header">
      <th>Key</th>
      <th>Value (default first)</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr class="odd">
      <td>amqp.mode</td>
      <td><code>EMBEDDED</code> | <code>NATIVE</code></td>
      <td>The default <code>EMBEDDED</code> starts up an internal AMQP service when the
      DHIS2 instance is starting up. If you want to connect to an external AMQP service
      you need to set the mode to <code>NATIVE</code>.</td>
    </tr>
    <tr class="odd">
      <td>amqp.host</td>
      <td><code>127.0.0.1</code></td>
      <td>Host to bind to.</td>
    </tr>
    <tr class="even">
      <td>amqp.port</td>
      <td><code>15672</code></td>
      <td>If mode is <code>EMBEDDED</code> then start the embedded server on this port,
      if <code>NATIVE</code> then the client will use this port to connect to.</td>
    </tr>
    <tr class="odd">
      <td>amqp.username</td>
      <td><code>guest</code></td>
      <td>Username to connect to if using <code>NATIVE</code> mode.</td>
    </tr>
    <tr class="even">
      <td>amqp.password</td>
      <td><code>guest</code></td>
      <td>Password to connect to if using <code>NATIVE</code> mode.</td>
    </tr>
    <tr class="odd">
      <td>amqp.embedded.persistence</td>
      <td><code>false</code> | <code>true</code></td>
      <td>If mode is <code>EMBEDDED</code>, this property controls persistence of
      the internal queue.</td>
    </tr>
  </tbody>
</table>

## Importation de métadonnées CSV { #webapi_csv_metadata_import } 

<!--DHIS2-SECTION-ID:webapi_csv_metadata_import-->

DHIS2 prend en charge l'importation de métadonnées au format CSV, telles que les éléments de données, les unités d'organisation et les règles de validation. Les propriétés des différents objets de métadonnées sont identifiées en fonction de l'ordre ou de l'index des colonnes (voir ci-dessous pour plus de détails). Vous pouvez omettre les propriétés d'objets ou les colonnes non nécessaires, mais puisque l'ordre des colonnes est important, une colonne vide doit être incluse. En d'autres termes, si vous voulez spécifier des propriétés ou des colonnes qui apparaissent tard dans l'ordre des colonnes, mais ne pas spécifier certaines colonnes qui apparaissent tôt dans l'ordre, vous pouvez inclure des colonnes vides pour elles.

La première ligne du fichier CSV est considérée comme un en-tête et est ignorée lors de l'importation. Le caractère _virgule_ doit être utilisé comme séparateur de texte. Le texte qui contient des virgules doit être placé entre _guillemets doubles_.

Pour télécharger des métadonnées au format CSV, vous pouvez envoyer une requête POST au point d'extrémité des métadonnées :

    POST /api/metadata?classKey=CLASS-KEY

Les types d'objets suivants sont pris en charge. Le paramètre de requête `classKey` est obligatoire et se trouve à côté de chaque type d'objet dans le tableau ci-dessous.

<table>
<caption>Object types and keys</caption>
<tr>
<th>Object type</th>
<th>Class key</th>
</tr>
<tr>
<td>Data elements</td>
<td>DATA_ELEMENT</td>
</tr>
<tr>
<td>Data element groups</td>
<td>DATA_ELEMENT_GROUP
</tr>
<tr>
<td>Category options</td>
<td>CATEGORY_OPTION</td>
</tr>
<tr>
<td>Category option groups</td>
<td>CATEGORY_OPTION_GROUP</td>
</tr>
<tr>
<td>Organisation units</td>
<td>ORGANISATION_UNIT</td>
</tr>
<tr>
<td>Organisation unit groups</td>
<td>ORGANISATION_UNIT_GROUP</td>
</tr>
<tr>
<td>Validation rules</td>
<td>VALIDATION_RULE</td>
</tr>
<tr>
<td>Option sets</td>
<td>OPTION_SET</td>
</tr>
<tr>
<td>Translations</td>
<td>TRANSLATION</td>
</tr>
</table>

> **Astuce**
>
> Si vous utilisez *curl*, l'option `--data-binary` doit être utilisée car elle préserve les sauts de ligne et les nouvelles lignes, ce qui est essentiel pour les données CSV.

Par exemple, pour télécharger un fichier d'éléments de données au format CSV avec `curl`, vous pouvez utiliser la commande suivante :

```bash
curl --data-binary @data_elements.csv "http://localhost/api/metadata?classKey=DATA_ELEMENT"
  -H "Content-Type:application/csv" -u admin:district
```

Les formats des types d'objets actuellement pris en charge pour l'importation en CSV sont énumérés dans les sections suivantes.

### Eléments de données { #webapi_csv_data_elements } 

<!--DHIS2-SECTION-ID:webapi_csv_data_elements-->

<table>
<caption>Data Element CSV Format</caption>
<colgroup>
<col />
<col style="width: 13%" />
<col style="width: 7%" />
<col style="width: 27%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Index</th>
<th>Column</th>
<th>Required</th>
<th>Value (default first)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Name</td>
<td>Yes</td>
<td></td>
<td>Name. Max 230 char. Unique.</td>
</tr>
<tr class="even">
<td>2</td>
<td>UID</td>
<td>No</td>
<td>UID</td>
<td>Stable identifier. Exactly 11 alpha-numeric characters, beginning with a character. Will be generated by system if not specified.</td>
</tr>
<tr class="odd">
<td>3</td>
<td>Code</td>
<td>No</td>
<td></td>
<td>Stable code. Max 50 char.</td>
</tr>
<tr class="even">
<td>4</td>
<td>Short name</td>
<td>No</td>
<td>50 first char of name</td>
<td>Will fall back to first 50 characters of name if unspecified. Max 50 char. Unique.</td>
</tr>
<tr class="odd">
<td>5</td>
<td>Description</td>
<td>No</td>
<td></td>
<td>Free text description.</td>
</tr>
<tr class="even">
<td>6</td>
<td>Form name</td>
<td>No</td>
<td></td>
<td>Max 230 char.</td>
</tr>
<tr class="odd">
<td>7</td>
<td>Domain type</td>
<td>No</td>
<td>AGGREGATE | TRACKER</td>
<td>Domain type for data element, can be aggregate or tracker. Max 16 char.</td>
</tr>
<tr class="even">
<td>8</td>
<td>Value type</td>
<td>No</td>
<td>INTEGER | NUMBER | UNIT_INTERVAL | PERCENTAGE | INTEGER_POSITIVE | INTEGER_NEGATIVE | INTEGER_ZERO_OR_POSITIVE | FILE_RESOURCE | COORDINATE |TEXT | LONG_TEXT | LETTER | PHONE_NUMBER | EMAIL | BOOLEAN | TRUE_ONLY | DATE | DATETIME</td>
<td>Value type. Max 16 char.</td>
</tr>
<tr class="odd">
<td>9</td>
<td>Aggregation type</td>
<td>No</td>
<td>SUM | AVERAGE | AVERAGE_SUM_ORG_UNIT | COUNT | STDDEV | VARIANCE | MIN | MAX | NONE</td>
<td>Aggregation type indicating how to aggregate data in various dimensions. Max 16 char.</td>
</tr>
<tr class="even">
<td>10</td>
<td>Category combination</td>
<td>No</td>
<td>UID</td>
<td>UID of category combination. Will default to default category combination if not specified.</td>
</tr>
<tr class="odd">
<td>11</td>
<td>Url</td>
<td>No</td>
<td></td>
<td>URL to data element resource. Max 255 char.</td>
</tr>
<tr class="even">
<td>12</td>
<td>Zero is significant</td>
<td>No</td>
<td>false | true</td>
<td>Indicates whether zero values will be stored for this data element.</td>
</tr>
<tr class="odd">
<td>13</td>
<td>Option set</td>
<td>No</td>
<td>UID</td>
<td>UID of option set to use for data.</td>
</tr>
<tr class="even">
<td>14</td>
<td>Comment option set</td>
<td>No</td>
<td>UID</td>
<td>UID of option set to use for comments.</td>
</tr>
</tbody>
</table>

Vous trouverez ci-dessous un exemple de fichier CSV pour les éléments de données. La première ligne sera toujours ignorée. Vous pouvez ignorer des colonnes et compter sur les valeurs par défaut utilisées par le système. Vous pouvez également ignorer les colonnes que vous n'utilisez pas et qui apparaissent à droite de celles

```csv
name,uid,code,shortname,description
"Women participated skill development training",,"D0001","Women participated in training"
"Women participated community organizations",,"D0002","Women participated in organizations"
```

### Les unités d’organisation { #webapi_csv_org_units } 

<!--DHIS2-SECTION-ID:webapi_csv_org_units-->

<table>
<caption>Organisation Unit CSV Format</caption>
<colgroup>
<col />
<col style="width: 14%" />
<col style="width: 10%" />
<col style="width: 21%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="header">
<th>Index</th>
<th>Column</th>
<th>Required</th>
<th>Value (default first)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Name</td>
<td>Yes</td>
<td></td>
<td>Name. Max 230 characters. Unique.</td>
</tr>
<tr class="even">
<td>2</td>
<td>UID</td>
<td>No</td>
<td>UID</td>
<td>Stable identifier. Max 11 char. Will be generated by system if not specified.</td>
</tr>
<tr class="odd">
<td>3</td>
<td>Code</td>
<td>No</td>
<td></td>
<td>Stable code. Max 50 char.</td>
</tr>
<tr class="even">
<td>4</td>
<td>Parent</td>
<td>No</td>
<td>UID</td>
<td>UID of parent organisation unit.</td>
</tr>
<tr class="odd">
<td>5</td>
<td>Short name</td>
<td>No</td>
<td>50 first char of name</td>
<td>Will fall back to first 50 characters of name if unspecified. Max 50 characters. Unique.</td>
</tr>
<tr class="even">
<td>6</td>
<td>Description</td>
<td>No</td>
<td></td>
<td>Free text description.</td>
</tr>
<tr class="odd">
<td>7</td>
<td>Opening date</td>
<td>No</td>
<td>1970-01-01</td>
<td>Opening date of organisation unit in YYYY-MM-DD format.</td>
</tr>
<tr class="even">
<td>8</td>
<td>Closed date</td>
<td>No</td>
<td></td>
<td>Closed date of organisation unit in YYYY-MM-DD format, skip if currently open.</td>
</tr>
<tr class="odd">
<td>9</td>
<td>Comment</td>
<td>No</td>
<td></td>
<td>Free text comment for organisation unit.</td>
</tr>
<tr class="even">
<td>10</td>
<td>Feature type</td>
<td>No</td>
<td>NONE | MULTI_POLYGON | POLYGON | POINT | SYMBOL</td>
<td>Geospatial feature type.</td>
</tr>
<tr class="odd">
<td>11</td>
<td>Coordinates</td>
<td>No</td>
<td></td>
<td>Coordinates used for geospatial analysis in Geo JSON format.</td>
</tr>
<tr class="even">
<td>12</td>
<td>URL</td>
<td>No</td>
<td></td>
<td>URL to organisation unit resource. Max 255 char.</td>
</tr>
<tr class="odd">
<td>13</td>
<td>Contact person</td>
<td>No</td>
<td></td>
<td>Contact person for organisation unit. Max 255 char.</td>
</tr>
<tr class="even">
<td>14</td>
<td>Address</td>
<td>No</td>
<td></td>
<td>Address for organisation unit. Max 255 char.</td>
</tr>
<tr class="odd">
<td>15</td>
<td>Email</td>
<td>No</td>
<td></td>
<td>Email for organisation unit. Max 150 char.</td>
</tr>
<tr class="even">
<td>16</td>
<td>Phone number</td>
<td>No</td>
<td></td>
<td>Phone number for organisation unit. Max 150 char.</td>
</tr>
</tbody>
</table>

Voici un exemple d'importation d'unités d'organisation avec une unité mère, en utilisant des informations minimales :

```csv
name,uid,code,parent
"West province",,"WESTP","ImspTQPwCqd"
"East province",,"EASTP","ImspTQPwCqd"
```

### Règles de validation { #webapi_csv_validation_rules } 

<!--DHIS2-SECTION-ID:webapi_csv_validation_rules-->

<table>
<caption>Validation Rule CSV Format</caption>
<colgroup>
<col />
<col style="width: 17%" />
<col style="width: 7%" />
<col style="width: 28%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th>Index</th>
<th>Column</th>
<th>Required</th>
<th>Value (default first)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Name</td>
<td>Yes</td>
<td></td>
<td>Name. Max 230 characters. Unique.</td>
</tr>
<tr class="even">
<td>2</td>
<td>UID</td>
<td>No</td>
<td>UID</td>
<td>Stable identifier. Max 11 char. Will be generated by system if not specified.</td>
</tr>
<tr class="odd">
<td>3</td>
<td>Code</td>
<td>No</td>
<td></td>
<td>Stable code. Max 50</td>
</tr>
<tr class="even">
<td>4</td>
<td>Description</td>
<td>No</td>
<td></td>
<td>Free text description.</td>
</tr>
<tr class="odd">
<td>5</td>
<td>Instruction</td>
<td>No</td>
<td></td>
<td>Free text instruction.</td>
</tr>
<tr class="even">
<td>6</td>
<td>Importance</td>
<td>No</td>
<td>MEDIUM | HIGH | LOW</td>
<td>Importance of validation rule.</td>
</tr>
<tr class="odd">
<td>7</td>
<td>Rule type (ignored)</td>
<td>No</td>
<td>VALIDATION | SURVEILLANCE</td>
<td>Type of validation rule.</td>
</tr>
<tr class="even">
<td>8</td>
<td>Operator</td>
<td>No</td>
<td>equal_to | not_equal_to | greater_than | greater_than_or_equal_to | less_than | less_than_or_equal_to | compulsory_pair | exclusive_pair</td>
<td>Expression operator.</td>
</tr>
<tr class="odd">
<td>9</td>
<td>Period type</td>
<td>No</td>
<td>Monthly | Daily | Weekly | Quarterly | SixMontly | Yearly</td>
<td>Period type.</td>
</tr>
<tr class="even">
<td>10</td>
<td>Left side expression</td>
<td>Yes</td>
<td></td>
<td>Mathematical formula based on data element and option combo UIDs.</td>
</tr>
<tr class="odd">
<td>11</td>
<td>Left side expression description</td>
<td>Yes</td>
<td></td>
<td>Free text.</td>
</tr>
<tr class="even">
<td>12</td>
<td>Left side missing value strategy</td>
<td>No</td>
<td>SKIP_IF_ANY_VALUE_MISSING | SKIP_IF_ALL_VALUES_MISSING | NEVER_SKIP</td>
<td>Behavior in case of missing values in left side expression.</td>
</tr>
<tr class="odd">
<td>13</td>
<td>Right side expression</td>
<td>Yes</td>
<td></td>
<td>Mathematical formula based on data element and option combo UIDs.</td>
</tr>
<tr class="even">
<td>14</td>
<td>Right side expression description</td>
<td>Yes</td>
<td></td>
<td>Free text.</td>
</tr>
<tr class="odd">
<td>15</td>
<td>Right side missing value strategy</td>
<td>No</td>
<td>SKIP_IF_ANY_VALUE_MISSING | SKIP_IF_ALL_VALUES_MISSING | NEVER_SKIP</td>
<td>Behavior in case of missing values in right side expression.</td>
</tr>
</tbody>
</table>

### Ensembles d'options { #webapi_csv_option_sets } 

<!--DHIS2-SECTION-ID:webapi_csv_option_sets-->

<table style="width:100%;">
<caption>Option Set CSV Format</caption>
<colgroup>
<col />
<col style="width: 14%" />
<col style="width: 11%" />
<col style="width: 15%" />
<col style="width: 59%" />
</colgroup>
<thead>
<tr class="header">
<th>Index</th>
<th>Column</th>
<th>Required</th>
<th>Value (default first)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>OptionSetName</td>
<td>Yes</td>
<td></td>
<td>Name. Max 230 characters. Unique. Should be repeated for each option.</td>
</tr>
<tr class="even">
<td>2</td>
<td>OptionSetUID</td>
<td>No</td>
<td>UID</td>
<td>Stable identifier. Max 11 char. Will be generated by system if not specified. Should be repeated for each option.</td>
</tr>
<tr class="odd">
<td>3</td>
<td>OptionSetCode</td>
<td>No</td>
<td></td>
<td>Stable code. Max 50 char. Should be repeated for each option.</td>
</tr>
<tr class="even">
<td>4</td>
<td>OptionName</td>
<td>Yes</td>
<td></td>
<td>Option name. Max 230 characters.</td>
</tr>
<tr class="odd">
<td>5</td>
<td>OptionUID</td>
<td>No</td>
<td>UID</td>
<td>Stable identifier. Max 11 char. Will be generated by system if not specified.</td>
</tr>
<tr class="even">
<td>6</td>
<td>OptionCode</td>
<td>Yes</td>
<td></td>
<td>Stable code. Max 50 char.</td>
</tr>
</tbody>
</table>

Le format des ensembles d'options est particulier. Les trois premières valeurs représentent un ensemble d'options. Les trois dernières valeurs représentent une option. Les trois premières valeurs représentant l'ensemble d'options doivent être répétées pour chaque option.

```csv
optionsetname,optionsetuid,optionsetcode,optionname,optionuid,optioncode
"Color",,"COLOR","Blue",,"BLUE"
"Color",,"COLOR","Green",,"GREEN"
"Color",,"COLOR","Yellow",,"YELLOW"
"Sex",,,"Male",,"MALE"
"Sex",,,"Female",,"FEMALE"
"Sex",,,"Unknown",,"UNKNOWN"
"Result",,,"High",,"HIGH"
"Result",,,"Medium",,"MEDIUM"
"Result",,,"Low",,"LOW"
"Impact","cJ82jd8sd32","IMPACT","Great",,"GREAT"
"Impact","cJ82jd8sd32","IMPACT","Medium",,"MEDIUM"
"Impact","cJ82jd8sd32","IMPACT","Poor",,"POOR"
```

### Groupe d'options { #option-group } 

<table style="width:100%;">
<caption>Option Group CSV Format</caption>
<colgroup>
<col />
<col style="width: 14%" />
<col style="width: 11%" />
<col style="width: 15%" />
<col style="width: 59%" />
</colgroup>
<thead>
<tr class="header">
<th>Index</th>
<th>Column</th>
<th>Required</th>
<th>Value (default first)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>OptionGroupName</td>
<td>Yes</td>
<td>Name. Max 230 characters. Unique. Should be repeated for each option.</td>
</tr>
<tr class="even">
<td>2</td>
<td>OptionGroupUid</td>
<td>No</td>
<td>Stable identifier. Max 11 char. Will be generated by system if not specified. Should be repeated for each option.</td>
</tr>
<tr class="odd">
<td>3</td>
<td>OptionGroupCode</td>
<td>No</td>
<td>Stable code. Max 50 char. Should be repeated for each option.</td>
</tr>
<tr class="even">
<td>4</td>
<td>OptionGroupShortName</td>
<td>Yes</td>
<td>Short Name. Max 50 characters. Unique. Should be repeated for each option.</td>
</tr>
<tr class="odd">
<td>5</td>
<td>OptionSetUid</td>
<td>Yes</td>
<td>Stable identifier. Max 11 char. Should be repeated for each option.</td>
</tr>
<tr class="even">
<td>6</td>
<td>OptionUid</td>
<td>No</td>
<td>Stable identifier. Max 11 char.</td>
</tr>
<tr class="odd">
<td>7</td>
<td>OptionCode</td>
<td>No</td>
<td>Stable code. Max 50 char.</td>
</tr>
</tbody>
</table>

Exemple de charge CSV d'un groupe d'options

```csv
optionGroupName,optionGroupUid,optionGroupCode,optionGroupShortName,optionSetUid,optionUid,optionCode
optionGroupA,,,groupA,xmRubJIhmaK,,OptionA
optionGroupA,,,groupA,xmRubJIhmaK,,OptionB
optionGroupB,,,groupB,QYDAByFgTr1,,OptionC
```
### Ensemble de groupes d'options { #option-group-set } 

<table style="width:100%;">
<caption>Option Group Set CSV Format</caption>
<colgroup>
<col />
<col style="width: 14%" />
<col style="width: 11%" />
<col style="width: 15%" />
<col style="width: 59%" />
</colgroup>
<thead>
<tr class="header">
<th>Index</th>
<th>Column</th>
<th>Required</th>
<th>Value (default first)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>OptionGroupSetName</td>
<td>Yes</td>
<td>Name. Max 230 characters. Unique. Should be repeated for each option.</td>
</tr>
<tr class="even">
<td>2</td>
<td>OptionGroupSetUid</td>
<td>No</td>
<td>Stable identifier. Max 11 char. Will be generated by system if not specified. Should be repeated for each option.</td>
</tr>
<tr class="odd">
<td>3</td>
<td>OptionGroupSetCode</td>
<td>No</td>
<td>Stable code. Max 50 char. Should be repeated for each option.</td>
</tr>
<tr class="even">
<td>4</td>
<td>OptionGroupSetDescription</td>
<td>No</td>
<td>Description. Should be repeated for each option.</td>
</tr>
<tr class="odd">
<td>5</td>
<td>DataDimension</td>
<td>No</td>
<td>TRUE, FALSE</td>
</tr>
<tr class="even">
<td>6</td>
<td>OptionSetUid</td>
<td>No</td>
<td>OptionSet UID. Stable identifier. Max 11 char.</td>
</tr>
</tbody>
</table>

Exemple de charge CSV d'un ensemble de groupes d'options

```csv
name,uid,code,description,datadimension,optionsetuid
optiongroupsetA,,,,,xmRubJIhmaK
optiongroupsetB,,,,false,QYDAByFgTr1
```
To add OptionGroups to an imported OptionGroupSet, follow the steps as importing collection membership 

### Appartenance à une collection { #collection-membership } 

Outre l'importation d'objets, vous pouvez également choisir de n'importer que la relation groupe-membre entre un objet et un groupe. Actuellement, les paires de groupes et d'objets suivantes sont prises en charge

  - Groupe d'unités d'organisation - Unité d'organisation

  - Groupe d'éléments de données - Élément de données

  - Groupe d'indicateurs - Indicateur

  - Ensemble de groupes d'options - Groupe d'options

Le format CSV pour ces importations est le même

<table>
<caption>Collection membership CSV Format</caption>
<colgroup>
<col />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th>Index</th>
<th>Column</th>
<th>Required</th>
<th>Value (default first)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>UID</td>
<td>Yes</td>
<td>UID</td>
<td>The UID of the collection to add an object to</td>
</tr>
<tr class="even">
<td>2</td>
<td>UID</td>
<td>Yes</td>
<td>UID</td>
<td>The UID of the object to add to the collection</td>
</tr>
</tbody>
</table>

### Autres objets { #webapi_csv_other_objects } 

<!--DHIS2-SECTION-ID:webapi_csv_other_objects-->

<table>
<caption>Data Element Group, Category Option, Category Option Group, Organisation Unit Group CSV Format</caption>
<colgroup>
<col />
<col style="width: 17%" />
<col style="width: 12%" />
<col style="width: 14%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="header">
<th>Index</th>
<th>Column</th>
<th>Required</th>
<th>Value (default first)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Name</td>
<td>Yes</td>
<td></td>
<td>Name. Max 230 characters. Unique.</td>
</tr>
<tr class="even">
<td>2</td>
<td>UID</td>
<td>No</td>
<td>UID</td>
<td>Stable identifier. Max 11 chars. Will be generated by system if not specified.</td>
</tr>
<tr class="odd">
<td>3</td>
<td>Code</td>
<td>No</td>
<td></td>
<td>Stable code. Max 50 char.</td>
</tr>
<tr class="even">
<td>4</td>
<td>Short name</td>
<td>No</td>
<td></td>
<td>Short name. Max 50 characters.</td>
</tr>
</tbody>
</table>

Voici un exemple d'options de catégorie :

```csv
name,uid,code,shortname
"Male",,"MALE"
"Female",,"FEMALE"
```

## Objets supprimés { #webapi_deleted_objects } 

<!--DHIS2-SECTION-ID:webapi_deleted_objects-->

La ressource des objets supprimés fournit un journal des objets de métadonnées supprimés.

    /api/deletedObjects

Chaque fois qu'un objet de métadonnées est supprimé, un journal est conservé avec l'identifiant, le code, le type et l'heure de la suppression. Cette API est disponible à l'adresse `/api/deletedObjects`. Le filtrage des champs et des objets fonctionne de la même manière que pour les autres ressources de métadonnées.

Obtenir des objets supprimés de type éléments de données :

    GET /api/deletedObjects.json?klass=DataElement

Obtenir un objet de type indicateur qui a été supprimé dans la période allant de 2015 et plus :

    GET /api/deletedObjects.json?klass=Indicator&deletedAt=2015-01-01

## Favoris { #webapi_favorites } 

<!--DHIS2-SECTION-ID:webapi_favorites-->

Certains types d'objets de métadonnées peuvent être marqués comme favoris pour l'utilisateur actuellement connecté. Cela s'applique actuellement aux tableaux de bord.

    /api/dashboards/<uid>/favorite

Pour faire d'un tableau de bord un favori, vous pouvez envoyer une requête *POST* (aucun type de contenu n'est requis) à une URL comme suit :

    /api/dashboards/iMnYyBfSxmM/favorite

Pour supprimer un tableau de bord en tant que favori, vous pouvez effectuer une requête *DELETE* en utilisant l'URL ci-dessus.

Le statut de favori apparaîtra comme un champ booléen *favori* sur l'objet (par exemple, le tableau de bord) dans la réponse de métadonnées.

## Abonnements { #webapi_subscription } 

<!--DHIS2-SECTION-ID:webapi_subscription-->

A logged user can subscribe to certain types of objects. Currently
subscribable objects are those of type Chart, EventChart, EventReport,
Map, ReportTable and Visualization.

> **Note**
>
> The Chart and ReportTable objects are deprecated. Use Visualization instead.

Pour obtenir les abonnés d'un objet (un tableau contenant les UID), vous pouvez effectuer une requête *GET* comme suit :

    /api/<object-type>/<object-id>/subscribers

Voir l'exemple suivant :

    /api/charts/DkPKc1EUmC2/subscribers

Pour vérifier si l'utilisateur actuel est abonné à un objet (obtenir une valeur booléenne), vous pouvez effectuer un appel *GET* :

    /api/<object-type>/<object-id>/subscribed

Voir l'exemple suivant :

    /api/charts/DkPKc1EUmC2/subscribed

Pour s'abonner ou se désabonner d'un objet, effectuez une requête *POST/DELETE* (aucun type de contenu n'est requis) :

    /api/<object-type>/<object-id>/subscriber

## Ressources de fichiers { #webapi_file_resources } 

<!--DHIS2-SECTION-ID:webapi_file_resources-->

Les *Ressources de fichiers* sont des objets utilisés pour représenter et stocker du contenu binaire. L'objet *FileResource* (ressource de fichier) contient les métadonnées du fichier (nom, contenu-type, taille, etc.) ainsi qu'une clé permettant d'extraire le contenu à partir d'un magasin de fichiers externe à la base de données. L'objet *FileResource* est stocké dans la base de données comme n'importe quel autre objet, mais le contenu (fichier) est stocké ailleurs et peut être récupéré à l'aide de la référence du contenu *(storageKey)* ou clé de stockage.

    /api/fileResources

Le contenu des ressources de fichiers n'est pas directement accessible, mais il est référencé à partir d'autres objets (tels que les valeurs de données) pour stocker des données binaires d'une taille pratiquement illimitée.

Creation of the file resource itself is done through the `/api/fileResources` endpoint as a multipart upload POST-request:

```bash
curl "https://server/api/fileResources" -X POST 
  -F "file=@/Path/to/file;filename=name-of-file.png" 
```

The only form parameter required is the *file* which is the file to
upload. The filename and content-type should also be included in the
request but will be replaced with defaults when not supplied.

Lorsque la création d'une ressource fichier est réussie, les données renvoyées contiennent un champ `response` qui contient à son tour `fileResource` comme suit :

```json
{
  "httpStatus": "Accepted",
  "httpStatusCode": 202,
  "status": "OK",
  "response": {
    "responseType": "FileResource",
    "fileResource": {
      "name": "name-of-file.png",
      "created": "2015-10-16T16:34:20.654+0000",
      "lastUpdated": "2015-10-16T16:34:20.667+0000",
      "externalAccess": false,
      "publicAccess": "--------",
      "user": { ... },
      "displayName": "name-of-file.png",
      "contentType": "image/png",
      "contentLength": 512571,
      "contentMd5": "4e1fc1c3f999e5aa3228d531e4adde58",
      "storageStatus": "PENDING",
      "id": "xm4JwRwke0i"
    }
  }
}
```

Notez la réponse *202 Accepted*, qui indique que la ressource renvoyée a été soumise à un traitement en arrière-plan (persistance vers le magasin de fichiers externe dans ce cas). Notez également le champ `storageStatus` qui indique si le contenu a été stocké ou non. À ce stade, la persistance vers le magasin externe n'est pas encore terminée (elle est probablement en train d'être téléchargée vers un magasin basé sur le cloud) comme le montre le statut `PENDING`.

Même si le contenu n'a pas encore été entièrement stocké, la ressource de fichier peut maintenant être utilisée, par exemple comme contenu référencé dans une valeur de données (voir [Travailler avec des valeurs de données de fichier](#datavalue_file)). Si nous avons besoin de vérifier le *storageStatus* mis à jour ou de récupérer les métadonnées du fichier, une requête peut être envoyée au point d'extrémité `fileResources`.

```bash
curl "https://server/api/fileResources/xm4JwRwke0i" -H "Accept: application/json"
```

Cette requête renverra l'objet `FileResource` comme le montre la réponse de l'exemple ci-dessus.

### Contraintes liées aux ressources de fichiers { #webapi_file_resources_constraints } 

<!--DHIS2-SECTION-ID:webapi_file_resources_constraints-->

  - Les ressources de fichiers *doivent* être référencées (attribuées) à partir d'un autre objet.
    afin d'être conservées à long terme. Un fichier de ressource qui est
    créé mais non référencé par un autre objet, par exemple une valeur de données, est
    est considérée comme étant en *staging*. Toutes les ressources de fichiers dans ce 
    état et datant de plus de *deux heures* seront marqués pour suppression.
    et seront retirées du système.

  - L'ID renvoyé par la création initiale de la ressource de fichier n'est pas
    récupérable à partir de tout autre emplacement, à moins que la ressource de fichier n'ait été
    été référencée (auquel cas l'ID sera stocké en tant que référence), 
    de sorte que sa perte nécessitera que la requête POST soit répétée et qu'un 
    nouvel objet soit créé. La ressource de fichier *orpheline* sera nettoyée automatiquement.
    automatiquement.

  - Les objets de ressources de fichiers sont *immuables*, ce qui signifie qu'ils ne peuvent pas être modifiés 
    et nécessitent plutôt la création d'une ressource entièrement nouvelle.

### Liste noire des ressources de fichiers { #file-resource-blocklist } 

Pour des raisons de sécurité, certains types de fichiers ne peuvent pas être téléchargés.

Les types de contenu suivants sont bloqués.

| Type de contenu | Type de contenu |
| ------------------------------------- | ---- |
| text/html                             | application/x-ms-dos-executable |
| text/css                              | application/vnd.microsoft.portable-executable |
| text/javascript                       | application/vnd.apple.installer+xml |
| font/otf                              | application/vnd.mozilla.xul+xml |
| application/x-shockwave-flash         | application/x-httpd-php  |
| application/vnd.debian.binary-package | application/x-sh |
| application/x-rpm                     | application/x-csh |
| application/java-archive              |  |

Les extensions de fichiers suivantes sont bloquées.

| Extension de fichier | Extension de fichier | Extension de fichier |
| ---- | ---- | ---- |
| html | deb  | xul  |
| htm  | rpm  | php  |
| css  | jar  | bin  |
| js   | jsp  | sh   |
| mjs  | exe  | csh  |
| otf  | msi  | bat  |
| swf  | mpkg |      |

## Versionnage des métadonnées { #webapi_metadata_versioning } 

<!--DHIS2-SECTION-ID:webapi_metadata_versioning-->

This section explains the Metadata Versioning APIs available starting
2.24

  - `/api/metadata/version`: This endpoint will return the current metadata
    du système sur lequel il est invoqué.

<table>
<caption>Query Parameters</caption>
<colgroup>
<col style="width: 19%" />
<col style="width: 23%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>versionName</td>
<td>false</td>
<td>If this parameter is not specified, it will return the current version of the system or otherwise it will return the details of the versionName passed as parameter. (versionName is of the syntax &quot;Version_&lt;id&gt;&quot;</td>
</tr>
</tbody>
</table>

### Obtenir des exemples de versions de métadonnées { #webapi_metadata_versioning_examples } 

<!--DHIS2-SECTION-ID:webapi_metadata_versioning_examples-->

**Exemple:** Obtenir la version actuelle des métadonnées de ce système

Requête :

```
/api/metadata/version
```

Réponse :

```json
{
  "name": "Version_4",
  "created": "2016-06-30T06:01:28.684+0000",
  "lastUpdated": "2016-06-30T06:01:28.685+0000",
  "externalAccess": false,
  "displayName": "Version_4",
  "type": "BEST_EFFORT",
  "hashCode": "848bf6edbaf4faeb7d1a1169445357b0",
  "id": "Ayz2AEMB6ry"
}
```

**Exemple:** Obtenir les détails de la version portant le nom "Version_2".

Requête :

```
/api/metadata/version?versionName=Version_2
```

Réponse :

```json
{
  "name": "Version_2",
  "created": "2016-06-30T05:59:33.238+0000",
  "lastUpdated": "2016-06-30T05:59:33.239+0000",
  "externalAccess": false,
  "displayName": "Version_2",
  "type": "BEST_EFFORT",
  "hashCode": "8050fb1a604e29d5566675c86d02d10b",
  "id": "SaNyhusVxBG"
}
```

  - `/api/metadata/version/history`: This endpoint will return the list of all
    versions des métadonnées du système sur lequel il est appelé.

<table>
<caption>Query Parameters</caption>
<colgroup>
<col style="width: 19%" />
<col style="width: 23%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="header">
<th><p>Name</p></th>
<th><p>Required</p></th>
<th><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>baseline</p></td>
<td><p>false</p></td>
<td><p>If this parameter is not specified, it will return list of all metadata versions. Otherwise we need to pass a versionName parameter of the form &quot;Version_&lt;id&gt;&quot;. It will then return the list of versions present in the system which were created after the version name supplied as the query parameter.</p></td>
</tr>
</tbody>
</table>

### Obtenir la liste de toutes les versions de métadonnées { #webapi_get_list_of_metadata_versions } 

<!--DHIS2-SECTION-ID:webapi_get_list_of_metadata_versions-->

**Exemple:** Obtenir la liste de toutes les versions de ce système

Requête :

```
/api/metadata/version/history
```

Réponse :

```json
{
  "metadataversions": [{
    "name": "Version_1",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T05:54:41.139+0000",
    "id": "SjnhUp6r4hG",
    "hashCode": "fd1398ff7ec9fcfd5b59d523c8680798"
  }, {
    "name": "Version_2",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T05:59:33.238+0000",
    "id": "SaNyhusVxBG",
    "hashCode": "8050fb1a604e29d5566675c86d02d10b"
  }, {
    "name": "Version_3",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T06:01:23.680+0000",
    "id": "FVkGzSjAAYg",
    "hashCode": "70b779ea448b0da23d8ae0bd59af6333"
  }]
}
```

**Exemple :** Obtenir la liste de toutes les versions de ce système créées après "Version_2".

Requête :

```
/api/metadata/version/history?baseline=Version_2
```

Réponse :

```json
{
  "metadataversions": [{
    "name": "Version_3",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T06:01:23.680+0000",
    "id": "FVkGzSjAAYg",
    "hashCode": "70b779ea448b0da23d8ae0bd59af6333"
  }, {
    "name": "Version_4",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T06:01:28.684+0000",
    "id": "Ayz2AEMB6ry",
    "hashCode": "848bf6edbaf4faeb7d1a1169445357b0"
  }]
 }
```

  - `/api/metadata/version/create`: This endpoint will create the metadata
    pour le type de version spécifié dans le paramètre.

<table>
<caption>Query Parameters</caption>
<colgroup>
<col style="width: 19%" />
<col style="width: 23%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="header">
<th><p>Name</p></th>
<th><p>Required</p></th>
<th><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>type</p></td>
<td><p>true</p></td>
<td><p>The type of metadata version which needs to be created.</p>
<ul>
<li><p>BEST_EFFORT</p></li>
<li><p>ATOMIC</p></li>
</ul></td>
</tr>
</tbody>
</table>

Les utilisateurs peuvent sélectionner le type de métadonnées à créer. Le type de version des métadonnées régit la manière dont l'importateur traite la version en question. Ce type sera utilisé lors de l'importation des métadonnées. Il existe deux types de métadonnées.

  - *BEST_EFFORT* : Ce type suggère que les références manquantes peuvent être
    ignorées et l'importateur peut continuer à importer les métadonnées (par exemple,
    les éléments de données manquants lors de l'importation d'un groupe d'éléments de données).

  - *ATOMIC*: This type ensures a strict type checking of the metadata 
    references and the metadata import will fail if any of the references 
    n'existe pas.

> **Remarque**
>
> Il est recommandé d'avoir un type de versions ATOMIQUE pour s'assurer que tous les systèmes (centraux et locaux) aient les mêmes métadonnées.
> Les références manquantes sont prises en compte dans la phase de validation elle-même. Veuillez consulter les
> détails de l'importateur pour obtenir une explication complète.
>

### Création d'une version de métadonnées { #webapi_create_metadata_version } 

<!--DHIS2-SECTION-ID:webapi_create_metadata_version-->

**Exemple:** Créer une version de métadonnées du type `BEST_EFFORT`.

Requête :

```bash
curl -X POST -u admin:district "https://play.dhis2.org/dev/api/metadata/version/create?type=BEST_EFFORT"
```

Réponse :

```json
{
  "name": "Version_1",
  "created": "2016-06-30T05:54:41.139+0000",
  "lastUpdated": "2016-06-30T05:54:41.333+0000",
  "externalAccess": false,
  "publicAccess": "--------",
  "user": {
    "name": "John Traore",
    "created": "2013-04-18T17:15:08.407+0000",
    "lastUpdated": "2016-04-06T00:06:06.571+0000",
    "externalAccess": false,
    "displayName": "John Traore",
    "id": "xE7jOejl9FI"
  },
  "displayName": "Version_1",
  "type": "BEST_EFFORT",
  "hashCode": "fd1398ff7ec9fcfd5b59d523c8680798",
  "id": "SjnhUp6r4hG"
}
```

  - `/api/metadata/version/{versionName}/data`: This endpoint will download
    les métadonnées spécifiques au nom de version utilisé comme paramètre du chemin d'accès.
     

  - `/api/metadata/version/{versionName}/data.gz`: This endpoint will download
    les métadonnées spécifiques au nom de version utilisé comme paramètre du chemin d'accès.
    dans un format compressé (gzippé).

<table>
<caption>Path parameters</caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th><p>Name</p></th>
<th><p>Required</p></th>
<th><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>versionName</p></td>
<td><p>true</p></td>
<td><p>Path parameter of the form &quot;Version_&lt;id&gt;&quot; so that the API downloads the specific version</p></td>
</tr>
</tbody>
</table>

### Télécharger les métadonnées de la version { #webapi_download_version_metadata } 

<!--DHIS2-SECTION-ID:webapi_download_version_metadata-->

**Exemple:** Obtenir les métadonnées pour la "Version 5"

Requête :

```bash
curl -u admin:district "https://play.dhis2.org/dev/api/metadata/version/Version_5/data"
```

Réponse :

```json
{
  "date": "2016-06-30T06:10:23.120+0000",
  "dataElements": [
    {
      "code": "ANC 5th Visit",
      "created": "2016-06-30T06:10:09.870+0000",
      "lastUpdated": "2016-06-30T06:10:09.870+0000",
      "name": "ANC 5th Visit",
      "id": "sCuZKDsix7Y",
      "shortName": "ANC 5th Visit ",
      "aggregationType": "SUM",
      "domainType": "AGGREGATE",
      "zeroIsSignificant": false,
      "valueType": "NUMBER",
      "categoryCombo": {
        "id": "p0KPaWEg3cf"
      },
      "user": {
        "id": "xE7jOejl9FI"
      }
    }
  ]
}
```

## Metadata Synchronization { #webapi_metadata_synchronization } 

<!--DHIS2-SECTION-ID:webapi_metadata_synchronization-->

Cette section explique l'API de synchronisation des métadonnées disponible à partir de la version 2.24

  - `/api/metadata/sync`: This endpoint performs metadata sync of the
    nom de la version utilisé dans le paramètre de requête. Cela se fait par le téléchargement et 
    l'importation de la version spécifiée à partir du serveur distant, tel que défini dans 
    l'application de paramétrage.

<table>
<caption>Query parameters</caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th><p>Name</p></th>
<th><p>Required</p></th>
<th><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>versionName</p></td>
<td><p>true</p></td>
<td><p>versionName query parameter of the form &quot;Version_&lt;id&gt;&quot; . The api downloads this version from the remote server and imports it in the local system.</p></td>
</tr>
</tbody>
</table>

  - Cette API doit être utilisée avec la plus grande prudence. Sachez qu'il existe 
    une autre façon d'effectuer la synchronisation de manière complètement automatisée en 
    s'appuyant sur la tâche de synchronisation des métadonnées à partir de l'application "Administration des données". 
    Voir le chapitre 22, section 22.17 du manuel de l'utilisateur pour plus de détails concernant la 
    tâche de synchronisation des métadonnées.

  - Cette API de synchronisation peut également être utilisée pour synchroniser les métadonnées pour les 
    versions qui ont échoué dans le planificateur de synchronisation des métadonnées. En raison 
    de sa dépendance à un numéro de version de métadonnées spécifique, il convient de faire 
    attention à l'ordre dans lequel cette API est appelée. Par exemple, si cette API est 
    utilisée pour synchroniser une version supérieure à partir de l'instance centrale, 
    la synchronisation peut échouer car les dépendances des métadonnées ne sont pas présentes dans 
    l'instance locale.

  - Supposons que l'instance locale soit à la `Version_12` et que ce point d'extrémité soit utilisé 
    pour synchroniser la `Version_15` (de type `BEST_EFFORT`) depuis l'instance centrale, 
    le planificateur commencera à synchroniser les métadonnées à partir de la 
    `Version_16`. Donc l'instance locale n'aura pas les versions 
    de métadonnées entre la `Version_12` et la `Version_15`. Vous devez synchroniser manuellement 
    les versions manquantes en utilisant uniquement ces points d'extrémité.

### Synchronisation d'une version de métadonnées { #webapi_metadata_synchronization_version } 

<!--DHIS2-SECTION-ID:webapi_metadata_synchronization_version-->

**Exemple:** Synchroniser la Version_6 du système central vers ce système

Requête :

```bash
curl -u admin:district "https://play.dhis2.org/dev/api/metadata/sync?versionName=Version_6"
```

## Valeurs des données { #webapi_data_values }

<!--DHIS2-SECTION-ID:webapi_data_values-->

Cette section traite de l'envoi et de la lecture des données.

    /api/33/dataValueSets

### Envoi de données { #webapi_sending_data_values }

<!--DHIS2-SECTION-ID:webapi_sending_data_values-->

Un cas d'utilisation courant pour l'intégration des systèmes est la nécessité d'envoyer un ensemble de valeurs de données d'un système tiers vers DHIS. Dans cet exemple, nous utiliserons la démonstration DHIS2 sur `http://play.dhis2.org/demo`. Supposons que nous avons collecté des données basées sur les cas à l'aide d'un simple logiciel client installé sur des téléphones portables pour l'ensemble de données *Mortalité <5 ans* dans la communauté du *Ngelehun CHC* (dans la chefferie *Badjia*, district *Bo*) pour le mois de janvier 2014. Nous avons maintenant agrégé nos données dans un rapport statistique et nous voulons envoyer ces données à l'instance DHIS2. L'URL de base de l'API de démonstration est `http://play.dhis2.org/demo/api`. Les liens suivants sont associés à l'URL de base.


La ressource la plus appropriée pour notre objectif d'envoi de valeurs de données est `/api/dataValueSets`. Un ensemble de valeurs de données représente des données qui ont une relation, généralement parce qu'elles ont été saisies dans le même formulaire. Le format ressemble à ceci :

```xml
<dataValueSet xmlns="http://dhis2.org/schema/dxf/2.0" dataSet="dataSetID"
  completeDate="date" period="period" orgUnit="orgUnitID" attributeOptionCombo="aocID">
  <dataValue dataElement="dataElementID" 
    categoryOptionCombo="cocID" value="1" comment="comment1"/>
  <dataValue dataElement="dataElementID" 
    categoryOptionCombo="cocID" value="2" comment="comment2"/>
  <dataValue dataElement="dataElementID" 
    categoryOptionCombo="cocID" value="3" comment="comment3"/>
</dataValueSet>
```

JSON est pris en charge dans ce format :

```json
{
  "dataSet": "dataSetID",
  "completeDate": "date",
  "period": "period",
  "orgUnit": "orgUnitID",
  "attributeOptionCombo": "aocID",
  "dataValues": [
    {
      "dataElement": "dataElementID", 
      "categoryOptionCombo": "cocID", 
      "value": "1", 
      "comment": "comment1"
    },
    {
      "dataElement": "dataElementID", 
      "categoryOptionCombo": "cocID", 
      "value": "2", 
      "comment": "comment2"
    },
    {
      "dataElement": "dataElementID", 
      "categoryOptionCombo": "cocID", 
      "value": "3", 
      "comment": "comment3"
    }
  ]
}
```

CSV est pris en charge dans ce format :

```csv
"élément de données", "période", "orgunit", "catoptcombo", "attroptcombo", "valeur", "strby", "lstupd", "cmt"
"dataElementID", "période", "orgUnitID", "cocID", "aocID", "1", "nom d'utilisateur", "2015-04-01", "comment1"
"dataElementID", "période", "orgUnitID", "cocID", "aocID", "2", "nom d'utilisateur", "2015-04-01", "comment2"
"dataElementID", "période", "orgUnitID", "cocID", "aocID", "3", "nom d'utilisateur", "2015-04-01", "comment3"
```

> **Remarque**
>
> Veuillez vous référer à la section date et période ci-dessus pour les formats d'heure.

À partir de l'exemple, nous l'importance d'identifier la période, l'ensemble de données, l'unité d'organisation (établissement) et les éléments de données qui nécessite des rapports.

To obtain the identifier for the data set we make a request to the
`/api/dataSets` resource. From there we find and follow the link to 
the *Mortality < 5 years* data set which leads us to `/api/dataSets/pBOMPrpg1QX`. 
The resource representation for the *Mortality < 5 years* data set conveniently
advertises links to the data elements which are members of it. From here
we can follow these links and obtain the identifiers of the data
elements. For brevity we will only report on three data elements:
*Measles* with id `f7n9E0hX8qk`, *Dysentery* with id `Ix2HsbDMLea` and
*Cholera* with id `eY5ehpbEsB7`.

Il ne nous reste que l'identifiant de l'organisation unité. L'*ensemble de données* fournit un lien vers les unités d'organisation qui produisent des rapports dessus. Nous recherchons donc *Ngelehun CHC* et suivons le lien vers la représentation HTML dans `/api/organisationUnits/DiszpKrYNg8`, qui nous indique que l'identifiant de cette unité d'organisation est `DiszpKrYNg8`.

À partir de nos données basées sur les cas, nous supposons que nous avons 12 cas de rougeole, 14 cas de dysenterie et 16 cas de choléra. Nous avons maintenant assez d'informations pour pouvoir composer le message XML de l'ensemble de valeurs des données :

```xml
<dataValueSet xmlns="http://dhis2.org/schema/dxf/2.0" dataSet="pBOMPrpg1QX"
  completeDate="2014-02-03" period="201401" orgUnit="DiszpKrYNg8">
  <dataValue dataElement="f7n9E0hX8qk" value="12"/>
  <dataValue dataElement="Ix2HsbDMLea" value="14"/>
  <dataValue dataElement="eY5ehpbEsB7" value="16"/>
</dataValueSet>
```

Au format JSON :

```json
{
  "dataSet": "pBOMPrpg1QX",
  "completeDate": "2014-02-03",
  "period": "201401",
  "orgUnit": "DiszpKrYNg8",
  "dataValues": [
    {
      "dataElement": "f7n9E0hX8qk", 
      "value": "1"
    },
    {
      "dataElement": "Ix2HsbDMLea", 
      "value": "2"
    },
    {
      "dataElement": "eY5ehpbEsB7", 
      "value": "3"
    }
  ]
}
```

Pour effectuer des tests fonctionnels, nous utiliserons l'outil _curl_ qui permet de transférer facilement des données à l'aide du protocole HTTP. Tout d'abord, nous sauvegardons le contenu XML de l'ensemble de données dans un fichier appelé `datavalueset.xml`. Dans le répertoire où se trouve ce fichier, nous invoquons ce qui suit à partir de la ligne de commande :

```bash
curl -d @datavalueset.xml "https://play.dhis2.org/demo/api/33/dataValueSets"
  -H "Content-Type:application/xml" -u admin:district
```

Pour envoyer du contenu JSON, vous devez définir l'en-tête "type de contenu" comme suit :

```bash
curl -d @datavalueset.json "https://play.dhis2.org/demo/api/33/dataValueSets"
  -H "Content-Type:application/json" -u admin:district
```

La commande enverra une requête à l'API Web de démonstration, définissez `application/xml` comme type de contenu et authentifiez-vous en utilisant `admin`/`district` comme nom d'utilisateur/mot de passe. Si tout se passe bien, le code d'état HTTP `200 OK` sera renvoyé. Vous pouvez vérifier la réception des données en ouvrant le module de saisie de données dans DHIS2 et en sélectionnant l'unité d'organisation, l'ensemble de données et la période utilisés dans cet exemple.

L'API suit la sémantique normale pour la gestion des erreurs et les codes d'état HTTP. Si vous fournissez un nom d'utilisateur ou un mot de passe invalide, `401 Non autorisé` est renvoyé. Si vous fournissez un type de contenu autre que `application/xml`, `415 Type de média non pris en charge` est renvoyé. Si le contenu XML n'est pas valide selon l'espace de noms DXF, `400 Mauvaise requête` est renvoyé. Si vous fournissez un identifiant invalide dans le contenu XML, `409 Conflit` est renvoyé avec un message descriptif.

### Envoi de données en masse { #webapi_sending_bulks_data_values }

<!--DHIS2-SECTION-ID:webapi_sending_bulks_data_values-->

L'exemple précédent nous a montré comment envoyer un ensemble de données associées qui partagent la même période et la même unité d’organisation. L'exemple suivant nous montrera comment envoyer de grandes quantités de données qui ne sont pas nécessairement associés.

Encore une fois, nous interagirons avec la ressource `/api/dataValueSets`. Cette fois nous n'allons pas spécifier les attributs `dataSet` et `completeDate`. De plus, nous allons spécifiez les attributs `period` et `orgUnit` comme éléments de données individuelles et non élément d’ensemble de données externes. Cela nous permettra d'envoyer des données pour différentes périodes et unités d'organisation :

```xml
<dataValueSet xmlns="http://dhis2.org/schema/dxf/2.0">
  <dataValue dataElement="f7n9E0hX8qk" 
    period="201401" orgUnit="DiszpKrYNg8" value="12"/>
  <dataValue dataElement="f7n9E0hX8qk" 
    period="201401" orgUnit="FNnj3jKGS7i" value="14"/>
  <dataValue dataElement="f7n9E0hX8qk" 
    period="201402" orgUnit="DiszpKrYNg8" value="16"/>
  <dataValue dataElement="f7n9E0hX8qk" 
    period="201402" orgUnit="Jkhdsf8sdf4" value="18"/>
</dataValueSet>
```

Au format JSON :

```json
{
  "dataValues": [
    {
      "dataElement": "f7n9E0hX8qk", 
      "period": "201401", 
      "orgUnit": "DiszpKrYNg8", 
      "value": "12"
    }, 
    {
      "dataElement": "f7n9E0hX8qk", 
      "period": "201401", 
      "orgUnit": "FNnj3jKGS7i", 
      "value": "14"
    }, 
    {
      "dataElement": "f7n9E0hX8qk", 
      "period": "201402", 
      "orgUnit": "DiszpKrYNg8", 
      "value": "16"
    }, 
    {
      "dataElement": "f7n9E0hX8qk", 
      "period": "201402", 
      "orgUnit": "Jkhdsf8sdf4", 
      "value": "18"
    }
  ]
}
```

Au format CSV :

```csv
"dataelement","period","orgunit","categoryoptioncombo","attributeoptioncombo","value"
"f7n9E0hX8qk","201401","DiszpKrYNg8","bRowv6yZOF2","bRowv6yZOF2","1"
"Ix2HsbDMLea","201401","DiszpKrYNg8","bRowv6yZOF2","bRowv6yZOF2","2"
"eY5ehpbEsB7","201401","DiszpKrYNg8","bRowv6yZOF2","bRowv6yZOF2","3"
```

Nous effectuons les tests en utilisant "curl" pour envoyer les données au format XML :

```bash
curl -d @datavalueset.xml "https://play.dhis2.org/demo/api/33/dataValueSets"
  -H "Content-Type:application/xml" -u admin:district
```

Notez que lorsque vous utilisez le format CSV, vous devez utiliser l'option de données binaires pour conserver le retour-à-la-ligne dans le fichier CSV :

```bash
curl --data-binary @datavalueset.csv "https://play.dhis2.org/demo/24/api/dataValueSets"
  -H "Content-Type:application/csv" -u admin:district
```

La ressource ensemble de valeurs de données fournit une réponse XML qui est utile lorsque vous voulez vérifier l'impact de votre requête. La première fois que nous envoyons la requête " ensemble de données " ci-dessus, le serveur répondra avec le résumé d'importation suivant :

```xml
<importSummary>
  <dataValueCount imported="2" updated="1" ignored="1"/>
  <dataSetComplete>faux</dataSetComplete>
</importSummary>
```

Ce message nous indique que 3 données ont été importées, 1 donnée a été mise à jour et 0 donnée a été ignorée. La seule mise à jour résulte de l'envoi de cette donnée dans l'exemple précédent. Une donnée sera ignorée si elle fait référence à un élément de données, une période, une unité d'organisation ou un ensemble de données qui n'existent pas. Dans notre cas, cette valeur unique ignorée est due au fait que la dernière donnée faisait référence à une unité d'organisation non valide. L'élément complet de l'ensemble de données affichera la date à laquelle l'ensemble de données a été achevé, ou " faux " si aucun attribut d'élément de données n'a été fourni.

### Paramètres d'importation { #webapi_data_values_import_parameters }

<!--DHIS2-SECTION-ID:webapi_data_values_import_parameters-->

Le processus d'importation peut être personnalisé à l'aide d'un ensemble de paramètres d'importation :

<table>
<caption>Import parameters</caption>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Values (default first)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>dataElementIdScheme</td>
<td>id | name | code | attribute:ID</td>
<td>Property of the data element object to use to map the data values.</td>
</tr>
<tr class="even">
<td>orgUnitIdScheme</td>
<td>id | name | code | attribute:ID</td>
<td>Property of the org unit object to use to map the data values.</td>
</tr>
<tr class="odd">
<td>categoryOptionComboIdScheme</td>
<td>id | name | code | attribute:ID</td>
<td>Property of the category option combo and attribute option combo objects to use to map the data values.</td>
</tr>
<tr class="even">
<td>idScheme</td>
<td>id | name | code| attribute:ID</td>
<td>Property of all objects including data elements, org units and category option combos, to use to map the data values.</td>
</tr>
<tr class="odd">
<td>preheatCache</td>
<td>false | true</td>
<td>Indicates whether to preload metadata caches before starting to import data values, will speed up large import payloads with high metadata cardinality.</td>
</tr>
<tr class="even">
<td>dryRun</td>
<td>false | true</td>
<td>Whether to save changes on the server or just return the import summary.</td>
</tr>
<tr class="odd">
<td>importStrategy</td>
<td>CREATE | UPDATE | CREATE_AND_UPDATE | DELETE</td>
<td>Save objects of all, new or update import status on the server.</td>
</tr>
<tr class="even">
<td>skipExistingCheck</td>
<td>false | true</td>
<td>Skip checks for existing data values. Improves performance. Only use for empty databases or when the data values to import do not exist already.</td>
</tr>
<tr class="even">
<td>skipAudit</td>
<td>false | true</td>
<td>Skip audit, meaning audit values will not be generated. Improves performance at the cost of ability to audit changes. Requires authority "F_SKIP_DATA_IMPORT_AUDIT".</td>
</tr>
<tr class="odd">
<td>async</td>
<td>false | true</td>
<td>Indicates whether the import should be done asynchronous or synchronous. The former is suitable for very large imports as it ensures that the request does not time out, although it has a significant performance overhead. The latter is faster but requires the connection to persist until the process is finished.</td>
</tr>
<tr class="even">
<td>force</td>
<td>false | true</td>
<td>Indicates whether the import should be forced. Data import could be rejected for various reasons of data set locking for example due to approval, data input period, expiry days, etc. In order to override such locks and force data input one can use data import with force=true. However, one needs to be a *superuser* for this parameter to work.</td>
</tr>
</tbody>
</table>

Tous les paramètres sont facultatifs et peuvent être fournis en tant que paramètres de requête dans l'URL de la requête comme ceci :

    /api/33/dataValueSets?dataElementIdScheme=code&orgUnitIdScheme=name
      &dryRun=true&importStrategy=CREATE

Ils peuvent également être fournis en tant qu'attributs XML sur l'élément " ensemble de valeurs de données ", tel qu'indiqué ci-dessous. Les attributs XML remplacent les paramètres de la chaîne de requête.

```xml
<dataValueSet xmlns="http://dhis2.org/schema/dxf/2.0" dataElementIdScheme="code"
  orgUnitIdScheme="name" dryRun="true" importStrategy="CREATE">
</dataValueSet>
```

Notez que le paramètre `preheatCache` peut avoir un impact considérable sur les performances. Pour les petits fichiers d'importation, maintenir "faux" permettra de gagner en rapidité. Pour les gros fichiers d'importation qui contiennent un grand nombre d'éléments de données et d'unités d'organisation distincts, le définir sur "vrai" permettra de gagner en rapidité en termes d'ordre de grandeur.

#### Exigences en matière de valeur des données { #webapi_data_values_import_requirement }

<!--DHIS2-SECTION-ID:webapi_data_values_import_requirement-->

L’importation de valeurs de données prend en charge un ensemble de types de valeurs. Chaque type de valeur a une exigence particulière. Le tableau suivant répertorie les cas extrêmes pour les types valeur.

<table>
<caption>Value type requirements</caption>
<thead>
<tr class="header">
<th>Value type</th>
<th>Requirements</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>BOOLEAN</td>
<td>true | True | TRUE | false | False | FALSE | 1 | 0 | t | f |</td>
<td>Used when the value is a boolean, true or false value. The import service does not care if the input begins with an uppercase or lowercase letter, or if it's all uppercase.</td>
</tr>
</tbody>
</table>

#### Schémas d'identifiants { #webapi_data_values_identifier_schemes }

<!--DHIS2-SECTION-ID:webapi_data_values_identifier_schemes-->

En ce qui concerne les schémas d'identifiants, les identifiants utilisés dans les messages XML utilisent par défaut les identifiants d'objets stables de DHIS2 appelés `UID`. Dans certaines situations d'interopérabilité, il se peut qu'un système externe détermine les identifiants des objets. Dans ce cas, nous pouvons utiliser la propriété `code` des unités d'organisation et d'autres objets pour définir des identifiants fixes. Lors de l'importation des valeurs de données, nous devons donc référencer la propriété "code" et non la propriété "identifiant" de ces objets de métadonnées. Les schémas d'identifiants peuvent être spécifiés dans le message XML ainsi que dans la requête en tant que paramètres de requête. Pour les spécifier dans la charge utile XML, vous pouvez procéder comme suit :

```xml
<dataValueSet xmlns="http://dhis2.org/schema/dxf/2.0"
  dataElementIdScheme="CODE" orgUnitIdScheme="UID" idScheme="CODE">
</dataValueSet>
```

Le tableau des paramètres ci-dessus explique comment les schémas d'identifiants peuvent être spécifiés comme paramètres de requête. Les règles suivantes déterminent l'ordre de priorité :

  - Les schémas d'identifiants définis dans la charge utile XML ou JSON ont priorité sur
    les schémas d'identifiants définis comme paramètres de requête URL.

  - Specific id schemes including dataElementIdScheme and
    orgUnitIdScheme ont priorité sur le idScheme général.

  - The default id scheme is UID, which will be used if no explicit id
    scheme is defined.

Les schémas d'identifiants suivants sont disponibles.

  - uid (default)

  - code

  - Nom

  - attribut (suivi de l'UID de l'attribut)

L'option d'attribut est spéciale et fait référence aux attributs de métadonnées qui ont été marqués comme *uniques*. En utilisant cette option, l'`attribut` doit être immédiatement suivi de l'identifiant de l'attribut, par exemple "attribut : DnrLSdo4hMl".

#### Importation de valeurs de données asynchrones { #webapi_data_values_async_import }

<!--DHIS2-SECTION-ID:webapi_data_values_async_import-->

Les valeurs de données peuvent être envoyées et importées de manière asynchrone à travers un paramètre de requête `async` défini sur *vrai* :

    /api/33/dataValueSets?async=true

Cela lancera une tâche d'importation asynchrone dont vous pourrez surveiller l'état grâce à l'API de résumés des tâches. La réponse de l'API indique l'identifiant unique de la tâche, du type de tâche et de l'URL que vous pouvez utiliser pour surveiller l’état de l'importation. La réponse ressemblera à ceci :

```json
{
  "httpStatus": "OK",
  "httpStatusCode": 200,
  "status": "OK",
  "message": "Initiated dataValueImport",
  "response": {
    "name": "dataValueImport",
    "id": "YR1UxOUXmzT",
    "created": "2018-08-20T14:17:28.429",
    "jobType": "DATAVALUE_IMPORT",
    "relativeNotifierEndpoint": "/api/system/tasks/DATAVALUE_IMPORT/YR1UxOUXmzT"
  }
}
```

Veuillez lire la section sur *l'état des tâches asynchrones* pour en savoir plus.

### Format des valeurs de données CSV { #webapi_data_values_csv }

<!--DHIS2-SECTION-ID:webapi_data_values_csv-->

La section suivante décrit le format CSV utilisé dans DHIS2. La première ligne est supposée être une ligne d'en-tête et sera ignorée lors de l'importation.

<table>
<caption>CSV format of DHIS2</caption>
<tbody>
<tr class="odd">
<td>Column</td>
<td>Required</td>
<td>Description</td>
</tr>
<tr class="even">
<td>Data element</td>
<td>Yes</td>
<td>Refers to ID by default, can also be name and code based on selected id scheme</td>
</tr>
<tr class="odd">
<td>Period</td>
<td>Yes</td>
<td>In ISO format</td>
</tr>
<tr class="even">
<td>Org unit</td>
<td>Yes</td>
<td>Refers to ID by default, can also be name and code based on selected id scheme</td>
</tr>
<tr class="odd">
<td>Category option combo</td>
<td>No</td>
<td>Refers to ID</td>
</tr>
<tr class="even">
<td>Attribute option combo</td>
<td>No</td>
<td>Refers to ID (from version 2.16)</td>
</tr>
<tr class="odd">
<td>Value</td>
<td>No</td>
<td>Data value</td>
</tr>
<tr class="even">
<td>Stored by</td>
<td>No</td>
<td>Refers to username of user who entered the value</td>
</tr>
<tr class="odd">
<td>Last updated</td>
<td>No</td>
<td>Date in ISO format</td>
</tr>
<tr class="even">
<td>Comment</td>
<td>No</td>
<td>Free text comment</td>
</tr>
<tr class="odd">
<td>Follow up</td>
<td>No</td>
<td>true or false</td>
</tr>
</tbody>
</table>

Ci-dessous un exemple de fichier CSV pouvant être importé dans DHIS2 :

```csv
"dataelement","period","orgunit","catoptcombo","attroptcombo","value","storedby","timestamp"
"DUSpd8Jq3M7","201202","gP6hn503KUX","Prlt0C1RF0s",,"7","bombali","2010-04-17"
"DUSpd8Jq3M7","201202","gP6hn503KUX","V6L425pT3A0",,"10","bombali","2010-04-17"
"DUSpd8Jq3M7","201202","OjTS752GbZE","V6L425pT3A0",,"9","bombali","2010-04-06"
```

### Génération d'un modèle d'ensemble de valeurs de données { #webapi_data_values_template }

<!--DHIS2-SECTION-ID:webapi_data_values_template-->

Pour générer un modèle d'ensemble de valeurs de données pour un ensemble de données spécifique, vous pouvez utiliser la ressource `/api/dataSets/<id>/dataValueSet`. les formats de réponse XML et JSON sont pris en charge. Exemple:

    /api/dataSets/BfMAe6Itzgt/dataValueSet.json

Ci-dessous les paramètres que vous pouvez utiliser pour ajuster davantage la sortie :

<table style="width:100%;">
<caption>Data values query parameters</caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 19%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="header">
<th>Query parameter</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>period</td>
<td>No</td>
<td>Period to use, will be included without any checks.</td>
</tr>
<tr class="even">
<td>orgUnit</td>
<td>No</td>
<td>Organisation unit to use, supports multiple orgUnits, both id and code can be used.</td>
</tr>
<tr class="odd">
<td>comment</td>
<td>No</td>
<td>Should comments be include, default: Yes.</td>
</tr>
<tr class="even">
<td>orgUnitIdScheme</td>
<td>No</td>
<td>Organisation unit scheme to use, supports id | code.</td>
</tr>
<tr class="odd">
<td>dataElementIdScheme</td>
<td>No</td>
<td>Data-element scheme to use, supports id | code.</td>
</tr>
</tbody>
</table>

### Lecture des valeurs de données { #webapi_reading_data_values }

<!--DHIS2-SECTION-ID:webapi_reading_data_values-->

This section explains how to retrieve data values from the Web API by
interacting with the *dataValueSets* resource. Data values can be
retrieved in *XML*, *JSON* and *CSV* format. Since we want to read data
we will use the *GET* HTTP verb. We will also specify that we are
interested in the XML resource representation by including an `Accept`
HTTP header with our request. The following query parameters are
required:

<table>
<caption>Data value set query parameters</caption>
<colgroup>
<col style="width: 27%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>dataSet</td>
<td>Data set identifier. Can be repeated any number of times.</td>
</tr>
<tr class="even">
<td>dataElementGroup</td>
<td>Data element group identifier. Can be repeated any number of times.</td>
</tr>
<tr class="odd">
<td>period</td>
<td>Period identifier in ISO format. Can be repeated any number of times.</td>
</tr>
<tr class="even">
<td>startDate</td>
<td>Start date for the time span of the values to export.</td>
</tr>
<tr class="odd">
<td>endDate</td>
<td>End date for the time span of the values to export.</td>
</tr>
<tr class="even">
<td>orgUnit</td>
<td>Organisation unit identifier. Can be repeated any number of times.</td>
</tr>
<tr class="odd">
<td>children</td>
<td>Whether to include the children in the hierarchy of the organisation units.</td>
</tr>
<tr class="even">
<td>orgUnitGroup</td>
<td>Organisation unit group identifier. Can be repeated any number of times.</td>
</tr>
<tr class="odd">
<td>attributeOptionCombo</td>
<td>Attribute option combo identifier. Can be repeated any number of times.</td>
</tr>
<tr class="even">
<td>includeDeleted</td>
<td>Whether to include deleted data values.</td>
</tr>
<tr class="odd">
<td>lastUpdated</td>
<td>Include only data values which are updated since the given time stamp.</td>
</tr>
<tr class="even">
<td>lastUpdatedDuration</td>
<td>Include only data values which are updated within the given duration. The format is &lt;value&gt;&lt;time-unit&gt;, where the supported time units are &quot;d&quot; (days), &quot;h&quot; (hours), &quot;m&quot; (minutes) and &quot;s&quot; (seconds).</td>
</tr>
<tr class="odd">
<td>limit</td>
<td>The max number of results in the response.</td>
</tr>
<tr class="even">
<td>idScheme</td>
<td>Property of meta data objects to use for data values in response.</td>
</tr>
<tr class="odd">
<td>dataElementIdScheme</td>
<td>Property of the data element object to use for data values in response.</td>
</tr>
<tr class="even">
<td>orgUnitIdScheme</td>
<td>Property of the org unit object to use for data values in response.</td>
</tr>
<tr class="odd">
<td>categoryOptionComboIdScheme</td>
<td>Property of the category option combo and attribute option combo objects to use for data values in response.</td>
</tr>
<tr class="even">
<td>dataSetIdScheme</td>
<td>Property of the data set object to use in the response.</td>
</tr>
</tbody>
</table>

Les formats de réponse suivants sont pris en charge :

  - xml (application/xml)

  - json (application/json)

  - csv (application/csv)

  - adx (application/adx+xml)

En supposant que nous avons publié les valeurs de données dans DHIS2 conformément à la section précédente intitulée *Envoi de valeurs de données*, nous pouvons maintenant constituer notre requête pour un ensemble de valeurs de données unique et l'exécuter en utilisant l'URL :

```bash
curl "https://play.dhis2.org/demo/api/33/dataValueSets?dataSet=pBOMPrpg1QX&period=201401&orgUnit=DiszpKrYNg8"
  -H "Accept:application/xml" -u admin:district
```

Nous pouvons également utiliser les paramètres de requête "date de début" et "date de fin" pour demander un plus grand nombre de valeurs de données. En d'autres termes, vous pouvez également demander des valeurs de données pour plusieurs ensembles de données, unités d'organisation et périodes afin d'exporter de plus grandes quantités de données. Notez que le paramètre de requête "période" est prioritaire sur les paramètres "date de début" et "date de fin". Voici un exemple :

```bash
curl "https://play.dhis2.org/demo/api/33/dataValueSets?dataSet=pBOMPrpg1QX&dataSet=BfMAe6Itzgt
  &startDate=2013-01-01&endDate=2013-01-31&orgUnit=YuQRtpLP10I&orgUnit=vWbkYPRmKyS&children=true"
  -H "Accept:application/xml" -u admin:district
```

Pour récupérer les valeurs de données qui ont été créées ou mises à jour au cours des 10 derniers jours, vous pouvez effectuer la requête suivante :

    /api/dataValueSets?dataSet=pBOMPrpg1QX&orgUnit=DiszpKrYNg8&lastUpdatedDuration=10d

La réponse ressemblera à ceci :

```xml
<?xml version='1.0' encoding='UTF-8'?>
<dataValueSet xmlns="http://dhis2.org/schema/dxf/2.0" dataSet="pBOMPrpg1QX"
  completeDate="2014-01-02" period="201401" orgUnit="DiszpKrYNg8">
<dataValue dataElement="eY5ehpbEsB7" period="201401" orgUnit="DiszpKrYNg8"
  categoryOptionCombo="bRowv6yZOF2" value="10003"/>
<dataValue dataElement="Ix2HsbDMLea" period="201401" orgUnit="DiszpKrYNg8"
  categoryOptionCombo="bRowv6yZOF2" value="10002"/>
<dataValue dataElement="f7n9E0hX8qk" period="201401" orgUnit="DiszpKrYNg8"
  categoryOptionCombo="bRowv6yZOF2" value="10001"/>
</dataValueSet>
```

Vous pouvez demander à ce que les données soient rendues au format JSON de la manière suivante :

    /api/dataValueSets.json?dataSet=pBOMPrpg1QX&period=201401&orgUnit=DiszpKrYNg8

La réponse ressemblera à ceci :

```json
{
  "dataSet": "pBOMPrpg1QX",
  "completeDate": "2014-02-03",
  "period": "201401",
  "orgUnit": "DiszpKrYNg8",
  "dataValues": [
    {
      "dataElement": "eY5ehpbEsB7", 
      "categoryOptionCombo": "bRowv6yZOF2", 
      "period": "201401",
      "orgUnit": "DiszpKrYNg8", 
      "value": "10003"
    }, 
    {
      "dataElement": "Ix2HsbDMLea", 
      "categoryOptionCombo": "bRowv6yZOF2", 
      "period": "201401",
      "orgUnit": "DiszpKrYNg8", 
      "value": "10002"
    }, 
    {
      "dataElement": "f7n9E0hX8qk", 
      "categoryOptionCombo": "bRowv6yZOF2", 
      "period": "201401",
      "orgUnit": "DiszpKrYNg8", 
      "value": "10001"
    }
  ]
}
```

Notez que les valeurs de données sont mises en corbeille, c'est-à-dire qu'une valeur supprimée a la propriété `supprimée` définie sur "vrai" et n'est pas supprimée de façon permanente. Ceci est utile lors de l'intégration de plusieurs systèmes afin de signaler les suppressions. Vous pouvez inclure les valeurs supprimées dans la réponse comme suit :

    /api/33/dataValueSets.json?dataSet=pBOMPrpg1QX&period=201401
      &orgUnit=DiszpKrYNg8&includeDeleted=true

Vous pouvez également demander à ce que les données soient rendues au format CSV de la manière suivante :

    /api/33/dataValueSets.csv?dataSet=pBOMPrpg1QX&period=201401
      &orgUnit=DiszpKrYNg8

La réponse ressemblera à ceci :

```csv
dataelement,period,orgunit,catoptcombo,attroptcombo,value,storedby,lastupdated,comment,flwup
f7n9E0hX8qk,201401,DiszpKrYNg8,bRowv6yZOF2,bRowv6yZOF2,12,system,2015-04-05T19:58:12.000,comment1,false
Ix2HsbDMLea,201401,DiszpKrYNg8,bRowv6yZOF2,bRowv6yZOF2,14,system,2015-04-05T19:58:12.000,comment2,false
eY5ehpbEsB7,201401,DiszpKrYNg8,bRowv6yZOF2,bRowv6yZOF2,16,system,2015-04-05T19:58:12.000,comment3,false
FTRrcoaog83,201401,DiszpKrYNg8,bRowv6yZOF2,bRowv6yZOF2,12,system,2014-03-02T21:45:05.519,comment4,false
```

Les contraintes suivantes s'appliquent à la ressource Ensembles de valeurs de données :

  - Au moins un ensemble de données doit être spécifié.

  - Soit au moins une période, soit une date de début et une date de fin doivent être
    spécifiés.

  - Au moins une unité d'organisation doit être spécifiée.

  - Les unités d'organisation doivent faire partie de la hiérarchie des unités d'organisation 
    de l’utilisateur authentifié.

  - La limite ne peut pas être inférieure à zéro.

### Envoi, lecture et suppression de valeurs de données individuelles { #webapi_sending_individual_data_values }

<!--DHIS2-SECTION-ID:webapi_sending_individual_data_values-->

Cet exemple montrera comment envoyer des valeurs de données individuelles à enregistrer dans une requête. Ceci peut être réalisé par l'envoi d'une requête *POST* à la ressource `dataValues` :

    /api/dataValues

Les paramètres de requête suivants sont pris en charge pour cette ressource :

<table style="width:100%;">
<caption>Data values query parameters</caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 19%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="header">
<th>Query parameter</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>de</td>
<td>Yes</td>
<td>Data element identifier</td>
</tr>
<tr class="even">
<td>pe</td>
<td>Yes</td>
<td>Period identifier</td>
</tr>
<tr class="odd">
<td>ou</td>
<td>Yes</td>
<td>Organisation unit identifier</td>
</tr>
<tr class="even">
<td>co</td>
<td>No</td>
<td>Category option combo identifier, default will be used if omitted</td>
</tr>
<tr class="odd">
<td>cc</td>
<td>No (must be combined with cp)</td>
<td>Attribute category combo identifier</td>
</tr>
<tr class="even">
<td>cp</td>
<td>No (must be combined with cc)</td>
<td>Attribute category option identifiers, separated with ; for multiple values</td>
</tr>
<tr class="odd">
<td>ds</td>
<td>No</td>
<td>Data set, to check if POST or DELETE is allowed for period and organisation unit. If specified, the data element must be assigned to this data set. If not specified, a data set containing the data element will be chosen to check if the operation is allowed.</td>
</tr>
<tr class="even">
<td>value</td>
<td>No</td>
<td>Data value. For boolean values, the following will be accepted: true | True | TRUE | false | False | FALSE | 1 | 0 | t | f |</td>
</tr>
<tr class="odd">
<td>comment</td>
<td>No</td>
<td>Data comment</td>
</tr>
<tr class="even">
<td>followUp</td>
<td>No</td>
<td>Follow up on data value, will toggle the current boolean value</td>
</tr>
</tbody>
</table>

Si l'un des identifiants fournis n'est pas valide, si la valeur de données ou le commentaire n'est pas valide ou si les données sont verrouillées, la réponse contiendra le code d'état *409 Conflit* et un message texte descriptif. Si l'opération conduit à une valeur enregistrée ou mise à jour, *200 OK* sera renvoyé. Ci-après, un exemple de requête :

```bash
curl "https://play.dhis2.org/demo/api/33/dataValues?de=s46m5MS0hxu
  &pe=201301&ou=DiszpKrYNg8&co=Prlt0C1RF0s&value=12"
  -X POST -u admin:district
```

Cette ressource permet également une syntaxe spéciale pour associer la valeur à une combinaison d'options d'attribut. Pour ce faire, il suffit d'envoyer l'identifiant de la combinaison de catégories d'attribut, ainsi que les identifiants des options de catégories d'attribut que la valeur représente au sein de la combinaison. La combinaison de catégories est spécifiée avec le paramètre `cc`, tandis que les options de catégorie sont spécifiées sous la forme d'une chaîne de caractères séparés par des points-virgules avec le paramètre `cp`. Il faut s'assurer que les options de catégorie font toutes partie de la combinaison de catégories. Voici un exemple :

```bash
curl "https://play.dhis2.org/demo/api/33/dataValues?de=s46m5MS0hxu&ou=DiszpKrYNg8
  &pe=201308&cc=dzjKKQq0cSO&cp=wbrDrL2aYEc;btOyqprQ9e8&value=26"
  -X POST -u admin:district
```

Vous pouvez récupérer une valeur de données avec une requête en utilisant la méthode *GET* (obtenir). Les paramètres de valeur, de commentaire et de suivi ne sont pas applicables ici :

```bash
curl "https://play.dhis2.org/demo/api/33/dataValues?de=s46m5MS0hxu
  &pe=201301&ou=DiszpKrYNg8&co=Prlt0C1RF0s"
  -u admin:district
```

Vous pouvez supprimer une valeur de données avec une requête en utilisant la méthode *DELETE*.

#### Utilisation des valeurs de données de fichiers { #datavalue_file }

<!--DHIS2-SECTION-ID:datavalue_file-->

Lorsqu'il s'agit de valeurs de données dont l'élément de données est de type *fichier*, la méthode décrite ci-dessus ne s'applique plus. Ces valeurs de données sont spéciales dans la mesure où le contenu de la valeur est une référence UID à un objet *Ressource de fichier* et non une constante autonome. Ces valeurs de données se comportent comme les autres valeurs de données qui stockent du contenu textuel, mais elles doivent être traitées différemment afin de produire des entrées et des sorties pertinentes.

The process of storing one of these data values roughly goes like this:

1.  Téléchargez le fichier sur le point de terminaison `/api/fileResources` tel que décrit
    dans la section des ressources de fichiers.

2.  Retrieve the `id` property of the returned *FileResource*.

3.  Store the retrieved id *as the value* to the data value using any
    des méthodes décrites ci-dessus.

Seules les relations un à un entre les valeurs de données et les ressources de fichiers sont autorisées. Cette règle est appliquée en interne, de sorte que l'enregistrement de l'identifiant d'une ressource de fichier dans plusieurs valeurs de données ne soit pas possible et entraîne une erreur. La suppression de la valeur de données entraîne la suppression de la ressource de fichier référencée. La suppression directe des ressources de fichiers n'est pas possible.

La valeur de données peut maintenant être récupérée normalement, mais c'est l'UID de la ressource du fichier qui sera renvoyé. Afin de récupérer le vrai contenu (c'est-à-dire le fichier stocké dans la ressource associée à la valeur de données), vous devez effectuer une requête GET à `/api/dataValues/files` en reproduisant les paramètres de la requête comme pour la valeur de données elle-même. Le point de terminaison `/api/dataValues/files` ne prend en charge que les requêtes GET.

Il convient de noter qu'en raison du fonctionnement asynchrone du mécanisme de stockage sous-jacent, le contenu du fichier peut ne pas être immédiatement téléchargeable à partir du point de terminaison `/api/dataValues/files`. Ceci est particulièrement valable pour les fichiers volumineux qui peuvent nécessiter des téléchargements en arrière-plan vers un entrepôt de fichiers externe (en fonction de la configuration du système). Récupérer les métadonnées de la ressource du fichier à partir du point de terminaison `/api/fileResources/<id>` permet de vérifier le `storageStatus` (état du stockage) du contenu avant d'essayer de le télécharger.

## Format de données ADX { #webapi_adx_data_format }

<!--DHIS2-SECTION-ID:webapi_adx_data_format-->

From version 2.20 we have included support for an international standard
for aggregate data exchange called ADX. ADX is developed and maintained
by the Quality Research and Public Health committee of the IHE
(Integrating the HealthCare Enterprise). The wiki page detailing QRPH
activity can be found at
[wiki.ihe.net](http://wiki.ihe.net/index.php?title=Quality,_Research_and_Public_Health#Current_Domain_Activities).
ADX is still under active development and has now been published for
trial implementation. Note that what is implemented currently in DHIS2
is the functionality to read and write adx formatted data, i.e. what is
described as Content Consumer and Content Producer actors in the ADX
profile.

La structure d'un message de données ADX est assez similaire à celle des données DXF 2 décrites précédemment et que vous connaissez probablement. Il existe quelques différences importantes. Nous les décrirons à l'aide d'un petit exemple :

```xml
<adx xmlns="urn:ihe:qrph:adx:2015" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="urn:ihe:qrph:adx:2015 ../schema/adx_loose.xsd" 
  exported="2015-02-08T19:30:00Z">
  <group orgUnit="OU_559" period="2015-06-01/P1M" 
    completeDate="2015-07-01" dataSet="(TB/HIV)VCCT">
    <dataValue dataElement="VCCT_0" GENDER="FMLE" HIV_AGE="AGE0-14" value="32"/>
    <dataValue dataElement="VCCT_1" GENDER="FMLE" HIV_AGE="AGE0-14" value="20"/>
    <dataValue dataElement="VCCT_2" GENDER="FMLE" HIV_AGE="AGE0-14" value="10"/>
    <dataValue dataElement="PLHIV_TB_0" GENDER="FMLE" HIV_AGE="AGE0-14" value="10"/>
    <dataValue dataElement="PLHIV_TB_1" GENDER="FMLE" HIV_AGE="AGE0-14" value="10"/>

    <dataValue dataElement="VCCT_0" GENDER="MLE" HIV_AGE="AGE0-14" value="32"/>
    <dataValue dataElement="VCCT_1" GENDER="MLE" HIV_AGE="AGE0-14" value="20"/>
    <dataValue dataElement="VCCT_2" GENDER="MLE" HIV_AGE="AGE0-14" value="10"/>
    <dataValue dataElement="PLHIV_TB_0" GENDER="MLE" HIV_AGE="AGE0-14" value="10"/>
    <dataValue dataElement="PLHIV_TB_1" GENDER="MLE" HIV_AGE="AGE0-14" value="10"/>

    <dataValue dataElement="VCCT_0" GENDER="FMLE" HIV_AGE="AGE15-24" value="32"/>
    <dataValue dataElement="VCCT_1" GENDER="FMLE" HIV_AGE="AGE15-24" value="20"/>
    <dataValue dataElement="VCCT_2" GENDER="FMLE" HIV_AGE="AGE15-24" value="10"/>
    <dataValue dataElement="PLHIV_TB_0" GENDER="FMLE" HIV_AGE="AGE15-24" value="10"/>
    <dataValue dataElement="PLHIV_TB_1" GENDER="FMLE" HIV_AGE="AGE15-24" value="10"/>

    <dataValue dataElement="VCCT_0" GENDER="MLE" HIV_AGE="AGE15-24" value="32"/>
    <dataValue dataElement="VCCT_1" GENDER="MLE" HIV_AGE="AGE15-24" value="20"/>
    <dataValue dataElement="VCCT_2" GENDER="MLE" HIV_AGE="AGE15-24" value="10"/>
    <dataValue dataElement="PLHIV_TB_0" GENDER="MLE" HIV_AGE="AGE15-24" value="10"/>
    <dataValue dataElement="PLHIV_TB_1" GENDER="MLE" HIV_AGE="AGE15-24" value="10"/>
  </group>
</adx>
```

### The adx root element { #the-adx-root-element } 

The adx root element has only one mandatory attribute, which is the
*exported* timestamp. In common with other adx elements, the schema is
extensible in that it does not restrict additional application specific
attributes.

### The group element { #the-group-element } 

Unlike dxf2, adx requires that the datavalues are grouped according to
orgUnit, period and dataSet. The example above shows a data report for
the "(TB/HIV) VCCT" dataset from the online demo database. This example
is using codes as identifiers instead of dhis2 uids. Codes are the
preferred form of identifier when using adx.

The orgUnit, period and dataSet attributes are mandatory in adx. The
group element may contain additional attributes. In our DHIS2
implementation any additional attributes are simply passed through to
the underlying importer. This means that all attributes which currently
have meaning in dxf2 (such as completeDate in the example above) can
continue to be used in adx and they will be processed in the same way.

A significant difference between adx and dxf2 is in the way that periods
are encoded. Adx makes strict use of ISO8601 and encodes the reporting
period as (date|datetime)/(duration). So the period in the example above
is a period of 1 month (P1M) starting on 2015-06-01. So it is the data
for June 2015. The notation is a bit more verbose, but it is very
flexible and allows us to support all existing period types in DHIS2

### Définitions des périodes ADX { #adx-period-definitions }

DHIS2 supports a limited number of periods or durations during import.
Periods should begin with the date in which the duration begins, followed by
a "/" and then the duration notation as noted in the table. The
following table details all of the ADX supported period types, along
with examples.

<table>
<caption>ADX Periods</caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th>Period type</th>
<th>Duration notation</th>
<th>Example</th>
<th>Duration</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Daily</td>
<td>P1D</td>
<td>2017-10-01/P1M</td>
<td>Oct 01 2017</td>
</tr>
<tr class="even">
<td>Weekly</td>
<td>P7D</td>
<td>2017-10-01/P7D</td>
<td>Oct 01 2017-Oct 07-2017</td>
</tr>
<tr class="odd">
<td>Monthly</td>
<td>P1M</td>
<td>2017-10-01/P1M</td>
<td>Oct 01 2017-Oct 31 2017</td>
</tr>
<tr class="even">
<td>Bi-monthly</td>
<td>P2M</td>
<td>2017-11-01/P2M</td>
<td>Nov 01 2017-Dec 31 2017</td>
</tr>
<tr class="odd">
<td>Quarterly</td>
<td>P3M</td>
<td>2017-09-01/P3M</td>
<td>Sep 01 2017-Dec 31 2017</td>
</tr>
<tr class="even">
<td>Six-monthly</td>
<td>P6M</td>
<td>2017-01-01/P6M</td>
<td>Jan 01 2017-Jun 30 2017</td>
</tr>
<tr class="odd">
<td>Yearly</td>
<td>P1Ý</td>
<td>2017-01-01/P1Y</td>
<td>Jan 01 2017-Dec 31 2017</td>
</tr>
<tr class="even">
<td>Financial October</td>
<td>P1Y</td>
<td>2017-10-01/P1Y</td>
<td>Oct 01 2017-Sep 30 2018</td>
</tr>
<tr class="odd">
<td>Financial April</td>
<td>P1Y</td>
<td>2017-04-01/P1Y</td>
<td>April 1 2017-Mar 31 2018</td>
</tr>
<tr class="even">
<td>Financial July</td>
<td>P1Y</td>
<td>2017-07-01/P1Y</td>
<td>July 1 2017-June 30 2018</td>
</tr>
</tbody>
</table>

### Valeurs de données { #data-values } 

The dataValue element in adx is very similar to its equivalent in DXF.
The mandatory attributes are *dataElement* and *value*. The *orgUnit* and
*period* attributes don't appear in the dataValue as they are required
at the *group* level.

The most significant difference is the way that disaggregation is
represented. DXF uses the categoryOptionCombo to indicate the disaggregation
of data. In adx the disaggregations (e.g. AGE_GROUP and SEX) are
expressed explicitly as attributes. One important constraint on using
adx is that the categories used for dataElements in the dataSet MUST
have a code assigned to them, and further, that code must be of a form
which is suitable for use as an XML attribute. The exact constraint on
an XML attribute name is described in the W3C XML standard - in practice,
this means no spaces, no non-alphanumeric characters other than '_' and
it may not start with a letter. The example above shows examples of
'good' category codes ('GENDER' and 'HIV_AGE').

This restriction on the form of codes applies only to categories.
Currently, the convention is not enforced by DHIS2 when you are assigning
codes, but you will get an informative error message if you try to
import adx data and the category codes are either not assigned or not
suitable.

Les principaux avantages de l’utilisation de dimensions explicites de données désagrégées sont les suivants :

  - Le système qui produit les données n'a pas besoin d'être synchronisé avec la
    combinaison d'options de catégorie dans DHIS2.

  - Le producteur et le consommateur peuvent faire correspondre leurs codes à une source tierce 
    qui fait autorité, telle qu'un service de terminologie. Notez que dans 
    l'exemple ci-dessus, les codes de genre et de groupe d'âge utilisent des listes de codes
    de l'[Observatoire mondial de la santé de l'OMS](http://apps.who.int/gho/data/node.resources.api).

Note that this feature may be extremely useful, for example when
producing disaggregated data from an EMR system, but there may be cases
where a *categoryOptionCombo* mapping is easier or more desirable. The
DHIS2 implementation of adx will check for the existence of a
*categoryOptionCombo* attribute and, if it exists, it will use that it
preference to exploded dimension attributes. Similarly, an
*attributeOptionCombo* attribute on the *group* element will be
processed in the legacy way. Otherwise, the attributeOptionCombo can be
treated as exploded categories just as on the *dataValue*.

In the simple example above, each of the dataElements in the dataSet
have the same dimensionality (categorycombo) so the data is neatly
rectangular. This need not be the case. dataSets may contain
dataElements with different categoryCombos, resulting in a
*ragged-right* adx data message.

### Importation de données { #importing-data } 

DHIS2 exposes an endpoint for POST adx data at `/api/dataValueSets`
using *application/xml+adx* as content type. So, for example, the
following curl command can be used to POST the example data above to the
DHIS2 demo server:

```bash
curl -u admin:district -X POST -H "Content-Type: application/adx+xml"
  -d @data.xml "https://play.dhis2.org/demo/api/33/dataValueSets?dataElementIdScheme=code&orgUnitIdScheme=code"
```

Note the query parameters are the same as are used with DXF data. The
adx endpoint should interpret all the existing DXF parameters with the
same semantics as DXF.

### Exportation de données { #exporting-data } 

DHIS2 exposes an endpoint to GET adx data sets at `/api/dataValueSets`
using *application/xml+adx* as the accepted content type. So, for
example, the following curl command can be used to retrieve the adx
data:

```bash
curl -u admin:district -H "Accept: application/adx+xml"
 "https://play.dhis2.org/demo/api/33/dataValueSets?dataValueSets?orgUnit=M_CLINIC&dataSet=MALARIA&period=201501"
```

Note the query parameters are the same as are used with DXF data. An
important difference is that the identifiers for dataSet and orgUnit are
assumed to be codes rather than uids.

## Règles du programme { #webapi_program_rules } 

<!--DHIS2-SECTION-ID:webapi_program_rules-->

Cette section traite de l'envoi et de la lecture des règles de programme et explique leur modèle de données. Les règles de programme permettent de configurer un fonctionnement dynamique au sein des programmes de DHIS2.

### Modèle de règles de programme { #webapi_program_rule_model } 

<!--DHIS2-SECTION-ID:webapi_program_rule_model-->

Le modèle de données des règles de programme se compose de variables de règles de programme (programRuleVariables), de règles de programme (programRules) et d'actions de règles de programme (programRuleActions). La règle de programme contient une expression - lorsque cette expression est définie sur "true" (vrai), les actions de règle de programme sous cette expression sont déclenchées. Les variables de règle de programme sont utilisées pour traiter les éléments de données, les valeurs de données des entités suivies et d'autres valeurs de données nécessaires à l'exécution des expressions. Toutes les règles d'un programme partagent la même bibliothèque de variables de règles, et une variable peut être utilisée dans les expressions de plusieurs règles.

![](resources/images/program_rules/program-rule-model.jpg)

#### Détails sur le modèle de règles de programme { #program-rule-model-details } 

Le tableau suivant donne un aperçu détaillé du modèle de règle de programme.

<table style="width:100%;">
<caption>programRule</caption>
<colgroup>
<col style="width: 16%" />
<col style="width: 66%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="header">
<th>name</th>
<th>description</th>
<th>Compulsory</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>program</td>
<td>The program of which the programRule is executed in.</td>
<td>Compulsory</td>
</tr>
<tr class="even">
<td>name</td>
<td>The name with which the program rule will be displayed to dhis2 configurators. Not visible to the end user of the program.</td>
<td>Compulsory</td>
</tr>
<tr class="odd">
<td>description</td>
<td>The description of the program rule, can be used by configurators to describe the rule. Not visible to the end user of the program.</td>
<td>Compulsory</td>
</tr>
<tr class="even">
<td>programStage</td>
<td>If a programStage is set for a program rule, the rule will only be evaluated inside the specified program stage.</td>
<td>optional</td>
</tr>
<tr class="odd">
<td>condition</td>
<td>The expression that needs to be evaluated to true in order for the program rule to trigger its child actions. The expression is written using operators, function calls, hard coded values, constants and program rule variables.
<pre><code>d2:hasValue(&#39;hemoglobin&#39;) &amp;&amp; #{hemoglobin} &lt;= 7</code></pre></td>
<td>Compulsory</td>
</tr>
<tr class="even">
<td>priority</td>
<td>The priority to run the rule in cases where the order of the rules matters. In most cases the rules does not depend on being run before or after other rules, and in these cases the priority can be omitted. If no priority is set, the rule will be run after any rules that has a priority defined. If a priority(integer) is set, the rule with the lowest priority will be run before rules with higher priority.</td>
<td>optional</td>
</tr>
</tbody>
</table>

#### Détails sur le modèle d'action de la règle de programme { #program-rule-action-model-details } 

Le tableau suivant donne un aperçu détaillé du modèle d'action de la règle de programme.

<table style="width:100%;">
<caption>programRuleAction</caption>
<colgroup>
<col style="width: 16%" />
<col style="width: 66%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="header">
<th>name</th>
<th>description</th>
<th>Compulsory</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>programRule</td>
<td>The programRule that is the parent of this action.</td>
<td>Compulsory</td>
</tr>
<tr class="even">
<td>programRule- ActionType</td>
<td>The type of action that is to be performed.
<ul>
<li><p>`DISPLAYTEXT` - Displays a text in a given widget.</p></li>
<li><p>`DISPLAYKEYVALUEPAIR` - Displays a key and value pair(like a program indicator) in a given widget.</p></li>
<li><p>`HIDEFIELD` - Hide a specified dataElement or trackedEntityAttribute.</p>
<ul>
<li><p><em>content</em> - if defined, the text in <em>content</em> will be displayed to the end user in the instance where a value is previously entered into a field that is now about to be hidden (and therefore blanked). If <em>content</em> is not defined, a standard message will be shown to the user in this instance.</p></li>
<li><p><em>dataElement</em> - if defined, the HIDEFIELD action will hide this dataElement when the rule is effective.</p></li>
<li><p><em>trackedEntityDataValue</em> - if defined, the HIDEFIELD action will hide this trackedEntityDataValue when the rule is effective.</p></li>
</ul></li>
<li><p>`HIDESECTION` - Hide a specified section.</p>
<ul>
<li><p><em>programStageSection</em> - must be defined. This is the programStageSection that will be hidden in case the parent rule is effective.</p></li>
</ul></li>
<li><p>`ASSIGN` - Assign a dataElement a value(help the user calculate something or fill in an obvious value somewhere)</p>
<ul>
<li><p><em>content</em> - if defined, the value in <em>data</em> is assigned to this variable. If content id defined, and thus a variable is assigned for use in other rules, it is important to also assign a <em>programRule.priority</em> to make sure the rule with an ASSIGN action runs before the rule that will in turn evaluate the assigned variable.</p></li>
<li><p><em>data</em> - must be defined, data forms an expression that is evaluated and assigned to either a variable(#{myVariable}), a dataElement, or both.</p></li>
<li><p><em>dataElement</em> - if defined, the value in <em>data</em> is assigned to this data element.</p></li>
</ul>
<p>Either the content or dataElement must be defined for the ASSIGN action to be effective.</p></li>
<li><p>`SHOWWARNING` - Show a warning to the user, not blocking the user from completing the event or registration.</p>
<ul>
<li><p><em>content</em> - if defined, content is a static part that is displayed at the end of the error message.</p></li>
<li><p><em>data</em> - if defined, data forms an expression that is evaluated and added to the end of the warning message.</p></li>
<li><p><em>dataElement</em> - if defined, the warning message is displayed next to this data element.</p></li>
<li><p><em>trackedEntityAttribute</em> - if defined, the warning message is displayed next to this tracked entity attribute.</p></li>
</ul>
<p>Either dataElement or trackedEntityAttribute must be specified.</p></li>
<li><p>`SHOWERROR` - Show an error to the user, blocking the user from completing the event or registration.</p>
<ul>
<li><p><em>content</em> - if defined, content is a static part that is displayed in the start of the error message.</p></li>
<li><p><em>data</em> - if defined, data forms an expression that is evaluated and added to the end of the error message.</p></li>
<li><p><em>dataElement</em> - if defined, the error message is linked to this data element.</p></li>
<li><p><em>trackedEntityAttribute</em> - if defined, the error message is linked to this tracked entity attribute.</p></li>
</ul>
<p>Either dataElement or trackedEntityAttribute must be specified.</p></li>
<li><p>`WARNINGONCOMPLETINON` - Show a warning to the user on the &quot;Complete form&quot; dialog, but allowing the user to complete the event.</p>
<ul>
<li><p><em>content</em> - if defined, content is a static part that is displayed at the end of the error message.</p></li>
<li><p><em>data</em> - if defined, data forms an expression that is evaluated and added to the end of the warning message.</p></li>
<li><p><em>dataElement</em> - if defined, the warning message prefixed with the name/formName of the data element.</p></li>
</ul></li>
<li><p>`ERRORONCOMPLETION` - Show an error to the user on in a modal window when the user tries to complete the event. The user is prevented from completing the event.</p>
<ul>
<li><p><em>content</em> - if defined, content is a static part that is displayed in the start of the error message.</p></li>
<li><p><em>data</em> - if defined, data forms an expression that is evaluated and added to the end of the error message.</p></li>
<li><p><em>dataElement</em> - if defined, the error message is linked to this data element.</p></li>
</ul></li>
<li><p>`CREATEEVENT` - Create an event within the same enrollment.</p>
<ul>
<li><p><em>content</em></p></li>
<li><p><em>data</em> - if defined, contains data values to assign the created event. The format is &lt;uid&gt;:&lt;data value&gt;. Where several values is specified, these are separated with comma.</p>
<pre><code>AcMrnleqHqc:100,AqK1IHqCkEE:&#39;Polyhydramnios&#39;</code></pre></li>
<li><p><em>programStage</em> - must be defined, and designates the program stage that the rule shall create an event of.</p></li>
</ul></li>
<li><p>`SETMANDATORYFIELD` - Set a field to be mandatory.</p>
<ul>
<li><p><em>dataElement</em> - if defined, this data element will be set to be mandatory in the data entry form.</p></li>
<li><p><em>trackedEntityAttribute</em> - if defined, this tracked entity attribute will be set to mandatory in the registration form or profile.</p></li>
</ul></li>
<li><p>`SENDMESSAGE` - To send message at completion of event/enrollment or at data value update.</p>
<ul>
<li><p><em>messageTemplate</em> - if defined, this template will be delivered either as SMS or EMAIL depending upon DeliveryChannel value in message template.</p></li>
</ul></li>
<li><p>`SCHEDULEMESSAGE` - To schedule message at completion of event/enrollment or at data value update.</p>
<ul>
<li><p><em>messageTemplate</em> - if defined, this template will be delivered either as SMS or EMAIL depending upon DeliveryChannel value in message template.</p></li>
<li><p><em>Date to send message</em> - Expression which is going to be used for evaluation of scheduled date. This expression should result in Date, any other resultant will be discarded and notification will not get scheduled.</p></li>
</ul></li>
</ul></td>
<td>Compulsory</td>
</tr>
<tr class="odd">
<td>location</td>
<td>Used for actionType DISPLAYKEYVALUEPAIR and DISPLAYTEXT to designate which widget to display the text or keyvaluepair in. Compulsory for DISPLAYKEYVALUEPAIR and DISPLAYTEXT.</td>
<td>See description</td>
</tr>
<tr class="even">
<td>content</td>
<td>Used for user messages in the different actions. See the actionType overview for a detailed explanation for how it is used in each of the action types. Compulsory for SHOWWARNING, SHOWERROR, WARNINGONCOMPLETION, ERRORONCOMPLETION, DISPLAYTEXT and DISPLAYKEYVALUEPAIR. Optional for HIDEFIELD and ASSIGN.</td>
<td>See description</td>
</tr>
<tr class="odd">
<td>data</td>
<td>Used for expressions in the different actions. See the actionType overview for a detailed explanation for how it is used in each of the action types. Compulsory for ASSIGN. Optional for SHOWWARNING, SHOWERROR, WARNINGONCOMPLETION, ERRORONCOMPLETION, DISPLAYTEXT, CREATEEVENT and DISPLAYKEYVALUEPAIR</td>
<td>See description</td>
</tr>
<tr class="even">
<td>dataElement</td>
<td>Used for linking rule actions to dataElements. See the actionType overview for a detailed explanation for how it is used in each of the action types. Optional for SHOWWARNING, SHOWERROR, WARNINGONCOMPLETION, ERRORONCOMPLETION, ASSIGN and HIDEFIELD</td>
<td>See description</td>
</tr>
<tr class="odd">
<td>trackedEntity- Attribute</td>
<td>Used for linking rule actions to trackedEntityAttributes. See the actionType overview for a detailed explanation for how it is used in each of the action types. Optional for SHOWWARNING, SHOWERROR and HIDEFIELD.</td>
<td>See description</td>
</tr>
<tr class="even">
<td>option</td>
<td>Used for linking rule actions to options. See the actionType overview for a detailed explanation for how it is used in each of the action types. Optional for HIDEOPTION</td>
<td>See description</td>
</tr>
<tr class="odd">
<td>optionGroup</td>
<td>Used for linking rule actions to optionGroups. See the actionType overview for a detailed explanation for how it is used in each of the action types. Compulsory for SHOWOPTIONGROUP, HIDEOPTIONGROUP.</td>
<td>See description</td>
</tr>
<tr class="even">
<td>programStage</td>
<td>Only used for CREATEEVENT rule actions. Compulsory for CREATEEEVENT.</td>
<td>See description</td>
</tr>
<tr class="odd">
<td>programStage- Section</td>
<td>Only used for HIDESECTION rule actions. Compulsory for HIDESECTION</td>
<td>See description</td>
</tr>
</tbody>
</table>

#### Détails sur le modèle de variables des règles de programme { #program-rule-variable-model-details } 

Le tableau suivant donne un aperçu détaillé du modèle de variables des règles de programme.

<table style="width:100%;">
<caption>programRuleVariable</caption>
<colgroup>
<col style="width: 16%" />
<col style="width: 66%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="header">
<th>name</th>
<th>description</th>
<th>Compulsory</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>name</td>
<td>the name for the programRuleVariable - this name is used in expressions.
<pre><code>#{myVariable} &gt; 5</code></pre></td>
<td>Compulsory</td>
</tr>
<tr class="even">
<td>sourceType</td>
<td>Defines how this variable is populated with data from the enrollment and events.
<ul>
<li><p>DATAELEMENT_NEWEST_EVENT_PROGRAM_STAGE - In tracker capture, gets the newest value that exists for a data element, within the events of a given program stage in the current enrollment. In event capture, gets the newest value among the 10 newest events on the organisation unit.</p></li>
<li><p>DATAELEMENT_NEWEST_EVENT_PROGRAM - In tracker capture, get the newest value that exists for a data element across the whole enrollment. In event capture, gets the newest value among the 10 newest events on the organisation unit.</p></li>
<li><p>DATAELEMENT_CURRENT_EVENT - Gets the value of the given data element in the current event only.</p></li>
<li><p>DATAELEMENT_PREVIOUS_EVENT - In tracker capture, gets the newest value that exists among events in the program that precedes the current event. In event capture, gets the newvest value among the 10 preceeding events registered on the organisation unit.</p></li>
<li><p>CALCULATED_VALUE - Used to reserve a variable name that will be assigned by a ASSIGN program rule action</p></li>
<li><p>TEI_ATTRIBUTE - Gets the value of a given tracked entity attribute</p></li>
</ul></td>
<td>Compulsory</td>
</tr>
<tr class="odd">
<td>dataElement</td>
<td>Used for linking the programRuleVariable to a dataElement. Compulsory for all sourceTypes that starts with DATAELEMENT_.</td>
<td>See description</td>
</tr>
<tr class="even">
<td>trackedEntity- Attribute</td>
<td>Used for linking the programRuleVariable to a trackedEntityAttribute. Compulsory for sourceType TEI_ATTRIBUTE.</td>
<td>See description</td>
</tr>
<tr class="odd">
<td>useCodeFor- OptionSet</td>
<td>If checked, the variable will be populated with the code - not the name - from any linked option set. Default is unchecked, meaning that the name of the option is populated.</td>
<td></td>
</tr>
<tr class="even">
<td>programStage</td>
<td>Used for specifying a specific program stage to retreive the programRuleVariable value from. Compulsory for DATAELEMENT_NEWEST_EVENT_PROGRAM_STAGE.</td>
<td>See description</td>
</tr>
</tbody>
</table>

### Création de règles de programme { #webapi_creating_program_rules } 

<!--DHIS2-SECTION-ID:webapi_creating_program_rules-->

- Pour effectuer des opérations CRUD, vous pouvez utiliser la ressource `programRules`, disponible dans l'API.

Pour récupérer la liste des règles de programmes, vous pouvez effectuer une requête GET comme suit :

    /api/programRules

Pour récupérer une seule règle de programme, vous pouvez effectuer une requête GET comme suit :

    /api/programRules/<program_rule_uid>

Pour sauvegarder ou ajouter une seule règle de programme, vous pouvez effectuer une requête POST comme suit :

    /api/programRules/<program_rule_uid>

Pour mettre à jour une seule règle de programme, vous pouvez effectuer une requête PUT comme suit :

    /api/programRules/<program_rule_uid>

Pour supprimer une seule règle de programme, vous pouvez effectuer une requête DELETE comme suit :

    /api/programRules/<program_rule_uid>

Pour récupérer la description de la condition de la règle de programme, vous pouvez effectuer une requête POST en fournissant la chaîne de la condition dans le corps de la requête.

    /api/programRules/condition/description?<program_rule_uid>

## Formulaires { #webapi_forms } 

<!--DHIS2-SECTION-ID:webapi_forms-->

Pour récupérer des informations sur un formulaire (qui correspond à un ensemble de données et à ses sections), vous pouvez interagir avec la ressource `form`. La réponse du formulaire est accessible en XML et JSON et fournira des informations sur chaque section (groupe) du formulaire ainsi que sur chaque champ de ces sections, y compris les étiquettes et les identifiants. En fournissant des identifiants de période et d'unité d'organisation, la réponse du formulaire sera constituée de valeurs de données.

<table>
<caption>Form query parameters</caption>
<colgroup>
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 74%" />
</colgroup>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>pe</td>
<td>ISO period</td>
<td>Period for which to populate form data values.</td>
</tr>
<tr class="even">
<td>ou</td>
<td>UID</td>
<td>Organisation unit for which to populate form data values.</td>
</tr>
<tr class="odd">
<td>metaData</td>
<td>false | true</td>
<td>Whether to include metadata about each data element of form sections.</td>
</tr>
</tbody>
</table>

Pour récupérer le formulaire d'un ensemble de données, vous pouvez effectuer une requête GET comme suit :

    /api/dataSets/<dataset-id>/form.json

Pour récupérer le formulaire pour l'ensemble de données ayant l'identifiant "BfMAe6Itzgt" au format XML :

    /api/dataSets/BfMAe6Itzgt/form

Pour récupérer le formulaire en incluant les métadonnées, au format JSON :

    /api/dataSets/BfMAe6Itzgt/form.json?metaData=true

Pour récupérer le formulaire rempli avec les valeurs de données d'une période et d'une unité d'organisation spécifiques au format XML :

    /api/dataSets/BfMAe6Itzgt/form.xml?ou=DiszpKrYNg8&pe=201401

Cette ressource permet également de créer des formulaires de saisie de données personnalisés, directement pour un ensemble de données. Cela peut se faire à l'aide d'une requête POST ou PUT avec un contenu de type text/html où la charge est le balisage du formulaire personnalisé. En voici l'illustration :

```bash
curl -d @form.html "localhost/api/dataSets/BfMAe6Itzgt/form"
  -H "Content-Type:text/html" -u admin:district -X PUT
```

## Documents { #webapi_documents } 

<!--DHIS2-SECTION-ID:webapi_documents-->

Les références aux fichiers peuvent être stockées avec la ressource "document".

<table>
<caption>Document fields</caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Field name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>name</td>
<td>unique name of document</td>
</tr>
<tr class="even">
<td>external</td>
<td>flag identifying the location of the document. TRUE for external files, FALSE for internal ones</td>
</tr>
<tr class="odd">
<td>url</td>
<td>the location of the file. URL for external files. File resource id for internal ones (see <a href="#webapi_file_resources">File resources</a>)</td>
</tr>
</tbody>
</table>

Une requête GET au point d'extrémité des documents renverra tous les documents :

    /api/documents

Une requête POST au point d'extrémité des documents créera un nouveau document :

```bash
curl -X POST -d @document.json -H "Content-type: application/json"
  "http://dhis.domain/api/documents"
```

```json
{
  "name": "dhis home",
  "external": true,
  "url": "https://www.dhis2.org"
}
```

Une requête GET à laquelle est ajouté l'identifiant d'un document renverra des informations sur ce document. Une requête PUT au même point d'extrémité mettra à jour les champs du document :

    /api/documents/<documentId>

Ajouter */data* à la requête GET renverra le contenu réel du document :

    /api/documents/<documentId>/data

## Validation { #webapi_validation }

<!--DHIS2-SECTION-ID:webapi_validation-->

Pour générer un résumé de validation des données, vous pouvez interagir avec la ressource de validation. La ressource "ensemble de données" est optimisée pour les clients chargés de la saisie des données et de la validation d'un ensemble de données ou d'un formulaire. Elle est accessible de la manière suivante :

    /api/33/validation/dataSet/QX4ZTUbOt3a.json?pe=201501&ou=DiszpKrYNg8

En plus de la validation des règles basées sur un ensemble de données, il existe deux méthodes supplémentaires de validation : validation personnalisée et validation programmée.

Custom validation can be initiated through the "Data Quality" app, where
you can configure the periods, validation rule groups and organisation
units to be included in the analysis and if you want to send out
notifications for and/or persist the results found. The result of this
analysis will be a list of violations found using your criteria.

La première variable path (de chemin) est un identifiant qui fait référence à l'ensemble de données à valider. Les représentations XML et JSON des ressources sont prises en charge. La réponse contient les violations des règles de validation. Cette fonction sera étendue à d'autres types de validation dans les versions à venir.

Pour récupérer les règles de validation relatives à un ensemble de données spécifique, c'est-à-dire les règles de validation avec des formules où tous les éléments de données font partie de l'ensemble de données en question, vous pouvez lancer une requête GET à la ressource `validationRules` de la manière suivante :

    /api/validationRules?dataSet=<dataset-id>

Les règles de validation ont un côté gauche et un côté droit, dont la validité est comparée en fonction d'un opérateur. Les valeurs valides de l'opérateur sont indiquées dans le tableau ci-dessous.

<table>
<caption>Operators</caption>
<colgroup>
<col style="width: 28%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="header">
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>equal_to</td>
<td>Equal to</td>
</tr>
<tr class="even">
<td>not_equal_to</td>
<td>Not equal to</td>
</tr>
<tr class="odd">
<td>greater_than</td>
<td>Greater than</td>
</tr>
<tr class="even">
<td>greater_than_or_equal_to</td>
<td>Greater than or equal to</td>
</tr>
<tr class="odd">
<td>less_than</td>
<td>Less than</td>
</tr>
<tr class="even">
<td>less_than_or_equal_to</td>
<td>Less than or equal to</td>
</tr>
<tr class="odd">
<td>compulsory_pair</td>
<td>If either side is present, the other must also be</td>
</tr>
<tr class="even">
<td>exclusive_pair</td>
<td>If either side is present, the other must not be</td>
</tr>
</tbody>
</table>

Les expressions du côté gauche et du côté droit sont des expressions mathématiques qui peuvent contenir des références à des éléments de données et à des combinaisons d'options de catégorie au format suivant :

    ${<dataelement-id>.<catoptcombo-id>}

Les expressions du côté gauche et du côté droit ont une *stratégie de valeur manquante*. Cette stratégie indique comment le système doit traiter les valeurs de données manquantes pour les références d'éléments de données ou de combinaisons d'options de catégorie dans la formule, en déterminant si la règle de validation doit être vérifiée ou ignorée. Les stratégies de valeurs manquantes valides sont présentées dans le tableau ci-dessous.

<table>
<caption>Missing value strategies</caption>
<colgroup>
<col style="width: 28%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="header">
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SKIP_IF_ANY_VALUE_MISSING</td>
<td>Skip validation rule if any data value is missing</td>
</tr>
<tr class="even">
<td>SKIP_IF_ALL_VALUES_MISSING</td>
<td>Skip validation rule if all data values are missing</td>
</tr>
<tr class="odd">
<td>NEVER_SKIP</td>
<td>Never skip validation rule irrespective of missing data values</td>
</tr>
</tbody>
</table>

## Validation Results { #webapi_validation_results } 

<!--DHIS2-SECTION-ID:webapi_validation_results-->

Les résultats de validation sont les résultats des violations constatées lors d'une analyse de validation. Si vous choisissez "conserver les résultats" lorsque vous lancez ou programmez une analyse de validation, toutes les violations constatées seront stockées dans la base de données. Lorsqu'un résultat est stocké dans la base de données, il est utilisé à trois fins :

1.  Générer des analyses basées sur les résultats stockés.

2.  Les résultats qui n'ont pas généré de notification le feront,
    une fois.

3.  Garder la trace des résultats qui ont généré ou non une
    notification.

4.  Ignorer les règles déjà vérifiées lors de
    l'analyse de validation.

Cela signifie que si vous ne conservez pas vos résultats, vous ne pourrez pas générer d'analyses pour les résultats de validation. Si cette option est sélectionnée, les résultats généreront des notifications à chaque fois qu'il y en aura et l'analyse de validation pourrait être plus lente.

Les résultats de validation conservés peuvent être consultés au point d'extrémité suivant :

    /api/33/validationResults

Vous pouvez également inspecter un résultat individuel à l'aide de l'identifiant du résultat de validation dans ce point d'extrémité :

    /api/33/validationResults/<id>

Validation results are sent out to the appropriate users once every day,
but can also be manually triggered to run on demand using the following
api endpoint:

    /api/33/validation/sendNotifications

Seuls les résultats non envoyés sont envoyés via ce point d'extrémité.

## Analyse des données { #webapi_data_analysis }

<!--DHIS2-SECTION-ID:webapi_data_analysis-->

Plusieurs ressources permettant d'effectuer des analyses de données et de détecter les problèmes de qualité et de validation des données sont fournies.

### Analyse des règles de validation { #webapi_data_analysis_validation_rules } 

<!--DHIS2-SECTION-ID:webapi_data_analysis_validation_rules-->

Pour exécuter des règles de validation et extraire les violations :

    /api/dataAnalysis/validationRules

Les paramètres de requête suivants sont pris en charge :

<table>
<caption>Validation rule analysis query parameters</caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Query parameter</th>
<th>Description</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>vrg</td>
<td>Validation rule group</td>
<td>ID</td>
</tr>
<tr class="even">
<td>ou</td>
<td>Organisation unit</td>
<td>ID</td>
</tr>
<tr class="odd">
<td>startDate</td>
<td>Start date for the timespan</td>
<td>Date</td>
</tr>
<tr class="even">
<td>endDate</td>
<td>End date for the timespan</td>
<td>Date</td>
</tr>
<tr class="odd">
<td>persist</td>
<td>Whether to persist violations in the system</td>
<td>false | true</td>
</tr>
<tr class="even">
<td>notification</td>
<td>Whether to send notifications about violations</td>
<td>false | true</td>
</tr>
</tbody>
</table>

Exemple de sortie :
```json
    [{
    "validationRuleId": "kgh54Xb9LSE",
    "validationRuleDescription": "Malaria outbreak",
    "organisationUnitId": "DiszpKrYNg8",
    "organisationUnitDisplayName": "Ngelehun CHC",
    "organisationUnitPath": "/ImspTQPwCqd/O6uvpzGd5pu/YuQRtpLP10I/DiszpKrYNg8",
    "organisationUnitAncestorNames": "Sierra Leone / Bo / Badjia / ",
    "periodId": "201901",
    "periodDisplayName": "January 2019",
    "attributeOptionComboId": "HllvX50cXC0",
    "attributeOptionComboDisplayName": "default",
    "importance": "MEDIUM",
    "leftSideValue": 10.0,
    "operator": ">",
    "rightSideValue": 14.0
}, {
    "validationRuleId": "ZoG4yXZi3c3",
    "validationRuleDescription": "ANC 2 cannot be higher than ANC 1",
    "organisationUnitId": "DiszpKrYNg8",
    "organisationUnitDisplayName": "Ngelehun CHC",
    "organisationUnitPath": "/ImspTQPwCqd/O6uvpzGd5pu/YuQRtpLP10I/DiszpKrYNg8",
    "organisationUnitAncestorNames": "Sierra Leone / Bo / Badjia / ",
    "periodId": "201901",
    "periodDisplayName": "January 2019",
    "attributeOptionComboId": "HllvX50cXC0",
    "attributeOptionComboDisplayName": "default",
    "importance": "MEDIUM",
    "leftSideValue": 22.0,
    "operator": "<=",
    "rightSideValue": 19.0
}]
```

### Analyse des valeurs atypiques sur la base de l'écart type { #webapi_data_analysis_std_dev_outlier }

<!--DHIS2-SECTION-ID:webapi_data_analysis_std_dev_outlier-->

Pour identifier les valeurs atypiques parmi les données en fonction des écarts types de la valeur  moyenne :

    /api/dataAnalysis/stdDevOutlier

Les paramètres de requête suivants sont pris en charge :

<table>
<caption>Standard deviation outlier analysis query parameters</caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Query parameter</th>
<th>Description</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ou</td>
<td>Organisation unit</td>
<td>ID</td>
</tr>
<tr class="even">
<td>startDate</td>
<td>Start date for the timespan</td>
<td>Date</td>
</tr>
<tr class="odd">
<td>endDate</td>
<td>End date for the timespan</td>
<td>Date</td>
</tr>
<tr class="even">
<td>ds</td>
<td>Data sets, parameter can be repeated</td>
<td>ID</td>
</tr>
<tr class="odd">
<td>standardDeviation</td>
<td>Number of standard deviations from the average</td>
<td>Numeric value</td>
</tr>
</tbody>
</table>

### Analyse des valeurs aberrantes basée sur les valeurs min/max { #webapi_data_analysis_min_max_outlier }

<!--DHIS2-SECTION-ID:webapi_data_analysis_min_max_outlier-->

Pour identifier les valeurs atypiques sur la base des valeurs min/max :

    /api/dataAnalysis/minMaxOutlier

Les paramètres de requête pris en charge équivalent à la ressource *analyse des valeurs atypiques en fonction de l'écart type* décrite ci-dessus.

### Analyse des données de suivi { #follow-up-data-analysis }

Pour identifier les données marquées pour le suivi :

    /api/dataAnalysis/followup

Les paramètres de requête pris en charge équivalent à la ressource *analyse des valeurs atypiques en fonction de l'écart type* décrite ci-dessus.

## Intégrité des données { #webapi_data_integrity } 

<!--DHIS2-SECTION-ID:webapi_data_integrity-->

The data integrity capabilities of the data administration module are
available through the web API. This section describes how to run the
data integrity process as well as retrieving the result. The details of
the analysis performed are described in the user manual.

### Running data integrity { #webapi_data_integrity_run } 

<!--DHIS2-SECTION-ID:webapi_data_integrity_run-->

The operation of measuring data integrity is a fairly resource (and
time) demanding task. It is therefore run as an asynchronous process and
only when explicitly requested. Starting the task is done by forming an
empty POST request to the *dataIntegrity* endpoint like so (demonstrated
in curl syntax):

```bash
curl -X POST "https://localhost/api/33/dataIntegrity"
```

If successful the request will return HTTP 202 immediately. The location
header of the response points to the resource used to check the status
of the request. The payload also contains a json object of the job
created. Forming a GET request to the given location yields an empty
JSON response if the task has not yet completed and a JSON taskSummary
object when the task is done. Polling (conservatively) to this resource
can hence be used to wait for the task to finish.

### Fetching the result { #webapi_data_integrity_fetch_results } 

<!--DHIS2-SECTION-ID:webapi_data_integrity_fetch_results-->

Once data integrity is finished running the result can be fetched from
the `system/taskSummaries` resource like so:

```bash
curl "https://dhis.domain/api/33/system/taskSummaries/DATAINTEGRITY"
```

The returned object contains a summary for each point of analysis,
listing the names of the relevant integrity violations. As stated in the
leading paragraph for this section the details of the analysis (and the
resulting data) can be found in the user manual chapter on Data
Administration.

## Indicateurs { #webapi_indicators } 

<!--DHIS2-SECTION-ID:webapi_indicators-->

Cette section décrit les indicateurs et les expressions d'indicateurs.

### Indicateurs agrégés { #webapi_aggregate_indicators } 

<!--DHIS2-SECTION-ID:webapi_aggregate_indicators-->

Pour récupérer les indicateurs, vous pouvez lancer une requête GET à la ressource des indicateurs comme suit :

    /api/indicators

Les indicateurs représentent des expressions qui peuvent être calculées et présentées sous forme de résultat. Les expressions des indicateurs sont divisées en un numérateur et un dénominateur. Les numérateurs et les dénominateurs sont des expressions mathématiques qui peuvent contenir des références à des éléments de données, à d'autres indicateurs, à des constantes et à des groupes d'unités d'organisation. Les variables seront remplacées par des valeurs de données lorsqu'elles seront utilisées, par exemple dans des rapports. Les variables autorisées dans les expressions sont décrites dans le tableau suivant.

Traduit avec DeepL.com (version gratuite)

<table>
<caption>Indicator variables</caption>
<colgroup>
<col style="width: 39%" />
<col style="width: 22%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="header">
<th>Variable</th>
<th>Object</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>#{&lt;dataelement-id&gt;.&lt;categoryoptcombo-id&gt;.&lt;attributeoptcombo-id&gt;}</td>
<td>Data element operand</td>
<td>Refers to a combination of an aggregate data element and a category option combination. Both category and attribute option combo ids are optional, and a wildcard &quot;*&quot; symbol can be used to indicate any value.</td>
</tr>
<tr class="even">
<td>#{&lt;dataelement-id&gt;.&lt;categoryoptiongroup-id&gt;.&lt;attributeoptcombo-id&gt;}</td>
<td>Category Option Group</td>
<td>Refers to an aggregate data element and a category option group, containing multiple category option combinations.</td>
</tr>
<tr class="odd">
<td>#{&lt;dataelement-id&gt;}</td>
<td>Aggregate data element</td>
<td>Refers to the total value of an aggregate data element across all category option combinations.</td>
</tr>
<tr class="even">
<td>D{&lt;program-id&gt;.&lt;dataelement-id&gt;}</td>
<td>Program data element</td>
<td>Refers to the value of a tracker data element within a program.</td>
</tr>
<tr class="odd">
<td>A{&lt;program-id&gt;.&lt;attribute-id&gt;}</td>
<td>Program tracked entity attribute</td>
<td>Refers to the value of a tracked entity attribute within a program.</td>
</tr>
<tr class="even">
<td>I{&lt;program-indicator-id&gt;}</td>
<td>Program indicator</td>
<td>Refers to the value of a program indicator.</td>
</tr>
<tr class="odd">
<td>R{&lt;dataset-id&gt;.&lt;metric&gt;}</td>
<td>Reporting rate</td>
<td>Refers to a reporting rate metric. The metric can be REPORTING_RATE, REPORTING_RATE_ON_TIME, ACTUAL_REPORTS, ACTUAL_REPORTS_ON_TIME, EXPECTED_REPORTS.</td>
</tr>
<tr class="even">
<td>C{&lt;constant-id&gt;}</td>
<td>Constant</td>
<td>Refers to a constant value.</td>
</tr>
<tr class="odd">
<td>N{&lt;indicator-id&gt;}</td>
<td>Indicator</td>
<td>Refers to an existing Indicator.</td>
</tr>
<tr class="even">
<td>OUG{&lt;orgunitgroup-id&gt;}</td>
<td>Organisation unit group</td>
<td>Refers to the count of organisation units within an organisation unit group.</td>
</tr>
</tbody>
</table>

La syntaxe ressemble à ceci :

    #{<dataelement-id>.<catoptcombo-id>} + C{<constant-id>} + OUG{<orgunitgroup-id>}

Un exemple correspondant se présente comme suit :

    #{P3jJH5Tu5VC.S34ULMcHMca} + C{Gfd3ppDfq8E} + OUG{CXw2yu5fodb}

Pour les variables d'éléments de données, l'identifiant de la combinaison d'options de catégorie peut être omis. La variable va alors représenter le total pour l'élément de données, par exemple pour toutes les combinaisons d'options de catégorie. Exemple :

    #{P3jJH5Tu5VC} + 2

Les opérandes des éléments de données peuvent inclure toute combinaison d'options de catégorie et toute combinaison d'options d'attributs. Elles peuvent également utiliser des caractères génériques pour indiquer n'importe quelle valeur :

    #{P3jJH5Tu5VC.S34ULMcHMca} + #{P3jJH5Tu5VC.*.j8vBiBqGf6O} + #{P3jJH5Tu5VC.S34ULMcHMca.*}

An example which uses a program data element and a program
    attribute:

    ( D{eBAyeGv0exc.vV9UWAZohSf} * A{IpHINAT79UW.cejWyOfXge6} ) / D{eBAyeGv0exc.GieVkTxp4HH}

An example which combines program indicators and aggregate indicators:

    I{EMOt6Fwhs1n} * 1000 / #{WUg3MYWQ7pt}

An example which uses a reporting rate looks like this:

    R{BfMAe6Itzgt.REPORTING_RATE} * #{P3jJH5Tu5VC.S34ULMcHMca}

Another example which uses actual data set reports:

    R{BfMAe6Itzgt.ACTUAL_REPORTS} / R{BfMAe6Itzgt.EXPECTED_REPORTS}

An example which uses an existing indicator would look like this:

    N{Rigf2d2Zbjp} * #{P3jJH5Tu5VC.S34ULMcHMca}

Les expressions peuvent être constituées de tout type d'expression mathématique valide, à titre d'exemple :

    ( 2 * #{P3jJH5Tu5VC.S34ULMcHMca} ) / ( #{FQ2o8UBlcrS.S34ULMcHMca} - 200 ) * 25

### ![](resources/images/pivot_table/table_layout.png) { #webapi_program_indicators } 

<!--DHIS2-SECTION-ID:webapi_program_indicators-->

Pour récupérer les indicateurs de programme, vous pouvez effectuer une requête GET à la ressource des indicateurs de programme, comme suit :

    /api/programIndicators

Les indicateurs de programme peuvent contenir des informations collectées dans le cadre d'un programme. Les indicateurs ont une expression qui peut contenir des références à des éléments de données, des attributs, des constantes et des variables de programme. Les variables autorisées dans les expressions sont décrites dans le tableau suivant.

<table>
<caption>Program indicator variables</caption>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>Variable</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>#{&lt;programstage-id&gt;.&lt;dataelement-id&gt;}</td>
<td>Refers to a combination of program stage and data element id.</td>
</tr>
<tr class="even">
<td>A{&lt;attribute-id&gt;}</td>
<td>Refers to a tracked entity attribute.</td>
</tr>
<tr class="odd">
<td>V{&lt;variable-id&gt;}</td>
<td>Refers to a program variable.</td>
</tr>
<tr class="even">
<td>C{&lt;constant-id&gt;}</td>
<td>Refers to a constant.</td>
</tr>
</tbody>
</table>

La syntaxe ressemble à ceci :

    #{<programstage-id>.<dataelement-id>} + #{<attribute-id>} + V{<varible-id>} + C{<constant-id>}

Voici un exemple correspondant :

    #{A03MvHHogjR.a3kGcGDCuk6} + A{OvY4VVhSDeJ} + V{incident_date} + C{bCqvfPR02Im}

### Expressions { #webapi_expressions } 

<!--DHIS2-SECTION-ID:webapi_expressions-->

Les expressions sont des formules mathématiques qui peuvent contenir des références à des éléments de données, des constantes et des groupes d'unités d'organisation. Pour valider une expression et en obtenir la description sous forme de texte, vous pouvez adresser une requête GET à la ressource des expressions :

    /api/expressions/description?expression=<expression-string>

La réponse suit le format standard des messages web JSON. La propriété *statut* indique le résultat de la validation et sera "OK" en cas de succès et "ERROR" en cas d'échec. La propriété *message* sera "Valid" (valide) si la validation réussit, et en cas d'échec, elle fournira une description textuelle de la raison de cet échec. La propriété *description* fournit une description textuelle de l'expression.

```json
{
  "httpStatus": "OK",
  "httpStatusCode": 200,
  "status": "OK",
  "message": "Valid",
  "description": "Acute Flaccid Paralysis"
}
```

## Enregistrements des ensembles de données complets{ #webapi_complete_data_set_registrations }

<!--DHIS2-SECTION-ID:webapi_complete_data_set_registrations-->

Cette section traite de l'enregistrement d'ensembles de données complétés en tant qu'ensembles de données. Un enregistrement marque un ensemble de données comme étant complètement capturé.

### Compléter les ensembles de données { #webapi_completing_data_sets }

<!--DHIS2-SECTION-ID:webapi_completing_data_sets-->

Cette section explique comment enregistrer des ensembles de données comme étant complets. Cela s'obtient en interagissant avec la ressource *completeDataSetRegistrations*:

    /api/33/completeDataSetRegistrations

Le point d'extrémité utilise la méthode *POST* pour enregistrer les ensembles de données complets. De façon pratique, ce point d'extrémité est très similaire à celui de *dataValueSets* (ensembles de valeurs de données), avec la possibilité d'importer des enregistrements complets en bloc.

L'importation de charges utiles au format *XML* et *JSON* est prise en charge. Le format de base de cette charge utile, donné en *XML* dans cet exemple, ressemble à ceci :

```xml
<completeDataSetRegistrations xmlns="http://dhis2.org/schema/dxf/2.0">
  <completeDataSetRegistration period="200810" dataSet="eZDhcZi6FLP" 
    organisationUnit="qhqAxPSTUXp" attributeOptionCombo="bRowv6yZOF2" storedBy="imported"/>
  <completeDataSetRegistration period="200811" dataSet="eZDhcZi6FLP" 
    organisationUnit="qhqAxPSTUXp" attributeOptionCombo="bRowv6yZOF2" storedBy="imported"/>
</completeDataSetRegistrations>
```

L'attribut *storedBy* (stocké par) est facultatif (car il peut être retiré de l'objet d'enregistrement complet). Vous pouvez également définir la propriété *date* (heure de l'enregistrement) en tant qu'attribut. Si l'heure n'est pas définie, l'heure actuelle sera utilisée.

Le processus d'importation prend en charge les paramètres de requête suivants :

<table>
<caption>Complete data set registrations query parameters</caption>
<colgroup>
<col style="width: 16%" />
<col style="width: 18%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Values</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>dataSetIdScheme</td>
<td>id | name | code | attribute:ID</td>
<td>Property of the data set to use to map the complete registrations.</td>
</tr>
<tr class="even">
<td>orgUnitIdScheme</td>
<td>id | name | code | attribute:ID</td>
<td>Property of the organisation unit to use to map the complete registrations.</td>
</tr>
<tr class="odd">
<td>attributeOptionComboIdScheme</td>
<td>id | name | code | attribute:ID</td>
<td>Property of the attribute option combos to use to map the complete registrations.</td>
</tr>
<tr class="even">
<td>idScheme</td>
<td>id | name | code | attribute:ID</td>
<td>Property of all objects including data sets, org units and attribute option combos, to use to map the complete registrations.</td>
</tr>
<tr class="odd">
<td>preheatCache</td>
<td>false | true</td>
<td>Whether to save changes on the server or just return the import summary.</td>
</tr>
<tr class="even">
<td>dryRun</td>
<td>false | true</td>
<td>Whether registration applies to sub units</td>
</tr>
<tr class="odd">
<td>importStrategy</td>
<td>CREATE | UPDATE | CREATE_AND_UPDATE | DELETE</td>
<td>Save objects of all, new or update import status on the server.</td>
</tr>
<tr class="even">
<td>skipExistingCheck</td>
<td>false | true</td>
<td>Skip checks for existing complete registrations. Improves performance. Only use for empty databases or when the registrations to import do not exist already.</td>
</tr>
<tr class="odd">
<td>async</td>
<td>false | true</td>
<td>Indicates whether the import should be done asynchronous or synchronous. The former is suitable for very large imports as it ensures that the request does not time out, although it has a significant performance overhead. The latter is faster but requires the connection to persist until the process is finished.</td>
</tr>
</tbody>
</table>

### Lecture des enregistrements d'ensembles de données complets { #webapi_reading_complete_data_sets }

<!--DHIS2-SECTION-ID:webapi_reading_complete_data_sets-->

Cette section explique comment récupérer les enregistrements d'ensembles de données complets. Nous utiliserons la ressource *completeDataSetRegistrations*. Les paramètres de requête à utiliser sont les suivants :

<table>
<caption>Data value set query parameters</caption>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>dataSet</td>
<td>Data set identifier, multiple data sets are allowed</td>
</tr>
<tr class="even">
<td>period</td>
<td>Period identifier in ISO format. Multiple periods are allowed.</td>
</tr>
<tr class="odd">
<td>startDate</td>
<td>Start date for the time span of the values to export</td>
</tr>
<tr class="even">
<td>endDate</td>
<td>End date for the time span of the values to export</td>
</tr>
<tr class="odd">
<td>created</td>
<td>Include only registrations which were created since the given timestamp</td>
</tr>
<tr class="even">
<td>createdDuration</td>
<td>Include only registrations which were created within the given duration. The format is &lt;value&gt;&lt;time-unit&gt;, where the supported time units are &quot;d&quot;, &quot;h&quot;, &quot;m&quot;, &quot;s&quot; <em>(days, hours, minutes, seconds).</em> The time unit is relative to the current time.</td>
</tr>
<tr class="odd">
<td>orgUnit</td>
<td>Organisation unit identifier, can be specified multiple times. Not applicable if orgUnitGroup is given.</td>
</tr>
<tr class="even">
<td>orgUnitGroup</td>
<td>Organisation unit group identifier, can be specified multiple times. Not applicable if orgUnit is given.</td>
</tr>
<tr class="odd">
<td>children</td>
<td>Whether to include the children in the hierarchy of the organisation units</td>
</tr>
<tr class="even">
<td>limit</td>
<td>The maximum number of registrations to include in the response.</td>
</tr>
<tr class="odd">
<td>idScheme</td>
<td>Identifier property used for meta data objects in the response.</td>
</tr>
<tr class="even">
<td>dataSetIdScheme</td>
<td>Identifier property used for data sets in the response. Overrides idScheme.</td>
</tr>
<tr class="odd">
<td>orgUnitIdScheme</td>
<td>Identifier property used for organisation units in the response. Overrides idScheme.</td>
</tr>
<tr class="even">
<td>attributeOptionComboIdScheme</td>
<td>Identifier property used for attribute option combos in the response. Overrides idScheme.</td>
</tr>
</tbody>
</table>

The dataSet and orgUnit parameters can be repeated in order to include
multiple data sets and organisation units.

The period, start/end date, created and createdDuration parameters
provide multiple ways to set the time dimension for the request, thus only
one can be used. For example, it doesn't make sense to both set the
start/end date and to set the periods.

Voici donc un exemple de requête :

```bash
curl "https://play.dhis2.org/demo/api/33/completeDataSetRegistrations?dataSet=pBOMPrpg1QX
  &dataSet=pBOMPrpg1QX&startDate=2014-01-01&endDate=2014-01-31&orgUnit=YuQRtpLP10I
  &orgUnit=vWbkYPRmKyS&children=true"
  -H "Accept:application/xml" -u admin:district
```

You can get the response in *xml* and *json* format. You can indicate
which response format you prefer through the *Accept* HTTP header like
in the example above. For xml you use *application/xml*; for json you
use *application/json*.

### Annuler la finalisation des ensembles de données { #webapi_uncompleting_data_sets }

<!--DHIS2-SECTION-ID:webapi_uncompleting_data_sets-->

This section explains how you can un-register the completeness of a data
set. To un-complete a data set you will interact with the
completeDataSetRegistrations resource:

    /api/33/completeDataSetRegistrations

Cette ressource prend en charge la fonction *DELETE* pour annuler l'inscription. Les paramètres de requête suivants sont pris en charge :

<table>
<caption>Complete data set registrations query parameters</caption>
<colgroup>
<col style="width: 16%" />
<col style="width: 18%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="header">
<th>Query parameter</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ds</td>
<td>Yes</td>
<td>Data set identifier</td>
</tr>
<tr class="even">
<td>pe</td>
<td>Yes</td>
<td>Period identifier</td>
</tr>
<tr class="odd">
<td>ou</td>
<td>Yes</td>
<td>Organisation unit identifier</td>
</tr>
<tr class="even">
<td>cc</td>
<td>No (must combine with cp)</td>
<td>Attribute combo identifier (for locking check)</td>
</tr>
<tr class="odd">
<td>cp</td>
<td>No (must combine with cp)</td>
<td>Attribute option identifiers, separated with ; for multiple values (for locking check)</td>
</tr>
<tr class="even">
<td>multiOu</td>
<td>No (default false)</td>
<td>Whether registration applies to sub units</td>
</tr>
</tbody>
</table>

## Approbation des données { #webapi_data_approval } 

<!--DHIS2-SECTION-ID:webapi_data_approval-->

Cette section explique comment approuver, désapprouver et vérifier le statut 
d'approbation en utilisant la ressource *dataApprovals* (Approbation des données). L'approbation se fait par flux 
de travail d'approbation des données, par période, par unité d'organisation et par combinaison d'options d'attributs.

    /api/33/dataApprovals

Un processus d'approbation des données est associé à plusieurs entités :

* Un type de période qui définit la fréquence d'approbation
* Une combinaison de catégories facultative
* Un ou plusieurs niveaux d'approbation des données qui font partie du flux de travail
* Un ou plusieurs ensembles de données utilisés pour la collecte de données

### Obtenir le statut d'approbation { #webapi_data_approval_get_status } 

<!--DHIS2-SECTION-ID:webapi_data_approval_get_status-->

Pour obtenir des informations sur l'approbation d'un ensemble de données, vous pouvez envoyer une requête GET :

    /api/dataApprovals?wf=rIUL3hYOjJc&pe=201801&ou=YuQRtpLP10I

<table style="width:100%;">
<caption>Data approval query parameters</caption>
<colgroup>
<col style="width: 16%" />
<col style="width: 18%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="header">
<th>Query parameter</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>wf</td>
<td>Yes</td>
<td>Data approval workflow identifier</td>
</tr>
<tr class="even">
<td>pe</td>
<td>Yes</td>
<td>Period identifier</td>
</tr>
<tr class="odd">
<td>ou</td>
<td>Yes</td>
<td>Organisation unit identifier</td>
</tr>
<tr class="even">
<td>aoc</td>
<td>No</td>
<td>Attribute option combination identifier</td>
</tr>
</tbody>
</table>

> **Remarque**
>
> Pour des raisons de compatibilité en amont, le paramètre `ds` pour l'ensemble de données peut être donné à la place de `wf` pour le flux de travail dans cette demande d'approbation de données et dans d'autres, comme décrit ci-dessous. Si l'ensemble de données est donné, le flux de travail associé à cet ensemble de données sera utilisé.

Vous obtiendrez une réponse similaire à celle-ci :

```json
{
  "mayApprove": false,
  "mayUnapprove": false,
  "mayAccept": false,
  "mayUnaccept": false,
  "state": "UNAPPROVED_ELSEWHERE"
}
```

Les paramètres obtenus sont les suivants :

<table>
<caption>Data approval returned parameters</caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="header">
<th>Return Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>mayApprove</td>
<td>Whether the current user may approve this data selection.</td>
</tr>
<tr class="even">
<td>mayUnapprove</td>
<td>Whether the current user may unapprove this data selection.</td>
</tr>
<tr class="odd">
<td>mayAccept</td>
<td>Whether the current user may accept this data selection.</td>
</tr>
<tr class="even">
<td>mayUnaccept</td>
<td>Whether the current user may unaccept this data selection.</td>
</tr>
<tr class="odd">
<td>state</td>
<td>One of the data approval states from the table below.</td>
</tr>
</tbody>
</table>

<table>
<caption>Data approval states</caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="header">
<th>State</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>UNAPPROVABLE</td>
<td>Data approval does not apply to this selection. (Data is neither approved nor unapproved.)</td>
</tr>
<tr class="even">
<td>UNAPPROVED_WAITING</td>
<td>Data could be approved for this selection, but is waiting for some lower-level approval before it is ready to be approved.</td>
</tr>
<tr class="odd">
<td>UNAPPROVED_ELSEWHERE</td>
<td>Data is unapproved, and is waiting for approval somewhere else (not approvable here.)</td>
</tr>
<tr class="even">
<td>UNAPPROVED_READY</td>
<td>Data is unapproved, and is ready to be approved for this selection.</td>
</tr>
<tr class="odd">
<td>APPROVED_HERE</td>
<td>Data is approved, and was approved here (so could be unapproved here.)</td>
</tr>
<tr class="even">
<td>APPROVED_ELSEWHERE</td>
<td>Data is approved, but was not approved here (so cannot be unapproved here.) This covers the following cases:
<ul>
<li><p>Data is approved at a higher level.</p></li>
<li><p>Data is approved for wider scope of category options.</p></li>
<li><p>Data is approved for all sub-periods in selected period.</p></li>
</ul>
In the first two cases, there is a single data approval object that covers the selection. In the third case there is not.</td>
</tr>
<tr class="odd">
<td>ACCEPTED_HERE</td>
<td>Data is approved and accepted here (so could be unapproved here.)</td>
</tr>
<tr class="even">
<td>ACCEPTED_ELSEWHERE</td>
<td>Data is approved and accepted, but elsewhere.</td>
</tr>
</tbody>
</table>

Notez que lorsque vous demandez l'état de l'approbation des données, vous pouvez spécifier
toute combinaison de paramètres d'interrogation. La combinaison que vous spécifiez
ne doit pas nécessairement décrire l'endroit où les données doivent être approuvées à l'un 
des niveaux d'approbation. Par exemple :

  - L'unité d'organisation peut ne pas être à un niveau d'approbation. Le
    statut d'approbation est déterminé par le fait que les données sont approuvées à un
    niveau d'approbation pour un ascendant de l'unité d'organisation.

  - Vous pouvez spécifier des options de catégories d'attributs individuelles. Le statut
    d'approbation est déterminé par le fait que les données sont approuvées pour une
    combinaison d'options de catégorie d'attributs qui comprend une ou plusieurs de ces
    options.

  - Vous pouvez spécifier une période plus longue que celle de
    l'ensemble de données, au cours de laquelle les données sont saisies et approuvées. Le statut 
    d'approbation est déterminé par l'approbation des données pour toutes les
    périodes de l'ensemble de données au cours de la période spécifiée.

Pour les ensembles de données associés à une combinaison de catégories, il est possible 
de récupérer les enregistrements d'approbation des données pour les combinaisons d'options d'attributs individuels 
à partir de la ressource suivante, au moyen d'une requête GET :

    /api/dataApprovals/categoryOptionCombos?wf=rIUL3hYOjJc&pe=201801&ou=YuQRtpLP10I

### Obtenir le statut d'approbation en bloc { #bulk-get-approval-status } 

Pour obtenir une liste de plusieurs statuts d'approbation, vous pouvez envoyer une requête GET similaire à celle-ci :

    /api/dataApprovals/approvals?wf=rIUL3hYOjJc&pe=201801,201802&ou=YuQRtpLP10I

Les paramètres `wf`, `pe`, `ou`, et `aoc` sont les mêmes que pour obtenir un statut d'approbation unique, sauf que vous pouvez fournir une liste séparée par des virgules d'une ou plusieurs valeurs pour chaque paramètre.

Vous obtiendrez une réponse contenant une liste de paramètres d'approbation et de statuts, comme suit :

```json
[
  {
    "aoc": "HllvX50cXC0",
    "pe": "201801",
    "level": "KaTJLhGmU95",
    "ou": "YuQRtpLP10I",
    "permissions": {
      "mayApprove": false,
      "mayUnapprove": true,
      "mayAccept": true,
      "mayUnaccept": false,
      "mayReadData": true
    },
    "state": "APPROVED_HERE",
    "wf": "rIUL3hYOjJc"
  },
  {
    "aoc": "HllvX50cXC0",
    "pe": "201802",
    "ou": "YuQRtpLP10I",
    "permissions": {
      "mayApprove": true,
      "mayUnapprove": false,
      "mayAccept": false,
      "mayUnaccept": false,
      "mayReadData": true
    },
    "state": "UNAPPROVED_READY",
    "wf": "rIUL3hYOjJc"
  }
]
```

Les champs obtenus sont décrits dans le tableau ci-dessous.

| Champ       | Description |
| ----------- | ----------- |
| aoc         | Identifiant de combinaison d'options d'attributs |
| pe          | Identifiant de période |
| ou          | Identifiant d'unité d'organisation |
| autorisations | The permissions: 'mayApprove', 'mayUnapprove', 'mayAccept', 'mayUnaccept', and 'mayReadData' (same definitions as for get single approval status). |
| État       | Un des états d'approbation des données (comme pour obtenir un statut d'approbation unique.) |
| wf          | Identifiant du workflow d'approbation des données |

### Approuver les données { #webapi_data_approval_approve_data } 

<!--DHIS2-SECTION-ID:webapi_data_approval_approve_data-->

Pour approuver des données, vous pouvez envoyer une demande *POST* à la ressource 
*dataApprovals*. Pour annuler l'approbation des données, vous pouvez envoyer une 
demande *SUPPRIMER* à la ressource dataApprovals.

    POST DELETE /api/33/dataApprovals

Pour accepter des données déjà approuvées, vous pouvez envoyer une demande 
*POSTER* à la ressource *Acceptationdesdonnées*. Pour annuler l'acceptation de données, 
vous pouvez envoyer une demande *SUPPRIMER* à la ressource *Acceptationdesdonnées*.

    POST DELETE /api/33/dataAcceptances

Ces demandes contiennent les paramètres suivants :

<table style="width:100%;">
<caption>Data approval action parameters</caption>
<colgroup>
<col style="width: 16%" />
<col style="width: 18%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="header">
<th>Action parameter</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>wf</td>
<td>Yes</td>
<td>Data approval workflow identifier</td>
</tr>
<tr class="even">
<td>pe</td>
<td>Yes</td>
<td>Period identifier</td>
</tr>
<tr class="odd">
<td>ou</td>
<td>Yes</td>
<td>Organisation unit identifier</td>
</tr>
<tr class="even">
<td>aoc</td>
<td>No</td>
<td>Attribute option combination identifier</td>
</tr>
</tbody>
</table>

Notez que, contrairement à la requête sur le statut d'approbation des données, vous devez 
spécifier des paramètres qui correspondent à une sélection de données susceptibles d'être 
approuvées. En particulier, les deux éléments suivants doivent être vrais :

  - Le niveau de l'unité d'organisation doit être spécifié par un niveau d'approbation 
    dans le flux de travail.

  - La période spécifiée doit correspondre au type de période du 
    flux de travail.

### Approuver les données en bloc { #webapi_data_approval_bulk_approve_data } 

<!--DHIS2-SECTION-ID:webapi_data_approval_bulk_approve_data-->

Vous pouvez approuver un ensemble d'enregistrements de données en postant dans 
la ressource `/api/dataApprovals/approvals`.

    POST /api/33/dataApprovals/approvals

Vous pouvez approuver un bloc d'enregistrements de données en postant dans 
la ressource `/api/dataApprovals/approvals`.

    POST /api/33/dataApprovals/unapprovals

Vous pouvez accepter un grand nombre d'enregistrements en envoyant un message à la ressource
`/api/dataAcceptances/acceptances`.

    POST /api/33/dataAcceptances/acceptances

Vous pouvez refuser un bloc d'enregistrements en envoyant un message à la ressource
`/api/dataAcceptances/acceptances`.

    POST /api/33/dataAcceptances/unacceptances

La charge utile d'approbation est prise en charge en tant que JSON et ressemble à ceci :

```json
{
  "wf": [
    "pBOMPrpg1QX", "lyLU2wR22tC"
  ],
  "pe": [
    "201601", "201602"
  ],
  "approvals": [
    {
      "ou": "cDw53Ej8rju",
      "aoc": "ranftQIH5M9"
    }, 
    {
      "ou": "cDw53Ej8rju",
      "aoc": "fC3z1lcAW5x"
    }
  ]
}
```

### Obtenir les niveaux d'approbation des données { #get-data-approval-levels } 

To retrieve data approval workflows and their data approval levels you 
can make a GET request similar to this:

/api/dataApprovalWorkflows ?
champs=identifiant, nom, type de période, niveau d'approbation des données [identifiant, nom, niveau, niveau de l'unité d'organisation]

## Auditing { #webapi_auditing } 

<!--DHIS2-SECTION-ID:webapi_auditing-->

DHIS2 does automatic auditing on all updates and deletions of aggregate
data values, tracked entity data values, tracked entity attribute
values, and data approvals. This section explains how to fetch this
data.

### Aggregate data value audits { #webapi_auditing_aggregate_audits } 

<!--DHIS2-SECTION-ID:webapi_auditing_aggregate_audits-->

The endpoint for aggregate data value audits is located at
`/api/audits/dataValue`, and the available parameters are displayed in
the table below.

<table>
<caption>Aggregate data value query parameters</caption>
<colgroup>
<col style="width: 12%" />
<col style="width: 14%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ds</td>
<td>Data Set</td>
<td>One or more data set identifiers to get data elements from.</td>
</tr>
<tr class="even">
<td>de</td>
<td>Data Element</td>
<td>One or more data element identifiers.</td>
</tr>
<tr class="odd">
<td>pe</td>
<td>ISO Period</td>
<td>One or more period ISO identifiers.</td>
</tr>
<tr class="even">
<td>ou</td>
<td>Organisation Unit</td>
<td>One or more org unit identifiers.</td>
</tr>
<tr class="odd">
<td>auditType</td>
<td>UPDATE | DELETE</td>
<td>Filter by audit type.</td>
</tr>
<tr class="even">
<td>skipPaging</td>
<td>false | true</td>
<td>Turn paging on / off</td>
</tr>
<tr class="odd">
<td>page</td>
<td>1 (default)</td>
<td>If paging is enabled, this parameter decides which page to show</td>
</tr>
</tbody>
</table>

Get all audits for data set with ID *lyLU2wR22tC*:

    /api/33/audits/dataValue?ds=lyLU2wR22tC

### Tracked entity data value audits { #webapi_tracked_entity_data_value_audits } 

<!--DHIS2-SECTION-ID:webapi_tracked_entity_data_value_audits-->

The endpoint for tracked entity data value audits is located at
`/api/audits/trackedEntityDataValue`, and the available parameters are
displayed in the table below.

<table>
<caption>Tracked entity data value query parameters</caption>
<colgroup>
<col style="width: 12%" />
<col style="width: 16%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>de</td>
<td>Data Element</td>
<td>One or more data element identifiers.</td>
</tr>
<tr class="even">
<td>ps</td>
<td>Program Stage Entity</td>
<td>One or more program stage instance identifiers.</td>
</tr>
<tr class="odd">
<td>auditType</td>
<td>UPDATE | DELETE</td>
<td>Filter by audit type.</td>
</tr>
<tr class="even">
<td>skipPaging</td>
<td>false | true</td>
<td>Turn paging on / off</td>
</tr>
<tr class="odd">
<td>page</td>
<td>1 (default)</td>
<td>If paging is enabled, this parameter decides which page to show</td>
</tr>
</tbody>
</table>

Get all audits which have data element ID eMyVanycQSC or qrur9Dvnyt5:

    /api/33/audits/trackedEntityDataValue?de=eMyVanycQSC&de=qrur9Dvnyt5

### Tracked entity attribute value audits { #webapi_tracked_entity_attribute_value_audits } 

<!--DHIS2-SECTION-ID:webapi_tracked_entity_attribute_value_audits-->

The endpoint for tracked entity attribute value audits is located at
`/api/audits/trackedEntityAttributeValue`, and the available parameters
are displayed in the table below.

<table>
<caption>Tracked entity attribute value query parameters</caption>
<colgroup>
<col style="width: 12%" />
<col style="width: 16%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>tea</td>
<td>Tracked Entity Attributes</td>
<td>One or more tracked entity attribute identifiers.</td>
</tr>
<tr class="even">
<td>te</td>
<td>Tracked Entity Instances</td>
<td>One or more tracked entity instance identifiers.</td>
</tr>
<tr class="odd">
<td>auditType</td>
<td>UPDATE | DELETE</td>
<td>Filter by audit type.</td>
</tr>
<tr class="even">
<td>skipPaging</td>
<td>false | true</td>
<td>Turn paging on / off</td>
</tr>
<tr class="odd">
<td>page</td>
<td>1 (default)</td>
<td>If paging is enabled, this parameter decides which page to show</td>
</tr>
</tbody>
</table>

Get all audits which have attribute with ID VqEFza8wbwA:

    /api/33/audits/trackedEntityAttributeValue?tea=VqEFza8wbwA

### Tracked entity instance audits { #webapi_tracked_entity_instance_audits } 

<!--DHIS2-SECTION-ID:webapi_tracked_entity_instance_audits-->

Once auditing is enabled for tracked entity instances (by setting
allowAuditLog of tracked entity types to true), all read and search
operations are logged. The endpoint for accessing audit logs is
api/audits/trackedEntityInstance. Below are available parameters to
interact with this endpoint.

<table>
<caption>Tracked entity instance audit query parameters</caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>tei</td>
<td>Tracked Entity Instance</td>
<td>One or more tracked entity instance identifiers</td>
</tr>
<tr class="even">
<td>user</td>
<td>User</td>
<td>One or more user identifiers</td>
</tr>
<tr class="odd">
<td>auditType</td>
<td>SEARCH | READ</td>
<td>Audit type to filter for</td>
</tr>
<tr class="even">
<td>startDate</td>
<td>Start date</td>
<td>Start date for audit filtering in yyyy-mm-dd format.</td>
</tr>
<tr class="odd">
<td>endDate</td>
<td>End date</td>
<td>End date for audit filtering in yyyy-mm-dd format.</td>
</tr>
<tr class="even">
<td>skipPaging</td>
<td>false | true</td>
<td>Turn paging on / off.</td>
</tr>
<tr class="odd">
<td>page</td>
<td>1 (default)</td>
<td>Specific page to ask for.</td>
</tr>
<tr class="even">
<td>pageSize</td>
<td>50 (default)</td>
<td>Page size.</td>
</tr>
</tbody>
</table>

Get all tracked entity instance audits of type READ with
startDate=2018-03-01 and endDate=2018-04-24 in a page size of 5:

    /api/33/audits/trackedEntityInstance.json?startDate=2018-03-01
      &endDate=2018-04-24&auditType=READ&pageSize=5

### Enrollment audits { #webapi_enrollment_audits } 

<!--DHIS2-SECTION-ID:webapi_enrollment_audits-->

Once auditing is enabled for enrollments (by setting allowAuditLog of
tracker programs to true), all read operations are logged. The
endpoint for accessing audit logs is api/audits/enrollment. Below are
available parameters to interact with this endpoint.

<table>
<caption>Enrollment audit query parameters</caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>en</td>
<td>Enrollment</td>
<td>One or more tracked entity instance identifiers</td>
</tr>
<tr class="even">
<td>user</td>
<td>User</td>
<td>One or more user identifiers</td>
</tr>
<tr class="odd">
<td>startDate</td>
<td>Start date</td>
<td>Start date for audit filtering in yyyy-mm-dd format.</td>
</tr>
<tr class="even">
<td>endDate</td>
<td>End date</td>
<td>End date for audit filtering in yyyy-mm-dd format.</td>
</tr>
<tr class="odd">
<td>skipPaging</td>
<td>false | true</td>
<td>Turn paging on / off.</td>
</tr>
<tr class="even">
<td>page</td>
<td>1 (default)</td>
<td>Specific page to ask for.</td>
</tr>
<tr class="odd">
<td>pageSize</td>
<td>50 (default)</td>
<td>Page size.</td>
</tr>
</tbody>
</table>

Get all enrollment audits with startDate=2018-03-01 and
endDate=2018-04-24 in a page size of 5:

    /api/audits/enrollment.json?startDate=2018-03-01&endDate=2018-04-24&pageSize=5

Get all enrollment audits for user admin:

    /api/audits/enrollment.json?user=admin

### Audits d'approbation des données { #data-approval-audits } 

The endpoint for data approval audits is located at
/api/audits/dataApproval, and the available parameters are displayed in
the table below.

<table>
<caption>Data approval query parameters</caption>
<colgroup>
<col style="width: 12%" />
<col style="width: 16%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>dal</td>
<td>Data Approval Level</td>
<td>One or more data approval level identifiers.</td>
</tr>
<tr class="even">
<td>wf</td>
<td>Workflow</td>
<td>One or more data approval workflow identifiers.</td>
</tr>
<tr class="odd">
<td>ou</td>
<td>Organisation Unit</td>
<td>One or more organisation unit identifiers.</td>
</tr>
<tr class="even">
<td>aoc</td>
<td>Attribute Option Combo</td>
<td>One or more attribute option combination identifiers.</td>
</tr>
<tr class="odd">
<td>startDate</td>
<td>Start Date</td>
<td>Starting Date for approvals in yyyy-mm-dd format.</td>
</tr>
<tr class="even">
<td>endDate</td>
<td>End Date</td>
<td>Ending Date for approvals in yyyy-mm-dd format.</td>
</tr>
<tr class="odd">
<td>skipPaging</td>
<td>false | true</td>
<td>Turn paging on / off</td>
</tr>
<tr class="even">
<td>page</td>
<td>1 (default)</td>
<td><p>If paging is enabled, this parameter decides which page to show.</p></td>
</tr>
</tbody>
</table>

Get all audits for data approval workflow RwNpkAM7Hw7:

    /api/33/audits/dataApproval?wf=RwNpkAM7Hw7

## Conversations par messages { #webapi_message_conversations } 

<!--DHIS2-SECTION-ID:webapi_message_conversations-->

DHIS2 dispose d'un mécanisme permettant d'envoyer des messages à des fins tels que 
le retour d'information des utilisateurs, les notifications et les informations générales à l'intention des utilisateurs. Les messages 
sont regroupés en conversations. Pour interagir avec les conversations de messages, 
vous pouvez envoyer des requêtes POST et GET à la ressource 
*messageConversations*.

    /api/33/messageConversations

Les messages sont transmis à la boîte de réception DHIS2, mais ils peuvent également être envoyés 
aux adresses électroniques et aux téléphones portables de l'utilisateur sous forme de SMS. Dans cet exemple, 
nous verrons comment utiliser l'API Web pour envoyer, lire et gérer des 
messages. Nous allons nous faire passer pour l'utilisateur *Administrateur DHIS2* et envoyer 
un message à l'utilisateur *Mobile*. Nous allons ensuite nous faire passer pour l'utilisateur 
mobile et lire notre nouveau message. Ensuite, nous allons gérer la boîte de réception de l'utilisateur 
administrateur en marquant et en supprimant des messages.

### Écrire et lire des messages { #webapi_writing_messages } 

<!--DHIS2-SECTION-ID:webapi_writing_messages-->

La ressource avec laquelle nous devons interagir pour envoyer et lire des messages 
est la ressource *messageConversations*. Nous commençons par visiter le point d'entrée 
de l'API Web à l'adresse <http://play.dhis2.org/demo/api>, où nous trouvons et suivons 
le lien vers la ressource *messageConversations* à l'adresse
<http://play.dhis2.org/demo/api messageConversations>. La description 
nous indique que nous pouvons utiliser une requête POST pour créer un nouveau message 
en utilisant le format XML suivant pour l'envoyer à plusieurs utilisateurs :

```xml
<message xmlns="http://dhis2.org/schema/dxf/2.0">
  <subject>Voici le sujet</subject>
  <text>Voici le texte</text>
  <users>
    <user id="user1ID" />
    <user id="user2ID" />
    <user id="user3ID" />
  </users>
</message>
```

Pour l'envoi à tous les utilisateurs appartenant à un ou plusieurs groupes d'utilisateurs, nous pouvons
utiliser :

```xml
<message xmlns="http://dhis2.org/schema/dxf/2.0">
  <subject>Voici le sujet</subject>
  <text>Voici le texte</text>
  <userGroups>
    <userGroup id="userGroup1ID" />
    <userGroup id="userGroup2ID" />
    <userGroup id="userGroup3ID" />
  </userGroups>
</message>
```

Pour l'envoi à tous les utilisateurs connectés à une ou plusieurs unités d'organisation, nous 
pouvons utiliser :

```xml
<message xmlns="http://dhis2.org/schema/dxf/2.0">
  <subject>Voici le sujet</subject>
  <text>Voici le texte</text>
  <organisationUnits>
    <organisationUnit id="ou1ID" />
    <organisationUnit id="ou2ID" />
    <organisationUnit id="ou3ID" />
  </organisationUnits>
</message>
```

Since we want to send a message to our friend the mobile user we need to
look up her identifier. We do so by going to the Web API entry point and
follow the link to the *users* resource at `/api/users`. We continue by 
following link to the mobile user at `/api/users/PhzytPW3g2J` where we learn
that her identifier is *PhzytPW3g2J*. We are now ready to put our XML
message together to form a message where we want to ask the mobile user
whether she has reported data for January 2014:

```xml
<message xmlns="http://dhis2.org/schema/dxf/2.0">
  <subject>Rapport sur les données de mortalité</subject>
  <text>Avez-vous déclaré des données pour l'ensemble de données sur la mortalité pour janvier 2014 ?</text>
  <users>
    <user id="PhzytPW3g2J" />
  </users>
</message>
```

Pour le tester, nous enregistrons le contenu XML dans un fichier appelé *message.xml*. 
Nous utilisons cURL pour envoyer le message à l'instance de démonstration DHIS2 où nous 
indiquons que le type de contenu est XML et où nous nous authentifions en tant qu'utilisateur 
*admin* :

```bash
curl -d @message.xml "https://play.dhis2.org/demo/api/messageConversations"
  -H "Content-Type:application/xml" -u admin:district -X POST
```

La charge correspondante en JSON et la commande POST ressemblent à ceci :

```json
{
  "subject": "Hey",
  "text": "How are you?",
  "users": [
    {
      "id": "OYLGMiazHtW"
    },
    {
      "id": "N3PZBUlN8vq"
    }
  ],
  "userGroups": [
    {
      "id": "ZoHNWQajIoe"
    }
  ],
  "organisationUnits": [
    {
      "id": "DiszpKrYNg8"
    }
  ]
}
```

```bash
curl -d @message.json "https://play.dhis2.org/demo/api/33/messageConversations"
  -H "Content-Type:application/json" -u admin:district -X POST
```

Si tout se passe bien, nous recevons un code de statut HTTP *201 Créé*. Notez également 
que nous recevons un en-tête HTTP *Localisation* qui nous informe de 
l'URL de la ressource de conversation de messages nouvellement créée - celle-ci peut être 
utilisée par un utilisateur pour effectuer d'autres actions.

Nous allons maintenant nous faire passer pour l'utilisateur mobile et lire le message qui 
vient d'être envoyé en envoyant une requête GET à la ressource *messageConversations*. 
Nous fournissons un en-tête *Accepter* avec l'*application/xml* comme 
valeur pour indiquer que nous sommes intéressés par la représentation de la ressource 
XML et nous nous authentifions en tant qu'utilisateur *mobile* :

```bash
curl "https://play.dhis2.org/demo/api/33/messageConversations"
  -H "Accept:application/xml" -u mobile:district
```

En réponse, nous obtenons le fichier XML suivant :

```xml
<messageConversations xmlns="http://dhis2.org/schema/dxf/2.0"
  link="https://play.dhis2.org/demo/api/messageConversations">
  <messageConversation name="Mortality data reporting" id="ZjHHSjyyeJ2"
    link="https://play.dhis2.org/demo/api/messageConversations/ZjHHSjyyeJ2"/>
  <messageConversation name="DHIS2 version 2.7 is deployed" id="GDBqVfkmnp2"
    link="https://play.dhis2.org/demo/api/messageConversations/GDBqVfkmnp2"/>
</messageConversations>
```

Dans la réponse, nous pouvons lire l'identifiant du nouveau message envoyé, 
qui est *ZjHHSjyyeJ2*. Notez que le lien vers la ressource spécifique 
est intégré et peut être suivi pour lire le message 
complet. Une fois que nous connaissons l'URL, nous pouvons répondre directement à 
une conversation sur un message existant en incluant le texte du message dans la charge de la requête. Nous 
sommes maintenant en mesure de créer une URL pour envoyer notre réponse :

```bash
curl -d "Oui, l'ensemble des données sur la mortalité a été déclaré"
  "https://play.dhis2.org/demo/api/messageConversations/ZjHHSjyyeJ2"
  -H "Content-Type:text/plain" -u mobile:district -X POST
```

Si tout s'est déroulé comme prévu, vous recevrez un code de statut *200 OK*.

Dans la version 2.30, nous avons ajouté un paramètre de recherche d'URL :

    queryString=?&queryOperator=?

The filter searches for matches in subject, text, and senders for message 
conversations. The default query operator is *token*, however other operators 
can be defined in the query.

### Gérer les messages { #webapi_managing_messages } 

<!--DHIS2-SECTION-ID:webapi_managing_messages-->

Au fur et à mesure que les utilisateurs reçoivent et envoient des messages, les conversations commencent à s'empiler 
dans leur boîte de réception, ce qui devient éventuellement difficile à suivre. Nous allons maintenant 
voir comment gérer la boîte de réception des messages d'un utilisateur en supprimant et en marquant 
des conversations par l'intermédiaire de la Web-API. Pour ce faire, nous allons effectuer quelques 
opérations de maintenance dans la boîte de réception de l'utilisateur « Administrateur DHIS ».

Commençons par supprimer quelques messages de la boîte de réception. Notez 
bien que toutes les opérations de suppression décrites ici ne suppriment que la 
relation entre un utilisateur et une conversation de messages. En termes pratiques, 
cela signifie que nous ne supprimons pas les messages eux-mêmes (ni aucun 
contenu d'ailleurs) mais que nous supprimons simplement le fil de messages de 
l'utilisateur de sorte qu'il ne soit plus listé dans 
la ressource `/api/messageConversations`.

Pour supprimer une conversation de messages de la boîte de réception d'un utilisateur, nous devons envoyer une 
requête *DELETE* à la ressource identifiée par l'identifiant de la conversation de 
messages et l'utilisateur participant. Par exemple, pour supprimer l'utilisateur 
avec l'identifiant `xE7jOejl9FI` de la conversation avec l'identifiant `jMe43trzrdi` :

```bash
curl "https://play.dhis2.org/demo/api/33/messageConversations/jMe43trzrdi
```

Si la demande a abouti, le serveur répondra par un *200 OK*. Le 
corps de la réponse contient un objet XML ou JSON (selon l'en-tête "accepter" 
de la demande) contenant l'identifiant de l'utilisateur supprimé.

```json
{
  "removed" : ["xE7jOejl9FI"]
}
```

En cas d'échec, l'objet renvoyé contiendra un message qui 
décrit l'erreur.

```json
{
  "message" : "No user with uid: dMV6G0tPAEa"
}
```

Le lecteur observateur aura déjà remarqué que l'objet renvoyé en cas 
de succès dans notre exemple est en fait une liste d'identifiants (contenant une seule 
entrée). Ceci est dû au fait que le endpoint prend également en charge les suppressions par lots. La 
requête est faite à la même ressource *messageConversations* mais suit 
une sémantique légèrement différente. Pour les opérations par lots, les identifiants 
de conversation sont donnés en tant que paramètres de la chaîne de requête. L'exemple suivant supprime deux 
conversations de messages distinctes pour l'utilisateur actuel :

```bash
curl "https://play.dhis2.org/demo/api/messageConversations?mc=WzMRrCosqc0&mc=lxCjiigqrJm"
  -X DELETE -u admin:district
```

Si vous disposez d'autorisations suffisantes, vous pouvez supprimer des conversations au 
nom d'un autre utilisateur en indiquant un paramètre facultatif, l'identifiant de l'utilisateur.

```bash
curl "https://play.dhis2.org/demo/api/messageConversations?mc=WzMRrCosqc0&mc=lxCjiigqrJm&user=PhzytPW3g2J"
  -X DELETE -u admin:district
```

Comme indiqué, les suppressions par lots renvoient le même format de message que pour 
les opérations individuelles. La liste des objets supprimés reflétera les suppressions 
effectuées avec succès. Les demandes partiellement erronées (c'est-à-dire les identifiants inexistants) 
n'annuleront donc pas l'ensemble de l'opération par lots.

Les messages comportent une propriété booléenne *read* (lire). Cette propriété permet de savoir si un 
utilisateur a vu (ouvert) un message ou non. Dans un scénario d'application 
typique (par exemple, le portail web DHIS2), un message est marqué comme 
lu dès que l'utilisateur l'ouvre pour la première fois. Cependant, les utilisateurs peuvent vouloir 
gérer le statut « lu » ou « non lu » de leurs messages afin de garder une 
trace de certaines conversations.

Marking messages read or unread follows similar semantics as batch
removals, and also supports batch operations. To mark messages as read
we issue a *POST* to the `messageConversations/read` resource with a
request body containing one or more message ids. To mark messages as
unread we issue an identical request to the `messageConversations/unread` 
resource. As is the case for removals, an optional *user* request parameter 
can be given.

Marquons quelques messages comme lus par l'utilisateur actuel :

```bash
curl "https://play.dhis2.org/dev/api/messageConversations/read"
  -d '["ZrKML5WiyFm","Gc03smoTm6q"]' -X POST
  -H "Content-Type: application/json" -u admin:district
```

La réponse est un *200 OK* avec le contenu JSON suivant :

```json
{
  "markedRead": ["ZrKML5WiyFm", "Gc03smoTm6q"]
}
```

Vous pouvez ajouter des destinataires à une conversation de messages existante. La ressource est située à l'adresse suivante : 

    /api/33/messageConversations/id/recipients

Les options de cette ressource sont une liste d'utilisateurs, de groupes d'utilisateurs et 
d'unités d'organisation. La requête doit ressembler à ceci :

```json
{
  "users": [
    {
      "id": "OYLGMiazHtW"
    },
    {
      "id": "N3PZBUlN8vq"
    }
  ],
  "userGroups": [
    {
      "id": "DiszpKrYNg8"
    }
  ],
  "organisationUnits": [
    {
      "id": "DiszpKrYNg8"
    }
  ]
}

```

### Pièces jointes aux messages { #webapi_message_attachments } 

<!--DHIS2-SECTION-ID:webapi_message_attachments-->

La création de messages avec des pièces jointes se fait en deux étapes : le téléchargement du 
fichier dans la ressource *attachments* (pièces jointes), puis inclure un ou plusieurs
pièces jointes lors de la création d'un nouveau message.

Une requête POST à la ressource *attachments* téléchargera le fichier sur le
serveur.

```
curl -F file=@attachment.png "https://play.dhis2.org/demo/api/messageConversations/attachments"
  -u admin:district 
```

La demande renvoie un objet qui représente la pièce jointe. L'identifiant de
cet objet doit être utilisé lors de la création d'un message afin de lier la 
pièce jointe au message.

```json
{
  "created": "2018-07-20T16:54:18.210",
  "lastUpdated": "2018-07-20T16:54:18.212",
  "externalAccess": false,
  "publicAccess": "--------",
  "user": {
    "name": "John Traore",
    "created": "2013-04-18T17:15:08.407",
    "lastUpdated": "2018-03-09T23:06:54.512",
    "externalAccess": false,
    "displayName": "John Traore",
    "favorite": false,
    "id": "xE7jOejl9FI"
  },
  "lastUpdatedBy": {
    "id": "xE7jOejl9FI",
    "name": "John Traore"
  },
  "favorite": false,
  "id": "fTpI4GOmujz"
}
```

Lors de la création d'un nouveau message, les identifiants peuvent être transmis dans le contenu de la requête
pour lier les fichiers téléchargés au message en cours de création.

```json
{
  "subject": "Hey",
  "text": "How are you?",
  "users": [
    {
      "id": "OYLGMiazHtW"
    },
    {
      "id": "N3PZBUlN8vq"
    }
  ],
  "userGroups": [
    {
      "id": "ZoHNWQajIoe"
    }
  ],
  "organisationUnits": [
    {
      "id": "DiszpKrYNg8"
    }
  ],
  "attachments": [
    "fTpI4GOmujz",
    "h2ZsOxMFMfq"
  ]
}
```

Lorsque vous répondez à un message, les identifiants peuvent être transmis en tant que paramètre de la 
requête.

```bash
curl -d "Oui, l'ensemble des données sur la mortalité a été déclaré"
  "https://play.dhis2.org/demo/api/33/messageConversations/ZjHHSjyyeJ2?attachments=fTpI4GOmujz,h2ZsOxMFMfq"
  -H "Content-Type:text/plain" -u mobile:district -X POST
```

Une fois qu'un message avec une pièce jointe a été créé, il est possible d'accéder à la pièce jointe 
à l'aide d'une requête GET à l'URL suivante :

    /api/messageConversations/<mcv-id>/<msg-id>/attachments/<attachment-id>

Où <mcv-id>est l'ID de la *conversation du message*, <msg-id>est l'ID du *message* qui contient la pièce jointe et <attachment-id>est l'ID de la *pièce jointe* spécifique du message.

### Notifications des tickets et des résultats de validation { #webapi_messaging_tickets } 

<!--DHIS2-SECTION-ID:webapi_messaging_tickets-->

Vous pouvez utiliser l'outil « écrire un feedback » pour créer des tickets et des messages.
La seule différence entre un ticket et un message est que vous pouvez donner 
un statut et une priorité à un ticket. Pour définir le statut :

    POST /api/messageConversations/<uid>/status

Pour définir la priorité :

    POST /api/messageConversations/<uid>/priority

Dans la version 2.29, les messages générés par l'analyse de validation peuvent désormais être utilisés dans 
les propriétés de statut et de priorité. Par défaut, les messages générés par 
l'analyse de validation héritent de la priorité de la règle de validation en 
question, ou de la plus grande importance si le message contient plusieurs 
règles.

Dans la version 2.30, les règles de validation peuvent être affectées à n'importe quel utilisateur, alors que les tickets 
doivent toujours être affectés à un utilisateur appartenant au groupe des destinataires du retour d'information du 
système.

<table>
<caption>A list of valid status and priority values</caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Status</th>
<th>Priority</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>OPEN</td>
<td>LOW</td>
</tr>
<tr class="even">
<td>PENDING</td>
<td>MEDIUM</td>
</tr>
<tr class="odd">
<td>INVALID</td>
<td>HIGH</td>
</tr>
<tr class="even">
<td>SOLVED</td>
<td></td>
</tr>
</tbody>
</table>

Vous pouvez également ajouter un message interne à un ticket, qui ne peut être vu que 
par les utilisateurs ayant les permissions « Gérer les tickets ». Pour créer une réponse 
interne, vous devez inclure le paramètre « interne » et le définir sur:

```bash
curl -d "Ceci est un message interne"
  "https://play.dhis2.org/demo/api/33/messageConversations/ZjHHSjyyeJ2?internal=true"
  -H "Content-Type:text/plain" -u admin:district -X POST
```

## Interprétations { #webapi_interpretations } 

<!--DHIS2-SECTION-ID:webapi_interpretations-->

For resources related to data analysis in DHIS2, such as pivot tables,
charts, maps, event reports and event charts, you can write and share
data interpretations. An interpretation can be a comment, question,
observation or interpretation about a data report or visualization.

    /api/interpretations

### Lire les interprétations { #webapi_reading_interpretations } 

<!--DHIS2-SECTION-ID:webapi_reading_interpretations-->

Pour lire les interprétations, nous allons interagir avec la ressource
`/api/interpretations`. Une requête GET typique utilisant le filtrage des champs
peut ressembler à ceci :

    GET /api/interpretations?fields=*,comments[id,text,user,mentions]

La réponse au format JSON pourrait ressembler à ce qui suit (les champs supplémentaires 
ont été omis par souci de concision) :

```json
{
  "interpretations": [
    {
      "id": "XSHiFlHAhhh",
      "created": "2013-05-30T10:24:06.181+0000",
      "text": "Data looks suspicious, could be a data entry mistake.",
      "type": "REPORT_TABLE",
      "likes": 2,
      "user": {
        "id": "uk7diLujYif"
      },
      "reportTable": {
        "id": "LcSxnfeBxyi"
      },
      "visualization": {
        "id": "LcSxnfeBxyi"
      }
    }, {
      "id": "kr4AnZmYL43",
      "created": "2013-05-29T14:47:13.081+0000",
      "text": "Delivery rates in Bo looks high.",
      "type": "CHART",
      "likes": 3,
      "user": {
        "id": "uk7diLujYif"
      },
      "chart": {
        "id": "HDEDqV3yv3H"
      },
      "visualization": {
        "id": "HDEDqV3yv3H"
      },
      "mentions": [
        {
          "created": "2018-06-25T10:25:54.498",
          "username": "boateng"
        }
      ],
      "comments": [
        {
          "id": "iB4Etq8yTE6",
          "text": "This report indicates a surge.",
          "user": {
            "id": "B4XIfwOcGyI"
          }
        },
        {
          "id": "iB4Etq8yTE6",
          "text": "Likely caused by heavy rainfall.",
          "user": {
            "id": "B4XIfwOcGyI"
          }
        }, 
        {
          "id": "SIjkdENan8p",
          "text": "Have a look at this @boateng.",
          "user": {
            "id": "xE7jOejl9FI"
          },
          "mentions": [
            {
              "created": "2018-06-25T10:03:52.316",
              "username": "boateng"
            }
          ]
        }
      ]
    }
  ]
}
```

<table>
<caption>Interpretation fields</caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>id</td>
<td>The interpretation identifier.</td>
</tr>
<tr class="even">
<td>created</td>
<td>The time of when the interpretation was created.</td>
</tr>
<tr class="odd">
<td>type</td>
<td>The type of analytical object being interpreted. Valid options: REPORT_TABLE, CHART, MAP, EVENT_REPORT, EVENT_CHART, DATASET_REPORT.
</tr>
<tr class="even">
<td>user</td>
<td>Association to the user who created the interpretation.</td>
</tr>
<tr class="odd">
<td>reportTable</td>
<td>Association to the report table if type is REPORT_TABLE.</td>
</tr>
<tr class="even">
<td>chart</td>
<td>Association to the chart if type is CHART.</td>
</tr>
<tr class="odd">
<td>visualization</td>
<td>Association to the visualization if type is CHART or REPORT_TABLE (**both types are in deprecation process in favour of VISUALIZATION**).</td>
</tr>
<tr class="even">
<td>map</td>
<td>Association to the map if type is MAP.</td>
</tr>
<tr class="odd">
<td>eventReport</td>
<td>Association to the event report is type is EVENT_REPORT.</td>
</tr>
<tr class="even">
<td>eventChart</td>
<td>Association to the event chart if type is EVENT_CHART.</td>
</tr>
<tr class="odd">
<td>dataSet</td>
<td>Association to the data set if type is DATASET_REPORT.</td>
</tr>
<tr class="even">
<td>comments</td>
<td>Array of comments for the interpretation. The text field holds the actual comment.</td>
</tr>
<tr class="odd">
<td>mentions</td>
<td>Array of mentions for the interpretation. A list of users identifiers.</td>
</tr>
</tbody>
</table>

Pour tous les objets analytiques, vous pouvez ajouter */ données* à l'URL pour récupérer 
les données associées à la ressource (par opposition aux métadonnées). Par 
exemple, en suivant le lien de la carte et en ajoutant / données, on peut 
récupérer une représentation PNG (image) de la carte thématique par l'intermédiaire de 
l'URL suivante :

    https://play.dhis2.org/demo/api/maps/bhmHJ4ZCdCd/data

Pour tous les objets analytiques, vous pouvez filtrer par *mentions*. Pour récupérer toutes 
les interprétations/commentaires où un utilisateur a été mentionné, vous avez 
trois options. Vous pouvez filtrer par les mentions d'interprétation (mentions 
dans la description de 
l'interprétation) :

    GET /api/interpretations?fields=*,comments[*]&filter=mentions.username:in:[boateng]

Vous pouvez filtrer les commentaires d'interprétation en fonction des mentions (mentions dans n'importe quel 
commentaire) :

    GET /api/interpretations?fields=*,comments[*]
      &filter=comments.mentions.username:in:[boateng]

Vous pouvez filtrer les interprétations qui contiennent les mentions soit
dans l'interprétation ou dans un commentaire ( OU jonction) :

    GET /api/interpretations?fields=*,comments[*]&filter=mentions:in:[boateng]

### Écrire les interprétations { #webapi_writing_interpretations } 

<!--DHIS2-SECTION-ID:webapi_writing_interpretations-->

Lorsque vous écrivez des interprétations, vous fournissez le texte de l'interprétation dans 
le corps de la requête en utilisant une requête POST avec un contenu de type « text/plain ». 
Le modèle d'URL ressemble à ce qui suit, où {object-type} fait référence au 
type de l'objet interprété et {object-id} fait référence à 
l'identifiant de l'objet interprété.

    /api/interpretations/{object-type}/{object-id}

Valid options for object type are *reportTable*, *chart*, *map*,
*eventReport*, *eventChart* and *dataSetReport*.

Quelques exemples pertinents d'interprétations sont énumérés ci-dessous.

> **Note**
>
> The `charts` and `reportTables` APIs are deprecated. We recommend using the `visualizations` API instead.

    /api/interpretations/reportTable/yC86zJxU1i1
    /api/interpretations/chart/ZMuYVhtIceD
    /api/interpretations/visualization/hQxZGXqnLS9
    /api/interpretations/map/FwLHSMCejFu
    /api/interpretations/eventReport/xJmPLGP3Cde
    /api/interpretations/eventChart/nEzXB2M9YBz
    /api/interpretations/dataSetReport/tL7eCjmDIgM

As an example, we will start by writing an interpretation for the chart
with identifier *EbRN2VIbPdV*. To write chart interpretations we will
interact with the `/api/interpretations/chart/{chartId}` resource.
The interpretation will be the request body. Based on this we can put
together the following request using cURL:

```bash
curl -d "This chart shows a significant ANC 1-3 dropout" -X POST
  "https://play.dhis2.org/demo/api/interpretations/chart/EbRN2VIbPdV"
  -H "Content-Type:text/plain" -u admin:district
```

Notez que la réponse fournit un en-tête de Localisation avec une valeur
indiquant l'emplacement de l'interprétation créée. Ceci est utile
du point de vue du client lorsque vous souhaitez ajouter un commentaire à
interprétation.

### Mise à jour et suppression d'interprétations { #webapi_updating_removing_interpretations } 

<!--DHIS2-SECTION-ID:webapi_updating_removing_interpretations-->

Pour mettre à jour une interprétation existante, vous pouvez utiliser une requête PUT dont le texte de l'interprétation est le corps de la requête, qui utilise le modèle d'URL suivant, dans lequel {id} fait référence à l'identifiant de l'interprétation :

    /api/interpretations/{id}

Sur cette base, nous pouvons utiliser curl pour mettre à jour l'interprétation :

```bash
curl -d "This charts shows a high dropout" -X PUT
  "https://play.dhis2.org/demo/api/interpretations/chart/EV08iI1cJRA"
  -H "Content-Type:text/plain" -u admin:district
```

Vous pouvez utiliser le même modèle d'URL que ci-dessus en utilisant une requête DELETE pour
supprimer l'interprétation.

### Création des commentaires d'interprétation { #webapi_creating_interpretation_comments } 

<!--DHIS2-SECTION-ID:webapi_creating_interpretation_comments-->

Lorsque vous écrivez des commentaires sur les interprétations, vous fournissez le texte du commentaire
dans le corps de la requête en utilisant une requête POST avec le type de contenu
« text/plain ». Le modèle d'URL ressemble à ce qui suit, où
{interpretation-id} fait référence à l'identifiant de l'interprétation.

    /api/interpretations/{interpretation-id}/comments

Deuxièmement, nous allons rédiger un commentaire à l'interprétation que nous avons écrite dans 
l'exemple ci-dessus. En regardant la réponse de l'interprétation, vous verrez 
qu'un en-tête *Localisation* est renvoyé. Cet en-tête nous indique l'URL de 
l'interprétation nouvellement créée et, à partir de là, nous pouvons lire son 
identifiant. Cet identifiant est généré de manière aléatoire, vous devrez donc 
remplacer celui de la commande ci-dessous par le vôtre. Pour écrire un commentaire, 
nous pouvons interagir avec la ressource `/api/interpretations/{id}/comments` 
comme ceci :

```bash
curl -d "Une intervention est nécessaire" -X POST
  "https://play.dhis2.org/demo/api/interpretations/j8sjHLkK8uY/comments"
  -H "Content-Type:text/plain" -u admin:district
```

### Mise à jour et suppression des commentaires d'interprétation { #webapi_updating_removing_interpretation_comments } 

<!--DHIS2-SECTION-ID:webapi_updating_removing_interpretation_comments-->

Pour mettre à jour un commentaire d'interprétation, vous pouvez utiliser une requête PUT où
le texte du commentaire est le corps de la requête en utilisant le modèle d'URL suivant :

    /api/interpretations/{interpretation-id}/comments/{comment-id}

Sur cette base, nous pouvons utiliser curl pour mettre à jour le commentaire :

```bash
curl "https://play.dhis2.org/demo/api/interpretations/j8sjHLkK8uY/comments/idAzzhVWvh2"
  -d "Je suis d'accord." -X PUT -H "Content-Type:text/plain" -u admin:district
```

Vous pouvez utiliser le même modèle d'URL que ci-dessus en utilisant une requête DELETE pour
supprimer le commentaire d'interprétation.

### Comment aimer les interprétations { #webapi_liking_interpretations } 

<!--DHIS2-SECTION-ID:webapi_liking_interpretations-->

Pour aimer une interprétation, vous pouvez utiliser une requête POST vide vers la ressource
*like* :

    POST /api/interpretations/{id}/like

Un like sera ajouté pour l'utilisateur actuellement authentifié. Un utilisateur ne peut
aimer une interprétation qu'une seule fois.

Pour supprimer un « like » pour une interprétation, vous pouvez utiliser une requête DELETE à 
la même ressource que pour l'opération « like ».

Le statut d'une interprétation peut être visualisé en regardant la 
représentation ordinaire de l'API Web :

    GET /api/interpretations/{id}

Les informations relatives aux appréciations se trouvent dans le champ *likes* (aimé), qui représente le 
nombre d'appréciations, et dans le tableau *likedBy* (aimé par), qui énumère les utilisateurs qui 
ont aimé l'interprétation.

```json
{
  "id": "XSHiFlHAhhh",
  "text": "Data looks suspicious, could be a data entry mistake.",
  "type": "REPORT_TABLE",
  "likes": 2,
  "likedBy": [
    {
      "id": "k7Hg12fJ2f1"
    },
    {
      "id": "gYhf26fFkjFS"
    }
  ]
}
```

## Visualisation des représentations des ressources analytiques { #webapi_viewing_analytical_resource_representations } 

<!--DHIS2-SECTION-ID:webapi_viewing_analytical_resource_representations-->

DHIS2 has several resources for data analysis. These resources include
*charts*, *maps*, *reportTables*, *reports* and *documents*. By visiting
these resources you will retrieve information about the resource. For
instance, by navigating to `/api/charts/R0DVGvXDUNP` the response will
contain the name, last date of modification and so on for the chart. To
retrieve the analytical representation, for instance, a PNG
representation of the chart, you can append */data* to all these
resources. For instance, by visiting `/api/charts/R0DVGvXDUNP/data` the
system will return a PNG image of the chart.

<table>
<caption>Analytical resources</caption>
<colgroup>
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 32%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="header">
<th>Resource</th>
<th>Description</th>
<th>Data URL</th>
<th>Resource representations</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>charts</td>
<td>Charts</td>
<td>/api/charts/&lt;identifier&gt;/data</td>
<td>png</td>
</tr>
<tr class="even">
<td>eventCharts</td>
<td>Event charts</td>
<td>/api/eventCharts/&lt;identifier&gt;/data</td>
<td>png</td>
</tr>
<tr class="odd">
<td>maps</td>
<td>Maps</td>
<td>/api/maps/&lt;identifier&gt;/data</td>
<td>png</td>
</tr>
<tr class="even">
<td>reportTables</td>
<td>Pivot tables</td>
<td>/api/reportTables/&lt;identifier&gt;/data</td>
<td>json | jsonp | html | xml | pdf | xls | csv</td>
</tr>
<tr class="odd">
<td>reports</td>
<td>Standard reports</td>
<td>/api/reports/&lt;identifier&gt;/data</td>
<td>pdf | xls | html</td>
</tr>
<tr class="even">
<td>documents</td>
<td>Resources</td>
<td>/api/documents/&lt;identifier&gt;/data</td>
<td>&lt;follows document&gt;</td>
</tr>
</tbody>
</table>

Le contenu des données des représentations analytiques peut être modifié en
fournissant un paramètre de requête *date*. Pour cela, il faut que la ressource analytique
soit configurée en périodes relatives pour la dimension période.

<table>
<caption>Data query parameters</caption>
<colgroup>
<col style="width: 21%" />
<col style="width: 28%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Query parameter</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>date</td>
<td>Date in yyyy-MM-dd format</td>
<td>Basis for relative periods in report (requires relative periods)</td>
</tr>
</tbody>
</table>

<table>
<caption>Query parameters for png / image types (charts, maps)</caption>
<colgroup>
<col style="width: 21%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="header">
<th>Query parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>width</td>
<td>Width of image in pixels</td>
</tr>
<tr class="even">
<td>height</td>
<td>Height of image in pixels</td>
</tr>
</tbody>
</table>

Quelques exemples d'URL valides pour la récupération de diverses représentations analytiques
sont énumérés ci-dessous.

    /api/charts/R0DVGvXDUNP/data
    /api/charts/R0DVGvXDUNP/data?date=2013-06-01

    /api/reportTables/jIISuEWxmoI/data.html
    /api/reportTables/jIISuEWxmoI/data.html?date=2013-01-01
    /api/reportTables/FPmvWs7bn2P/data.xls
    /api/reportTables/FPmvWs7bn2P/data.pdf

    /api/maps/DHE98Gsynpr/data
    /api/maps/DHE98Gsynpr/data?date=2013-07-01

    /api/reports/OeJsA6K1Otx/data.pdf
    /api/reports/OeJsA6K1Otx/data.pdf?date=2014-01-01

## Plugins { #webapi_plugins } 

<!--DHIS2-SECTION-ID:webapi_plugins-->

DHIS2 comes with plugins which enable you to embed live data directly in
your web portal or web site. Currently, plugins exist for charts, maps
and pivot tables.

Please be aware that all of the code examples in this section are for
demonstration purposes only. They should not be used as is in
production systems. To make things simple, the credentials
(admin/district) have been embedded into the scripts. In a real scenario,
you should never expose credentials in javascript as it opens a
vulnerability to the application. In addition, you would create a user
with more minimal privileges rather than make use of a superuser to
fetch resources for your portal.

It is possible to workaround exposing the credentials by using a reverse
proxy such as nginx or apache2. The proxy can be configured to inject
the required Authorization header for only the endpoints that you wish
to make public. There is some documentation to get you started in the
section of the implementers manual which describes [reverse
proxy](https://docs.dhis2.org/master/en/implementer/html/install_reverse_proxy_configuration.html#install_making_resources_available_with_nginx)
configuration.

### Embedding pivot tables with the Pivot Table plug-in { #webapi_pivot_table_plugin } 

<!--DHIS2-SECTION-ID:webapi_pivot_table_plugin-->

In this example, we will see how we can embed good-looking, light-weight
html pivot tables with data served from a DHIS2 back-end into a Web
page. To accomplish this we will use the Pivot table plug-in. The
plug-in is written in Javascript and depends on the jQuery library only.
A complete working example can be found at
<http://play.dhis2.org/portal/table.html>. Open the page in a web
browser and view the source to see how it is set up.

We start by having a look at what the complete html file could look
like. This setup puts two tables in our web page. The first one is
referring to an existing table. The second is configured inline.

```html
<!DOCTYPE html>
<html>
<head>
  <script src="https://dhis2-cdn.org/v227/plugin/jquery-2.2.4.min.js"></script>
  <script src="https://dhis2-cdn.org/v227/plugin/reporttable.js"></script>

  <script>
    reportTablePlugin.url = "https://play.dhis2.org/demo";
    reportTablePlugin.username = "admin";
    reportTablePlugin.password = "district";
    reportTablePlugin.loadingIndicator = true;

    // Referring to an existing table through the id parameter, render to "report1" div

    var r1 = { el: "report1", id: "R0DVGvXDUNP" };

    // Table configuration, render to "report2" div

    var r2 = {
      el: "report2",
      columns: [
        {dimension: "dx", items: [{id: "YtbsuPPo010"}, {id: "l6byfWFUGaP"}]}
      ],
      rows: [
        {dimension: "pe", items: [{id: "LAST_12_MONTHS"}]}
      ],
      filters: [
        {dimension: "ou", items: [{id: "USER_ORGUNIT"}]}
      ],

      // All following properties are optional
      title: "My custom title",
      showColTotals: false,
      showRowTotals: false,
      showColSubTotals: false,
      showRowSubTotals: false,
      showDimensionLabels: false,
      hideEmptyRows: true,
      skipRounding: true,
      aggregationType: "AVERAGE",
      showHierarchy: true,
      completedOnly: true,
      displayDensity: "COMFORTABLE",
      fontSize: "SMALL",
      digitGroupSeparator: "COMMA",
      legendSet: {id: "fqs276KXCXi"}
    };

    reportTablePlugin.load([r1, r2]);
  </script>
</head>

<body>
  <div id="report1"></div>
  <div id="report2"></div>
</body>
</html>
```

Two files are included in the header section of the HTML document. The
first file is the jQuery JavaScript library (we use the DHIS2 content
delivery network in this case). The second file is the Pivot table
plug-in. Make sure the path is pointing to your DHIS2 server
installation.

Now let us have a look at the various options for the Pivot tables. One
property is required: *el* (please refer to the table below). Now, if
you want to refer to pre-defined tables already made inside DHIS2 it is
sufficient to provide the additional *id* parameter. If you instead want
to configure a pivot table dynamically you should omit the id parameter
and provide data dimensions inside a *columns* array, a *rows* array and
optionally a *filters* array instead.

A data dimension is defined as an object with a text property called
*dimension*. This property accepts the following values: *dx*
(indicator, data element, data element operand, data set, event data
item and program indicator), *pe* (period), *ou* (organisation unit) or
the id of any organisation unit group set or data element group set (can
be found in the web api). The data dimension also has an array property
called *items* which accepts objects with an *id* property.

To sum up, if you want to have e.g. "ANC 1 Coverage", "ANC 2 Coverage"
and "ANC 3 Coverage" on the columns in your table you can make the
following *columns* config:

```json
columns: [{
  dimension: "dx",
  items: [
    {id: "Uvn6LCg7dVU"}, // the id of ANC 1 Coverage
    {id: "OdiHJayrsKo"}, // the id of ANC 2 Coverage
    {id: "sB79w2hiLp8"}  // the id of ANC 3 Coverage
  ]
}]
```

<table>
<caption>Pivot table plug-in configuration</caption>
<thead>
<tr class="header">
<th>Param</th>
<th>Type</th>
<th>Required</th>
<th>Options (default first)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>url</td>
<td>string</td>
<td>Yes</td>
<td></td>
<td>Base URL of the DHIS2 server</td>
</tr>
<tr class="even">
<td>username</td>
<td>string</td>
<td>Yes (if cross-domain)</td>
<td></td>
<td>Used for authentication if the server is running on a different domain</td>
</tr>
<tr class="odd">
<td>password</td>
<td>string</td>
<td>Yes (if cross-domain)</td>
<td></td>
<td>Used for authentication if the server is running on a different domain</td>
</tr>
<tr class="even">
<td>loadingIndicator</td>
<td>boolean</td>
<td>No</td>
<td></td>
<td>Whether to show a loading indicator before the table appears</td>
</tr>
</tbody>
</table>

<table>
<caption>Pivot table configuration</caption>
<thead>
<tr class="header">
<th>Param</th>
<th>Type</th>
<th>Required</th>
<th>Options (default first)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>el</td>
<td>string</td>
<td>Yes</td>
<td></td>
<td>Identifier of the HTML element to render the table in your web page</td>
</tr>
<tr class="even">
<td>id</td>
<td>string</td>
<td>No</td>
<td></td>
<td>Identifier of a pre-defined table (favorite) in DHIS2</td>
</tr>
<tr class="odd">
<td>columns</td>
<td>array</td>
<td>Yes (if no id provided)</td>
<td></td>
<td>Data dimensions to include in table as columns</td>
</tr>
<tr class="even">
<td>rows</td>
<td>array</td>
<td>Yes (if no id provided)</td>
<td></td>
<td>Data dimensions to include in table as rows</td>
</tr>
<tr class="odd">
<td>filter</td>
<td>array</td>
<td>No</td>
<td></td>
<td>Data dimensions to include in table as filters</td>
</tr>
<tr class="even">
<td>title</td>
<td>string</td>
<td>No</td>
<td></td>
<td>Show a custom title above the table</td>
</tr>
<tr class="odd">
<td>showColTotals</td>
<td>boolean</td>
<td>No</td>
<td>true | false</td>
<td>Whether to display totals for columns</td>
</tr>
<tr class="even">
<td>showRowTotals</td>
<td>boolean</td>
<td>No</td>
<td>true | false</td>
<td>Whether to display totals for rows</td>
</tr>
<tr class="odd">
<td>showColSubTotals</td>
<td>boolean</td>
<td>No</td>
<td>true | false</td>
<td>Whether to display sub-totals for columns</td>
</tr>
<tr class="even">
<td>showRowSubTotals</td>
<td>boolean</td>
<td>No</td>
<td>true | false</td>
<td>Whether to display sub-totals for rows</td>
</tr>
<tr class="odd">
<td>showDimensionLabels</td>
<td>boolean</td>
<td>No</td>
<td>true | false</td>
<td>Whether to display the name of the dimension top-left in the table</td>
</tr>
<tr class="even">
<td>hideEmptyRows</td>
<td>boolean</td>
<td>No</td>
<td>false | true</td>
<td>Whether to hide rows with no data</td>
</tr>
<tr class="odd">
<td>skipRounding</td>
<td>boolean</td>
<td>No</td>
<td>false | true</td>
<td>Whether to skip rounding of data values</td>
</tr>
<tr class="even">
<td>completedOnly</td>
<td>boolean</td>
<td>No</td>
<td>false | true</td>
<td>Whether to only show completed events</td>
</tr>
<tr class="odd">
<td>showHierarchy</td>
<td>boolean</td>
<td>No</td>
<td>false | true</td>
<td>Whether to extend orgunit names with the name of all anchestors</td>
</tr>
<tr class="even">
<td>aggregationType</td>
<td>string</td>
<td>No</td>
<td>&quot;SUM&quot; |&quot;AVERAGE&quot; | &quot;AVERAGE_SUM_ORG_UNIT&quot;|&quot;LAST&quot;|&quot;LAST_AVERAGE_ORG_UNIT&quot;| &quot;COUNT&quot; | &quot;STDDEV&quot; | &quot;VARIANCE&quot; | &quot;MIN&quot; | &quot;MAX&quot;</td>
<td>Override the data element's default aggregation type</td>
</tr>
<tr class="odd">
<td>displayDensity</td>
<td>string</td>
<td>No</td>
<td>&quot;NORMAL&quot; | &quot;COMFORTABLE&quot; | &quot;COMPACT&quot;</td>
<td>The amount of space inside table cells</td>
</tr>
<tr class="even">
<td>fontSize</td>
<td>string</td>
<td>No</td>
<td>&quot;NORMAL&quot; | &quot;LARGE&quot; | &quot;SMALL&quot;</td>
<td>Table font size</td>
</tr>
<tr class="odd">
<td>digitGroupSeparator</td>
<td>string</td>
<td>No</td>
<td>&quot;SPACE&quot; | &quot;COMMA&quot; | &quot;NONE&quot;</td>
<td>How values are formatted: 1 000 | 1,000 | 1000</td>
</tr>
<tr class="even">
<td>legendSet</td>
<td>object</td>
<td>No</td>
<td></td>
<td>Color the values in the table according to the legend set</td>
</tr>
<tr class="odd">
<td>userOrgUnit</td>
<td>string / array</td>
<td>No</td>
<td></td>
<td>Organisation unit identifiers, overrides organisation units associated with curretn user, single or array</td>
</tr>
<tr class="even">
<td>relativePeriodDate</td>
<td>string</td>
<td>No</td>
<td></td>
<td>Date identifier e.g: &quot;2016-01-01&quot;. Overrides the start date of the relative period</td>
</tr>
</tbody>
</table>

### Embedding charts with the Visualizer chart plug-in { #webapi_chart_plugin } 

<!--DHIS2-SECTION-ID:webapi_chart_plugin-->

In this example, we will see how we can embed good-looking Highcharts
charts (<http://www.highcharts.com>) with data served from a DHIS2
back-end into a Web page. To accomplish this we will use the DHIS2
Visualizer plug-in. The plug-in is written in JavaScript and depends on
the jQuery library. A complete working example can be found at
<http://play.dhis2.org/portal/chart.html>. Open the page in a web
browser and view the source to see how it is set up.

We start by having a look at what the complete html file could look
like. This setup puts two charts on our web page. The first one is
referring to an existing chart. The second is configured inline.

```html
<!DOCTYPE html>
<html>
<head>
  <script src="https://dhis2-cdn.org/v227/plugin/jquery-2.2.4.min.js"></script>
  <script src="https://dhis2-cdn.org/v227/plugin/chart.js"></script>

  <script>
    chartPlugin.url = "https://play.dhis2.org/demo";
    chartPlugin.username = "admin";
    chartPlugin.password = "district";
    chartPlugin.loadingIndicator = true;

    // Referring to an existing chart through the id parameter, render to "report1" div

    var r1 = { el: "report1", id: "R0DVGvXDUNP" };

    // Chart configuration, render to "report2" div

    var r2 = {
      el: "report2",
      columns: [
        {dimension: "dx", items: [{id: "YtbsuPPo010"}, {id: "l6byfWFUGaP"}]}
      ],
      rows: [
        {dimension: "pe", items: [{id: "LAST_12_MONTHS"}]}
      ],
      filters: [
        {dimension: "ou", items: [{id: "USER_ORGUNIT"}]}
      ],

      // All following properties are optional
      title: "Custom title",
      type: "line",
      showValues: false,
      hideEmptyRows: true,
      regressionType: "LINEAR",
      completedOnly: true,
      targetLineValue: 100,
      targetLineTitle: "My target line title",
      baseLineValue: 20,
      baseLineTitle: "My base line title",
      aggregationType: "AVERAGE",
      rangeAxisMaxValue: 100,
      rangeAxisMinValue: 20,
      rangeAxisSteps: 5,
      rangeAxisDecimals: 2,
      rangeAxisTitle: "My range axis title",
      domainAxisTitle: "My domain axis title",
      hideLegend: true
    };

    // Render the charts

    chartPlugin.load(r1, r2);
  </script>
</head>

<body>
  <div id="report1"></div>
  <div id="report2"></div>
</body>
</html>
```

Two files are included in the header section of the HTML document. The
first file is the jQuery JavaScript library (we use the DHIS2 content
delivery network in this case). The second file is the Visualizer chart
plug-in. Make sure the path is pointing to your DHIS2 server
installation.

Now let us have a look at the various options for the charts. One
property is required: *el* (please refer to the table below). Now, if
you want to refer to pre-defined charts already made inside DHIS2 it is
sufficient to provide the additional *id* parameter. If you instead want
to configure a chart dynamically you should omit the id parameter and
provide data dimensions inside a *columns* array, a *rows* array and
optionally a *filters* array instead.

A data dimension is defined as an object with a text property called
*dimension*. This property accepts the following values: *dx*
(indicator, data element, data element operand, data set, event data
item and program indicator), *pe* (period), *ou* (organisation unit) or
the id of any organisation unit group set or data element group set (can
be found in the web api). The data dimension also has an array property
called *items* which accepts objects with an *id* property.

To sum up, if you want to have e.g. "ANC 1 Coverage", "ANC 2 Coverage"
and "ANC 3 Coverage" on the columns in your chart you can make the
following *columns* config:

```json
columns: [{
  dimension: "dx",
  items: [
    {id: "Uvn6LCg7dVU"}, // the id of ANC 1 Coverage
    {id: "OdiHJayrsKo"}, // the id of ANC 2 Coverage
    {id: "sB79w2hiLp8"}  // the id of ANC 3 Coverage
  ]
}]
```

<table>
<caption>Chart plug-in configuration</caption>
<thead>
<tr class="header">
<th>Param</th>
<th>Type</th>
<th>Required</th>
<th>Options (default first)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>url</td>
<td>string</td>
<td>Yes</td>
<td></td>
<td>Base URL of the DHIS2 server</td>
</tr>
<tr class="even">
<td>username</td>
<td>string</td>
<td>Yes (if cross-domain)</td>
<td></td>
<td>Used for authentication if the server is running on a different domain</td>
</tr>
<tr class="odd">
<td>password</td>
<td>string</td>
<td>Yes (if cross-domain)</td>
<td></td>
<td>Used for authentication if the server is running on a different domain</td>
</tr>
<tr class="even">
<td>loadingIndicator</td>
<td>boolean</td>
<td>No</td>
<td></td>
<td>Whether to show a loading indicator before the chart appears</td>
</tr>
</tbody>
</table>

<table>
<caption>Chart configuration</caption>
<thead>
<tr class="header">
<th>Param</th>
<th>Type</th>
<th>Required</th>
<th>Options (default first)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>el</td>
<td>string</td>
<td>Yes</td>
<td></td>
<td>Identifier of the HTML element to render the chart in your web page</td>
</tr>
<tr class="even">
<td>id</td>
<td>string</td>
<td>No</td>
<td></td>
<td>Identifier of a pre-defined chart (favorite) in DHIS</td>
</tr>
<tr class="odd">
<td>type</td>
<td>string</td>
<td>No</td>
<td>column | stackedcolumn | bar | stackedbar | line | area | pie | radar | gauge</td>
<td>Chart type</td>
</tr>
<tr class="even">
<td>columns</td>
<td>array</td>
<td>Yes (if no id provided)</td>
<td></td>
<td>Data dimensions to include in chart as series</td>
</tr>
<tr class="odd">
<td>rows</td>
<td>array</td>
<td>Yes (if no id provided)</td>
<td></td>
<td>Data dimensions to include in chart as category</td>
</tr>
<tr class="even">
<td>filter</td>
<td>array</td>
<td>No</td>
<td></td>
<td>Data dimensions to include in chart as filters</td>
</tr>
<tr class="odd">
<td>title</td>
<td>string</td>
<td>No</td>
<td></td>
<td>Show a custom title above the chart</td>
</tr>
<tr class="even">
<td>showValues</td>
<td>boolean</td>
<td>No</td>
<td>false | true</td>
<td>Whether to display data values on the chart</td>
</tr>
<tr class="odd">
<td>hideEmptyRows</td>
<td>boolean</td>
<td>No</td>
<td>false | true</td>
<td>Whether to hide empty categories</td>
</tr>
<tr class="even">
<td>completedOnly</td>
<td>boolean</td>
<td>No</td>
<td>false | true</td>
<td>Whether to only show completed events</td>
</tr>
<tr class="odd">
<td>regressionType</td>
<td>string</td>
<td>No</td>
<td>&quot;NONE&quot; | &quot;LINEAR&quot;</td>
<td>Show trend lines</td>
</tr>
<tr class="even">
<td>targetLineValue</td>
<td>number</td>
<td>No</td>
<td></td>
<td>Display a target line with this value</td>
</tr>
<tr class="odd">
<td>targetLineTitle</td>
<td>string</td>
<td>No</td>
<td></td>
<td>Display a title on the target line (does not apply without a target line value)</td>
</tr>
<tr class="even">
<td>baseLineValue</td>
<td>number</td>
<td>No</td>
<td></td>
<td>Display a base line with this value</td>
</tr>
<tr class="odd">
<td>baseLineTitle</td>
<td>string</td>
<td>No</td>
<td></td>
<td>Display a title on the base line (does not apply without a base line value)</td>
</tr>
<tr class="even">
<td>rangeAxisTitle</td>
<td>number</td>
<td>No</td>
<td></td>
<td>Title to be displayed along the range axis</td>
</tr>
<tr class="odd">
<td>rangeAxisMaxValue</td>
<td>number</td>
<td>No</td>
<td></td>
<td>Max value for the range axis to display</td>
</tr>
<tr class="even">
<td>rangeAxisMinValue</td>
<td>number</td>
<td>No</td>
<td></td>
<td>Min value for the range axis to display</td>
</tr>
<tr class="odd">
<td>rangeAxisSteps</td>
<td>number</td>
<td>No</td>
<td></td>
<td>Number of steps for the range axis to display</td>
</tr>
<tr class="even">
<td>rangeAxisDecimals</td>
<td>number</td>
<td>No</td>
<td></td>
<td>Bumber of decimals for the range axis to display</td>
</tr>
<tr class="odd">
<td>domainAxisTitle</td>
<td>number</td>
<td>No</td>
<td></td>
<td>Title to be displayed along the domain axis</td>
</tr>
<tr class="even">
<td>aggregationType</td>
<td>string</td>
<td>No</td>
<td>&quot;SUM&quot; |&quot;AVERAGE&quot; | &quot;AVERAGE_SUM_ORG_UNIT&quot;|&quot;LAST&quot;|&quot;LAST_AVERAGE_ORG_UNIT&quot;| &quot;COUNT&quot; | &quot;STDDEV&quot; | &quot;VARIANCE&quot; | &quot;MIN&quot; | &quot;MAX&quot;</td>
<td>Override the data element's default aggregation type</td>
</tr>
<tr class="odd">
<td>hideLegend</td>
<td>boolean</td>
<td>No</td>
<td>false | true</td>
<td>Whether to hide the series legend</td>
</tr>
<tr class="even">
<td>hideTitle</td>
<td>boolean</td>
<td>No</td>
<td>false | true</td>
<td>Whether to hide the chart title</td>
</tr>
<tr class="odd">
<td>userOrgUnit</td>
<td>string / array</td>
<td>No</td>
<td></td>
<td>Organisation unit identifiers, overrides organisation units associated with curretn user, single or array</td>
</tr>
<tr class="even">
<td>relativePeriodDate</td>
<td>string</td>
<td>No</td>
<td></td>
<td>Date identifier e.g: &quot;2016-01-01&quot;. Overrides the start date of the relative period</td>
</tr>
</tbody>
</table>

### Embedding maps with the GIS map plug-in { #webapi_map_plugin } 

<!--DHIS2-SECTION-ID:webapi_map_plugin-->

In this example we will see how we can embed maps with data served from
a DHIS2 back-end into a Web page. To accomplish this we will use the GIS
map plug-in. The plug-in is written in JavaScript and depends on the Ext
JS library only. A complete working example can be found at
<http://play.dhis2.org/portal/map.html>. Open the page in a web browser
and view the source to see how it is set up.

We start by having a look at what the complete html file could look
like. This setup puts two maps on our web page. The first one is
referring to an existing map. The second is configured inline.

```html
<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" type="text/css" href="http://dhis2-cdn.org/v215/ext/resources/css/ext-plugin-gray.css" />
  <script src="http://dhis2-cdn.org/v215/ext/ext-all.js"></script>
  <script src="https://maps.google.com/maps/api/js?sensor=false"></script>
  <script src="http://dhis2-cdn.org/v215/openlayers/OpenLayers.js"></script>
  <script src="http://dhis2-cdn.org/v215/plugin/map.js"></script>

  <script>
    var base = "https://play.dhis2.org/demo";

    // Login - if OK, call the setLinks function

    Ext.onReady( function() {
      Ext.Ajax.request({
        url: base + "dhis-web-commons-security/login.action",
        method: "POST",
        params: { j_username: "portal", j_password: "Portal123" },
        success: setLinks
      });
    });

    function setLinks() {
      DHIS.getMap({ url: base, el: "map1", id: "ytkZY3ChM6J" });

      DHIS.getMap({
        url: base,
        el: "map2",
        mapViews: [{
          columns: [{dimension: "in", items: [{id: "Uvn6LCg7dVU"}]}], // data
          rows: [{dimension: "ou", items: [{id: "LEVEL-3"}, {id: "ImspTQPwCqd"}]}], // organisation units,
          filters: [{dimension: "pe", items: [{id: "LAST_3_MONTHS"}]}], // period
          // All following options are optional
          classes: 7,
          colorLow: "02079c",
          colorHigh: "e5ecff",
          opacity: 0.9,
          legendSet: {id: "fqs276KXCXi"}
        }]
      });
    }
  </script>
</head>

<body>
  <div id="map1"></div>
  <div id="map2"></div>
</body>
</html>
```

Four files and Google Maps are included in the header section of the
HTML document. The first two files are the Ext JS JavaScript library (we
use the DHIS2 content delivery network in this case) and its stylesheet.
The third file is the OpenLayers JavaScript mapping framework
(<http://openlayers.org>) and finally we include the GIS map plug-in.
Make sure the path is pointing to your DHIS2 server
    installation.

    <link rel="stylesheet" type="text/css" href="http://dhis2-cdn.org/v215/ext/resources/css/ext-plugin-gray.css" />
    <script src="http://dhis2-cdn.org/v215/ext/ext-all.js"></script>
    <script src="https://maps.google.com/maps/api/js?sensor=false"></script>
    <script src="http://dhis2-cdn.org/v215/openlayers/OpenLayers.js"></script>
    <script src="http://dhis2-cdn.org/v215/plugin/map.js"></script>

To authenticate with the DHIS2 server we use the same approach as in the
previous section. In the header of the HTML document we include the
following Javascript inside a script element. The *setLinks* method will
be implemented later. Make sure the *base* variable is pointing to your
DHIS2 installation.

    Ext.onReady( function() {
      Ext.Ajax.request({
        url: base + "dhis-web-commons-security/login.action",
        method: "POST",
        params: { j_username: "portal", j_password: "Portal123" },
        success: setLinks
      });
    });

Now let us have a look at the various options for the GIS plug-in. Two
properties are required: *el* and *url* (please refer to the table
below). Now, if you want to refer to pre-defined maps already made in
the DHIS2 GIS it is sufficient to provide the additional *id* parameter.
If you instead want to configure a map dynamically you should omit the id
parameter and provide *mapViews* (layers) instead. They should be
configured with data dimensions inside a *columns* array, a *rows* array
and optionally a *filters* array instead.

A data dimension is defined as an object with a text property called
*dimension*. This property accepts the following values: *in*
(indicator), *de* (data element), *ds* (data set), *dc* (data element
operand), *pe* (period), *ou* (organisation unit) or the id of any
organisation unit group set or data element group set (can be found in
the web api). The data dimension also has an array property called
*items* which accepts objects with an *id* property.

To sum up, if you want to have a layer with e.g. "ANC 1 Coverage" in
your map you can make the following *columns* config:

```json
columns: [{
  dimension: "in", // could be "in", "de", "ds", "dc", "pe", "ou" or any dimension id
  items: [{id: "Uvn6LCg7dVU"}], // the id of ANC 1 Coverage
}]
```

<table>
<caption>GIS map plug-in configuration</caption>
<thead>
<tr class="header">
<th>Param</th>
<th>Type</th>
<th>Required</th>
<th>Options (default first)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>el</td>
<td>string</td>
<td>Yes</td>
<td></td>
<td>Identifier of the HTML element to render the map in your web page</td>
</tr>
<tr class="even">
<td>url</td>
<td>string</td>
<td>Yes</td>
<td></td>
<td>Base URL of the DHIS2 server</td>
</tr>
<tr class="odd">
<td>id</td>
<td>string</td>
<td>No</td>
<td></td>
<td>Identifier of a pre-defined map (favorite) in DHIS</td>
</tr>
<tr class="even">
<td>baseLayer</td>
<td>string/boolean</td>
<td>No</td>
<td>'gs', 'googlestreets' | 'gh', 'googlehybrid' | 'osm', 'openstreetmap' | false, null, 'none', 'off'</td>
<td>Show background map</td>
</tr>
<tr class="odd">
<td>hideLegend</td>
<td>boolean</td>
<td>No</td>
<td>false | true</td>
<td>Hide legend panel</td>
</tr>
<tr class="even">
<td>mapViews</td>
<td>array</td>
<td>Yes (if no id provided)</td>
<td></td>
<td>Array of layers</td>
</tr>
</tbody>
</table>

If no id is provided you must add map view objects with the following
config options:

<table>
<caption>Map plug-in configuration</caption>
<tbody>
<tr class="odd">
<td>layer</td>
<td>string</td>
<td>No</td>
<td>&quot;thematic1&quot; | &quot;thematic2&quot; | &quot;thematic3&quot; | &quot;thematic4&quot; | &quot;boundary&quot; | &quot;facility&quot; |</td>
<td>The layer to which the map view content should be added</td>
</tr>
<tr class="even">
<td>columns</td>
<td>array</td>
<td>Yes</td>
<td></td>
<td>Indicator, data element, data operand or data set (only one will be used)</td>
</tr>
<tr class="odd">
<td>rows</td>
<td>array</td>
<td>Yes</td>
<td></td>
<td>Organisation units (multiple allowed)</td>
</tr>
<tr class="even">
<td>filter</td>
<td>array</td>
<td>Yes</td>
<td></td>
<td>Period (only one will be used)</td>
</tr>
<tr class="odd">
<td>classes</td>
<td>integer</td>
<td>No</td>
<td>5 | 1-7</td>
<td>The number of automatic legend classes</td>
</tr>
<tr class="even">
<td>method</td>
<td>integer</td>
<td>No</td>
<td>2 | 3</td>
<td>Legend calculation method where 2 = equal intervals and 3 = equal counts</td>
</tr>
<tr class="odd">
<td>colorLow</td>
<td>string</td>
<td>No</td>
<td>&quot;ff0000&quot; (red) | Any hex color</td>
<td>The color representing the first automatic legend class</td>
</tr>
<tr class="even">
<td>colorHigh</td>
<td>string</td>
<td>No</td>
<td>&quot;00ff00&quot; (green) | Any hex color</td>
<td>The color representing the last automatic legend class</td>
</tr>
<tr class="odd">
<td>radiusLow</td>
<td>integer</td>
<td>No</td>
<td>5 | Any integer</td>
<td>Only applies for facilities (points) - radius of the point with lowest value</td>
</tr>
<tr class="even">
<td>radiusHigh</td>
<td>integer</td>
<td>No</td>
<td>15 | Any integer</td>
<td>Only applies for facilities (points) - radius of the point with highest value</td>
</tr>
<tr class="odd">
<td>opacity</td>
<td>double</td>
<td>No</td>
<td>0.8 | 0 - 1</td>
<td>Opacity/transparency of the layer content</td>
</tr>
<tr class="even">
<td>legendSet</td>
<td>object</td>
<td>No</td>
<td></td>
<td>Pre-defined legend set. Will override the automatic legend set.</td>
</tr>
<tr class="odd">
<td>labels</td>
<td>boolean/object</td>
<td>No</td>
<td>false | true | object properties: fontSize (integer), color (hex string), strong (boolean), italic (boolean)</td>
<td>Show labels on the map</td>
</tr>
<tr class="even">
<td>width</td>
<td>integer</td>
<td>No</td>
<td></td>
<td>Width of map</td>
</tr>
<tr class="odd">
<td>height</td>
<td>integer</td>
<td>No</td>
<td></td>
<td>Height of map</td>
</tr>
<tr class="even">
<td>userOrgUnit</td>
<td>string / array</td>
<td>No</td>
<td></td>
<td>Organisation unit identifiers, overrides organisation units associated with current user, single or array</td>
</tr>
</tbody>
</table>

We continue by adding one pre-defined and one dynamically configured map
to our HTML document. You can browse the list of available maps using
the Web API here: <http://play.dhis2.org/demo/api/33/maps>.

```javascript
function setLinks() {
  DHIS.getMap({ url: base, el: "map1", id: "ytkZY3ChM6J" });

  DHIS.getMap({
 url: base,
 el: "map2",
 mapViews: [
   columns: [ // Chart series
  columns: [{dimension: "in", items: [{id: "Uvn6LCg7dVU"}]}], // data
   ],
   rows: [ // Chart categories
  rows: [{dimension: "ou", items: [{id: "LEVEL-3"}, {id: "ImspTQPwCqd"}]}], // organisation units
   ],
   filters: [
  filters: [{dimension: "pe", items: [{id: "LAST_3_MONTHS"}]}], // period
   ],
   // All following options are optional
   classes: 7,
   colorLow: "02079c",
   colorHigh: "e5ecff",
   opacity: 0.9,
   legendSet: {id: "fqs276KXCXi"}
 ]
  });
}
```

Finally we include some *div* elements in the body section of the HTML
document with the identifiers referred to in the plug-in JavaScript.

```html
<div id="map1"></div>
<div id="map2"></div>
```

To see a complete working example please visit
<http://play.dhis2.org/portal/map.html>.



## Les vues SQL { #webapi_sql_views } 

<!--DHIS2-SECTION-ID:webapi_sql_views-->

La ressource des vues SQL vous permet de créer et d'extraire l'ensemble des résultats
de vues SQL. Les vues SQL peuvent être exécutées directement dans la base de données
et restituer l'ensemble des résultats par l'intermédiaire de la ressource Web API.

    /api/sqlViews

Les vues SQL sont utiles dans la création de vues de données qui peuvent être plus facilement 
construites avec SQL qu'en combinant les multiples objets de l'API 
Web. Par exemple, supposons qu'il nous a été demandé de fournir une vue de 
toutes les unités d'organisation avec leur noms, les noms des parents, le niveau et le nom de l'unité 
d'organisation, ainsi que les coordonnées répertoriées dans la base de données. La vue 
pourrait ressembler à ceci :

```sql
SELECT ou.name as orgunit, par.name as parent, ou.coordinates, ous.level, oul.name from organisationunit ou
INNER JOIN _orgunitstructure ous ON ou.organisationunitid = ous.organisationunitid
INNER JOIN organisationunit par ON ou.parentid = par.organisationunitid
INNER JOIN orgunitlevel oul ON ous.level = oul.level
WHERE ou.coordinates is not null
ORDER BY oul.level, par.name, ou.name
```

Nous allons utiliser *curl* pour exécuter d'abord la vue sur le serveur de DHIS2. Il s'agit 
essentiellement d'un processus de matérialisation, qui garantit que les données les plus 
récentes sont disponibles dans la vue SQL lorsqu'elles sont récupérées 
sur le serveur. Vous pouvez d'abord rechercher la vue SQL dans la 
ressource api/sqlViews, puis faire un POST à l'aide de la commande suivante :

```bash
curl "https://play.dhis2.org/demo/api/sqlViews/dI68mLkP1wN/execute" -X POST -u admin:district
```

The next step in the process is the retrieval of the data.The basic
structure of the URL is as follows

    http://{server}/api/sqlViews/{id}/data(.csv)

The `{server}` parameter should be replaced with your own server. The
next part of the URL `/api/sqlViews/` should be appended with the
specific SQL view identifier. Append either `data` for XML data or
`data.csv` for comma delimited values. Support response formats are
json, xml, csv, xls, html and html+css. As an example, the following
command would retrieve XML data for the SQL view defined above.

```bash
curl "https://play.dhis2.org/demo/api/sqlViews/dI68mLkP1wN/data.csv" -u admin:district
```

Il existe trois types de vues SQL :

  - *Vues SQL:* Vues SQL standard.

  - *Vue SQL matérialisée:* Les vues SQL matérialisées, c'est-à-dire 
    écrites sur le disque, doivent être mises à jour pour refléter les modifications apportées aux 
    tables sous-jacentes. Elles prennent en charge les critères permettant de filtrer l'ensemble des résultats.

  - *Requêtes SQL:* Les requêtes SQL simples. Elles prennent en charge les variables en ligne pour 
    les requêtes personnalisées.

### Critère { #webapi_sql_view_criteria } 

<!--DHIS2-SECTION-ID:webapi_sql_view_criteria-->

Vous pouvez effectuer un filtrage simple sur les colonnes de l'ensemble de résultats en
ajoutant des paramètres de requête *critère* à l'URL, en utilisant les noms de colonnes
et les valeurs de filtrage séparées par les colonnes en tant que valeurs de paramètre, au 
format suivant :

    /api/sqlViews/{id}/data?criteria=col1:value1&criteria=col2:value2

As an example, to filter the SQL view result set above to only return
organisation units at level 4 you can use the following
    URL:

    https://play.dhis2.org/demo/api/sqlViews/dI68mLkP1wN/data.csv?criteria=level:4

### Les variables { #webapi_sql_view_variables } 

<!--DHIS2-SECTION-ID:webapi_sql_view_variables-->

Les vues SQL supportent la substitution de variables. La substitution de variables n'est 
disponible que pour les vues SQL de type *requête*, c'est-à-dire les vues SQL qui ne sont pas 
créées dans la base de données mais simplement exécutées comme des requêtes SQL normales. 
Les variables peuvent être insérées directement dans la requête SQL et doivent être dans 
ce format :

    ${variable-key}

Par exemple, une requête SQL qui récupère tous les éléments de données d'un 
type de valeur donné, où le type de valeur est défini par une variable, peut ressembler 
à ceci :

    select * from dataelement where valuetype = '${valueType}';

Ces variables peuvent ensuite être fournies dans le cadre de l'URL lorsqu'elles sont demandées par l'intermédiaire de la ressource API Web *sqlViews*. Les variables peuvent être fournies dans le format suivant :

    /api/sqlViews/{id}/data?var=key1:value1&var=key2:value2

Un exemple de requête correspondant à l'exemple ci-dessus peut se présenter comme suit :

    /api/sqlViews/dI68mLkP1wN/data.json?var=valueType:int

La variable *valueType* sera remplacée par la valeur *int* et 
la requête renverra des éléments de données de type int.

Le paramètre variable ne doit contenir que des caractères alphanumériques. Les 
variables doivent contenir uniquement des caractères alphanumériques, des tirets, des traits 
de soulignement et des espaces.

Les vues SQL de type *query* prennent également en charge deux variables définies par le système qui permettent à la requête d'accéder à des informations sur l'utilisateur qui exécute la vue :

| variable | signifie |
| -------- | ----- |
| ${_current_user_id} | l'identifiant de l'utilisateur dans la base de données |
| ${_current_username} | le nom d'utilisateur de l'utilisateur |

Les valeurs de ces variables ne peuvent pas être fournies dans le cadre de l'URL. Elles sont toujours remplies d'informations sur l'utilisateur.

Par exemple, la vue SQL suivante de type *requête* affiche toutes les unités d'organisation affectées à l'utilisateur :

```sql
    select ou.path, ou.name
    from organisationunit ou_user
    join organisationunit ou on ou.path like ou_user.path || '%'
    join usermembership um on um.organisationunitid = ou_user.organisationunitid
    where um.userinfoid = ${_current_user_id}
    order by ou.path
```

### Filtrage { #webapi_sql_view_filtering } 

<!--DHIS2-SECTION-ID:webapi_sql_view_filtering-->

The SQL view api supports data filtering, equal to the [metadata object
filter](#webapi_metadata_object_filter). For a complete list of filter
operators you can look at the documentation for [metadata object
filter](#webapi_metadata_object_filter).

To use filters, simply add them as parameters at the end of the request
url for your SQL view like
    this:

    /api/sqlViews/w3UxFykyHFy/data.json?filter=orgunit_level:eq:2&filter=orgunit_name:ilike:bo

This request will return a result including org units with "bo" in the
name and which has org unit level 2.

The following example will return all org units with `orgunit_level` 2 or
4:

    /api/sqlViews/w3UxFykyHFy/data.json?filter=orgunit_level:in:[2,4]

And last, an example to return all org units that does not start with
"Bo"

    /api/sqlViews/w3UxFykyHFy/data.json?filter=orgunit_name:!like:Bo

## Tableaux de bord { #webapi_dashboard } 

<!--DHIS2-SECTION-ID:webapi_dashboard-->

Le tableau de bord est conçu pour vous donner un aperçu de plusieurs éléments 
analytiques tels que des cartes, des graphiques, des tableaux croisés dynamiques et des rapports qui, ensemble, 
peuvent fournir un aperçu complet de vos données. Les tableaux de bord sont disponibles 
dans l'API Web via la ressource *tableaux de bord*. Un tableau de bord contient une 
liste d'*éléments* de tableau de bord. Un élément peut représenter une ressource unique, comme 
un graphique, une carte ou un tableau de rapport, ou représenter une liste de liens vers des ressources 
analytiques, comme des rapports, des ressources, des rapports tabulaires et des utilisateurs. Un 
élément de tableau de bord peut contenir jusqu'à huit liens. En règle générale, un client de 
tableau de bord peut choisir de visualiser les éléments à objet unique directement dans une 
interface utilisateur, tout en rendant les éléments à objets multiples sous forme de liens 
cliquables.

    /api/tableau de bord

### Parcourir les tableaux de bord { #webapi_browsing_dashboards } 

<!--DHIS2-SECTION-ID:webapi_browsing_dashboards-->

Pour obtenir une liste de vos tableaux de bord avec des informations de base telles que 
l'identifiant, le nom et le lien au format JSON, vous pouvez envoyer une requête *GET* à 
l'URL suivante :

    /api/dashboards.json

La ressource Tableaux de bord fournit une liste de tableaux de bord. N'oubliez pas que 
l'objet tableau de bord est partagé et que la liste sera donc affectée par 
l'utilisateur actuellement authentifié. Vous pouvez obtenir plus d'informations sur un 
tableau de bord spécifique en suivant son lien, comme suit :

    /api/dashboards/vQFhmLJU5sK.json

Un tableau de bord contient des informations telles que le nom et la date de création, ainsi 
qu'un tableau d'éléments du tableau de bord. La réponse au format JSON ressemblera 
à cette réponse (certaines informations ont été supprimées par souci de 
concision).

```json
{
  "lastUpdated" : "2013-10-15T18:17:34.084+0000",
  "id": "vQFhmLJU5sK",
  "created": "2013-09-08T20:55:58.060+0000",
  "name": "Mother and Child Health",
  "href": "https://play.dhis2.org/demo/api/dashboards/vQFhmLJU5sK",
  "publicAccess": "--------",
  "externalAccess": false,
  "itemCount": 17,
  "displayName": "Mother and Child Health",
  "access": {
    "update": true,
    "externalize": true,
    "delete": true,
    "write": true,
    "read": true,
    "manage": true
  },
  "user": {
    "id": "xE7jOejl9FI",
    "name": "John Traore",
    "created": "2013-04-18T15:15:08.407+0000",
    "lastUpdated": "2014-12-05T03:50:04.148+0000",
    "href": "https://play.dhis2.org/demo/api/users/xE7jOejl9FI"
  },
  "dashboardItems": [{
    "id": "bu1IAnPFa9H",
    "created": "2013-09-09T12:12:58.095+0000",
    "lastUpdated": "2013-09-09T12:12:58.095+0000"
    }, {
    "id": "ppFEJmWWDa1",
    "created": "2013-09-10T13:57:02.480+0000",
    "lastUpdated": "2013-09-10T13:57:02.480+0000"
  }],
  "userGroupAccesses": []
}
```

Il est possible d'obtenir une réponse plus personnalisée en spécifiant des champs 
particuliers dans la demande. Un exemple est fourni ci-dessous, qui renverrait des 
informations plus détaillées sur chaque objet du tableau de bord d'un utilisateur.

    /api/dashboards/vQFhmLJU5sK/?fields=:all,dashboardItems[:all]

### Rechercher des tableaux de bord { #webapi_searching_dasboards } 

<!--DHIS2-SECTION-ID:webapi_searching_dasboards-->

When a user is building a dashboard it is convenient
to be able to search for various analytical resources using the
*/dashboards/q* resource. This resource lets you search for matches on
the name property of the following objects: charts, maps, report tables,
users, reports and resources. You can do a search by making a *GET*
request on the following resource URL pattern, where my-query should be
replaced by the preferred search query:

    /api/dashboards/q/my-query.json

Par exemple, cette requête :

    /api/dashboards/q/ma?count=6&maxCount=20&max=CHART&max=MAP

La recherche portera sur les éléments suivants :

* Le nom de l'objet analytique contient la chaîne « ma »
* Renvoi jusqu'à 6 exemplaires de chaque type
* For CHART and MAP types, return up to 20 items

<table>
<caption>dashboards/q query parameters</caption>
<colgroup>
<col style="width: 19%" />
<col style="width: 44%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr class="header">
<th>Query parameter</th>
<th>Description</th>
<th>Type</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>count</td>
<td>The number of items of each type to return</td>
<td>Positive integer</td>
<td>6</td>
</tr>
<tr class="odd">
<td>maxCount</td>
<td>The number of items of max types to return</td>
<td>Positive integer</td>
<td>25</td>
</tr>
<tr class="even">
<td>max</td>
<td>The type to return the maxCount for</td>
<td>String [CHART|MAP|REPORT_TABLE|USER|REPORT|RESOURCE|VISUALIZATION]</td>
<td>N/A</td>
</tr>
</tbody>
</table>

Les formats de réponse JSON et XML sont pris en charge. La réponse au format JSON 
contiendra les références aux ressources correspondantes et le nombre de 
correspondances trouvées au total et pour chaque type de ressource. Elle 
ressemblera à ceci :

```json
{
  "charts": [{
    "name": "ANC: 1-3 dropout rate Yearly",
    "id": "LW0O27b7TdD"
  }, {
    "name": "ANC: 1 and 3 coverage Yearly",
    "id": "UlfTKWZWV4u"
  }, {
    "name": "ANC: 1st and 3rd trends Monthly",
    "id": "gnROK20DfAA"
  }],
  "visualizations": [{
    "name": "ANC: ANC 3 Visits Cumulative Numbers",
    "id": "arf9OiyV7df",
    "type": "LINE"
  }, {
    "name": "ANC: 1st and 2rd trends Monthly",
    "id": "jkf6OiyV7el",
    "type": "PIVOT_TABLE"
  }],
  "maps": [{
    "name": "ANC: 1st visit at facility (fixed) 2013",
    "id": "YOEGBvxjAY0"
  }, {
    "name": "ANC: 3rd visit coverage 2014 by district",
    "id": "ytkZY3ChM6J"
  }],
  "reportTables": [{
    "name": "ANC: ANC 1 Visits Cumulative Numbers",
    "id": "tWg9OiyV7mu"
  }],
  "reports": [{
    "name": "ANC: 1st Visit Cumulative Chart",
    "id": "Kvg1AhYHM8Q"
  }, {
    "name": "ANC: Coverages This Year",
    "id": "qYVNH1wkZR0"
  }],
  "searchCount": 8,
  "chartCount": 3,
  "mapCount": 2,
  "reportTableCount": 1,
  "reportCount": 2,
  "userCount": 0,
  "patientTabularReportCount": 0,
  "resourceCount": 0
}
```

### Créer, mettre à jour et supprimer des tableaux de bords{ #webapi_creating_updating_removing_dashboards } 

<!--DHIS2-SECTION-ID:webapi_creating_updating_removing_dashboards-->

La création, la mise à jour et la suppression des tableaux de bord suivent la sémantique REST 
standard. Pour créer un nouveau tableau de bord, vous pouvez faire une requête *POST* 
à la ressource `/api/dashboards`. Du point de vue du consommateur, 
il peut être pratique de créer d'abord un tableau de bord et d'y ajouter ensuite des 
éléments. Les formats JSON et XML sont supportés pour la charge de la requête. Pour 
créer un tableau de bord avec le nom « Mon tableau de bord », vous pouvez utiliser une 
charge JSON comme celle-ci :

    {
      "nom": "Mon tableau de bord"
    }

Pour mettre à jour, par exemple renommer, un tableau de bord, vous pouvez faire une 
demande *PUT* avec une charge similaire à la même ressource api/dashboards.

To remove a dashboard, you can make a *DELETE* (supprimer) request to the specific
dashboard resource similar to this:

    /api/dashboards/vQFhmLJU5sK

### Ajouter, déplacer et supprimer des éléments et du contenu du tableau de bord { #webapi_adding_moving_removing_dashboard_items } 

<!--DHIS2-SECTION-ID:webapi_adding_moving_removing_dashboard_items-->

In order to add dashboard items a consumer can use the
`/api/dashboards/<dashboard-id>/items/content` resource, where
\<dashboard-id\> should be replaced by the relevant dashboard
identifier. The request must use the *POST* method. The URL syntax and
parameters are described in detail in the following table.

<table>
<caption>Items content parameters</caption>
<colgroup>
<col style="width: 19%" />
<col style="width: 44%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr class="header">
<th>Query parameter</th>
<th>Description</th>
<th>Options</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>type</td>
<td>Type of the resource to be represented by the dashboard item</td>
<td>chart | visualization | map | reportTable | users | reports | reportTables | resources | patientTabularReports | app</td>
</tr>
<tr class="even">
<td>id</td>
<td>Identifier of the resource to be represented by the dashboard item</td>
<td>Resource identifier</td>
</tr>
</tbody>
</table>

A *POST* request URL for adding a chart to a specific dashboard could
look like this, where the last id query parameter value is the chart
resource
    identifier:

    /api/dashboards/vQFhmLJU5sK/items/content?type=chart&id=LW0O27b7TdD

When adding resource of type map, chart, report table and app, the API
will create and add a new item to the dashboard. When adding a resource
of type users, reports, report tables and resources, the API will try to
add the resource to an existing dashboard item of the same type. If no
item of same type or no item of same type with less than eight resources
associated with it exists, the API will create a new dashboard item and
add the resource to it.

Pour déplacer un élément du tableau de bord vers une nouvelle position dans la liste des 
éléments du tableau de bord, un utilisateur peut envoyer une requête *POST* à 
l'URL suivante, où `<dashboard-id>` doit être remplacé par 
l'identifiant du tableau de bord, `<item-id>` doit être remplacé par 
l'identifiant de l'élément du tableau de bord et `<index>` doit être remplacé par la 
nouvelle position de l'élément dans le tableau de bord, où l'index est 
égal à zéro :

    /api/dashboards/<dashboard-id>/items/<item-id>/position/<index>

Pour supprimer complètement un élément d'un tableau de bord spécifique, un 
utilisateur peut envoyer une requête *DELETE* à l'URL de la ressource ci-dessous, où 
`<dashboard-id>` doit être remplacé par l'identifiant du tableau de bord 
et `<item-id>` par l'identifiant de l'élément du tableau de 
bord. Les identifiants des éléments du tableau de bord peuvent être récupérés par le biais 
d'une requête GET à l'URL de la ressource tableau de bord.

    /api/dashboards/<dashboard-id>/items/<item-id>

Pour supprimer une ressource de contenu spécifique dans un élément de tableau de bord, un utilisateur 
peut envoyer une requête *DELETE* à l'URL de ressource ci-dessous, où 
`<content-resource-id>` doit être remplacé par l'identifiant d'une 
ressource associée à l'élément de tableau de bord, par exemple l'identifiant 
d'un rapport ou d'un utilisateur. Par exemple, cela peut être utilisé pour supprimer un seul 
rapport d'un élément de tableau de bord de type rapports, plutôt que de supprimer 
complètement l'élément du tableau de bord :

    /api/dashboards/<dashboard-id>/items/<item-id>/content/<content-resource-id>

## Visualisation { #webapi_visualization } 

<!--DHIS2-SECTION-ID:webapi_visualization-->

L'API de visualisation est conçue pour aider les clients à interagir avec les graphiques et les tableaux croisés dynamiques/rapports. Les endpoints de cette API sont utilisés par l'application de visualisation des données qui permet la création, la configuration et la gestion des graphiques et des tableaux croisés dynamiques sur la base des définitions du client. L'idée principale est de permettre aux clients et aux utilisateurs de disposer d'une API unique et centralisée fournissant tous les types de graphiques et de tableaux croisés dynamiques ainsi que des paramètres et une configuration spécifiques pour chaque type de visualisation.

This API was introduced with the expectation to unify both `charts` and `reportTables` APIs and entirely replace them in favour of the `visualizations` API (which means that the usage of `charts` and `reportTables` APIs should be avoided). In summary, the following resources/APIs:

    /api/charts, /api/reportTables

*are being replaced by*

    /api/visualizations

> **Note**
>
> New applications and clients should avoid using the `charts` and `reportTables` APIs because they are deprecated. Use the `visualizations` API instead.

Un objet de visualisation est composé de nombreux attributs (certains sont liés aux graphiques et d'autres aux tableaux croisés dynamiques), mais les plus importants d'entre eux, qui reflètent les informations essentielles de l'objet, sont les suivants :*  "id" (identifiant) , "name" (nom) , "type" (type) , "dataDimensionItems" (éléments de données de dimensions) , "columns" (colonnes) , "rows" (lignes) et "filters" (filtres) .*

Le endpoint racine de l'API est `/api/visualizations`, et la liste des attributs et éléments actuels est décrite dans le tableau ci-dessous.

<table>
<caption>Visualization attributes</caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>id</td>
<td>The unique identifier.</td>
</tr>
<tr class="even">
<td>code</td>
<td>A custom code to identify the Visualization.</td>
</tr>
<tr class="odd">
<td>name</td>
<td>The name of the Visualization</td>
</tr>
<tr class="even">
<td>type</td>
<td>The type of the Visualization. The valid types are: COLUMN, STACKED_COLUMN, BAR, STACKED_BAR, LINE, AREA, PIE, RADAR, GAUGE, YEAR_OVER_YEAR_LINE YEAR_OVER_YEAR_COLUMN, SINGLE_VALUE, PIVOT_TABLE.</td>
</tr>
<tr class="odd">
<td>title</td>
<td>A custom title.</td>
</tr>
<tr class="even">
<td>subtitle</td>
<td>A custom subtitle.</td>
</tr>
<tr class="odd">
<td>description</td>
<td>Defines a custom description for the Visualization.</td>
</tr>
<tr class="even">
<td>created</td>
<td>The date/time of the Visualization creation.</td>
</tr>
<tr class="odd">
<td>startDate</td>
<td>The beginning date used during the filtering.</td>
</tr>
<tr class="even">
<td>endDate</td>
<td>The ending date used during the filtering.</td>
</tr>
<tr class="odd">
<td>sortOrder</td>
<td>The sorting order of this Visualization. Integer value.</td>
</tr>
<tr class="even">
<td>user</td>
<td>An object representing the creator of the Visualization.</td>
</tr>
<tr class="odd">
<td>publicAccess</td>
<td>Sets the permissions for public access.</td>
</tr>
<tr class="even">
<td>displayDensity</td>
<td>The display density of the text.</td>
</tr>
<tr class="odd">
<td>fontSize</td>
<td>The font size of the text.</td>
</tr>
<tr class="even">
<td>fontStyle</td>
<td>Custom font styles for: visualizationTitle, visualizationSubtitle, horizontalAxisTitle, verticalAxisTitle, targetLineLabel, baseLineLabel, seriesAxisLabel, categoryAxisLabel, legend.</td>
</tr>
<tr class="odd">
<td>relativePeriods</td>
<td>An object representing the relative periods used in the analytics query.</td>
</tr>
<tr class="even">
<td>legendSet</td>
<td>An object representing the definitions for the legend.</td>
</tr>
<tr class="odd">
<td>legendDisplayStyle</td>
<td>The legend's display style. It can be: FILL or TEXT.</td>
</tr>
<tr class="even">
<td>legendDisplayStrategy</td>
<td>The legend's display style. It can be: FIXED or BY_DATA_ITEM.</td>
</tr>
<tr class="odd">
<td>aggregationType</td>
<td>Determines how the values in the pivot table are aggregated. Valid options: SUM, AVERAGE, AVERAGE_SUM_ORG_UNIT, LAST, LAST_AVERAGE_ORG_UNIT, FIRST, FIRST_AVERAGE_ORG_UNIT, COUNT, STDDEV, VARIANCE, MIN, MAX, NONE, CUSTOM or DEFAULT.</td>
</tr>
<tr class="even">
<td>regressionType</td>
<td>A valid regression type: NONE, LINEAR, POLYNOMIAL or LOESS.</td>
</tr>
<tr class="odd">
<td>targetLineValue</td>
<td>The chart target line. Accepts a Double type.</td>
</tr>
<tr class="even">
<td>targetLineLabel</td>
<td>The chart target line label.</td>
</tr>
<tr class="odd">
<td>rangeAxisLabel</td>
<td>The chart vertical axis (y) label/title.</td>
</tr>
<tr class="even">
<td>domainAxisLabel</td>
<td>The chart horizontal axis (x) label/title.</td>
</tr>
<tr class="odd">
<td>rangeAxisMaxValue</td>
<td>The chart axis maximum value. Values outside of the range will not be displayed.</td>
</tr>
<tr class="even">
<td>rangeAxisMinValue</td>
<td>The chart axis minimum value. Values outside of the range will not be displayed.</td>
</tr>
<tr class="odd">
<td>rangeAxisSteps</td>
<td>The number of axis steps between the minimum and maximum values.</td>
</tr>
<tr class="even">
<td>rangeAxisDecimals</td>
<td>The number of decimals for the axes values.</td>
</tr>
<tr class="odd">
<td>baseLineValue</td>
<td>A chart baseline value.</td>
</tr>
<tr class="even">
<td>baseLineLabel</td>
<td>A chart baseline label.</td>
</tr>
<tr class="odd">
<td>digitGroupSeparator</td>
<td>The digit group separator. Valid values: COMMA, SPACE or NONE.</td>
</tr>
<tr class="even">
<td>topLimit</td>
<td>The top limit set for the Pivot table.</td>
</tr>
<tr class="odd">
<td>measureCriteria</td>
<td>Describes the criteria applied to this measure.</td>
</tr>
<tr class="even">
<td>percentStackedValues</td>
<td>Uses stacked values or not. More likely to be applied for graphics/charts. Boolean value.</td>
</tr>
<tr class="odd">
<td>noSpaceBetweenColumns</td>
<td>Show/hide space between columns. Boolean value.</td>
</tr>
<tr class="even">
<td>regression</td>
<td>Indicates whether the Visualization contains regression columns. More likely to be applicable to Pivot/Report. Boolean value.</td>
</tr>
<tr class="odd">
<td>externalAccess</td>
<td>Indicates whether the Visualization is available as external read-only. Boolean value.</td>
</tr>
<tr class="even">
<td>userOrganisationUnit</td>
<td>Indicates if the user has an organisation unit. Boolean value.</td>
</tr>
<tr class="odd">
<td>userOrganisationUnitChildren</td>
<td>Indicates if the user has a children organisation unit. Boolean value.</td>
</tr>
<tr class="even">
<td>userOrganisationUnitGrandChildren</td>
<td>Indicates if the user has a grand children organisation unit . Boolean value.</td>
</tr>
<tr class="odd">
<td>reportingParams</td>
<td>Object used to define boolean attributes related to reporting.</td>
</tr>
<tr class="even">
<td>rowTotals</td>
<td>Displays (or not) the row totals. Boolean value.</td>
</tr>
<tr class="odd">
<td>colTotals</td>
<td>Displays (or not) the columns totals. Boolean value.</td>
</tr>
<tr class="even">
<td>rowSubTotals</td>
<td>Displays (or not) the row sub-totals. Boolean value.</td>
</tr>
<tr class="odd">
<td>colSubTotals</td>
<td>Displays (or not) the columns sub-totals. Boolean value.</td>
</tr>
<tr class="even">
<td>cumulativeValues</td>
<td>Indicates whether the visualization is using cumulative values. Boolean value.</td>
</tr>
<tr class="odd">
<td>hideEmptyColumns</td>
<td>Indicates whether to hide columns with no data values. Boolean value.</td>
</tr>
<tr class="even">
<td>hideEmptyRows</td>
<td>Indicates whether to hide rows with no data values. Boolean value.</td>
</tr>
<tr class="odd">
<td>completedOnly</td>
<td>Indicates whether to hide columns with no data values. Boolean value.</td>
</tr>
<tr class="even">
<td>skipRounding</td>
<td>Apply or not rounding. Boolean value.</td>
</tr>
<tr class="odd">
<td>showDimensionLabels</td>
<td>Shows the dimension labels or not. Boolean value.</td>
</tr>
<tr class="even">
<td>hideTitle</td>
<td>Hides the title or not. Boolean value.</td>
</tr>
<tr class="odd">
<td>hideSubtitle</td>
<td>Hides the subtitle or not. Boolean value.</td>
</tr>
<tr class="even">
<td>hideLegend</td>
<td>Show/hide the legend. Very likely to be used by charts. Boolean value.</td>
</tr>
<tr class="odd">
<td>showHierarchy</td>
<td>Displays (or not) the organisation unit hierarchy names. Boolean value.</td>
</tr>
<tr class="even">
<td>showData</td>
<td>Used by charts to hide or not data/values within the rendered model. Boolean value.</td>
</tr>
<tr class="odd">
<td>lastUpdatedBy</td>
<td>Object that represents the user that applied the last changes to the Visualization.</td>
</tr>
<tr class="even">
<td>lastUpdated</td>
<td>The date/time of the last time the Visualization was changed.</td>
</tr>
<tr class="odd">
<td>favorites</td>
<td>List of user ids who have marked this object as a favorite.</td>
</tr>
<tr class="even">
<td>subscribers</td>
<td>List of user ids who have subscribed to this Visualization.</td>
</tr>
<tr class="odd">
<td>translations</td>
<td>Set of available object translation, normally filtered by locale.</td>
</tr>
</tbody>
</table>

### Récupération des visualisations { #webapi_visualization_retrieving_visualizations } 

<!--DHIS2-SECTION-ID:webapi_visualization_retrieving_visualizations-->

Pour récupérer une liste de toutes les visualisations existantes, au format JSON, avec quelques informations de base (y compris l'identifiant, le nom et la pagination), vous pouvez faire une requête `GET` à l'URL ci-dessous. Vous devriez voir une liste de toutes les visualisations publiques/partagées ainsi que vos visualisations privées.

    GET /api/visualizations.json

Si vous souhaitez extraire la définition JSON d'une visualisation spécifique, vous pouvez ajouter son identifiant respectif à l'URL :

    GET /api/visualizations/hQxZGXqnLS9.json

La représentation suivante est un exemple de réponse au format JSON (par souci de concision, certaines informations ont été supprimées). Pour obtenir le schéma complet, veuillez utiliser `GET /api/schemas/visualization`.

```json
{
  "lastUpdated": "2020-02-06T11:57:09.678",
  "href": "http://my-domain/dhis/api/visualizations/hQxZGXqnLS9",
  "id": "hQxZGXqnLS9",
  "created": "2017-05-19T17:22:00.785",
  "name": "ANC: ANC 1st visits last 12 months cumulative values",
  "publicAccess": "rw------",
  "userOrganisationUnitChildren": false,
  "type": "LINE",
  "access": {},
  "reportingParams": {
    "parentOrganisationUnit": false,
    "reportingPeriod": false,
    "organisationUnit": false,
    "grandParentOrganisationUnit": false
  },
  "dataElementGroupSetDimensions": [],
  "attributeDimensions": [],
  "yearlySeries": [],
  "filterDimensions": [
    "dx"
  ],
  "columns": [
    {
      "id": "ou"
    }
  ],
  "dataElementDimensions": [],
  "categoryDimensions": [],
  "rowDimensions": [
    "pe"
  ],
  "columnDimensions": [
    "ou"
  ],
  "dataDimensionItems": [
    {
      "dataDimensionItemType": "DATA_ELEMENT",
      "dataElement": {
        "id": "fbfJHSPpUQD"
      }
    }
  ],
  "filters": [
    {
      "id": "dx"
    }
  ],
  "rows": [
    {
      "id": "pe"
    }
  ]
}
```
Une réponse plus personnalisée peut être obtenue en spécifiant, dans l'URL, les champs que vous souhaitez extraire. Par exemple:

    GET /api/visualizations/hQxZGXqnLS9.json?fields=interpretations

renvoie

```json
{
  "interpretations": [
    {
      "id": "Lfr8I2RPU0C"
    },
    {
      "id": "JuwgdJlJPGb"
    },
    {
      "id": "WAoU2rSpyZp"
    }
  ]
}
```

Comme on peut le voir, le `GET` ci-dessus ne renverra que les interprétations liées à l'identifiant donné (dans ce cas `hQxZGXqnLS9`).

### Créer, mettre à jour et supprimer des visualisations { #webapi_visualization_add_update_remove_visualizations } 

<!--DHIS2-SECTION-ID:webapi_visualization_add_update_remove_visualizations-->

Ces opérations suivent la sémantique standard *REST*. Une nouvelle visualisation peut être créée par une requête `POST` à la ressource `/api/visualisations` avec une charge JSON valide. Un exemple de charge pourrait être :

```json
{
  "columns": [
    {
      "dimension": "J5jldMd8OHv",
      "items": [
        {
          "name": "CHP",
          "id": "uYxK4wmcPqA",
          "displayName": "CHP",
          "displayShortName": "CHP",
          "dimensionItemType": "ORGANISATION_UNIT_GROUP"
        },
        {
          "name": "Hospital",
          "id": "tDZVQ1WtwpA",
          "displayName": "Hospital",
          "displayShortName": "Hospital",
          "dimensionItemType": "ORGANISATION_UNIT_GROUP"
        }
      ]
    }
  ],
  "rows": [
    {
      "dimension": "SooXFOUnciJ",
      "items": [
        {
          "name": "DOD",
          "id": "B0bjKC0szQX",
          "displayName": "DOD",
          "displayShortName": "DOD",
          "dimensionItemType": "CATEGORY_OPTION_GROUP"
        },
        {
          "name": "CDC",
          "id": "OK2Nr4wdfrZ",
          "displayName": "CDC",
          "displayShortName": "CDC",
          "dimensionItemType": "CATEGORY_OPTION_GROUP"
        }
      ]
    }
  ],
  "filters": [
    {
      "dimension": "ou",
      "items": [
        {
          "name": "Sierra Leone",
          "id": "ImspTQPwCqd",
          "displayName": "Sierra Leone",
          "displayShortName": "Sierra Leone",
          "dimensionItemType": "ORGANISATION_UNIT"
        },
        {
          "name": "LEVEL-1",
          "id": "LEVEL-H1KlN4QIauv",
          "displayName": "LEVEL-1"
        }
      ]
    }
  ],
  "name": "HIV Cases Monthly",
  "description": "Cases of HIV across the months",
  "category": "XY1vwCQskjX",
  "showDimensionLabels": true,
  "hideEmptyRows": true,
  "hideEmptyColumns": true,
  "skipRounding": true,
  "aggregationType": "SUM",
  "regressionType": "LINEAR",
  "type": "PIVOT_TABLE",
  "numberType": "VALUE",
  "measureCriteria": "Some criteria",
  "showHierarchy": true,
  "completedOnly": true,
  "displayDensity": "NORMAL",
  "fontSize": "NORMAL",
  "digitGroupSeparator": "SPACE",
  "legendDisplayStyle": "FILL",
  "legendDisplayStrategy": "FIXED",
  "hideEmptyRowItems": "BEFORE_FIRST_AFTER_LAST",
  "regression": false,
  "cumulative": true,
  "sortOrder": 1,
  "topLimit": 2,
  "rowTotals": true,
  "colTotals": true,
  "hideTitle": true,
  "hideSubtitle": true,
  "hideLegend": true,
  "showData": true,
  "baseLineLabel": "A base label",
  "targetLineLabel": "A target label",
  "targetLineValue": 45.5,
  "baseLineValue": 19.99,
  "percentStackedValues": true,
  "noSpaceBetweenColumns": true,
  "rowSubTotals": true,
  "colSubTotals": true,
  "domainAxisLabel": "A domain axis label",
  "rangeAxisLabel": "A range axis label",
  "rangeAxisMaxValue": 123.65,
  "rangeAxisMinValue": 33.89,
  "rangeAxisSteps": 5,
  "rangeAxisDecimals": 10,
  "userOrgUnitType": "TEI_SEARCH",
  "externalAccess": false,
  "publicAccess": "--------",
  "reportingParams": {
    "reportingPeriod": true,
    "organisationUnit": true,
    "parentOrganisationUnit": true,
    "grandParentOrganisationUnit": true
  },
  "parentGraphMap": {
    "ImspTQPwCqd": ""
  },
  "access": {
    "read": true,
    "update": true,
    "externalize": true,
    "delete": false,
    "write": true,
    "manage": false
  },
  "optionalAxes": [
    {
      "dimensionalItem": "fbfJHSPpUQD",
      "axis": 1
    },
    {
      "dimensionalItem": "cYeuwXTCPkU",
      "axis": 2
    }
  ],
  "relativePeriods": {
    "thisYear": false,
    "quartersLastYear": true,
    "last52Weeks": false,
    "thisWeek": false,
    "lastMonth": false,
    "last14Days": false,
    "biMonthsThisYear": false,
    "monthsThisYear": false,
    "last2SixMonths": false,
    "yesterday": false,
    "thisQuarter": false,
    "last12Months": false,
    "last5FinancialYears": false,
    "thisSixMonth": false,
    "lastQuarter": false,
    "thisFinancialYear": false,
    "last4Weeks": false,
    "last3Months": false,
    "thisDay": false,
    "thisMonth": false,
    "last5Years": false,
    "last6BiMonths": false,
    "last4BiWeeks": false,
    "lastFinancialYear": false,
    "lastBiWeek": false,
    "weeksThisYear": false,
    "last6Months": false,
    "last3Days": false,
    "quartersThisYear": false,
    "monthsLastYear": false,
    "lastWeek": false,
    "last7Days": false,
    "thisBimonth": false,
    "lastBimonth": false,
    "lastSixMonth": false,
    "thisBiWeek": false,
    "lastYear": false,
    "last12Weeks": false,
    "last4Quarters": false
  },
  "user": {},
  "yearlySeries": [
    "THIS_YEAR"
  ],
  "userGroupAccesses": [
    {
      "access": "rwx-----",
      "userGroupUid": "ZoHNWQajIoe",
      "displayName": "Bo District M&E officers",
      "id": "ZoHNWQajIoe"
    }
  ],
  "userAccesses": [
    {
      "access": "--------",
      "displayName": "John Barnes",
      "id": "DXyJmlo9rge",
      "userUid": "DXyJmlo9rge"
    }
  ],
  "legendSet": {
    "name": "Death rate up",
    "id": "ham2eIDJ9k6",
    "legends": [
      {
        "startValue": 1,
        "endValue": 2,
        "color": "red",
        "image": "some-image"
      },
      {
        "startValue": 2,
        "endValue": 3,
        "color": "blue",
        "image": "other-image"
      }
    ]
  },
  "fontStyle": {
    "visualizationTitle": {
      "font": "VERDANA",
      "fontSize": 16,
      "bold": true,
      "italic": false,
      "underline": false,
      "textColor": "#3a3a3a",
      "textAlign": "LEFT"
    },
    "horizontalAxisTitle": {
      "font": "ROBOTO",
      "fontSize": 12,
      "bold": false,
      "italic": true,
      "underline": false,
      "textColor": "#2a2a2a",
      "textAlign": "CENTER"
    },
    "categoryAxisLabel": {
      "font": "ROBOTO",
      "fontSize": 12,
      "bold": false,
      "italic": true,
      "underline": false,
      "textColor": "#dedede",
      "textAlign": "CENTER"
    },
    "targetLineLabel": {
      "font": "ARIAL",
      "fontSize": 12,
      "bold": false,
      "italic": true,
      "underline": false,
      "textColor": "#dedede",
      "textAlign": "CENTER"
    }
  }
}
```

Pour mettre à jour une visualisation spécifique, vous pouvez envoyer une requête `PUT` à la même ressource `/api/visualisations` avec une charge similaire `PLUS` l'identifiant de la visualisation respective, par exemple :

    PUT /api/visualizations/hQxZGXqnLS9

Enfin, pour supprimer une visualisation existante, vous pouvez faire une requête `DELETE` en spécifiant l'identifiant de la visualisation à supprimer, comme indiqué :

    DELETE /api/visualizations/hQxZGXqnLS9

## Éléments de données { #webapi_data_items } 

<!--DHIS2-SECTION-ID:webapi_data_items-->

Ce endpoint permet à l'utilisateur d'interroger les données relatives à quelques éléments dimensionnels différents. Ces éléments sont les suivants : `INDICATEUR`, `ÉLÉMENT DE_DONNÉES`, `ENSEMBLE DE_DONNÉES`, `INDICATEUR DE_PROGRAMME`, `ÉLÉMENT DE_DONNÉES_DE PROGRAMME`, `ATTRIBUT DE_PROGRAMME`. Le endpoint ne supporte que les requêtes `GET` et, comme les autres endpoints, peut renvoyer des réponses au format JSON ou XML.

L'URL est `/api/dataItems` et comme vous pouvez l'imaginer, il est possible de récupérer différents objets à travers le même endpoint dans la même requête `GET`. Pour cette raison, certains attributs disponibles pour les requêtes seront différents en fonction de l'élément dimensionnel interrogé.

Pour comprendre la déclaration ci-dessus, examinons les exemples de requête suivants :

1) `GET /api/dataItems?filter=dimensionItemType:eq:DATA_ELEMENT&filter=valueType:eq:TEXT`
Dans cet exemple, le type d'élément `ELEMENT_DE DONNÉES` possède un attribut `Type de valeur` qui peut être utilisé dans la requête.

2) `GET /api/dataItems?filter=dimensionItemType:in:[PROGRAM_INDICATOR]&filter=program.id:eq:IpHINAT79UW`
Here, the `PROGRAM_INDICATOR` allows filtering by `program.id`.

So, based on the examples `1)` and `2)` if you try filtering a `DATA_ELEMENT` by `program.id` or filter a `PROGRAM_INDICATOR` by `valueType` you will get an error, as the respective attributes don't belong to those dimensional items.

Another important aspect to be highlighted is that this endpoint follows the same querying standards as other existing endpoints, like `Metadata object  filter` for example. As a consequence, it supports the same operators. See <a href="#webapi_metadata_object_filter">Metadata object filter</a> for the list of available operators.

### Possible endpoint responses { #webapi_data_items_possible_responses } 

<!--DHIS2-SECTION-ID:webapi_data_items_possible_responses-->

Base on the `GET` request/query, a few different responses are possible. Below we are summarizing each possibility.

#### Results found (HTTP status code 302) { #results-found-http-status-code-302 } 

```
{
  "pager": {
    "page": 1,
    "pageCount": 1,
    "total": 26,
    "pageSize": 50
  },
  "nameableObjects": [
    {
      "code": "DE_399",
      "lastUpdated": "2014-11-11T21:56:05.728",
      "id": "A2VfEfPflHV",
      "created": "2011-12-24T12:24:25.088",
      "name": "All other new",
      "shortName": "Others new",
      "aggregationType": "SUM",
      "displayName": "All other new",
      "publicAccess": "rw------",
      "displayShortName": "Others new",
      "externalAccess": false,
      "dimensionItem": "A2VfEfPflHV",
      "displayFormName": "All other new",
      "favorite": false,
      "dimensionItemType": "DATA_ELEMENT",
      "access": {
        "read": true,
        "update": true,
        "externalize": false,
        "delete": true,
        "write": true,
        "manage": true
      },
      "user": {
        "id": "GOLswS44mh8"
      },
      "favorites": [],
      "translations": [
        {
          "property": "SHORT_NAME",
          "locale": "en_GB",
          "value": "Others new"
        },
        {
          "property": "NAME",
          "locale": "en_GB",
          "value": "All other new"
        }
      ],
      "userGroupAccesses": [],
      "attributeValues": [],
      "userAccesses": [],
      "legendSets": []
    }, ...
  ]
}
```

#### Results not found (HTTP status code 404) { #results-not-found-http-status-code-404 } 

```
{
  "pager": {
    "page": 1,
    "pageCount": 1,
    "total": 0,
    "pageSize": 50
  },
  "nameableObjects": []
}
```

#### Invalid query (HTTP status code 409) { #invalid-query-http-status-code-409 } 

```
{
  "httpStatus": "Conflict",
  "httpStatusCode": 409,
  "status": "ERROR",
  "message": "Unable to parse element `INVALID_TYPE` on filter `dimensionItemType`. The values available are: [INDICATOR, DATA_ELEMENT, DATA_ELEMENT_OPERAND, DATA_SET, PROGRAM_INDICATOR, PROGRAM_DATA_ELEMENT, PROGRAM_ATTRIBUTE]",
  "errorCode": "E2016"
}
```

#### Unhandled error (HTTP status code 500) { #unhandled-error-http-status-code-500 } 

```
{
  "httpStatus": "Internal Server Error",
  "httpStatusCode": 500,
  "status": "ERROR"
}
```

### Pagination { #webapi_data_items_pagination } 

<!--DHIS2-SECTION-ID:webapi_data_items_pagination-->

This endpoint also supports pagination as a default option. If needed, you can disable pagination by adding `paging=false` to the `GET` request.
ie.: `/api/dataItems?filter=dimensionItemType:in:[INDICATOR]&paging=false`.

Voici un exemple de charge lorsque la pagination est activée. N'oubliez pas que la pagination est l'option par défaut et qu'il n'est pas nécessaire de la définir explicitement.

```
{
  "pager": {
    "page": 1,
    "pageCount": 20,
    "total": 969,
    "pageSize": 50,
    "nextPage": "http://your-domain/dhis/api/dataItems?page=2&filter=dimensionItemType:in:[INDICATOR]"
  },
  "nameableObjects": [...]
}
```

> **Note**
>
> The pagination of this endpoint needs to consolidate different dimensional items before building the response payload. Because of that, if some `order` is defined in the `GET` request, each page will bring an array of dimensional items respecting the ordering set.
>
> When paging is enabled the ordering is applied per page and not on the full result. In the other hand, if paging is disabled, the ordering will be applied to the full list of results. This will result in a difference in order. The first will order per page basis while the second will order the full list of items all at once.
>
> For better performance, we recommend leaving the pagination always enabled. It will optimize the performance by avoiding memory consumption and increasing the response time.

### Attributs de la réponse { #webapi_data_items_response_attributes } 

<!--DHIS2-SECTION-ID:webapi_data_items_response_attributes-->

Maintenant que nous avons une bonne idée des principales caractéristiques et de l'utilisation de ce endpoint , examinons la liste des attributs renvoyés dans la réponse.

<table>
<caption>Data items attributes</caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>id</td>
<td>The unique identifier.</td>
</tr>
<tr class="even">
<td>code</td>
<td>A custom code to identify the dimensional item.</td>
</tr>
<tr class="odd">
<td>created</td>
<td>The date of creation.</td>
</tr>
<tr class="even">
<td>lastUpdated</td>
<td>The last date when this item was updated.</td>
</tr>
<tr class="odd">
<td>name</td>
<td>The name given for the item.</td>
</tr>
<tr class="even">
<td>shortName</td>
<td>A short name given for the item.</td>
</tr>
<tr class="odd">
<td>displayName</td>
<td>The display name defined.</td>
</tr>
<tr class="even">
<td>displayShortName</td>
<td>The display short name set.</td>
</tr>
<tr class="odd">
<td>displayFormName</td>
<td>The name of the associated form.</td>
</tr>
<tr class="even">
<td>dimensionItem</td>
<td>The unique identifier, same as id.</td>
</tr>
<tr class="odd">
<td>dimensionItemType</td>
<td>The dimension type. Possible types: INDICATOR, DATA_ELEMENT, REPORTING_RATE, PROGRAM_INDICATOR, PROGRAM_DATA_ELEMENT, PROGRAM_ATTRIBUTE.</td>
</tr>
<tr class="even">
<td>aggregationType</td>
<td>The aggregation type defined for this dimensional item. They can be: SUM, AVERAGE, AVERAGE_SUM_ORG_UNIT, LAST,
LAST_AVERAGE_ORG_UNIT, FIRST, FIRST_AVERAGE_ORG_UNIT, COUNT, STDDEV, VARIANCE, MIN, MAX, NONE, CUSTOM, DEFAULT.</td>
</tr>
<tr class="odd">
<td>publicAccess</td>
<td>The permissions set for public access.</td>
</tr>
<tr class="even">
<td>externalAccess</td>
<td>Indicates whether the item is available externaly as read-only. Boolean value.</td>
</tr>
<tr class="odd">
<td>favorites</td>
<td>List of user ids who have marked this object as a favorite.</td>
</tr>
<tr class="even">
<td>favorite</td>
<td>Indicates if the current istem is set as favorite for the current user. Boolean value.</td>
</tr>
<tr class="odd">
<td>access</td>
<td>Access information for this item, related to the current user.</td>
</tr>
<tr class="even">
<td>user</td>
<td>The owner of this object.</td>
</tr>
<tr class="odd">
<td>translations</td>
<td>Set of translatable objects available. Normally filtered by locale.</td>
</tr>
<tr class="even">
<td>userGroupAccesses</td>
<td>Groups access to the current dimensional item.</td>
</tr>
<tr class="odd">
<td>attributeValues</td>
<td>Set of the dynamic attributes values that belong to the current item.</td>
</tr>
<tr class="even">
<td>userAccesses</td>
<td>List of user accesses related to this object.</td>
</tr>
<tr class="odd">
<td>legendSet</td>
<td>Defines the legend set values. Will override the automatic legend set.</td>
</tr>
</tbody>
</table>

## Analyses { #webapi_analytics }

<!--DHIS2-SECTION-ID:webapi_analytics-->

Pour accéder aux données analytiques et agrégées dans DHIS2, vous pouvez utiliser la ressource *analyse*. L'importance de la ressource "analyse" réside dans le fait qu'elle vous permet d'interroger et d'extraire des données agrégées pour toutes les dimensions de données disponibles. Par exemple, vous pouvez demander à la ressource "analyse" de vous fournir des valeurs agrégées pour un ensemble d'éléments de données, de périodes et d'unités d'organisation. Vous pouvez également récupérer les données agrégées d'une combinaison de dimensions en vous basant sur des éléments de données et des groupes d'unités d'organisation.

    /api/33/analytics

### Paramètres de requête { #webapi_analytics_query_parameters }

<!--DHIS2-SECTION-ID:webapi_analytics_query_parameters-->

La ressource "analyse" vous permet de définir un ensemble de paramètres de requête :

<table>
<caption>Query parameters</caption>
<colgroup>
<col style="width: 17%" />
<col style="width: 10%" />
<col style="width: 45%" />
<col style="width: 27%" />
</colgroup>
<thead>
<tr class="header">
<th>Query parameter</th>
<th>Required</th>
<th>Description</th>
<th>Options (default first)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>dimension</td>
<td>Yes</td>
<td>Dimensions and dimension items to be retrieved, repeated for each.</td>
<td>Any dimension</td>
</tr>
<tr class="even">
<td>filter</td>
<td>No</td>
<td>Filters and filter items to apply to the query, repeated for each.</td>
<td>Any dimension</td>
</tr>
<tr class="odd">
<td>aggregationType</td>
<td>No</td>
<td>Aggregation type to use in the aggregation process.</td>
<td>SUM | AVERAGE | AVERAGE_SUM_ORG_UNIT | LAST | LAST_AVERAGE_ORG_UNIT | COUNT | STDDEV | VARIANCE | MIN | MAX</td>
</tr>
<tr class="even">
<td>measureCriteria</td>
<td>No</td>
<td>Filters for the data/measures.</td>
<td>EQ | GT | GE | LT | LE</td>
</tr>
<tr class="odd">
<td>preAggregationMeasureCriteria</td>
<td>No</td>
<td>Filters for the data/measure, applied before aggregation is performed.</td>
<td>EQ | GT | GE | LT | LE</td>
</tr>
<tr>
<td>startDate</td>
<td>No</td>
<td>Start date for a date range. Will be applied as a filter. Can not be used together with a period dimension or filter.</td>
<td>Date</td>
</tr>
<tr>
<td>endDate</td>
<td>No</td>
<td>End date for date range. Will be applied as a filter. Can not be used together with a period dimension or filter.</td>
<td>Date</td>
</tr>
<tr class="even">
<td>skipMeta</td>
<td>No</td>
<td>Exclude the metadata part of the response (improves performance).</td>
<td>false | true</td>
</tr>
<tr class="odd">
<td>skipData</td>
<td>No</td>
<td>Exclude the data part of the response.</td>
<td>false | true</td>
</tr>
<tr class="even">
<td>skipRounding</td>
<td>No</td>
<td>Skip rounding of data values, i.e. provide full precision.</td>
<td>false | true</td>
</tr>
<tr class="odd">
<td>hierarchyMeta</td>
<td>No</td>
<td>Include names of organisation unit ancestors and hierarchy paths of organisation units in the metadata.</td>
<td>false | true</td>
</tr>
<tr class="even">
<td>ignoreLimit</td>
<td>No</td>
<td>Ignore limit on max 50 000 records in response - use with care.</td>
<td>false | true</td>
</tr>
<tr class="odd">
<td>tableLayout</td>
<td>No</td>
<td>Use plain data source or table layout for the response.</td>
<td>false | true</td>
</tr>
<tr class="even">
<td>hideEmptyRows</td>
<td>No</td>
<td>Hides empty rows in response, applicable when table layout is true.</td>
<td>false | true</td>
</tr>
<tr class="odd">
<td>hideEmptyColumns</td>
<td>No</td>
<td>Hides empty columns in response, applicable when table layout is true.</td>
<td>false | true</td>
</tr>
<tr class="even">
<td>showHierarchy</td>
<td>No</td>
<td>Display full org unit hierarchy path together with org unit name.</td>
<td>false | true</td>
</tr>
<tr class="odd">
<td>includeNumDen</td>
<td>No</td>
<td>Include the numerator and denominator used to calculate the value in the response.</td>
<td>false | true</td>
</tr>
<tr class="even">
<td>includeMetadataDetails</td>
<td>No</td>
<td>Include metadata details to raw data response.</td>
<td>false | true</td>
</tr>
<tr class="odd">
<td>displayProperty</td>
<td>No</td>
<td>Property to display for metadata.</td>
<td>NAME | SHORTNAME</td>
</tr>
<tr class="even">
<td>outputIdScheme</td>
<td>No</td>
<td>Identifier scheme to use for metadata items the query response, can be identifier, code or attributes.</td>
<td>UID | CODE |NAME| ATTRIBUTE:&lt;ID&gt;</td>
</tr>
<tr class="odd">
<td>inputIdScheme</td>
<td>No</td>
<td>Identifier scheme to use for metadata items in the query request, can be an identifier, code or attributes.</td>
<td>UID | CODE | ATTRIBUTE:&lt;ID&gt;</td>
</tr>
<tr class="even">
<td>approvalLevel</td>
<td>No</td>
<td>Include data which has been approved at least up to the given approval level, refers to identifier of approval level.</td>
<td>Identifier of approval level</td>
</tr>
<tr class="odd">
<td>relativePeriodDate</td>
<td>No</td>
<td>Date used as basis for relative periods.</td>
<td>Date.</td>
</tr>
<tr class="even">
<td>userOrgUnit</td>
<td>No</td>
<td>Explicitly define the user org units to utilize, overrides organisation units associated with the current user, multiple identifiers can be separated by semicolon.</td>
<td>Organisation unit identifiers.</td>
</tr>
<tr class="odd">
<td>columns</td>
<td>No</td>
<td>Dimensions to use as columns for table layout.</td>
<td>Any dimension (must be query dimension)</td>
</tr>
<tr class="even">
<td>rows</td>
<td>No</td>
<td>Dimensions to use as rows for table layout.</td>
<td>Any dimension (must be query dimension)</td>
</tr>
<tr class="odd">
<td>order</td>
<td>No</td>
<td>Specify the ordering of rows based on value.</td>
<td>ASC | DESC</td>
</tr>
<tr class="even">
<td>timeField</td>
<td>No</td>
<td>The time field to base event aggregation on. Applies to event data items only. Can be a predefined option or the ID of an attribute or data element with a time-based value type.</td>
<td>EVENT_DATE | ENROLLMENT_DATE | INCIDENT_DATE | DUE_DATE | COMPLETED_DATE | CREATED | LAST_UPDATED | &lt;Attribute ID&gt; | &lt;Data element ID&gt;</td>
</tr>
<tr>
<td>orgUnitField</td>
<td>No</td>
<td>The organisation unit field to base event aggregation on. Applies to event data items only. Can be the ID of an attribute or data element with the Organisation unit value type. The default option is specified as omitting the query parameter.
<td>&lt;Attribute ID&gt; | &lt;Data element ID&gt;</td>
</tr>
</tbody>
</table>

Le paramètre de requête *dimension* définit les dimensions à inclure dans la requête d'analyse. Un nombre quelconque de dimensions peut être spécifié. Le paramètre "dimension" doit être répété pour chaque dimension à inclure dans la réponse à la requête. La réponse à la requête peut éventuellement contenir des valeurs agrégées pour toutes les combinaisons des éléments de dimension spécifiés.

Le paramètre *filtre* définit les dimensions à utiliser comme filtres pour les données extraites de la requête d'analyse. Un nombre quelconque de filtres peut être spécifié. Le paramètre "filtre" doit être répété pour chaque filtre à utiliser dans la requête. La différence entre un filtre et une dimension réside dans le fait que les dimensions du filtre ne font pas partie du contenu de la réponse à la requête et que les valeurs agrégées dans la réponse sont regroupées en fonction des dimensions du filtre. En d'autres termes, les données de la réponse seront agrégées selon les dimensions du filtre, mais les filtres ne seront pas inclus en tant que dimensions dans la réponse proprement dite. Par exemple, pour lancer une requête pour certains éléments de données filtrés par les périodes et les unités d'organisation, vous pouvez utiliser l'URL suivante :

    /api/33/analytics?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU&filter=pe:2014Q1;2014Q2
      &filter=ou:O6uvpzGd5pu;lc3eMKXaEfw

Le paramètre de requête *aggregationType* (type d'agrégation) vous permet de définir l'opérateur d'agrégation à utiliser pour la requête. Par défaut, l'opérateur d'agrégation défini pour les éléments de données inclus dans la requête sera utilisé. Si votre requête ne contient aucun élément de données mais des groupes d'éléments de données, l'opérateur d'agrégation du premier élément de données du premier groupe sera utilisé. L'ordre des groupes et des éléments de données n'est pas défini. Ce paramètre de requête vous permet de remplacer l'opérateur d'agrégation par défaut et de définir un opérateur spécifique. Par exemple, vous pouvez le définir sur "count" (compter) avec l'URL suivante :

    /api/33/analytics?dimension=dx:fbfJHSPpUQD&dimension=pe:2014Q1&dimension=ou:O6uvpzGd5pu
      &aggregationType=COUNT

Le paramètre de requête *measureCriteria* (critères de mesure) vous permet de filtrer les plages d'enregistrements de données à renvoyer. Vous pouvez demander au système de ne renvoyer que les enregistrements dont les valeurs agrégées sont égales, supérieures, supérieures ou égales, inférieures ou inférieures ou égales à certaines valeurs. Vous pouvez spécifier un nombre quelconque de critères dans le format suivant, où *criteria* et *value* doivent être remplacés par des valeurs réelles :

    /api/33/analytics?measureCriteria=criteria:value;criteria:value

À titre d'exemple, la requête suivante renverra uniquement les enregistrements pour lesquels la valeur est supérieure ou égale à 6 500 et inférieure à 33 000 :

    /api/33/analytics?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU&dimension=pe:2014
      &dimension=ou:O6uvpzGd5pu;lc3eMKXaEfw&measureCriteria=GE:6500;LT:33000

Comme pour *measureCriteria*, le paramètre de requête *preAggregationMeasureCriteria* vous permet de filtrer les données avant que l'agrégation ne soit effectuée. Par exemple, la requête suivante n'agrège que les données dont la valeur initiale correspond aux critères définis :

    /api/33/analytics?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU&dimension=pe:2014
      &dimension=ou:O6uvpzGd5pu;lc3eMKXaEfw&preAggregationMeasureCriteria=GE:10;LT:100

The *startDate* and *endDate* parameters can be used to specify a custom 
date range to aggregate over. When specifying a date range you can not
specify relative nor fixed periods as dimension or filter. The date range
will filter the analytics response. You can use it like this:

    /api/33/analytics.json?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU
      &dimension=ou:ImspTQPwCqd&startDate=2018-01-01&endDate=2018-06-01

Pour que la ressource analytique génère les données sous forme d'un tableau tout fait, vous pouvez définir le paramètre *tableLayout* (présentation du tableau) en lui attribuant la valeur "true" (vrai). Au lieu de générer une source de données normalisée, la ressource analytique va maintenant générer les données dans un tableau. Vous pouvez utiliser les paramètres *columns* (colonnes) et *rows* (lignes) avec des identifiants de dimension séparés par des points-virgules en guise de valeurs pour indiquer ceux qui doivent apparaître dans les colonnes et ceux qui doivent apparaître dans les lignes du tableau. Les dimensions des colonnes et des lignes doivent être utilisées comme dimension de données dans la requête (et non comme filtre). Une telle requête peut ressembler à ceci :

    /api/33/analytics.html?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU&dimension=pe:2014Q1;2014Q2
      &dimension=ou:O6uvpzGd5pu&tableLayout=true&columns=dx;ou&rows=pe

Le paramètre *order* peut être utilisé pour les ressources analytiques afin de générer des données ordonnées. Les données seront classées dans l'ordre croissant (ou décroissant) des valeurs. Voici un exemple de requête permettant de classer les valeurs par ordre décroissant :

    /api/33/analytics?dimension=dx:fbfJHSPpUQD&dimension=pe:LAST_12_MONTHS
      &dimension=ou:O6uvpzGd5pu&order=DESC

### Dimensions et éléments { #webapi_analytics_dimensions_and_items }

<!--DHIS2-SECTION-ID:webapi_analytics_dimensions_and_items-->

DHIS2 dispose d'un modèle de données multidimensionnel avec plusieurs dimensions de données fixes et dynamiques. Les dimensions fixes sont l'élément de données, la période (temps) et l'unité d'organisation. Vous pouvez ajouter des dimensions de manière dynamique par le biais de catégories, de groupes d'éléments de données et de groupes d'unités d'organisation. Le tableau ci-dessous présente les dimensions de données disponibles dans DHIS2. Chaque dimension de données a un *identifiant de dimension* et chaque dimension peut avoir un ensemble d'*éléments de dimension*:

<table>
<caption>Dimensions and dimension items</caption>
<colgroup>
<col style="width: 38%" />
<col style="width: 12%" />
<col style="width: 49%" />
</colgroup>
<thead>
<tr class="header">
<th>Dimension</th>
<th>Dimension id</th>
<th>Dimension items</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Data elements, indicators, data set reporting rate metrics, data element operands, program indicators, program data elements, program attributes, validation rules</td>
<td>dx</td>
<td>Data element, indicator, data set reporting rate metrics, data element operand, program indicator, program attribute identifiers, keyword DE_GROUP-&lt;group-id&gt;, IN_GROUP-&lt;group-id&gt;, use &lt;dataelement-id&gt;.&lt;optioncombo-id&gt; for data element operands, &lt;program-id&gt;.&lt;dataelement-id&gt; for program data elements, &lt;program-id&gt;.&lt;attribute-id&gt; for program attributes, &lt;validationrule-id&gt; for validation results.</td>
</tr>
<tr class="even">
<td>Periods (time)</td>
<td>pe</td>
<td>ISO periods and relative periods, see &quot;date and period format&quot;</td>
</tr>
<tr class="odd">
<td>Organisation unit hierarchy</td>
<td>ou</td>
<td>Organisation unit identifiers, and keywords USER_ORGUNIT, USER_ORGUNIT_CHILDREN, USER_ORGUNIT_GRANDCHILDREN, LEVEL-&lt;level&gt; and OU_GROUP-&lt;group-id&gt;</td>
</tr>
<tr class="even">
<td>Category option combinations</td>
<td>co</td>
<td>Category option combo identifiers  (omit to get all items)</td>
</tr>
<tr class="odd">
<td>Attribute option combinations</td>
<td>ao</td>
<td>Category option combo identifiers (omit to get all items)</td>
</tr>
<tr class="even">
<td>Categories</td>
<td>&lt;category id&gt;</td>
<td>Category option identifiers (omit to get all items)</td>
</tr>
<tr class="odd">
<td>Data element group sets</td>
<td>&lt;group set id&gt;</td>
<td>Data element group identifiers (omit to get all items)</td>
</tr>
<tr class="even">
<td>Organisation unit group sets</td>
<td>&lt;group set id&gt;</td>
<td>Organisation unit group identifiers (omit to get all items)</td>
</tr>
<tr class="odd">
<td>Category option group sets</td>
<td>&lt;group set id&gt;</td>
<td>Category option group identifiers (omit to get all items)</td>
</tr>
</tbody>
</table>

Il n'est pas nécessaire de savoir quels objets sont utilisés pour les 
différentes dimensions dynamiques lors de la conception des requêtes analytiques. Vous pouvez obtenir 
une liste complète des dimensions dynamiques en visitant cette URL dans l'API Web :

    /api/33/dimensions

If you want to retrieve only the dimensional items for a given dynamic dimension you can
use the exemple below. The pagination is disabled by default. It can be enabled by adding
the pagination parameter `paging=true` to the URL.

    /api/33/dimensions/J5jldMd8OHv/items?paging=true

L'URL de base de la ressource analytique est `/api/analytics`. Pour demander des dimensions et des éléments de dimension spécifiques, vous pouvez utiliser une chaîne de requête au format suivant, où `dim-id` (identifiant de la dimension) et `dim-item` (élément de dimension) doivent être remplacés par des valeurs réelles :

    /api/33/analytics?dimension=dim-id:dim-item;dim-item&dimension=dim-id:dim-item;dim-item

Comme illustré ci-dessus, l'identifiant de la dimension est suivi de deux points, tandis que les éléments de la dimension sont séparés par des points-virgules. Par exemple, une requête portant sur deux éléments de données, deux périodes et deux unités d'organisation peut être effectuée à l'aide de l'URL suivante :

    /api/33/analytics?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU
      &dimension=pe:2016Q1;2016Q2&dimension=ou:O6uvpzGd5pu;lc3eMKXaEfw

Pour obtenir des données ventilées par combinaisons d'options de catégorie au lieu des totaux des éléments de données, vous pouvez inclure la dimension de catégorie dans la chaîne de requête. Voici une exemple :

    /api/33/analytics?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU
      &dimension=co&dimension=pe:201601&dimension=ou:O6uvpzGd5pu;lc3eMKXaEfw

When selecting data elements you can also select all data elements in a
group as items by using the DE_GROUP-<id> syntax:

    /api/33/analytics?dimension=dx:DE_GROUP-h9cuJOkOwY2
      &dimension=pe:201601&dimension=ou:O6uvpzGd5pu

Au moment de sélectionner les taux de déclaration des ensembles de données, la syntaxe contient un identifiant d'ensemble de données suivi d'une mesure de taux de déclaration :

    /api/33/analytics?dimension=dx:BfMAe6Itzgt.REPORTING_RATE;BfMAe6Itzgt.ACTUAL_REPORTS
      &dimension=pe:201601&dimension=ou:O6uvpzGd5pu

To query for program data elements (of tracker domain type) you can get
those by specifying the program for each data element using the
<program-id>.<dataelement-id> syntax:

    /api/33/analytics.json?dimension=dx:eBAyeGv0exc.qrur9Dvnyt5;eBAyeGv0exc.GieVkTxp4HH
      &dimension=pe:LAST_12_MONTHS&filter=ou:ImspTQPwCqd

To query for program attributes (tracked entity attributes) you can get
those by specifying the program for each attribute using the
<program.id>.<attribute-id> syntax:

    /api/33/analytics.json?dimension=dx:IpHINAT79UW.a3kGcGDCuk6;IpHINAT79UW.UXz7xuGCEhU
      &dimension=pe:LAST_4_QUARTERS&dimension=ou:ImspTQPwCqd

Pour obtenir des ensembles de groupes d'unités d'organisation et des éléments de données, vous pouvez utiliser l'URL ci-dessous. Remarquez que l'identifiant de l'ensemble de groupes est utilisé comme identifiant de dimension et les groupes comme éléments de dimension :

    /api/33/analytics?dimension=Bpx0589u8y0:oRVt7g429ZO;MAs88nJc9nL
      &dimension=pe:2016&dimension=ou:ImspTQPwCqd

Pour obtenir des éléments de données et des catégories, vous pouvez utiliser l'URL suivante. Utilisez l'identifiant de la catégorie comme identifiant de dimension et les options de la catégorie comme éléments de dimension :

    /api/33/analytics?dimension=dx:s46m5MS0hxu;fClA2Erf6IO&dimension=pe:2016
      &dimension=YNZyaJHiHYq:btOyqprQ9e8;GEqzEKCHoGA&filter=ou:ImspTQPwCqd

Pour effectuer une requête en utilisant des périodes relatives et des unités d'organisation associées à l'utilisateur actuellement connecté, vous pouvez utiliser l'URL suivante :

    /api/33/analytics?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU
      &dimension=pe:LAST_12_MONTHS&dimension=ou:USER_ORGUNIT

When selecting organisation units for a dimension you can select an
entire level optionally constrained by any number of boundary
organisation units with the `LEVEL-<level>` syntax. Boundary refers to a
top node in a sub-hierarchy, meaning that all organisation units at the
given level below the given boundary organisation unit in the hierarchy
will be included in the response, and is provided as regular organisation unit 
dimension items. The level value can either be a numerical level or refer to the identifier
of the organisation unit level entity. A simple query for all org units at level three:

    /api/33/analytics?dimension=dx:fbfJHSPpUQD&dimension=pe:2016&dimension=ou:LEVEL-3

Une requête pour les niveaux trois et quatre avec deux unités d'organisation limites peut se présenté comme suit :

    /api/33/analytics?dimension=dx:fbfJHSPpUQD&dimension=pe:2016
      &dimension=ou:LEVEL-3;LEVEL-4;O6uvpzGd5pu;lc3eMKXaEf

When selecting organisation units you can also select all organisation
units in an organisation unit group to be included as dimension items
using the OU_GROUP-<id> syntax. The organisation units in the groups
can optionally be constrained by any number of boundary organisation
units. Both the level and the group items can be repeated any number of
times:

    /api/33/analytics?dimension=dx:fbfJHSPpUQD&dimension=pe:2016
      &dimension=ou:OU_GROUP-w0gFTTmsUcF;OU_GROUP-EYbopBOJWsW;O6uvpzGd5pu;lc3eMKXaEf

Vous pouvez utiliser des schémas d'identification pour la partie métadonnées de la réponse analytique avec la propriété outputIdScheme. Vous pouvez utiliser l'identifiant, le code ou les attributs comme schéma d'identification. Voici un exemple :

    /api/33/analytics?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU
      &dimension=pe:2017Q1;2017Q2&dimension=ou:O6uvpzGd5pu&outputIdScheme=CODE

Quelques éléments à prendre en compte lors de l'utilisation de la ressource analytique sont répertoriés ci-dessous.

  - Éléments de données, indicateur, taux de déclaration des ensembles de données, données de programme
    et les indicateurs de programme font partie d’une dimension de données commune,
    identifié comme "dx". Cela signifie que vous pouvez utiliser n'importe quelle élément de données, 
    indicateur et identifiant d'ensemble de données avec l'identifiant 
    de dimension "dx" dans la requête.

  - Pour les dimensions "catégorie", "ensemble de groupes d'éléments de données" et "ensemble de groupes d'unités d'organisation", 
    tous les éléments de dimension seront utilisés dans la requête si
    éléments de dimension ne sont pas spécifiés.

  - Pour la dimension de période, les éléments de dimension sont des identifiants de période ISO
    et/ou des périodes relatives. Consultez la section 
    "Format de date et de période" plus haut, pour mieux comprendre le format des périodes et
    les périodes relatives disponibles.

  - Pour la dimension d'unité d'organisation, vous pouvez spécifier des éléments qui seront 
    l'unité d'organisation ou les sous-unités de l'unité d'organisation
    associée à l'utilisateur actuellement authentifié pour la requête.
    Vous pouvez le faire en utilisant respectivement les clés `USER_ORGUNIT` ou `USER_ORGUNIT_CHILDREN` comme éléments.
    Vous pouvez également spécifier des identifiants d'unité d'organisation
    ou une combinaison des deux possibilités.

  - Pour la dimension d'unité d'organisation, vous pouvez spécifier le niveau hiérarchique 
    et l'unité d'organisation limite à utiliser pour la requête en utilisant le 
    format `LEVEL-<level>-<boundary-id>` ; par exemple
    `LEVEL-3-ImspTQPwCqd` prend en compte toutes les unités d'organisation inférieures à 
    l'unité d'organisation limite au niveau 3 de la hiérarchie.

  - Pour la dimension d'unité d'organisation, les éléments de dimension sont les
    unités d'organisation et leur sous-hiérarchie - les données seront agrégées
    pour toutes les unités d'organisation situées en dessous de l'unité d'organisation spécifiée dans la 
    hiérarchie.

  - Vous ne pouvez pas spécifier d'éléments de dimension pour la dimension de combinaison 
    d'options de catégorie. En lieu et place de cela, la réponse contiendra les éléments
    associés aux valeurs de données.

### La dimension dx { #webapi_analytics_dx_dimension }

<!--DHIS2-SECTION-ID:webapi_analytics_dx_dimension-->

La dimension `dx` est une dimension spéciale qui peut contenir tous les types de données suivants.

<table>
<caption>Data dx dimension types</caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 23%" />
<col style="width: 27%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Syntax</th>
<th>Description</th>
<th>Data source</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Indicator</td>
<td>&lt;indicator-id&gt;</td>
<td>Indicator identifier.</td>
<td>Aggregated data</td>
</tr>
<tr class="even">
<td>Indicator grop</td>
<td>IN_GROUP-&lt;indicatorgroup-id&gt;</td>
<td>Keyword followed by an indicator group identifier. Will include all indicators in the group in the response.</td>
<td>Aggregated data</td>
</tr>
<tr class="odd">
<td>Data element</td>
<td>&lt;dataelement-id&gt;</td>
<td>Data element identifier.</td>
<td>Aggregated data</td>
</tr>
<tr class="even">
<td>Data element group</td>
<td>DE_GROUP-&lt;dataelementgroup-id&gt;</td>
<td>Keyword followed by a data element group identifier. Will include all data elements in the group in the response.</td>
<td>Aggregated data</td>
</tr>
<tr class="odd">
<td>Data element operand</td>
<td>&lt;dataelement-id&gt;.&lt;categoryoptcombo-id&gt;.&lt;attributeoptcombo-id&gt;</td>
<td>Data element identifier followed by one or both of category option combination and attribute option combo identifier. Wildcard &quot;*&quot; symbol can be used to indicate any option combination value. The attribute option combination identifier can be completely left out.</td>
<td>Aggregate data</td>
</tr>
<tr class="even">
<td>Data set</td>
<td>&lt;dataset-id&gt;.&lt;reporting-rate-metric&gt;</td>
<td>Data set identifier followed by reporting rate metric. Can be REPORTING_RATE | REPORTING_RATE_ON_TIME | ACTUAL_REPORTS | ACTUAL_REPORTS_ON_TIME | EXPECTED_REPORTS.</td>
<td>Data set completeness registrations</td>
</tr>
<tr class="odd">
<td>Program data element</td>
<td>&lt;program-id&gt;.&lt;dataelement-id&gt;</td>
<td>Program identifier followed by data element identifier. Reads from events within the specified program.</td>
<td>Events from the given program</td>
</tr>
<tr class="even">
<td>Program indicator</td>
<td>&lt;programindicator-id&gt;</td>
<td>Program indicator identifier. Reads from events from within the program associated with the program identifier.</td>
<td>Events from the program of the program indicator</td>
</tr>
<tr class="odd">
<td>Validation result</td>
<td>&lt;validationrule-id&gt;</td>
<td>Validation rule identifier. Will include validation rule violations for the validation rule, requires that validation results are generated and persisted.</td>
<td>Validation results</td>
</tr>
</tbody>
</table>

Les éléments de tous les différents types `dx` peuvent être combinés dans une requête d'analyse. Voici un exemple :

    /api/33/analytics.json
      ?dimension=dx:Uvn6LCg7dVU;BfMAe6Itzgt.REPORTING_RATE;IpHINAT79UW.a3kGcGDCuk6
      &dimension=pe:LAST_12_MONTHS&filter=ou:ImspTQPwCqd

La syntaxe de groupe peut également être utilisée avec n’importe quel autre élément. Voici un exemple :

    /api/33/analytics.json
      ?dimension=dx:DE_GROUP-qfxEYY9xAl6;IN_GROUP-oehv9EO3vP7;BfMAe6Itzgt.REPORTING_RATE
      &dimension=pe:LAST_12_MONTHS&filter=ou:ImspTQPwCqd

Les opérandes d'élément de données peuvent éventuellement spécifier des combinaisons d'options d'attribut et utiliser des caractères génériques, par exemple pour spécifier toutes les valeurs des combinaisons d'options de catégorie :

    /api/33/analytics.json
      ?dimension=dx:Uvn6LCg7dVU.*.j8vBiBqGf6O;Uvn6LCg7dVU.Z4oQs46iTeR
      &dimension=pe:LAST_12_MONTHS&filter=ou:ImspTQPwCqd

> **Tip**
>
> A great way to learn how to use the analytics API is to use the DHIS2
> *pivot table* app. You can play around with pivot tables using the
> various dimensions and items and click Download > Plain data source > JSON
> to see the resulting analytics API calls in the address bar of
> your Web browser.

### Formats de réponse { #webapi_analytics_response_formats }

<!--DHIS2-SECTION-ID:webapi_analytics_response_formats-->

La réponse analytique contenant les données agrégées peut être renvoyée sous différents formats. Comme toujours, vous pouvez définir un format spécifique en ajoutant une extension de fichier à l'URL, via l'en-tête HTTP `Accept` ou via le paramètre de requête `format`. Le format par défaut est JSON. Les formats et types de contenu disponibles sont listés ci-dessous.

  - json (application/json)

  - jsonp (application/javascript)

  - xml (application/xml)

  - csv (application/csv)

  - html (texte/html)

  - html+css (texte/html)

  - xls (application/vnd.ms-excel)

À titre d'exemple, vous pouvez demander une réponse analytique au format XML, en utilisant l'URL suivante :

    /api/33/analytics.xml?dimension=dx:fbfJHSPpUQD
      &dimension=pe:2016&dimension=ou:O6uvpzGd5pu;lc3eMKXaEfw

The analytics responses must be retrieved using the HTTP *GET* method.
This allows for direct linking to analytics responses from Web pages as
well as other HTTP-enabled clients. To do functional testing we can use
the cURL library. By executing this command against the demo database
you will get an analytics response in JSON format:

```bash
curl "play.dhis2.org/demo/api/analytics.json?dimension=dx:eTDtyyaSA7f;FbKK4ofIv5R
  &dimension=pe:2016Q1;2016Q2&filter=ou:ImspTQPwCqd" -u admin:district
```

La réponse JSON ressemblera à ceci :

```json
{
  "headers": [
    {
      "name": "dx",
      "column": "Data",
      "meta": true,
      "type": "java.lang.String"
    },
    {
      "name": "pe",
      "column": "Period",
      "meta": true,
      "type": "java.lang.String"
    },
    {
      "name": "value",
      "column": "Value",
      "meta": false,
      "type": "java.lang.Double"
    }
  ],
  "height": 4,
  "metaData": {
    "pe": [
      "2016Q1",
      "2016Q2"
    ],
    "ou": [
      "ImspTQPwCqd"
    ],
    "names": {
      "2016Q1": "Jan to Mar 2016",
      "2016Q2": "Apr to Jun 2016",
      "FbKK4ofIv5R": "Measles Coverage <1 y",
      "ImspTQPwCqd": "Sierra Leone",
      "eTDtyyaSA7f": "Fully Immunized Coverage"
    }
  },
  "rows": [
    [
      "eTDtyyaSA7f",
      "2016Q2",
      "81.1"
    ],
    [
      "eTDtyyaSA7f",
      "2016Q1",
      "74.7"
    ],
    [
      "FbKK4ofIv5R",
      "2016Q2",
      "88.9"
    ],
    [
      "FbKK4ofIv5R",
      "2016Q1",
      "84.0"
    ]
  ],
  "width": 3
}
```

La réponse représente un tableau de données dimensionnelles. L'*en-tête* donne un aperçu des colonnes du tableau et de leur contenu. La propriété *colonne* indique l'identifiant de la dimension de la colonne ou, si la colonne contient des mesures, le mot "Value". La propriété *métadonnées* est définie sur *vrai* si la colonne contient des éléments de dimension ou *faux* si la colonne contient une mesure (valeurs de données agrégées). La propriété *nom* est similaire à la propriété "colonne", à la différence qu'elle affiche "valeur" lorsque la colonne contient une mesure. La propriété *type* indique le type de classe Java des valeurs de la colonne.

Les propriétés *hauteur* et *largeur* indiquent respectivement le nombre de colonnes et de lignes de données contenues dans la réponse.

La propriété *périodes de métadonnées* contient un tableau unique et ordonné des périodes contenues dans la réponse. La propriété *unité d'organisation de métadonnées* contient un tableau d'identifiants d'unités d'organisation contenues dans la réponse. La propriété *noms de métadonnées* permet d'obtenir une correspondance entre les identifiants utilisés dans la réponse et les noms des objets qu'ils représentent. Les clients peuvent utiliser cette propriété pour remplacer les identifiants de la réponse par des noms afin d'obtenir une représentation plus claire du tableau de données.

La rubrique *lignes* contient le tableau des données dimensionnelles. Ce dernier est fait de colonnes dans lesquelles figurent des éléments de dimension (identifiants d'objets ou de périodes) et une colonne dans laquelle figurent des valeurs de données agrégées. L'exemple de réponse ci-dessus comporte une colonne pour les données et les indicateurs, une colonne pour les périodes et une colonne pour les valeurs. La première colonne contient les identifiants d'indicateur, la deuxième contient les identifiants de période ISO et la troisième contient les valeurs de données agrégées.

### Contraintes et validation { #webapi_analytics_constraints }

<!--DHIS2-SECTION-ID:webapi_analytics_constraints-->

Les paramètres d'entrée que vous pouvez fournir à la ressource analytique sont soumis à plusieurs contraintes. Si l'une de ces contraintes n'est pas respectée, l'API renvoie une réponse *409 Conflict* avec un message semblable à celui-ci :

```json
{
  "httpStatus": "Conflict",
  "httpStatusCode": 409,
  "status": "ERROR",
  "message": "Only a single indicator can be specified as filter",
  "errorCode": "E7108"
}
```

Les champs `httpStatus` et `httpStatusCode` indiquent le statut HTTP et le code de statut conformément à la spécification HTTP. Le champ `message` fournit une description de l'erreur de validation lisible par l'homme. Le champ `errorCode` fournit un code lisible par une machine que les clients peuvent utiliser pour gérer les erreurs de validation. Les erreurs de validation potentielles pour l'API d'analyse des données agrégées sont décrites dans le tableau ci-dessous.

| Code d'erreur | Message |
| ---------- | ------- |
| E7100      | Les paramètres de requête ne peuvent pas être nuls |
| E7101      | Au moins une dimension doit être spécifiée |
| E7102      | Au moins un élément de dimension de données ou un élément de dimension d'ensemble de groupes d'éléments de données doit être spécifié. |
| E7103      | Les dimensions ne peuvent pas être spécifiées à la fois comme dimension et comme filtre |
| E7104      | Au moins une période doit être spécifiée comme dimension ou filtre, ou dates de début et de fin  |
| E7105      | Les périodes et les dates de début et de fin ne peuvent pas être spécifiées simultanément |
| E7106      | La date de début ne peut pas être postérieure à la date de fin |
| E7107      | Des dates de début et de fin ne peuvent pas être spécifiées pour les taux de déclaration |
| E7108      | Un seul indicateur peut être spécifié comme filtre |
| E7109      | Un seul taux de déclaration peut être spécifié comme filtre |
| E7110      | Les combinaisons d'options de catégorie ne peuvent pas être spécifiées comme filtre |
| E7111      | Les dimensions ne peuvent pas être spécifiées plus d'une fois |
| E7112      | Les taux de déclaration ne peuvent être spécifiés qu'avec les dimensions de type |
| E7113      | Les catégories attribuées ne peuvent pas être spécifiées si les éléments de données ne sont pas spécifiés |
| E7114      | Les catégories attribuées ne peuvent être spécifiées qu'avec des éléments de données, et non avec des indicateurs ou des taux de déclaration. |
| E7115      | Les éléments de données doivent être d'un type de valeur et d'agrégation qui permette l'agrégation |
| E7116      | Les expressions d'indicateur ne peuvent pas contenir de références cycliques |
| E7117      | Une dimension de données 'dx' doit être spécifiée lorsque le format de sortie est DATA_VALUE_SET (ensemble de v. |
| E7118      | Une dimension de période 'pe' doit être spécifiée lorsque le format de sortie est DATA_VALUE_SET. |
| E7119      | Une dimension d'unité d'organisation 'ou' doit être spécifiée lorsque le format de sortie est DATA_VALUE_SET. |
| E7120      | L'utilisateur n'est pas autorisé à visualiser l'unité d'organisation |
| E7121      | L'utilisateur n'est pas autorisé à lire les données de l'objet |
| E7122      | Le niveau d'approbation des données n'existe pas |
| E7123      | L'utilisateur actuel est limité par une dimension mais n'a accès à aucun élément de dimension |
| E7124      | La dimension est présente dans la requête sans aucune option de dimension valide |
| E7125      | L'identifiant de dimension ne fait référence à aucune dimension |
| E7126      | La colonne doit être présente en tant que dimension dans la requête |
| E7127      | La ligne doit être présente dans la requête en tant que dimension |
| E7128      | Les résultats de la requête ont dépassé la limite maximale |
| E7129      | Le programme est spécifié mais n'existe pas |
| E7130      | L'étape de programme est spécifiée mais n'existe pas |
| E7131      | La requête a échoué, probablement parce que la requête a expiré |

### Format de l'ensemble de valeurs de données { #webapi_analytics_data_value_set_format }

<!--DHIS2-SECTION-ID:webapi_analytics_data_value_set_format-->

La ressource analytique *dataValueSet* permet de renvoyer des données agrégées dans le format "ensemble de valeurs de données". Ce format représente des valeurs de données brutes, par opposition aux données qui ont été agrégées en fonction des différentes dimensions. L'exportation de données agrégées sous la forme de valeurs de données régulières permet d'échanger des données entre systèmes lorsque le système cible contient des données d'une granularité plus fine que celles stockées par le système de destination.

Par exemple, il est possible de spécifier un indicateur dans le système cible qui va récapituler les données de plusieurs éléments de données, et d'importer ces données pour le compte d'un seul élément de données dans le système de destination. Autre exemple, l'on peut agréger les données collectées au niveau 4 de l'unité d'organisation dans le système cible au niveau 2 et importer ces données dans le système de destination.

Vous pouvez récupérer des données au format d'ensemble de valeurs de données brutes à partir de la ressource dataValueSet :

    /api/33/analytics/dataValueSet

Les représentations de ressources suivantes sont prises en charge :

  - json (application/json)

  - xml (application/xml)

Lorsque vous utilisez le format d'ensemble de valeurs de données, exactement trois dimensions doivent être spécifiées en tant que dimensions analytiques avec au moins un élément de dimension pour chacune d'entre elles :

  - Données (dx)

  - Période (pe)

  - Unité d'organisation (ou)

Toute autre dimension sera ignorée. Les filtres seront appliqués de la même manière que pour les demandes d'analyse ordinaires. Notez que tout type de dimension de données peut être spécifié, notamment les indicateurs, les éléments de données, les opérandes d'éléments de données, les ensembles de données et les indicateurs de programme.

Voici un exemple de requête qui agrège des données pour des indicateurs, des périodes et des unités d'organisation spécifiques et les renvoie sous forme de valeurs de données régulières au format XML :

    api/analytics/dataValueSet.xml?dimension=dx:Uvn6LCg7dVU;OdiHJayrsKo
      &dimension=pe:LAST_4_QUARTERS&dimension=ou:lc3eMKXaEfw;PMa2VCrupOd

Trouvez ci-dessous un exemple de requête qui agrège des données pour des opérandes d'éléments de données et qui utilise CODE comme schéma d'identification de sortie. Lorsque vous définissez un schéma d'identification de sortie, tous les objets de métadonnées qui font partie de la réponse sont affectés :

    api/analytics/dataValueSet.json?dimension=dx:fbfJHSPpUQD.pq2XI5kz2BY;fbfJHSPpUQD.PT59n8BQbqM
      &dimension=pe:LAST_12_MONTHS&dimension=ou:ImspTQPwCqd&outputIdScheme=CODE

Lorsque vous utilisez des schémas d'identification basés sur des attributs pour effectuer des exportations, des valeurs peuvent être dupliquées. Le paramètre de requête booléen duplicatesOnly peut être utilisé à des fins de débogage pour ne renvoyer que les valeurs de données dupliquées. Cette réponse peut être utilisée pour nettoyer les doublons :

    api/analytics/dataValueSet.xml?dimension=dx:Uvn6LCg7dVU;OdiHJayrsKo
      &dimension=pe:LAST_4_QUARTERS&dimension=ou:lc3eMKXaEfw&duplicatesOnly=true

### Format de données brutes { #webapi_analytics_raw_data }

<!--DHIS2-SECTION-ID:webapi_analytics_raw_data-->

La ressource analytique *rawData* permet de renvoyer les données stockées dans les tableaux de données analytiques sans qu'aucune agrégation ne soit effectuée. Cette ressource permet aux clients qui le souhaitent d'effectuer eux-mêmes des agrégations et des filtrages sans avoir à dénormaliser eux-mêmes les données existant dans les dimensions disponibles.

    /api/analytics/rawData

Les représentations de ressources suivantes sont prises en charge :

  - json (application/json)

  - csv (application/csv)

Cette ressource respecte la syntaxe d'une ressource analytique ordinaire. Seul un sous-ensemble de paramètres de requête est pris en charge. En outre, les paramètres *startDate* et *endDate* sont disponibles. Les paramètres pris en charge sont énumérés dans le tableau ci-dessous.

<table>
<caption>Query parameters</caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Query parameter</th>
<th>Required / Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>dimension</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>startDate</td>
<td>No / yyyy-MM-dd</td>
</tr>
<tr class="odd">
<td>endDate</td>
<td>No / yyyy-MM-dd</td>
</tr>
<tr class="even">
<td>skipMeta</td>
<td>No</td>
</tr>
<tr class="odd">
<td>skipData</td>
<td>No</td>
</tr>
<tr class="even">
<td>hierarchyMeta</td>
<td>No</td>
</tr>
<tr class="odd">
<td>showHierarchy</td>
<td>No</td>
</tr>
<tr class="even">
<td>displayProperty</td>
<td>No</td>
</tr>
<tr class="odd">
<td>outputIdScheme</td>
<td>No</td>
</tr>
<tr class="even">
<td>inputIdScheme</td>
<td>No</td>
</tr>
<tr class="odd">
<td>userOrgUnit</td>
<td>No</td>
</tr>
</tbody>
</table>

Le paramètre de requête *dimension* définit les dimensions (colonnes du tableau) à inclure dans la réponse. Il peut éventuellement être limité par des éléments. Le paramètre de requête *filter* (filtre) définit les éléments et les dimensions (colonnes du tableau) qui doivent être utilisés comme filtre pour la réponse.

Pour la dimension "unité d'organisation", la réponse contiendra les données associées à l'unité d'organisation et à toutes les unités d'organisation qui lui sont inférieures dans la hiérarchie (c'est-à-dire ses subordonnées). Ceci est différent de la ressource analytique ordinaire, où seules les unités d'organisation explicitement sélectionnées sont incluses dans la réponse.

Pour obtenir une réponse contenant des éléments de données, périodes et unités d'organisation spécifiques, ainsi que toutes les données relatives à deux dimensions personnalisées, vous pouvez lancer une requête de ce type :

    /api/analytics/rawData.json?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU;Jtf34kNZhzP
      &dimension=J5jldMd8OHv&dimension=Bpx0589u8y0
      &dimension=pe:LAST_12_MONTHS
      &dimension=ou:O6uvpzGd5pu;fdc6uOvgoji

Les paramètres *startDate* et *endDate* permettent de récupérer des données associées à toute période comprise entre ces dates. Avec cette méthode, nul besoin de définir explicitement toutes les périodes dans la requête :

    /api/analytics/rawData.json?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU;Jtf34kNZhzP
      &dimension=J5jldMd8OHv&dimension=Bpx0589u8y0
      &startDate=2015-01-01&endDate=2015-12-31
      &dimension=ou:O6uvpzGd5pu;fdc6uOvgoji

Le paramètre *filter* peut être utilisé pour filtrer une réponse sans inclure cette dimension dans la réponse, cette fois au format CSV :

    /api/analytics/rawData.csv?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU;Jtf34kNZhzP
      &filter=J5jldMd8OHv:uYxK4wmcPqA;tDZVQ1WtwpA
      &startDate=2015-01-01&endDate=2015-12-31
      &dimension=ou:O6uvpzGd5pu

Vous pouvez utiliser le paramètre *outputIdScheme* (schéma d'identification de la sortie) pour obtenir des données lisibles par l'homme, car il peut être défini sur *NOM* comme dans l'exemple suivant :

    /api/analytics/rawData.csv?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU
      &filter=J5jldMd8OHv:uYxK4wmcPqA;tDZVQ1WtwpA
      &startDate=2017-01-01&endDate=2017-12-31
      &dimension=ou:O6uvpzGd5pu
      &outputIdScheme=NAME

La réponse de la ressource *rawData* est identique à celle de la ressource analytique ordinaire, à la différence qu'elle contient des données brutes et non agrégées qui peuvent être agrégées ultérieurement par des systèmes tiers.

### Débogage { #webapi_analytics_debugging }

<!--DHIS2-SECTION-ID:webapi_analytics_debugging-->

Lors du débogage des requêtes analytiques, il peut être utile d'examiner la source des valeurs de données de la réponse analytique agrégée. La ressource *analytics/debug/sql* fournira une instruction SQL qui renvoie le contenu recherché du tableau des valeurs de données. Vous pouvez produire cette instruction SQL en effectuant une requête GET avec le type de contenu "text/html" ou "text/plain" comme ci-dessous. La syntaxe des dimensions et des filtres est identique à celle des requêtes analytiques ordinaires :

    /api/analytics/debug/sql?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU
      &filter=pe:2016Q1;2016Q2&filter=ou:O6uvpzGd5pu

## Analyse d'événements { #webapi_event_analytics }

<!--DHIS2-SECTION-ID:webapi_event_analytics-->

L'API d'analyse d'événements vous permet d'accéder à des données d'événements agrégées et d'interroger des *événements* capturés dans DHIS2. Cette ressource vous permet d'extraire des événements à partir d'un programme et éventuellement d'une étape de programme. Elle vous permet également d'extraire et de filtrer des événements en fonction des différentes dimensions d'événements.

    /api/33/analytics/events

### Dimensions et éléments { #webapi_event_analytics_dimensions_items }

<!--DHIS2-SECTION-ID:webapi_event_analytics_dimensions_items-->

Les dimensions d'événements comprennent les éléments de données, les attributs, les unités d'organisation et les périodes. La ressource analytique des événements agrégés renvoie des informations agrégées telles que des chiffres issus de comptages ou des moyennes. La ressource analytique de requête renvoie simplement les événements correspondant à un ensemble de critères et n'effectue aucune agrégation. Vous pouvez spécifier des éléments de dimension sous la forme d'options à partir d'ensembles d'options et de légendes à partir d'ensembles de légendes, pour les éléments de données et les attributs qui y sont associés. Les dimensions des événements sont répertoriées dans le tableau ci-dessous.

<table>
<caption>Event dimensions</caption>
<colgroup>
<col style="width: 27%" />
<col style="width: 11%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="header">
<th>Dimension</th>
<th>Dimension id</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Data elements</td>
<td>&lt;id&gt;</td>
<td>Data element identifiers</td>
</tr>
<tr class="even">
<td>Attributes</td>
<td>&lt;id&gt;</td>
<td>Attribute identifiers</td>
</tr>
<tr class="odd">
<td>Periods</td>
<td>pe</td>
<td>ISO periods and relative periods, see &quot;date and period format&quot;</td>
</tr>
<tr class="even">
<td>Organisation units</td>
<td>ou</td>
<td>Organisation unit identifiers and keywords USER_ORGUNIT, USER_ORGUNIT_CHILDREN, USER_ORGUNIT_GRANDCHILDREN, LEVEL-&lt;level&gt; and OU_GROUP-&lt;group-id&gt;</td>
</tr>
<tr class="odd">
<td>Organisation unit group sets</td>
<td>&lt;org unit group set id&gt;</td>
<td>Organisation unit group set identifiers</td>
</tr>
<tr class="even">
<td>Categories</td>
<td>&lt;category id&gt;</td>
<td>Category identifiers (program attribute categories only)</td>
</tr>
</tbody>
</table>

### Paramètres de requête{ #webapi_event_analytics_request_query_parameters }

<!--DHIS2-SECTION-ID:webapi_event_analytics_request_query_parameters-->

L'API d'événement analytique vous permet de définir un ensemble de paramètres de requête.

<table>
<caption>Query parameters for both event query and aggregate analytics</caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 11%" />
<col style="width: 48%" />
<col style="width: 19%" />
</colgroup>
<thead>
<tr class="header">
<th>Query parameter</th>
<th>Required</th>
<th>Description</th>
<th>Options (default first)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>program</td>
<td>Yes</td>
<td>Program identifier.</td>
<td>Any program identifier</td>
</tr>
<tr class="even">
<td>stage</td>
<td>No</td>
<td>Program stage identifier.</td>
<td>Any program stage identifier</td>
</tr>
<tr class="odd">
<td>startDate</td>
<td>Yes</td>
<td>Start date for events.</td>
<td>Date in yyyy-MM-dd format</td>
</tr>
<tr class="even">
<td>endDate</td>
<td>Yes</td>
<td>End date for events.</td>
<td>Date in yyyy-MM-dd format</td>
</tr>
<tr class="odd">
<td>dimension</td>
<td>Yes</td>
<td>Dimension identifier including data elements, attributes, program indicators, periods, organisation units and organisation unit group sets. Parameter can be repeated any number of times. Item filters can be applied to a dimension on the format &lt;item-id&gt;:&lt;operator&gt;:&lt;filter&gt;. Filter values are case-insensitive.</td>
<td>Operators can be EQ | GT | GE | LT | LE | NE | LIKE | IN</td>
</tr>
<tr class="even">
<td>filter</td>
<td>No</td>
<td>Dimension identifier including data elements, attributes, periods, organisation units and organisation unit group sets. Parameter can be repeated any number of times. Item filters can be applied to a dimension on the format &lt;item-id&gt;:&lt;operator&gt;:&lt;filter&gt;. Filter values are case-insensitive.</td>
<td></td>
</tr>
<tr class="odd">
<td>hierarchyMeta</td>
<td>No</td>
<td>Include names of organisation unit ancestors and hierarchy paths of organisation units in the metadata.</td>
<td>false | true</td>
</tr>
<tr class="even">
<td>eventStatus</td>
<td>No</td>
<td>Specify status of events to include.</td>
<td>ACTIVE | COMPLETED | SCHEDULE | OVERDUE | SKIPPED</td>
</tr>
<tr class="odd">
<td>programStatus</td>
<td>No</td>
<td>Specify enrollment status of events to include.</td>
<td>ACTIVE | COMPLETED | CANCELLED</td>
</tr>
<tr class="even">
<td>relativePeriodDate</td>
<td>string</td>
<td>No</td>
<td>Date identifier e.g: &quot;2016-01-01&quot;. Overrides the start date of the relative period</td>
</tr>
<tr class="odd">
<td>columns</td>
<td>No</td>
<td>Dimensions to use as columns for table layout.</td>
<td>Any dimension (must be query dimension)</td>
</tr>
<tr class="even">
<td>rows</td>
<td>No</td>
<td>Dimensions to use as rows for table layout.</td>
<td>Any dimension (must be query dimension)</td>
</tr>
</tbody>
</table>

<table>
<caption>Query parameters for event query analytics only</caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 11%" />
<col style="width: 48%" />
<col style="width: 19%" />
</colgroup>
<thead>
<tr class="header">
<th>Query parameter</th>
<th>Required</th>
<th>Description</th>
<th>Options</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ouMode</td>
<td>No</td>
<td>The mode of selecting organisation units. Default is DESCENDANTS, meaning all sub units in the hierarchy. CHILDREN refers to immediate children in the hierarchy; SELECTED refers to the selected organisation units only.</td>
<td>DESCENDANTS, CHILDREN, SELECTED</td>
</tr>
<tr class="even">
<td>asc</td>
<td>No</td>
<td>Dimensions to be sorted ascending, can reference event date, org unit name and code and any item identifiers.</td>
<td>EVENTDATE | OUNAME | OUCODE | item identifier</td>
</tr>
<tr class="odd">
<td>desc</td>
<td>No</td>
<td>Dimensions to be sorted descending, can reference event date, org unit name and code and any item identifiers.</td>
<td>EVENTDATE | OUNAME | OUCODE | item identifier</td>
</tr>
<tr class="even">
<td>coordinatesOnly</td>
<td>No</td>
<td>Whether to only return events which have coordinates.</td>
<td>false | true</td>
</tr>
<tr class="odd">
<td>dataIdScheme</td>
<td>No</td>
<td>Id scheme to be used for data, more specifically data elements and attributes which have an option set or legend set, e.g. return the name of the option instead of the code, or the name of the legend instead of the legend ID, in the data response.</td>
<td>NAME | CODE | UID</td>
</tr>
<tr class="even">
<td>page</td>
<td>No</td>
<td>The page number. Default page is 1.</td>
<td>Numeric positive value</td>
</tr>
<tr class="odd">
<td>pageSize</td>
<td>No</td>
<td>The page size. Default size is 50 items per page.</td>
<td>Numeric zero or positive value</td>
</tr>
</tbody>
</table>

<table>
<caption>Query parameters for aggregate event analytics only</caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 11%" />
<col style="width: 48%" />
<col style="width: 19%" />
</colgroup>
<thead>
<tr class="header">
<th>Query parameter</th>
<th>Required</th>
<th>Description</th>
<th>Options</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>value</td>
<td>No</td>
<td>Value dimension identifier. Can be a data element or an attribute which must be of numeric value type.</td>
<td>Data element or attribute identifier</td>
</tr>
<tr class="even">
<td>aggregationType</td>
<td>No</td>
<td>Aggregation type for the value dimension. Default is AVERAGE.</td>
<td>SUM | AVERAGE | AVERAGE_SUM_ORG_UNIT | LAST | LAST_AVERAGE_ORG_UNIT | COUNT | STDDEV | VARIANCE | MIN | MAX</td>
</tr>
<tr class="odd">
<td>showHierarchy</td>
<td>No</td>
<td>Display full org unit hierarchy path together with org unit name.</td>
<td>false | true</td>
</tr>
<tr class="even">
<td>displayProperty</td>
<td>No</td>
<td>Property to display for metadata.</td>
<td>NAME | SHORTNAME</td>
</tr>
<tr class="odd">
<td>sortOrder</td>
<td>No</td>
<td>Sort the records on the value column in ascending or descending order.</td>
<td>ASC | DESC</td>
</tr>
<tr class="even">
<td>limit</td>
<td>No</td>
<td>The maximum number of records to return. Cannot be larger than 10 000.</td>
<td>Numeric positive value</td>
</tr>
<tr class="odd">
<td>outputType</td>
<td>No</td>
<td>Specify output type for analytical data which can be events, enrollments or tracked entity instances. The two last options apply to programs with registration only.</td>
<td>EVENT | ENROLLMENT | TRACKED_ENTITY_INSTANCE</td>
</tr>
<tr class="even">
<td>collapseDataDimensions</td>
<td>No</td>
<td>Collapse all data dimensions (data elements and attributes) into a single dimension in the response.</td>
<td>false | true</td>
</tr>
<tr class="odd">
<td>skipMeta</td>
<td>No</td>
<td>Exclude the meta data part of the response (improves performance).</td>
<td>false | true</td>
</tr>
<tr class="even">
<td>skipData</td>
<td>No</td>
<td>Exclude the data part of the response.</td>
<td>false | true</td>
</tr>
<tr class="odd">
<td>skipRounding</td>
<td>No</td>
<td>Skip rounding of aggregate data values.</td>
<td>false | true</td>
</tr>
<tr class="even">
<td>aggregateData</td>
<td>No</td>
<td>Produce aggregate values for the data dimensions (as opposed to dimension items).</td>
<td>false | true</td>
</tr>
<tr class="odd">
<td>timeField</td>
<td>No</td>
<td>The time field to base event aggregation on. Applies to event data items only. Can be a predefined option or the ID of an attribute or data element having a time-based value type.</td>
<td>EVENT_DATE | ENROLLMENT_DATE | INCIDENT_DATE | DUE_DATE | COMPLETED_DATE | &lt;Attribute ID&gt; | &lt;Data element ID&gt;</td>
</tr>
<tr>
<td>orgUnitField</td>
<td>No</td>
<td>The organisation unit field to base event aggregation on. Applies to event data items only. Can be the ID of an attribute or data element with the Organisation unit value type. The default option is specified as omitting the query parameter.
<td>&lt;Attribute ID&gt; | &lt;Data element ID&gt;</td>
</tr>
</tbody>
</table>

<table>
<caption>Query parameters for cluster event analytics only</caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 11%" />
<col style="width: 49%" />
<col style="width: 19%" />
</colgroup>
<thead>
<tr class="header">
<th>Query parameter</th>
<th>Required</th>
<th>Description</th>
<th>Options</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>clusterSize</td>
<td>Yes</td>
<td>Size of clusters in meters.</td>
<td>Numeric positive value</td>
</tr>
<tr class="even">
<td>coordinateField</td>
<td>No</td>
<td>Field to base geospatial event analytics on. Default is event. Can be set to identifiers of attributes and data elements of value type coordinate.</td>
<td>EVENT | &lt;attribute-id&gt; | &lt;dataelement-id&gt;</td>
</tr>
<tr class="odd">
<td>bbox</td>
<td>Yes</td>
<td>Bounding box / area of events to include in the response on the format &quot;min longitude, min latitude, max longitude , max latitude&quot;.</td>
<td>String</td>
</tr>
<tr class="even">
<td>includeClusterPoints</td>
<td>No</td>
<td>Include information about underlying points for each cluster, be careful if cluster represent a very high number of points.</td>
<td>false | true</td>
</tr>
</tbody>
</table>

### Analyse des requêtes d'événements { #webapi_event_query_analytics } 

<!--DHIS2-SECTION-ID:webapi_event_query_analytics-->

La ressource *analytics/events/query* vous permet d'effectuer des requêtes sur des événements capturés. Cette ressource ne fait pas d'agrégation, elle vous permet plutôt de lancer des requêtes et de filtrer des informations sur les événements.

    /api/33/analytics/events/query

Vous pouvez spécifier un nombre quelconque de dimensions et de filtres dans une requête. Les identifiants d'éléments de dimension peuvent faire référence à des éléments de données, des attributs de personnes, des identifiants de personnes, des périodes fixes et relatives et des unités d'organisation. Les dimensions peuvent éventuellement être accompagnées d'un opérateur de requête et d'un filtre. Les requêtes d'événements doivent respecter le format décrit ci-dessous.

    /api/33/analytics/events/query/<program-id>?startDate=yyyy-MM-dd&endDate=yyyy-MM-dd
      &dimension=ou:<ou-id>;<ou-id>&dimension=<item-id>&dimension=<item-id>:<operator>:<filter>

Par exemple, pour extraire des événements du programme "Morbidité et mortalité chez les patients hospitalisés" entre janvier et octobre 2016, où les éléments de données "Sexe" et "Âge" sont inclus et où la dimension "Âge" est filtrée sur "18 ans", vous pouvez utiliser la requête suivante :

    /api/33/analytics/events/query/eBAyeGv0exc?startDate=2016-01-01&endDate=2016-10-31
      &dimension=ou:O6uvpzGd5pu;fdc6uOvgoji&dimension=oZg33kd9taw&dimension=qrur9Dvnyt5:EQ:18

Pour extraire les événements de l'étape "Naissance" du "Programme pour les enfants" entre mars et décembre 2016, où l'élément de données "Poids" est filtré pour les valeurs supérieures à 2000, vous pouvez utiliser ce qui suit :

    /api/33/analytics/events/query/IpHINAT79UW?stage=A03MvHHogjR&startDate=2016-03-01
      &endDate=2016-12-31&dimension=ou:O6uvpzGd5pu&dimension=UXz7xuGCEhU:GT:2000

Le tri peut être appliqué à la requête pour la date de l'événement et toutes les dimensions. Pour effectuer un tri par ordre décroissant sur la date de l'événement et par ordre croissant sur la dimension de l'élément de données "Âge", vous pouvez utiliser ceci :

    /api/33/analytics/events/query/eBAyeGv0exc?startDate=2016-01-01&endDate=2016-10-31
      &dimension=ou:O6uvpzGd5pu&dimension=qrur9Dvnyt5&desc=EVENTDATE&asc=qrur9Dvnyt5

Vous pouvez appliquer la pagination à la requête à travers les paramètres de numéro de page et de taille de page. Si le numéro de page est spécifié mais que la taille de la page ne l'est pas, la taille de page "50" sera utilisée. Si la taille de la page est spécifiée mais que le numéro de page ne l'est pas, le numéro de page "1" sera utilisé. Pour obtenir la troisième page de la réponse avec une taille de page de 20, vous pouvez utiliser la requête suivante :

    /api/33/analytics/events/query/eBAyeGv0exc?startDate=2016-01-01&endDate=2016-10-31
      &dimension=ou:O6uvpzGd5pu&dimension=qrur9Dvnyt5&page=3&pageSize=20

#### Filtrage { #filtering } 

Des filtres peuvent être appliqués aux éléments de données, aux attributs de personnes et aux identifiants de personnes. Le filtrage est effectué par le biais de la valeur du paramètre de la requête dans le format suivant :

    &dimension=<item-id>:<operator>:<filter-value>

À titre d'exemple, vous pouvez filtrer l'élément de données "Poids" pour les valeurs supérieures à 2000 et inférieures à 4000 comme suit :

    &dimension=UXz7xuGCEhU:GT:2000&dimension=UXz7xuGCEhU:LT:4000

Vous pouvez filtrer l'élément de données "Âge" pour plusieurs âges spécifiques à l'aide de l'opérateur IN comme dans l'exemple suivant :

    &dimension=qrur9Dvnyt5:IN:18;19;20

Vous pouvez spécifier plusieurs filtres pour un élément donné en répétant les composants de l'opérateur et du filtre, tous séparés par des points-virgules :

    &dimension=qrur9Dvnyt5:GT:5:LT:15

Les opérateurs disponibles sont répertoriés ci-dessous.

<table>
<caption>Filter operators</caption>
<colgroup>
<col style="width: 19%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="header">
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>EQ</td>
<td>Equal to</td>
</tr>
<tr class="even">
<td>GT</td>
<td>Greater than</td>
</tr>
<tr class="odd">
<td>GE</td>
<td>Greater than or equal to</td>
</tr>
<tr class="even">
<td>LT</td>
<td>Less than</td>
</tr>
<tr class="odd">
<td>LE</td>
<td>Less than or equal to</td>
</tr>
<tr class="even">
<td>NE</td>
<td>Not equal to</td>
</tr>
<tr class="odd">
<td>LIKE</td>
<td>Like (free text match)</td>
</tr>
<tr class="even">
<td>IN</td>
<td>Equal to one of multiple values separated by &quot;;&quot;</td>
</tr>
</tbody>
</table>

#### Formats de réponse { #response-formats } 

Le format de représentation de la réponse par défaut est JSON. Les requêtes doivent utiliser la méthode HTTP *GET*. Les formats de réponse suivants sont pris en charge.

  - json (application/json)

  - jsonp (application/javascript)

  - xls (application/vnd.ms-excel)

À titre d'exemple, pour obtenir une réponse au format Excel vous pouvez utiliser une extension de fichier dans l'URL de la requête comme ceci :

    /api/33/analytics/events/query/eBAyeGv0exc.xls?startDate=2016-01-01&endDate=2016-10-31
      &dimension=ou:O6uvpzGd5pu&dimension=oZg33kd9taw&dimension=qrur9Dvnyt5

Vous pouvez définir le paramètre de requête hierarchyMeta (hiérarchie de métadonnées) sur "true" pour inclure les noms de toutes les unités d'organisation ascendantes dans la section métadonnées de la réponse :

    /api/33/analytics/events/query/eBAyeGv0exc?startDate=2016-01-01&endDate=2016-10-31
      &dimension=ou:YuQRtpLP10I&dimension=qrur9Dvnyt5:EQ:50&hierarchyMeta=true

Le format JSON de réponse par défaut ressemblera à ceci :

```json
{
  "headers": [
    {
      "name": "psi",
      "column": "Event",
      "type": "java.lang.String",
      "hidden": false,
      "meta": false
    },
    {
      "name": "ps",
      "column": "Program stage",
      "type": "java.lang.String",
      "hidden": false,
      "meta": false
    },
    {
      "name": "eventdate",
      "column": "Event date",
      "type": "java.lang.String",
      "hidden": false,
      "meta": false
    },
    {
      "name": "coordinates",
      "column": "Coordinates",
      "type": "java.lang.String",
      "hidden": false,
      "meta": false
    },
    {
      "name": "ouname",
      "column": "Organisation unit name",
      "type": "java.lang.String",
      "hidden": false,
      "meta": false
    },
    {
      "name": "oucode",
      "column": "Organisation unit code",
      "type": "java.lang.String",
      "hidden": false,
      "meta": false
    },
    {
      "name": "ou",
      "column": "Organisation unit",
      "type": "java.lang.String",
      "hidden": false,
      "meta": false
    },
    {
      "name": "oZg33kd9taw",
      "column": "Gender",
      "type": "java.lang.String",
      "hidden": false,
      "meta": false
    },
    {
      "name": "qrur9Dvnyt5",
      "column": "Age",
      "type": "java.lang.String",
      "hidden": false,
      "meta": false
    }
  ],
  "metaData": {
    "names": {
      "qrur9Dvnyt5": "Age",
      "eBAyeGv0exc": "Inpatient morbidity and mortality",
      "ImspTQPwCqd": "Sierra Leone",
      "O6uvpzGd5pu": "Bo",
      "YuQRtpLP10I": "Badjia",
      "oZg33kd9taw": "Gender"
    },
    "ouHierarchy": {
      "YuQRtpLP10I": "/ImspTQPwCqd/O6uvpzGd5pu"
    }
  },
  "width": 8,
  "height": 4,
  "rows": [
    [
      "yx9IDINf82o",
      "Zj7UnCAulEk",
      "2016-08-05",
      "[5.12, 1.23]",
      "Ngelehun",
      "OU_559",
      "YuQRtpLP10I",
      "Female",
      "50"
    ],
    [
      "IPNa7AsCyFt",
      "Zj7UnCAulEk",
      "2016-06-12",
      "[5.22, 1.43]",
      "Ngelehun",
      "OU_559",
      "YuQRtpLP10I",
      "Female",
      "50"
    ],
    [
      "ZY9JL9dkhD2",
      "Zj7UnCAulEk",
      "2016-06-15",
      "[5.42, 1.33]",
      "Ngelehun",
      "OU_559",
      "YuQRtpLP10I",
      "Female",
      "50"
    ],
    [
      "MYvh4WAUdWt",
      "Zj7UnCAulEk",
      "2016-06-16",
      "[5.32, 1.53]",
      "Ngelehun",
      "OU_559",
      "YuQRtpLP10I",
      "Female",
      "50"
    ]
  ]
}
```

La section *en-têtes* de la réponse décrit le contenu du résultat de la requête. L'identifiant unique de l'événement, l'identifiant de l'étape de programme, la date de l'événement, le nom de l'unité d'organisation, le code de l'unité d'organisation et l'identifiant de l'unité d'organisation apparaissent en tant que six premières dimensions dans la réponse et seront toujours présents. Viennent ensuite les éléments de données, les attributs et identifiants de personnes qui ont été définis comme dimensions dans la demande ; il s'agit dans ce cas précis des dimensions d'éléments de données "Sexe" et "Âge". L'identifiant de l'élément de dimension se trouve dans la propriété "nom" et une description lisible de la dimension dans la propriété "colonne" de la section en-têtes.

La section *metaData*, objet *ou* (unité d'organisation), contient les identifiants de toutes les unités d'organisation présentes dans la réponse, mis en correspondance avec une chaîne qui représente la hiérarchie. Cette chaîne hiérarchique énumère les identifiants des ascendants de l'unité d'organisation en commençant par la racine. L'objet *noms* contient les identifiants de tous les éléments de la réponse mis en correspondance avec leurs noms.

La section *lignes* contient les événements produits par la requête. Chaque ligne représente exactement un événement.

Pour que la ressource analytique des événements génère les données dans un tableau tout fait, vous pouvez renseigner les paramètres *lignes* et *colonnes* avec les identifiants des dimensions requises. Ces identifiants doivent être séparés par des points-virgules ; elles serviront de valeurs pour indiquer quelles dimensions doivent être utilisées comme colonnes ou lignes du tableau. Au lieu de générer une source de données simples et normalisées, la ressource analytique d'événements va maintenant générer les données dans un tableau. Dans la requête, les dimensions des colonnes et des lignes doivent figurer en tant que dimensions de données (et non en tant que filtre). Une telle requête peut ressembler à ceci :

    /api/33/analytics.html+css?dimension=dx:cYeuwXTCPkU;fbfJHSPpUQD&dimension=pe:WEEKS_THIS_YEAR
      &filter=ou:ImspTQPwCqd&displayProperty=SHORTNAME&columns=dx&rows=pe

### Analyse agrégée des événements { #webapi_event_aggregate_analytics } 

<!--DHIS2-SECTION-ID:webapi_event_aggregate_analytics-->

La ressource `/analytics/events/aggregate` vous permet d'extraire des *nombres agrégés* d'événements capturés dans DHIS2. Cette ressource vous permet d'extraire des données agrégées liés à un programme spécifique ou éventuellement à une étape de programme. Elle vous permet également d'effectuer des filtrages en fonction d'une dimension d'événement quelconque.

    /api/33/analytics/events/aggregate

La ressource d'agrégation des événements ne renvoie pas les informations relatives à l'événement lui-même, mais plutôt les nombres agrégés d'événements correspondant à la requête. Les dimensions d'événements comprennent les éléments de données, les attributs de personnes, les identifiants de personnes, les périodes et les unités d'organisation. Les requêtes d'agrégation des événements doivent respecter le format décrit ci-dessous.

    /api/33/analytics/events/aggregate/<program-id>?startDate=yyyy-MM-dd&endDate=yyyy-MM-dd
      &dimension=ou:<ou-id>;<ou-id>&dimension=<item-id>&dimension=<item-id>:<operator>:<filter>

Par exemple, pour extraire des nombres agrégés des événements du programme "Morbidité et mortalité chez les patients hospitalisés" entre janvier et octobre 2016, où les éléments de données "Sexe" et "Âge" sont inclus, avec l'élément de dimension "Âge" filtré sur "18 ans" et l'élément de dimension "Sexe"  filtré sur "Femme", vous pouvez utiliser la requête suivante :

    /api/33/analytics/events/aggregate/eBAyeGv0exc?startDate=2016-01-01&endDate=2016-10-31
      &dimension=ou:O6uvpzGd5pu&dimension=oZg33kd9taw:EQ:Female&dimension=qrur9Dvnyt5:GT:50

Pour extraire des données relatives à des périodes fixes et relatives au lieu des dates de début et de fin, dans ce cas, mai 2016 et les 12 derniers mois, et l'unité d'organisation associée à l'utilisateur actuel, vous pouvez utiliser la requête suivante :

    /api/33/analytics/events/aggregate/eBAyeGv0exc?dimension=pe:201605;LAST_12_MONTHS
      &dimension=ou:USER_ORGUNIT;fdc6uOvgo7ji&dimension=oZg33kd9taw

Afin de spécifier "Femme" comme filtre pour le "Sexe" dans la réponse, ce qui signifie que "Sexe" ne fera pas partie de la réponse mais filtrera les nombres agrégés qu'il contient, vous pouvez utiliser la syntaxe suivante :

    /api/33/analytics/events/aggregate/eBAyeGv0exc?dimension=pe:2016;
      &dimension=ou:O6uvpzGd5pu&filter=oZg33kd9taw:EQ:Female

Pour spécifier l'unité d'organisation "Bo" et la période "2016" comme filtres, et le "Mode de sortie" et le "Sexe" comme dimensions, où le "Sexe" est filtré en fonction de l'élément "Masculin", vous pouvez utiliser une requête comme celle-ci :

    /api/33/analytics/events/aggregate/eBAyeGv0exc?filter=pe:2016&filter=ou:O6uvpzGd5pu
      &dimension=fWIAEtYVEGk&dimension=oZg33kd9taw:EQ:Male

Pour créer un "rapport de Top 3" pour le _Mode de sortie_, vous pouvez utiliser les paramètres de requête "limit" (limite) et sortOrder (ordre de tri) de la manière suivante :

    /api/33/analytics/events/aggregate/eBAyeGv0exc?filter=pe:2016&filter=ou:O6uvpzGd5pu
      &dimension=fWIAEtYVEGk&limit=3&sortOrder=DESC

Pour spécifier une dimension de valeur avec un type d'agrégation correspondant, vous pouvez utiliser les paramètres de requête "value" (valeur) et "aggregationType" (type d'aggrégation). En spécifiant une dimension de valeur, le moteur d'analyse renverra des valeurs agrégées pour les valeurs de cette dimension dans la réponse, plutôt que des nombres d'événements.

    /api/33/analytics/events/aggregate/eBAyeGv0exc.json?stage=Zj7UnCAulEk
      &dimension=ou:ImspTQPwCqd&dimension=pe:LAST_12_MONTHS&dimension=fWIAEtYVEGk
      &value=qrur9Dvnyt5&aggregationType=AVERAGE

Pour que l'agrégation des analyses d'événements se fasse en fonction d'un élément de données ou d'un attribut spécifique de type 'date' ou 'date et heure', vous pouvez utiliser le paramètre `timeField` (champ de temps) :

    /api/33/analytics/events/aggregate/IpHINAT79UW.json?dimension=ou:ImspTQPwCqd
      &dimension=pe:LAST_12_MONTHS&dimension=cejWyOfXge6&stage=A03MvHHogjR
      &timeField=ENROLLMENT_DATE

Pour que l'agrégation des analyses d'événements se fasse en fonction d'un élément de données ou d'un attribut spécifique de type 'unité d'organisation', vous pouvez utiliser le paramètre `orgUnitField` (champ d'unité d'organisation) :

    /api/33/analytics/events/aggregate/eBAyeGv0exc.json?dimension=ou:ImspTQPwCqd
      &dimension=pe:THIS_YEAR&dimension=oZg33kd9taw&stage=Zj7UnCAulEk
      &orgUnitField=S33cRBsnXPo

#### Plages / jeux de légendes { #ranges-legend-sets } 

Pour les requêtes d'agrégation, vous pouvez spécifier une plage ou un ensemble de légendes pour les éléments de données numériques et les dimensions d'attributs. L'objectif est de regrouper les valeurs numériques dans des plages. Par exemple, au lieu de générer des données pour un élément de données "Âge" pour des années différentes, vous pouvez regrouper les informations par tranche d'âge. Pour ce faire, l'élément de données ou l'attribut doit être associé à l'ensemble de légendes. Le format est décrit ci-dessous :

    ?dimension=<item-id>-<legend-set-id>

Voici donc un exemple :

    /api/33/analytics/events/aggregate/eBAyeGv0exc.json?stage=Zj7UnCAulEk
      &dimension=qrur9Dvnyt5-Yf6UHoPkdS6&dimension=ou:ImspTQPwCqd&dimension=pe:LAST_MONTH

#### Formats de réponse { #response-formats } 

Le format de représentation de réponse par défaut est JSON. Les requêtes doivent utiliser la méthode HTTP *GET*. La réponse va ressembler à ceci :

```json
{
  "headers": [
    {
      "name": "oZg33kd9taw",
      "column": "Gender",
      "type": "java.lang.String",
      "meta": false
    },
    {
      "name": "qrur9Dvnyt5",
      "column": "Age",
      "type": "java.lang.String",
      "meta": false
    },
    {
      "name": "pe",
      "column": "Period",
      "type": "java.lang.String",
      "meta": false
    },
    {
      "name": "ou",
      "column": "Organisation unit",
      "type": "java.lang.String",
      "meta": false
    },
    {
      "name": "value",
      "column": "Value",
      "type": "java.lang.String",
      "meta": false
    }
  ],
  "metaData": {
    "names": {
      "eBAyeGv0exc": "Inpatient morbidity and mortality"
    }
  },
  "width": 5,
  "height": 39,
  "rows": [
    [
      "Female",
      "95",
      "201605",
      "O6uvpzGd5pu",
      "2"
    ],
    [
      "Female",
      "63",
      "201605",
      "O6uvpzGd5pu",
      "2"
    ],
    [
      "Female",
      "67",
      "201605",
      "O6uvpzGd5pu",
      "1"
    ],
    [
      "Female",
      "71",
      "201605",
      "O6uvpzGd5pu",
      "1"
    ],
    [
      "Female",
      "75",
      "201605",
      "O6uvpzGd5pu",
      "14"
    ],
    [
      "Female",
      "73",
      "201605",
      "O6uvpzGd5pu",
      "5"
    ]
  ]
}
```

Note that the max limit for rows to return in a single response is 10 000. 
If the query produces more than the max limit, a *409 Conflict* status code 
will be returned.

### Analyse des événements en grappes{ #webapi_event_clustering_analytics } 

<!--DHIS2-SECTION-ID:webapi_event_clustering_analytics-->

La ressource *analytics/events/cluster* fournit des données géospatiales en grappe. Une requête se présente comme suit :

    /api/33/analytics/events/cluster/eBAyeGv0exc?startDate=2016-01-01&endDate=2016-10-31
      &dimension=ou:LEVEL-2&clusterSize=100000
      &bbox=-13.2682125,7.3721619,-10.4261178,9.904012&includeClusterPoints=false

La réponse fournit le nombre de points sous-jacents, le point central et l'étendue de chaque grappe. Si le paramètre de requête `includeClusterPoints` (inclure des points en grappe) est défini sur 'true' (vrai), une chaîne contenant les identifiants des événements sous-jacents, séparés par des virgules, sera incluse dans la réponse. Voici un exemple de réponse :

```json
{
  "headers": [
    {
      "name": "count",
      "column": "Count",
      "type": "java.lang.Long",
      "meta": false
    },
    {
      "name": "center",
      "column": "Center",
      "type": "java.lang.String",
      "meta": false
    },
    {
      "name": "extent",
      "column": "Extent",
      "type": "java.lang.String",
      "meta": false
    },
    {
      "name": "points",
      "column": "Points",
      "type": "java.lang.String",
      "meta": false
    }
  ],
  "width": 3,
  "height": 4,
  "rows": [
    [
      "3",
      "POINT(-13.15818 8.47567)",
      "BOX(-13.26821 8.4St7215,-13.08711 8.47807)",
      ""
    ],
    [
      "9",
      "POINT(-13.11184 8.66424)",
      "BOX(-13.24982 8.51961,-13.05816 8.87696)",
      ""
    ],
    [
      "1",
      "POINT(-12.46144 7.50597)",
      "BOX(-12.46144 7.50597,-12.46144 7.50597)",
      ""
    ],
    [
      "7",
      "POINT(-12.47964 8.21533)",
      "BOX(-12.91769 7.66775,-12.21011 8.49713)",
      ""
    ]
  ]
}
```

### Analyse du nombre d'événements et de la portée { #webapi_event_count_extent_analytics } 

<!--DHIS2-SECTION-ID:webapi_event_count_extent_analytics-->

The *analytics/events/count* resource is suitable for geometry-related
requests for retrieving the count and extent (bounding box) of events
for a specific query. The query syntax is equal to the *events/query*
resource. A request looks like
    this:

    /api/33/analytics/events/count/eBAyeGv0exc?startDate=2016-01-01
      &endDate=2016-10-31&dimension=ou:O6uvpzGd5pu

La réponse va fournir le nombre et l'étendue dans le format JSON :

```json
{
  extent: "BOX(-13.2682125910096 7.38679562779441,-10.4261178860988 9.90401290212795)",
  count: 59
}
```

### Contraintes et validation { #webapi_event_analytics_constraints } 

<!--DHIS2-SECTION-ID:webapi_event_analytics_constraints-->

Les paramètres d'entrée que vous pouvez fournir à la ressource d'analyse des événements sont soumis à plusieurs contraintes. Si l'une de ces contraintes n'est pas respectée, l'API renvoie une réponse *409 Conflict* avec un message semblable à celui-ci :

```json
{
  "httpStatus": "Conflict",
  "httpStatusCode": 409,
  "status": "ERROR",
  "message": "At least one organisation unit must be specified",
  "errorCode": "E7200"
}
```

The possible validation errors for the event analytics API are described 
in the table below.

| Code d'erreur | Message |
| ---------- | ------- |
| E7200      | Au moins une unité d'organisation doit être spécifiée |
| E7201      | Les dimensions ne peuvent pas être spécifiées plus d'une fois |
| E7202      | Les éléments de la requête ne peuvent pas être spécifiés plus d'une fois |
| E7203      | Une dimension de valeur ne peut pas être spécifiée en tant qu'élément ou filtre d'élément. |
| E7204      | La dimension de valeur ou les données agrégées doivent être spécifiées lorsque le type d'agrégation est spécifié. |
| E7205      | Les dates de début et de fin ou au moins une période doivent être spécifiées. |
| E7206      | La date de début est postérieure à la date de fin |
| E7207      | Le numéro de page doit être un nombre positif |
| E7208      | La taille de la page doit être zéro ou nombre positif |
| E7209      | La limite est supérieure à la limite maximale |
| E7210      | Le champ de l'heure n'est pas valide |
| E7211      | Le champ de l'unité d'organisation n'est pas valide |
| E7212      | La taille de la grappe doit être un nombre positif |
| E7213      | La zone de délimitation n'est pas valide ; elle doit être au format : 'min-lng,min-lat,max-lng,max-lat' |
| E7214      | Le champ de la grappe doit être renseigné lorsque la zone de délimitation ou la taille de la grappe sont spécifiées. |
| E7215      | L'élément de requête ne peut pas spécifier à la fois un ensemble de légendes et un ensemble d'options. |
| E7216      | L'élément de requête doit pouvoir être agrégé lorsqu'il est utilisé dans une requête agrégée. |
| E7217      | L'utilisateur n'est pas autorisé à consulter les données d'analyse des événements |
| E7218      | La prise en charge des bases de données spatiales n'est pas activée |
| E7219      | L'élément de données doit être de type "coordonnée" pour pouvoir être utilisé comme champ de coordonnées. |
| E7220      | L'attribut doit être de type "coordonnée" pour pouvoir être utilisé comme champ de coordonnées. |
| E7221      | Le champ de coordonnées n'est pas valide |
| E7222      | L'élément de requête ou le filtre n'est pas valide |
| E7223      | La valeur ne fait pas référence à un élément de données ou à un attribut qui sont numériques et font partie du programme. |
| E7224      | L'identifiant d'élément ne fait référence à aucun élément de données, attribut ou indicateur qui fait partie du programme. |
| E7225      | L'étape de programme est obligatoire pour les dimensions de l'élément de données dans les requêtes d'analyse d'inscriptions. |
| E7226      | La dimension n'est pas un élément de requête valide |
| E7227      | Le type d'entité 'relation' n'est pas pris en charge |

## Analyse des inscriptions { #webapi_enrollment_analytics } 

<!--DHIS2-SECTION-ID:webapi_enrollment_analytics-->

L'API d'analyse des inscriptions vous permet d'accéder aux données agrégées des événements et d'interroger les *inscriptions avec leurs données d'événements* capturées dans DHIS2. Cette ressource vous permet d'extraire des données d'un programme à partir des étapes du programme et des éléments de données, en plus des attributs d'entités suivies. Lorsque vous effectuez une requête sur des données d'événements pour des étapes spécifiques d'un programme au sein de chaque inscription, les valeurs des éléments de données pour chaque étape du programme seront renvoyées dans une même ligne dans la réponse de l'API. Si vous effectuez une requête sur un élément de données dans une étape répétable du programme, la valeur la plus récente de l'élément de données sera utilisée pour cet élément de données dans la réponse de l'API.

### Dimensions et éléments { #webapi_enrollment_analytics_dimensions } 

<!--DHIS2-SECTION-ID:webapi_enrollment_analytics_dimensions-->

Les dimensions d'inscription comprennent les éléments de données, les attributs, les unités d'organisation et les périodes. La ressource d'analyse des requêtes renvoie simplement les inscriptions correspondant à un ensemble de critères et n'effectue aucune agrégation.

<table>
<caption>Enrollment dimensions</caption>
<colgroup>
<col style="width: 27%" />
<col style="width: 11%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="header">
<th>Dimension</th>
<th>Dimension id</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Data elements in program stages</td>
<td>&lt;program stage id&gt;.&lt;data element id&gt;</td>
<td>Data element identifiers must include the program stage when querying data for enrollments.

    dimension=edqlbukwRfQ.vANAXwtLwcT

</td>
</tr>
<tr>
<td>Attributes</td>
<td>&lt;id&gt;</td>
<td>Attribute identifiers</td>
</tr>
<tr>
<td>Periods</td>
<td>pe</td>
<td>ISO periods and relative periods, see &quot;date and period format&quot;</td>
</tr>
<tr>
<td>Organisation units</td>
<td>ou</td>
<td>Organisation unit identifiers and keywords USER_ORGUNIT, USER_ORGUNIT_CHILDREN, USER_ORGUNIT_GRANDCHILDREN, LEVEL-&lt;level&gt; and OU_GROUP-&lt;group-id&gt;</td>
</tr>
</tbody>
</table>

### Analyse des requêtes d'inscription { #webapi_enrollment_query_analytics } 

<!--DHIS2-SECTION-ID:webapi_enrollment_query_analytics-->

The *analytics/enrollments/query* resource lets you query for captured enrollments. This resource does not perform any aggregation, rather it lets you query and filter for information about enrollments.

    /api/33/analytics/enrollments/query

Vous pouvez spécifier un nombre quelconque de dimensions et de filtres dans une requête. Les identifiants d'éléments de dimension peuvent faire référence à tout élément de données dans des étapes de programme, des attributs de personnes, des périodes fixes et relatives et des unités d'organisation. Les dimensions peuvent éventuellement être accompagnées d'un opérateur de requête et d'un filtre. Les requêtes d'inscription doivent respecter le format décrit ci-dessous.

    /api/33/analytics/enrollments/query/<program-id>?startDate=yyyy-MM-dd&endDate=yyyy-MM-dd
      &dimension=ou:<ou-id>;<ou-id>&dimension=<item-id>&dimension=<item-id>:<operator>:<filter>

Par exemple, pour extraire des inscriptions au programme "Soins prénatals" à partir de janvier 2019, où le "Prénom" est tiré des attributs, les éléments de données "Maladies chroniques" et "Tabagisme" sont inclus à partir de la première étape du programme, la "Valeur de l'hémoglobine" à partir de l'étape suivante du programme, et où seules les femmes atteintes de "Maladies chroniques" sont incluses, vous pouvez utiliser la requête suivante :

    /api/33/analytics/enrollments/query/WSGAb5XwJ3Y.json?dimension=ou:ImspTQPwCqd
      &dimension=w75KJ2mc4zz&dimension=WZbXY0S00lP.de0FEHSIoxh:eq:1&dimension=w75KJ2mc4zz
      &dimension=WZbXY0S00lP.sWoqcoByYmD&dimension=edqlbukwRfQ.vANAXwtLwcT
      &startDate=2019-01-01&endDate=2019-01-31

Pour extraire des inscriptions au programme "Soins prénatals" à partir du mois dernier (par rapport au moment où la requête est effectuée), où les éléments de données "Maladies chroniques" et "Tabagisme" sont inclus à partir de la première étape du programme, et "Valeur de l'hémoglobine" à partir de l'étape de suivi du programme, et où seules les femmes fumeuses avec un taux d'hémoglobine inférieur à 20 sont prises en compte :

    /api/33/analytics/enrollments/query/WSGAb5XwJ3Y.json?dimension=ou:ImspTQPwCqd
      &dimension=WZbXY0S00lP.de0FEHSIoxh&dimension=w75KJ2mc4zz
      &dimension=WZbXY0S00lP.sWoqcoByYmD:eq:1&dimension=edqlbukwRfQ.vANAXwtLwcT:lt:20
      &dimension=pe:LAST_MONTH

Un tri peut être appliqué à la requête pour les dates d'inscription et d'incident :

    /api/33/analytics/enrollments/query/WSGAb5XwJ3Y.xls?dimension=ou:ImspTQPwCqd
      &columns=w75KJ2mc4zz&dimension=WZbXY0S00lP.sWoqcoByYmD&dimension=pe:LAST_MONTH
      &stage=WZbXY0S00lP&pageSize=10&page=1&asc=ENROLLMENTDATE&ouMode=DESCENDANTS

Vous pouvez appliquer la pagination à la requête à travers les paramètres de numéro de page et de taille de page. Si le numéro de page est spécifié mais que la taille de la page ne l'est pas, la taille de page "50" sera utilisée. Si la taille de la page est spécifiée mais que le numéro de page ne l'est pas, le numéro de page "1" sera utilisé. Pour obtenir la deuxième page de la réponse avec une taille de page de 10, vous pouvez utiliser la requête suivante :

    /api/33/analytics/enrollments/query/WSGAb5XwJ3Y.json?dimension=ou:ImspTQPwCqd
      &dimension=WZbXY0S00lP.de0FEHSIoxh&dimension=w75KJ2mc4zz&dimension=pe:LAST_MONTH
      &dimension=WZbXY0S00lP.sWoqcoByYmD&pageSize=10&page=2

#### Filtrage { #filtering } 

Des filtres peuvent être appliqués aux éléments de données, aux attributs de personnes et aux identifiants de personnes. Le filtrage est effectué par le biais de la valeur du paramètre de la requête dans le format suivant :

    &dimension=<item-id>:<operator>:<filter-value>

À titre d'exemple, vous pouvez filtrer l'élément de données "Poids" pour les valeurs supérieures à 2000 et inférieures à 4000 comme suit :

    &dimension=WZbXY0S00lP.UXz7xuGCEhU:GT:2000&dimension=WZbXY0S00lP.UXz7xuGCEhU:LT:4000

Vous pouvez filtrer l'attribut "Âge" pour plusieurs âges spécifiques à l'aide de l'opérateur IN comme dans l'exemple suivant :

    &dimension=qrur9Dvnyt5:IN:18;19;20

Vous pouvez spécifier plusieurs filtres pour un élément donné en répétant les composants de l'opérateur et du filtre, tous séparés par des points-virgules :

    &dimension=qrur9Dvnyt5:GT:5:LT:15

Les opérateurs disponibles sont répertoriés ci-dessous.

<table>
<caption>Filter operators</caption>
<colgroup>
<col style="width: 19%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="header">
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>EQ</td>
<td>Equal to</td>
</tr>
<tr>
<td>GT</td>
<td>Greater than</td>
</tr>
<tr>
<td>GE</td>
<td>Greater than or equal to</td>
</tr>
<tr>
<td>LT</td>
<td>Less than</td>
</tr>
<tr>
<td>LE</td>
<td>Less than or equal to</td>
</tr>
<tr>
<td>NE</td>
<td>Not equal to</td>
</tr>
<tr>
<td>LIKE</td>
<td>Like (free text match)</td>
</tr>
<tr>
<td>IN</td>
<td>Equal to one of multiple values separated by &quot;;&quot;</td>
</tr>
</tbody>
</table>

### Paramètres de requête { #webapi_enrollment_analytics_query_parameters } 

<!--DHIS2-SECTION-ID:webapi_enrollment_analytics_query_parameters-->

L'API de requête d'inscription analytique vous permet de spécifier un ensemble de paramètres de requête.

<table>
<caption>Query parameters for enrollment query endpoint</caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 11%" />
<col style="width: 48%" />
<col style="width: 19%" />
</colgroup>
<thead>
<tr class="header">
<th>Query parameter</th>
<th>Required</th>
<th>Description</th>
<th>Options (default first)</th>
</tr>
</thead>
<tbody>
<tr>
<td>program</td>
<td>Yes</td>
<td>Program identifier.</td>
<td>Any program identifier</td>
</tr>
<tr>
<td>startDate</td>
<td>No</td>
<td>Start date for enrollments.</td>
<td>Date in yyyy-MM-dd format</td>
</tr>
<tr>
<td>endDate</td>
<td>No</td>
<td>End date for enrollments.</td>
<td>Date in yyyy-MM-dd format</td>
</tr>
<tr>
<td>dimension</td>
<td>Yes</td>
<td>Dimension identifier including data elements, attributes, program indicators, periods, organisation units and organisation unit group sets. Parameter can be repeated any number of times. Item filters can be applied to a dimension on the format &lt;item-id&gt;:&lt;operator&gt;:&lt;filter&gt;. Filter values are case-insensitive.</td>
<td>Operators can be EQ | GT | GE | LT | LE | NE | LIKE | IN</td>
</tr>
<tr>
<td>filter</td>
<td>No</td>
<td>Dimension identifier including data elements, attributes, periods, organisation units and organisation unit group sets. Parameter can be repeated any number of times. Item filters can be applied to a dimension on the format &lt;item-id&gt;:&lt;operator&gt;:&lt;filter&gt;. Filter values are case-insensitive.</td>
<td></td>
</tr>
<tr>
<td>programStatus</td>
<td>No</td>
<td>Specify enrollment status of enrollments to include.</td>
<td>ACTIVE | COMPLETED | CANCELLED</td>
</tr>
<tr>
<td>relativePeriodDate</td>
<td>string</td>
<td>No</td>
<td>Date identifier e.g: &quot;2016-01-01&quot;. Overrides the start date of the relative period</td>
</tr>
<tr>
<td>ouMode</td>
<td>No</td>
<td>The mode of selecting organisation units. Default is DESCENDANTS, meaning all sub units in the hierarchy. CHILDREN refers to immediate children in the hierarchy; SELECTED refers to the selected organisation units only.</td>
<td>DESCENDANTS, CHILDREN, SELECTED</td>
</tr>
<tr>
<td>asc</td>
<td>No</td>
<td>Dimensions to be sorted ascending, can reference enrollment date, incident date, org unit name and code.</td>
<td> ENROLLMENTDATE | INCIDENTDATE| OUNAME | OUCODE </td>
</tr>
<tr>
<td>desc</td>
<td>No</td>
<td>Dimensions to be sorted descending, can reference enrollment date, incident date, org unit name and code.</td>
<td> ENROLLMENTDATE | INCIDENTDATE| OUNAME | OUCODE </td>
</tr>
<td>hierarchyMeta</td>
<td>No</td>
<td>Include names of organisation unit ancestors and hierarchy paths of organisation units in the metadata.</td>
<td>false | true</td>
</tr>
<tr>
<td>coordinatesOnly</td>
<td>No</td>
<td>Whether to only return enrollments which have coordinates.</td>
<td>false | true</td>
</tr>
<tr>
<td>page</td>
<td>No</td>
<td>The page number. Default page is 1.</td>
<td>Numeric positive value</td>
</tr>
<tr>
<td>pageSize</td>
<td>No</td>
<td>The page size. Default size is 50 items per page.</td>
<td>Numeric zero or positive value</td>
</tr>
</tbody>
</table>

#### Formats de réponse { #response-formats } 

Le format de représentation de réponse par défaut est JSON. Les requêtes doivent utiliser la méthode HTTP *GET*. Les formats de réponse suivants sont pris en charge.

  - json (application/json)
  - xml (application/xml)
  - xls (application/vnd.ms-excel)
  - csv (application/csv)
  - html (texte/html)
  - html+css (texte/html)

À titre d'exemple, pour obtenir une réponse au format Excel, vous pouvez utiliser une extension de fichier dans l'URL de la requête comme ceci :

    /api/33/analytics/enrollments/query/WSGAb5XwJ3Y.xls?dimension=ou:ImspTQPwCqd
      &dimension=WZbXY0S00lP.de0FEHSIoxh&columns=w75KJ2mc4zz
      &dimension=WZbXY0S00lP.sWoqcoByYmD&dimension=pe:LAST_MONTH&stage=WZbXY0S00lP
      &pageSize=10&page=1&asc=ENROLLMENTDATE&ouMode=DESCENDANTS

Le format JSON de réponse par défaut ressemblera à ceci :

```json
{
  "headers": [
    {
      "name": "pi",
      "column": "Enrollment",
      "valueType": "TEXT",
      "type": "java.lang.String",
      "hidden": false,
      "meta": true
    },
    {
      "name": "tei",
      "column": "Tracked entity instance",
      "valueType": "TEXT",
      "type": "java.lang.String",
      "hidden": false,
      "meta": true
    },
    {
      "name": "enrollmentdate",
      "column": "Enrollment date",
      "valueType": "DATE",
      "type": "java.util.Date",
      "hidden": false,
      "meta": true
    },
    {
      "name": "incidentdate",
      "column": "Incident date",
      "valueType": "DATE",
      "type": "java.util.Date",
      "hidden": false,
      "meta": true
    },
    {
      "name": "geometry",
      "column": "Geometry",
      "valueType": "TEXT",
      "type": "java.lang.String",
      "hidden": false,
      "meta": true
    },
    {
      "name": "longitude",
      "column": "Longitude",
      "valueType": "NUMBER",
      "type": "java.lang.Double",
      "hidden": false,
      "meta": true
    },
    {
      "name": "latitude",
      "column": "Latitude",
      "valueType": "NUMBER",
      "type": "java.lang.Double",
      "hidden": false,
      "meta": true
    },
    {
      "name": "ouname",
      "column": "Organisation unit name",
      "valueType": "TEXT",
      "type": "java.lang.String",
      "hidden": false,
      "meta": true
    },
    {
      "name": "oucode",
      "column": "Organisation unit code",
      "valueType": "TEXT",
      "type": "java.lang.String",
      "hidden": false,
      "meta": true
    },
    {
      "name": "ou",
      "column": "Organisation unit",
      "valueType": "TEXT",
      "type": "java.lang.String",
      "hidden": false,
      "meta": true
    },
    {
      "name": "de0FEHSIoxh",
      "column": "WHOMCH Chronic conditions",
      "valueType": "BOOLEAN",
      "type": "java.lang.Boolean",
      "hidden": false,
      "meta": true
    },
    {
      "name": "sWoqcoByYmD",
      "column": "WHOMCH Smoking",
      "valueType": "BOOLEAN",
      "type": "java.lang.Boolean",
      "hidden": false,
      "meta": true
    }
  ],
  "metaData": {
    "pager": {
      "page": 2,
      "total": 163,
      "pageSize": 4,
      "pageCount": 41
    },
    "items": {
      "ImspTQPwCqd": {
        "name": "Sierra Leone"
      },
      "PFDfvmGpsR3": {
        "name": "Care at birth"
      },
      "bbKtnxRZKEP": {
        "name": "Postpartum care visit"
      },
      "ou": {
        "name": "Organisation unit"
      },
      "PUZaKR0Jh2k": {
        "name": "Previous deliveries"
      },
      "edqlbukwRfQ": {
        "name": "Antenatal care visit"
      },
      "WZbXY0S00lP": {
        "name": "First antenatal care visit"
      },
      "sWoqcoByYmD": {
        "name": "WHOMCH Smoking"
      },
      "WSGAb5XwJ3Y": {
        "name": "WHO RMNCH Tracker"
      },
      "de0FEHSIoxh": {
        "name": "WHOMCH Chronic conditions"
      }
    },
    "dimensions": {
      "pe": [],
      "ou": [
        "ImspTQPwCqd"
      ],
      "sWoqcoByYmD": [],
      "de0FEHSIoxh": []
    }
  },
  "width": 12,
  "rows": [
    [
      "A0cP533hIQv",
      "to8G9jAprnx",
      "2019-02-02 12:05:00.0",
      "2019-02-02 12:05:00.0",
      "",
      "0.0",
      "0.0",
      "Tonkomba MCHP",
      "OU_193264",
      "xIMxph4NMP1",
      "0",
      "1"
    ],
    [
      "ZqiUn2uXmBi",
      "SJtv0WzoYki",
      "2019-02-02 12:05:00.0",
      "2019-02-02 12:05:00.0",
      "",
      "0.0",
      "0.0",
      "Mawoma MCHP",
      "OU_254973",
      "Srnpwq8jKbp",
      "0",
      "0"
    ],
    [
      "lE747mUAtbz",
      "PGzTv2A1xzn",
      "2019-02-02 12:05:00.0",
      "2019-02-02 12:05:00.0",
      "",
      "0.0",
      "0.0",
      "Kunsho CHP",
      "OU_193254",
      "tdhB1JXYBx2",
      "",
      "0"
    ],
    [
      "nmcqu9QF8ow",
      "pav3tGLjYuq",
      "2019-02-03 12:05:00.0",
      "2019-02-03 12:05:00.0",
      "",
      "0.0",
      "0.0",
      "Korbu MCHP",
      "OU_678893",
      "m73lWmo5BDG",
      "",
      "1"
    ]
  ],
  "height": 4
}
```

La section *en-têtes* de la réponse décrit le contenu du résultat de la requête. L'identifiant unique de l'inscription, l'identifiant de l'instance d'entité suivie, la date de l'inscription, le nom de l'incident, la géométrie, la latitude, la longitude, le nom et le code de l'unité d'organisation apparaissent en tant que premières dimensions dans la réponse et seront toujours présents. Viennent ensuite les éléments de données, les attributs d'entité suivie qui ont été définis comme dimensions dans la demande ; il s'agit dans ce cas précis des dimensions d'éléments de données "WHOMCH maladies chroniques" et "WHOMCH fumeurs". L'identifiant de l'élément de dimension se trouve dans la propriété "nom" et une description lisible de la dimension dans la propriété "colonne" de la section en-têtes.

La section *metaData*, objet *ou* (unité d'organisation), contient les identifiants de toutes les unités d'organisation présentes dans la réponse, mis en correspondance avec une chaîne qui représente la hiérarchie. Cette chaîne hiérarchique énumère les identifiants des ascendants de l'unité d'organisation en commençant par la racine. L'objet *noms* contient les identifiants de tous les éléments de la réponse mis en correspondance avec leurs noms.

La section *lignes* contient les inscriptions produites par la requête. Chaque ligne représente exactement un inscription.

### Support of analytics across tracked entity instance relationships with program indicators { #support-of-analytics-across-tracked-entity-instance-relationships-with-program-indicators } 

L'API d'analyse des inscriptions sans agrégation permet également de relier les indicateurs de programme aux types de relations, afin d'afficher le résultat du calcul d'un indicateur de programme spécifique, appliqué aux entités liées à l'instance d'entité suivie répertoriée.

![](resources/images/enrollments/enrollments-pi-relationship.jpg)

For the Program Indicator/Relationship Type link to work, the `/api/33/analytics/enrollments/query` API requires an additional dimension which must include the chosen Relationship Type UID and the chosen Program Indicator UID:

    /api/33/analytics/enrollments/query/<program-id>
      ?dimension=<relationshiptype-id>.<programindicator-id>

Par exemple, pour extraire une liste d'inscriptions du programme "WHO RMNCH Tracker" pour janvier 2019 et afficher le nombre de cas de paludisme liés à cette inscription par le type de relation "Cas de paludisme lié à une personne", vous pouvez utiliser la requête suivante :

    /api/33/analytics/enrollments/query/WSGAb5XwJ3Y.json?dimension=mxZDvSZYxlw.nFICjJluo74
      &startDate=2019-01-01&endDate=2019-01-31    

L'API permet d'utiliser des indicateurs de programme qui ne sont pas associés au programme "principal" (c'est-à-dire le programme dont l'ID est spécifié après `/query/`).

## Analyse des unités d'organisation { #webapi_org_unit_analytics } 

<!--DHIS2-SECTION-ID:webapi_org_unit_analytics-->

L'API d'analyse des unités d'organisation fournit des statistiques sur les unités d'organisation classées par ensembles de groupes d'unités d'organisation, c'est-à-dire le nombre d'unités d'organisation dans chaque groupe au sein des ensembles de groupes d'unités d'organisation.

    GET /api/orgUnitAnalytics?ou=<org-unit-id>&ougs=<org-unit-group-set-id>

L'API requiert au moins une unité d'organisation et au moins un ensemble de groupes d'unités d'organisation. Plusieurs unités d'organisation et ensembles de groupes peuvent être fournis, séparés par un point-virgule.

### Paramètres de requête{ #request-query-parameters }

La ressource analytique des unités d'organisation vous permet de spécifier un ensemble de paramètres d'interrogation :

<table>
<caption>Org unit analytics query parameters</caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 60%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="header">
<th>Property</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr>
<td>ou</td>
<td>Org unit identifiers, potentially separated by a semicolon.</td>
<td>Yes</td>
</tr>
<tr>
<td>ougs</td>
<td>Org unit group set identifiers, potentially separated by a semicolon.</td>
<td>Yes</td>
</tr>
<tr>
<td>columns</td>
<td>Org unit group set identifiers, potentially separated by a semicolon. Defines which group sets are rendered as columns in a table layout.</td>
<td>No</td>
</tr>
</tbody>
</table>

La réponse contiendra une colonne pour l'unité d'organisation mère, des colonnes pour chaque groupe d'unités d'organisation faisant partie de la requête et une colonne pour le nombre d'unités d'organisation. Les statistiques comprennent le nombre d'unités d'organisation qui se trouvent en dessous des unités d'organisation spécifiées dans la requête. La réponse contient une section 'métadonnées' qui spécifie le nom de chaque unité d'organisation et de chaque groupe d'unités d'organisation qui font partie de la réponse. Elles sont référencées par leurs identifiants.

La réponse par défaut comporte une seule colonne `count`. Elle peut être présentée dans un tableau dans lequel au moins un groupe d'unités d'organisation est spécifié à l'aide du paramètre de requête `columns`.

### Formats de réponse { #response-formats } 

Le point d'extrémité analytique des unités d'organisation rend en charge les formats de représentation suivants :

- json (application/json)
- csv (application/csv)
- xls (application/vnd.ms-excel)
- pdf (candidature/pdf)

### Exemples { #examples }

Pour obtenir des analyses d'unité d'organisation pour une unité d'organisation et un ensemble de groupes d'unités d'organisation :

    GET /api/orgUnitAnalytics?ou=lc3eMKXaEfw&ougs=J5jldMd8OHv

Pour obtenir des  données analytiques d'unité d'organisation pour deux unités d'organisation et deux ensembles de groupes d'unités d'organisation, utilisez ce qui suit :

    GET /api/orgUnitAnalytics?ou=lc3eMKXaEfw;PMa2VCrupOd&ougs=J5jldMd8OHv;Bpx0589u8y0

Pour obtenir des données analytiques d'unité d'organisation dans un tableau avec un ensemble de groupes présenté dans des colonnes, utilisez ceci :

    GET /api/orgUnitAnalytics?ou=fdc6uOvgoji;jUb8gELQApl;lc3eMKXaEfw;PMa2VCrupOd
      &ougs=J5jldMd8OHv&columns=J5jldMd8OHv

### Contraintes et validation { #constraints-and-validation }

Les éventuelles erreurs de validation spécifiques à l'API d'analyse des unités d'organisation sont décrites dans le tableau ci-dessous. Certaines erreurs spécifiées pour l'API d'analyse agrégée sont également concernées.

| Code d'erreur | Message |
| ---------- | ------- |
| E7300      | Au moins une unité d'organisation doit être spécifiée |
| E7301      | Au moins un ensemble de groupes d'unités d'organisation doit être spécifié. |

## Rapport sur l'ensemble de données { #webapi_data_set_report } 

<!--DHIS2-SECTION-ID:webapi_data_set_report-->

Les rapports sur les ensembles de données peuvent être générés avec l'API Web, à l'aide de la ressource `/dataSetReport`. Cette ressource génère des rapports sur les ensembles de données et renvoie le résultat dans un un tableau HTML.

    /api/33/dataSetReport

### Paramètres de requête{ #request-query-parameters }

La requête prend en charge les paramètres suivants :

<table>
<caption>Data set report query parameters</caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 50%" />
<col style="width: 17%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
<th>Type</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ds</td>
<td>Data set to create the report from.</td>
<td>Data set UID</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>pe</td>
<td>Period to create the report from.</td>
<td>ISO String</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td>ou</td>
<td>Organisation unit to create the report from.</td>
<td>Organisation unit UID</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>filter</td>
<td>Filters to be used as filters for the report. Can be repeated any number of times. Follows the analytics API syntax.</td>
<td>One or more UIDs</td>
<td>No</td>
</tr>
<tr class="odd">
<td>selectedUnitOnly</td>
<td>Whether to use captured data only or aggregated data.</td>
<td>Boolean</td>
<td>No</td>
</tr>
</tbody>
</table>

La ressource du rapport sur les ensembles de données accepte uniquement les requêtes `GET`. Le contenu de la réponse est de type `application/json` et les données sont renvoyées dans une grille. Ce point d'extrémité fonctionne pour tous les types d'ensemble de données, notamment les formulaires par défaut, les formulaires à sections et les formulaires personnalisés.

An example request to retrieve a report for a data set and org unit for 2018 looks like this:

    GET /api/33/dataSetReport?ds=BfMAe6Itzgt&pe=201810&ou=ImspTQPwCqd&selectedUnitOnly=false

Pour obtenir un rapport sur un ensemble de données avec un filtre, vous pouvez utiliser le paramètre `filter`. Dans ce cas, le filtre se base sur un ensemble de groupes d'unités d'organisation et deux groupes d'unités d'organisation :

    GET /api/33/dataSetReport?ds=BfMAe6Itzgt&pe=201810&ou=ImspTQPwCqd
      &filter=J5jldMd8OHv:RXL3lPSK8oG;tDZVQ1WtwpA

### Formats de réponse { #response-formats } 

Le point d'extrémité du rapport sur l'ensemble de données prend en charge les formats de sortie suivants. Vous pouvez récupérer un point d'extrémité spécifique en utilisant l'extension du fichier ou l'en-tête HTTP `Accept`.

- json (application/json)
- pdf (candidature/pdf)
- xls (application/vnd.ms-excel)

### Formulaires personnalisés { #custom-forms } 

Un point d'extrémité spécifique est disponible pour les ensembles de données avec des formulaires HTML personnalisés. Ce point d'extrémité renvoie le contenu du formulaire HTML au format `text/html` avec les données qui y sont insérées. Vous pouvez également utiliser le point d'extrémité du rapport général sur les ensembles de données pour les ensembles de données avec des formulaires personnalisés. Cependant, ce point d'extrémité renverra le rapport au format JSON dans une grille. Ce point d'extrémité ne fonctionne que pour les ensembles de données avec des formulaires HTML personnalisés.

    GET /api/33/dataSetReport/custom

La syntaxe de ce point d'extrémité est par ailleurs la même que celle du point d'extrémité du rapport général sur les ensembles de données. Pour récupérer un rapport HTML personnalisé sur un ensemble de données, vous pouvez effectuer la requête suivant :

    GET /api/33/dataSetReport/custom?ds=lyLU2wR22tC&pe=201810&ou=ImspTQPwCqd


## Analyse push { #webapi_push_analysis } 

<!--DHIS2-SECTION-ID:webapi_push_analysis-->

L'API d'analyse push comprend des points d'extrémité qui permettent la prévisualisation d'un rapport d'analyse push par l'utilisateur connecté et le déclenchement manuel de la génération et de l'envoi de rapports d'analyse push par le système, en plus des opérations CRUD normales. Lorsque vous utilisez les points d'extrémité de création et de mise à jour pour l'analyse push, celle-ci est programmée pour s'exécuter selon les propriétés de l'analyse push. De même, lorsque vous supprimez ou mettez à jour une analyse push pour la désactiver, la tâche ne pourra plus être exécutée à l'avenir.

Pour obtenir l'aperçu d'une analyse push existante en HTML, vous pouvez effectuer une requête GET au point d'extrémité suivant :

    /api/33/pushAnalysis/<id>/render

Pour déclencher manuellement une tâche d'analyse push, vous pouvez envoyer une requête POST au point d'extrémité suivant :

    /api/33/pushAnalysis/<id>/run

Une analyse push comprend les propriétés suivantes, dont certaines sont nécessaires pour l'exécution automatique des tâches d'analyse push :

<table>
<caption>Push analysis properties</caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th>Property</th>
<th>Description</th>
<th>Type</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>dashboard</td>
<td>Dashboard on which reports are based</td>
<td>Dashboard UID</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>message</td>
<td>Appears after title in reports</td>
<td>String</td>
<td>No</td>
</tr>
<tr class="odd">
<td>recipientUserGroups</td>
<td>A set of user groups who should receive the reports</td>
<td>One or more user Group UID</td>
<td>No. Scheduled jobs without any recipient will be skipped.</td>
</tr>
<tr class="even">
<td>enabled</td>
<td>Indicated whether this push analysis should be scheduled or not. False by default.</td>
<td>Boolean</td>
<td>Yes. Must be true to be scheduled.</td>
</tr>
<tr class="odd">
<td>schedulingFrequency</td>
<td>The frequency of which reports should be scheduled.</td>
<td>&quot;DAILY&quot;, &quot;WEEKLY&quot;, &quot;MONTHLY&quot;</td>
<td>No. Push analysis without a frequency will not be scheduled</td>
</tr>
<tr class="even">
<td>schedulingDayOfFrequency</td>
<td>The day in the frequency the job should be scheduled.</td>
<td>Integer. Any value when frequency is &quot;DAILY&quot;. 0-7 when frequency is &quot;WEEKLY&quot;. 1-31 when frequency is &quot;MONTHLY&quot;</td>
<td>No. Push analysis without a valid day of frequency for the frequency set will not be scheduled.</td>
</tr>
</tbody>
</table>

## Analyse de l'utilisation des données { #webapi_usage_analytics } 

<!--DHIS2-SECTION-ID:webapi_usage_analytics-->

L'API d'analyse de l'utilisation vous permet d'accéder à des informations sur la manière dont les gens utilisent DHIS2 sur la base d'une analyse de données. Lorsque les utilisateurs accèdent aux favoris, un événement est enregistré. L'événement se compose du nom de l'utilisateur, de l'UID du favori, de la date de l'événement et du type d'événement. Les différents types d'événements sont répertoriés dans le tableau.

    /api/33/dataStatistics

L'API d'analyse de l'utilisation vous permet de récupérer des instantanés agrégés sur l'analyse de l'utilisation, en fonction d'intervalles de temps donnés. L'API capture les vues des utilisateurs (par exemple le nombre de fois qu'un graphique ou un tableau croisé dynamique a été visualisé par un utilisateur) et les favoris d'analyse enregistrés (par exemple les graphiques et les tableaux croisés dynamiques favoris). DHIS2 capture des instantanés nocturnes qui sont ensuite agrégés à la demande.

### Paramètres de requête{ #webapi_usage_analytics_request_query_parameters } 

<!--DHIS2-SECTION-ID:webapi_usage_analytics_request_query_parameters-->

L'API d'analyse de l'utilisation (statistiques de données) prend en charge deux opérations :

  - *POST:* crée un événement de vue

  - *GET:* récupère les statistiques agrégées

### Création des événements de visualisation (POST) { #webapi_usage_analytics_create_view_events } 

<!--DHIS2-SECTION-ID:webapi_usage_analytics_create_view_events-->

L'API d'analyse de l'utilisation vous permet de créer des visualisations d'événement. Le paramètre dataStatisticsEventType (type d'événement des statistiques de données) décrit le type de l'élément visualisé. Le paramètre de favori indique l'identifiant du favori concerné.

URL that creates a new event view of
    charts:

    POST /api/33/dataStatistics?eventType=CHART_VIEW&favorite=LW0O27b7TdD

Une opération de sauvegarde réussie renvoie un code de statut HTTP "201". Le tableau ci-dessous présente les types d'événement pris en charge.

<table>
<caption>Supported event types</caption>
<colgroup>
<col style="width: 38%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr class="header">
<th>Key</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>REPORT_TABLE_VIEW</td>
<td>Report table (pivot table) view</td>
</tr>
<tr class="even">
<td>CHART_VIEW</td>
<td>Chart view</td>
</tr>
<tr class="odd">
<td>MAP_VIEW</td>
<td>Map view (GIS)</td>
</tr>
<tr class="even">
<td>EVENT_REPORT_VIEW</td>
<td>Event report view</td>
</tr>
<tr class="odd">
<td>EVENT_CHART_VIEW</td>
<td>Event chart view</td>
</tr>
<tr class="even">
<td>DASHBOARD_VIEW</td>
<td>Dashboard view</td>
</tr>
<tr class="odd">
<td>DATA_SET_REPORT_VIEW</td>
<td>Data set report view</td>
</tr>
</tbody>
</table>

### Récupération des rapports agrégés d'analyse de l'utilisation (GET) { #webapi_aggregated_usage_analytics } 

<!--DHIS2-SECTION-ID:webapi_aggregated_usage_analytics-->

L'API d'analyse de l'utilisation (statistiques de données) vous permet de spécifier certains paramètres de requête lorsque vous demandez un rapport agrégé.

<table>
<caption>Query parameters for aggregated usage analytics (data statistics)</caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th>Query parameter</th>
<th>Required</th>
<th>Description</th>
<th>Options</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>startDate</td>
<td>Yes</td>
<td>Start date for period</td>
<td>Date in yyyy-MM-dd format</td>
</tr>
<tr class="even">
<td>endDate</td>
<td>Yes</td>
<td>End date for period</td>
<td>Date in yyyy-MM-dd format</td>
</tr>
<tr class="odd">
<td>interval</td>
<td>Yes</td>
<td>Type of interval to be aggregated</td>
<td>DAY, WEEK, MONTH, YEAR</td>
</tr>
</tbody>
</table>

Les paramètres 'date de début' et 'date de fin' spécifient la période pour laquelle les instantanés doivent être utilisés dans l'agrégation. Vous devez mettre les dates au format indiqué ci-dessus. Si aucun instantané n'est sauvegardé au cours de la période spécifiée, une liste vide est renvoyée. Le paramètre appelé 'intervalle' spécifie le type d'agrégation qui sera effectué.

Requête API qui crée une agrégation mensuelle :

    GET /api/33/dataStatistics?startDate=2014-01-02&endDate=2016-01-01&interval=MONTH

### Récupération des favoris { #webapi_usage_analytics_top_favorites } 

<!--DHIS2-SECTION-ID:webapi_usage_analytics_top_favorites-->

L'API d'analyse de l'utilisation vous permet de récupérer les principaux favoris utilisés dans DHIS2, et par utilisateur.

<table>
<caption>Query parameters for top favorites</caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th>Query parameter</th>
<th>Required</th>
<th>Description</th>
<th>Options</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>eventType</td>
<td>Yes</td>
<td>The data statistics event type</td>
<td>See above table</td>
</tr>
<tr class="even">
<td>pageSize</td>
<td>No</td>
<td>Size of the list returned</td>
<td>For example 5, 10, 25. Default is 25</td>
</tr>
<tr class="odd">
<td>sortOrder</td>
<td>No</td>
<td>Descending or ascending</td>
<td>ASC or DESC. Default is DESC.</td>
</tr>
<tr class="even">
<td>username</td>
<td>No</td>
<td>If specified, the response will only contain favorites by this user.</td>
<td>For example 'admin'</td>
</tr>
</tbody>
</table>

La requête API peut être utilisée sans nom d'utilisateur. Dans ce cas, elle trouvera les principaux favoris de tout le système.

    /api/33/dataStatistics/favorites?eventType=CHART_VIEW&pageSize=25&sortOrder=ASC

Si le nom d'utilisateur est spécifié, la réponse ne contiendra que les favoris de cet utilisateur.

    /api/33/dataStatistics/favorites?eventType=CHART_VIEW&pageSize=25
      &sortOrder=ASC&username=admin

### Format de la réponse { #webapi_usage_analytics_response_format } 

<!--DHIS2-SECTION-ID:webapi_usage_analytics_response_format-->

Vous pouvez renvoyer les données agrégées dans une réponse d'analyse d'utilisation dans différents formats de représentation. Le format par défaut est JSON. Les formats et types de contenu disponibles sont les suivants :

  - json (application/json)

  - xml (application/xml)

  - html (texte/html)

API query that requests a usage analytics response in XML
    format:

    /api/33/dataStatistics.xml?startDate=2014-01-01&endDate=2016-01-01&interval=WEEK

You must retrieve the aggregated usage analytics response with the HTTP
GET method. This allows you to link directly from Web pages and other
HTTP-enabled clients to usage analytics responses. To do functional
testing use the cURL library.

Pour obtenir une réponse d'analyse d'utilisation au format JSON :

    /api/33/dataStatistics?startDate=2016-02-01&endDate=2016-02-14&interval=WEEK

La réponse JSON ressemble à ceci :

```json
[
  {
    "year": 2016,
    "week": 5,
    "mapViews": 2181,
    "chartViews": 2227,
    "reportTableViews": 5633,
    "eventReportViews": 6757,
    "eventChartViews": 9860,
    "dashboardViews": 10082,
    "totalViews": 46346,
    "averageViews": 468,
    "averageMapViews": 22,
    "averageChartViews": 22,
    "averageReportTableViews": 56,
    "averageEventReportViews": 68,
    "averageEventChartViews": 99,
    "averageDashboardViews": 101,
    "savedMaps": 1805,
    "savedCharts": 2205,
    "savedReportTables": 1995,
    "savedEventReports": 1679,
    "savedEventCharts": 1613,
    "savedDashboards": 0,
    "savedIndicators": 1831,
    "activeUsers": 99,
    "users": 969
  },
  {
    "year": 2016,
    "week": 6,
    "mapViews": 2018,
    "chartViews": 2267,
    "reportTableViews": 4714,
    "eventReportViews": 6697,
    "eventChartViews": 9511,
    "dashboardViews": 12181,
    "totalViews": 47746,
    "averageViews": 497,
    "averageMapViews": 21,
    "averageChartViews": 23,
    "averageReportTableViews": 49,
    "averageEventReportViews": 69,
    "averageEventChartViews": 99,
    "averageDashboardViews": 126,
    "savedMaps": 1643,
    "savedCharts": 1935,
    "savedReportTables": 1867,
    "savedEventReports": 1977,
    "savedEventCharts": 1714,
    "savedDashboards": 0,
    "savedIndicators": 1646,
    "activeUsers": 96,
    "users": 953
  }
]
```

### Récupération des statistiques pour un favori { #webapi_usage_analytics_retrieve_favorite_statistics } 

<!--DHIS2-SECTION-ID:webapi_usage_analytics_retrieve_favorite_statistics-->

Vous pouvez obtenir le nombre de visualisations pour un favori spécifique en utilisant la ressource *favoris*, où *{favorite-id}* (Id du favori) doit être remplacé par l'identifiant du favori en question :

    /api/33/dataStatistics/favorites/{favorite-id}.json

La réponse contiendra le nombre de visualisations pour le favori en question et ressemblera à ceci :

```json
{
  "views": 3
}
```

## Fonctionnalités géospatiales { #webapi_geospatial_features } 

<!--DHIS2-SECTION-ID:webapi_geospatial_features-->

La ressource *geoFeatures* vous permet d'extraire des informations géospatiales de DHIS2. Les fonctionnalités géospatiales sont stockées avec les unités d'organisation. La syntaxe utilisée pour extraire ces fonctionnalités est identique à la celle utilisée pour la dimension d'unité d'organisation de la ressource analytique. Nous vous recommandons de vous renseigner sur la ressource de l'API analytique avant de poursuivre la lecture de cette section. Vous devez utiliser le type de requête GET et seul le format de réponse JSON est pris en charge.

Par exemple, pour récupérer les éléments géospatiaux de toutes les unités d'organisation situées au niveau 3 de la hiérarchie des unités d'organisation, vous pouvez utiliser une requête GET avec l'URL suivante :

    /api/33/geoFeatures.json?ou=ou:LEVEL-3

Pour récupérer les éléments géospatiaux des unités d'organisation à un niveau situé à l'intérieur d'une unité d'organisation (par exemple au niveau 2), vous pouvez utiliser l'URL suivante :

    /api/33/geoFeatures.json?ou=ou:LEVEL-4;O6uvpzGd5pu

La sémantique des propriétés de la réponse est décrite dans le tableau suivant :

<table>
<caption>Geo features response</caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>id</td>
<td>Organisation unit / geo feature identifier</td>
</tr>
<tr class="even">
<td>na</td>
<td>Organisation unit / geo feature name</td>
</tr>
<tr class="odd">
<td>hcd</td>
<td>Has coordinates down, indicating whether one or more children organisation units exist with coordinates (below in the hierarchy)</td>
</tr>
<tr class="even">
<td>hcu</td>
<td>Has coordinates up, indicating whether the parent organisation unit has coordinates (above in the hierarchy)</td>
</tr>
<tr class="odd">
<td>le</td>
<td>Level of this organisation unit / geo feature.</td>
</tr>
<tr class="even">
<td>pg</td>
<td>Parent graph, the graph of parent organisation unit identifiers up to the root in the hierarchy</td>
</tr>
<tr class="odd">
<td>pi</td>
<td>Parent identifier, the identifier of the parent of this organisation unit</td>
</tr>
<tr class="even">
<td>pn</td>
<td>Parent name, the name of the parent of this organisation unit</td>
</tr>
<tr class="odd">
<td>ty</td>
<td>Geo feature type, 1 = point and 2 = polygon or multi-polygon</td>
</tr>
<tr class="even">
<td>co</td>
<td>Coordinates of this geo feature</td>
</tr>
</tbody>
</table>

### GeoJSON { #geojson } 

Pour exporter du GeoJSON, vous pouvez simplement ajouter *.geosjon* en tant qu'extension au point d'extrémité */api/organisationUnits*, ou vous pouvez utiliser l'en-tête *Accept* avec *application/json+geojson*.

Deux paramètres sont pris en charge : `level` (1 par défaut) et `parent` (unités d'organisation racine par défaut). Les deux paramètres peuvent être ajoutés à plusieurs reprise. Quelques exemples :

Obtenir tous les éléments aux niveaux 2 et 4 :

    /api/organisationUnits.geojson?level=2&level=4

Pour obtenir tous les éléments du niveau 3 avec une unité d'organisation limite :

    /api/organisationUnits.geojson?parent=fdc6uOvgoji&level=3

## Generating resource and analytics tables { #webapi_generating_resource_analytics_tables } 

<!--DHIS2-SECTION-ID:webapi_generating_resource_analytics_tables-->

DHIS2 comporte un ensemble de tableaux de base de données générés qui sont utilisés comme 
base pour diverses fonctionnalités du système. Ces tableaux peuvent être exécutés 
immédiatement ou programmés à intervalles réguliers via 
l'interface utilisateur. Ils peuvent également être générés via l'API Web, comme 
expliqué dans cette section. Cette tâche incombe généralement à un administrateur 
système et non aux clients consommateurs.

Les tables de ressources sont utilisées en interne par l'application DHIS2 pour
diverses fonctions d'analyse. Ces tables sont également utiles aux utilisateurs
qui rédigent des rapports SQL avancés. Elles peuvent être générées par une requête POST ou PUT
à l'URL suivante :

    /api/33/resourceTables

Les tableaux analytiques sont optimisés pour l'agrégation des données et sont actuellement 
utilisés dans DHIS2 pour le module de tableau croisé dynamique. Les tableaux d'analyse peuvent 
être générés à l'aide d'une requête POST ou PUT à :

    /api/33/resourceTables/analytics

<table>
<caption>Analytics tables optional query parameters</caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 14%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th>Query parameter</th>
<th>Options</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>skipResourceTables</td>
<td>false | true</td>
<td>Skip generation of resource tables</td>
</tr>
<tr class="even">
<td>skipAggregate</td>
<td>false | true</td>
<td>Skip generation of aggregate data and completeness data</td>
</tr>
<tr class="odd">
<td>skipEvents</td>
<td>false | true</td>
<td>Skip generation of event data</td>
</tr>
<tr class="even">
<td>skipEnrollment</td>
<td>false | true</td>
<td>Skip generation of enrollment data</td>
</tr>
<tr class="odd">
<td>lastYears</td>
<td>integer</td>
<td>Number of last years of data to include</td>
</tr>
</tbody>
</table>

Les tâches « Qualité des données “ et ” Surveillance des données » peuvent être exécutées 
via la tâche de surveillance, déclenchée avec le endpoint 

    /api/33/resourceTables/monitoring

Cette tâche analyse vos règles de validation, détecte les violations et 
les conserve en tant que résultats de validation.

Ces demandes sont renvoyées immédiatement et déclenchent un processus 
côté serveur.

## Maintenance { #webapi_maintenance } 

<!--DHIS2-SECTION-ID:webapi_maintenance-->

Pour effectuer la maintenance, vous pouvez interagir avec la ressource *maintenance*. Vous devez utiliser *POST* ou *PUT* comme méthode pour les requêtes. Les méthodes suivantes sont disponibles.

La suppression des tables d'analyse entraîne la disparition de toutes les tables d'analyse.

    POST PUT /api/maintenance/analyticsTablesClear

L'analyse des tables d'analyse permet de collecter des statistiques sur le contenu des tables d'analyse de la base de données.

    POST PUT /api/maintenance/analyticsTablesAnalyze

La suppression des invitations expirées permet de supprimer toutes les invitations de comptes d'utilisateurs qui 
ont expiré.

    POST PUT /api/maintenance/expiredInvitationsClear

L'élagage des périodes permet de supprimer les périodes qui ne sont liées à aucune valeur de 
données.

    POST PUT /api/maintenance/periodPruning

La suppression des valeurs de données nulles permet de supprimer les valeurs de données nulles liées à des 
éléments de données où les données nulles sont définies comme non significatives :

    POST PUT /api/maintenance/zeroDataValueRemoval

La suppression des valeurs de données supprimées de façon réversible supprime définitivement les valeurs de données supprimées de façon réversible.

    POST PUT /api/maintenance/softDeletedDataValueRemoval

La suppression de l'instance de l'étape du programme supprimé de façon réversible supprime de façon permanente les événements supprimés de façon réversible.

    POST PUT /api/maintenance/softDeletedProgramStageInstanceRemoval

La suppression de l'instance de programme supprimée de façon réversible supprime définitivement les inscriptions supprimées de façon réversible.

    POST PUT /api/maintenance/softDeletedProgramInstanceRemoval

La suppression des instances d'entités suivies supprimées de façon réversible supprime définitivement les instances d'entités suivies supprimées de façon réversible.

    POST PUT /api/maintenance/softDeletedTrackedEntityInstanceRemoval

Supprimer les vues SQL supprime toutes les vues SQL de la base de données. Notez qu'il ne supprime pas les entités de la vue SQL de DHIS2.

    POST PUT /api/maintenance/sqlViewsDrop

Créer des vues SQL va recréer toutes les vues SQL dans la base de données.

    POST PUT /api/maintenance/sqlViewsCreate

La mise à jour des combinaisons d'options de catégories supprimera les combinaisons d'options de catégories obsolètes et générera les combinaisons d'options de catégories manquantes pour toutes les combinaisons de catégories.

    POST PUT /api/maintenance/categoryOptionComboUpdate

Il est également possible de mettre à jour les combinaisons d'options de catégorie pour une seule combinaison de catégorie en utilisant le point d'extrémité suivant.

    POST PUT /api/maintenance/categoryOptionComboUpdate/categoryCombo/<category-combo-uid>

Le nettoyage du cache efface le cache d'hibernation de l'application et les caches de la partition analytique.

    POST PUT /api/maintenance/cacheClear

La mise à jour des chemins des unités d'organisation va regénérer la propriété du chemin de l'unité d'organisation. Cela peut être utile, par exemple, si vous avez importé des unités d'organisation avec SQL.

    POST PUT /api/maintenance/ouPathsUpdate

L'élagage des données permet de supprimer des enregistrements complets d'ensembles de données, des approbations de données, des audits de valeurs de données et des valeurs de données, dans ce cas pour une unité d'organisation.

    POST PUT /api/maintenance/dataPruning/organisationUnits/<org-unit-id>

L'élagage des données pour les éléments de données, qui supprime les audits de valeurs de données et les valeurs de données.

    POST PUT /api/maintenance/dataPruning/dataElement/<data-element-uid>

La validation des métadonnées appliquera toutes les règles de validation des métadonnées et renverra le résultat de l'opération.

    POST PUT /api/metadataValidation

Le rechargement d'applications actualise le cache des applications installées géré par DHIS2 en lisant le système de fichiers.

    POST PUT /api/appReload

Les opérations de maintenance sont prises en charge par lots au moyen d'une requête POST à la ressource api/maintenance, où les opérations sont fournies en tant que paramètres de requête :

    POST PUT /api/maintenance?analyticsTablesClear=true&expiredInvitationsClear=true
      &periodPruning=true&zeroDataValueRemoval=true&sqlViewsDrop=true&sqlViewsCreate=true
      &categoryOptionComboUpdate=true&cacheClear=true&ouPathsUpdate=true

## System resource { #webapi_system_resource } 

<!--DHIS2-SECTION-ID:webapi_system_resource-->

La ressource système vous fournit des informations et des fonctions 
pratiques. La ressource système se trouve à l'adresse */api/system*.

### Générer des identifiants { #webapi_system_resource_generate_identifiers } 

<!--DHIS2-SECTION-ID:webapi_system_resource_generate_identifiers-->

Pour générer des identifiants DHIS2 valides et aléatoires, vous pouvez effectuer une requête GET à 
cette ressource :

    /api/33/system/id?limit=3

Le paramètre de requête *limit* est facultatif et indique le nombre 
d'identifiants à renvoyer avec la réponse. La valeur par défaut est
de renvoyer un seul identifiant. La réponse contiendra un objet JSON avec un 
tableau nommé codes, similaire à ceci :

```json
{
  "codes": [
    "Y0moqFplrX4",
    "WI0VHXuWQuV",
    "BRJNBBpu4ki"
  ]
}
```

Le format DHIS2 UID répond à ces critères :

  - Long de 11 caractères.

  - Caractères alphanumériques uniquement, c'est-à-dire caractères alphabétiques ou numériques
    (A-Za-z0-9).

  - Commencez par un caractère alphabétique (A-Za-z).

### Visualiser les informations du système { #webapi_system_resource_view_system_information } 

<!--DHIS2-SECTION-ID:webapi_system_resource_view_system_information-->

Pour obtenir des informations sur le système actuel, vous pouvez envoyer une requête GET à 
cette URL :

    /api/33/system/info

Les formats de réponse JSON et JSONP sont pris en charge. La réponse info système
comprend actuellement les propriétés suivantes.

```json
{
  contextPath: "http://yourdomain.com",
  userAgent: "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 Chrome/29.0.1547.62",
  version: "2.13-SNAPSHOT",
  revision: "11852",
  buildTime: "2013-09-01T21:36:21.000+0000",
  serverDate: "2013-09-02T12:35:54.311+0000",
  environmentVariable: "DHIS2_HOME",
  javaVersion: "1.7.0_06",
  javaVendor: "Oracle Corporation",
  javaIoTmpDir: "/tmp",
  javaOpts: "-Xms600m -Xmx1500m -XX:PermSize=400m -XX:MaxPermSize=500m",
  osName: "Linux",
  osArchitecture: "amd64",
  osVersion: "3.2.0-52-generic",
  externalDirectory: "/home/dhis/config/dhis2",
  databaseInfo: {
    type: "PostgreSQL",
    name: "dhis2",
    user: "dhis",
    spatialSupport: false
  },
  memoryInfo: "Mem Total in JVM: 848 Free in JVM: 581 Max Limit: 1333",
  cpuCores: 8
}
```

> **Note**
>
> If the user requesting this resource does not have full authority then only the first seven properties will be included, as other properties are considered sensitive information.

Pour obtenir des informations sur le contexte du système uniquement, c'est-à-dire `contextPath` et
`userAgent`, vous pouvez faire une requête GET à l'URL ci-dessous. Les formats de réponse JSON et
JSONP sont supportés :

    /api/33/system/context

### Vérifier si la combinaison du nom d'utilisateur et du mot de passe est correcte { #webapi_system_resource_check_username_password } 

<!--DHIS2-SECTION-ID:webapi_system_resource_check_username_password-->

Pour vérifier si les informations d'identification d'un utilisateur (combinaison d'un nom d'utilisateur et d'un mot de passe)
est correcte, vous pouvez envoyer une requête *GET* à la ressource suivante en utilisant l'option
*authentification de base* :

    /api/33/system/ping

Vous pouvez détecter le résultat de l'authentification en inspectant le *code du statut HTTP*
de l'en-tête de la réponse. La signification des codes de statut possibles
sont énumérés ci-dessous. Notez que cela s'applique aux demandes d'API Web en
général.

<table>
<caption>HTTP Status codes</caption>
<colgroup>
<col style="width: 13%" />
<col style="width: 12%" />
<col style="width: 74%" />
</colgroup>
<thead>
<tr class="header">
<th>HTTP Status code</th>
<th>Description</th>
<th>Outcome</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>200</td>
<td>OK</td>
<td>Authentication was successful</td>
</tr>
<tr class="even">
<td>302</td>
<td>Found</td>
<td>No credentials were supplied with the request - no authentication took place</td>
</tr>
<tr class="odd">
<td>401</td>
<td>Unauthorized</td>
<td>The username and password combination was incorrect - authentication failed</td>
</tr>
</tbody>
</table>

### Consulter le statut d'une tâche asynchrone { #webapi_system_resource_view_async_task_status } 

<!--DHIS2-SECTION-ID:webapi_system_resource_view_async_task_status-->

Les tâches qui prennent souvent beaucoup de temps peuvent être exécutées 
de manière asynchrone. Après avoir initié une tâche asynchrone, vous pouvez interroger son statut 
via la ressource `system/tasks` en fournissant la catégorie de tâche et 
l'identifiant de la tâche qui vous intéresse.

Lorsque vous demandez le statut d'une tâche, vous devez vous authentifier en tant 
qu'utilisateur ayant initié la tâche. Les catégories de tâches suivantes sont 
prises en charge :

<table>
<caption>Task categories</caption>
<colgroup>
<col style="width: 21%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="header">
<th>Identifier</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ANALYTICS_TABLE</td>
<td>Generation of the analytics tables.</td>
</tr>
<tr class="even">
<td>RESOURCE_TABLE</td>
<td>Generation of the resource tables.</td>
</tr>
<tr class="odd">
<td>MONITORING</td>
<td>Processing of data surveillance/monitoring validation rules.</td>
</tr>
<tr class="even">
<td>DATAVALUE_IMPORT</td>
<td>Import of data values.</td>
</tr>
<tr class="odd">
<td>EVENT_IMPORT</td>
<td>Import of events.</td>
</tr>
<tr class="even">
<td>ENROLLMENT_IMPORT</td>
<td>Import of enrollments.</td>
</tr>
<tr class="odd">
<td>TEI_IMPORT</td>
<td>Import of tracked entity instances.</td>
</tr>
<tr class="even">
<td>METADATA_IMPORT</td>
<td>Import of metadata.</td>
</tr>
<tr class="odd">
<td>DATA_INTEGRITY</td>
<td>Processing of data integrity checks.</td>
</tr>
</tbody>
</table>

Chaque tâche asynchrone se voit automatiquement attribuer un identifiant qui peut 
être utilisé pour contrôler le statut de la tâche. Cet identifiant de tâche est
renvoyé par l'API lorsque vous lancez une tâche asynchrone via les différents
endpoints activés asynchrones.


#### Surveillance d'une tâche { #monitoring-a-task } 

Vous pouvez consulter l'état des tâches par le biais d'une requête GET à la ressource des tâches 
du système, comme suit :

    /api/33/system/tasks/{task-category-id}/{task-id}

Un exemple de requête peut ressembler à ceci :

    /api/33/system/tasks/DATAVALUE_IMPORT/j8Ki6TgreFw

La réponse fournira des informations sur le statut, telles que le niveau de 
notification, la catégorie, l'heure et le statut. La propriété *terminé* indique 
si le processus est considéré comme terminé.

```json
[{
  "uid": "hpiaeMy7wFX",
  "level": "INFO",
  "category": "DATAVALUE_IMPORT",
  "time": "2015-09-02T07:43:14.595+0000",
  "message": "Import done",
  "completed": true
}]
```

#### Suivre toutes les tâches d'une catégorie { #monitoring-all-tasks-for-a-category } 

Vous pouvez consulter toutes les tâches d'une catégorie spécifique par le biais d'une requête GET vers
la ressource des tâches du système :

    /api/33/system/tasks/{task-category-id}

Un exemple de requête pour consulter le statut des tâches d'importation de données
ressemble à ceci :

    /api/33/system/tasks/DATAVALUE_IMPORT

#### Suivre toutes les tâches { #monitor-all-tasks } 

Vous pouvez demander une liste de toutes les tâches en cours d'exécution dans le système avec 
une requête GET à la ressource tâches du système :

    /api/33/system/tasks

La réponse ressemblera à ceci :

```json
[{
  "EVENT_IMPORT": {},
  "DATA_STATISTICS": {},
  "RESOURCE_TABLE": {},
  "FILE_RESOURCE_CLEANUP": {},
  "METADATA_IMPORT": {},
  "CREDENTIALS_EXPIRY_ALERT": {},
  "SMS_SEND": {},
  "MOCK": {},
  "ANALYTICSTABLE_UPDATE": {},
  "COMPLETE_DATA_SET_REGISTRATION_IMPORT": {},
  "DATAVALUE_IMPORT": {},
  "DATA_SET_NOTIFICATION": {},
  "DATA_INTEGRITY": {
    "OB1qGRlCzap": [{
      "uid": "LdHQK0PXZyF",
      "level": "INFO",
      "category": "DATA_INTEGRITY",
      "time": "2018-03-26T15:02:32.171",
      "message": "Data integrity checks completed in 38.31 seconds.",
      "completed": true
    }]
  },
  "PUSH_ANALYSIS": {},
  "MONITORING": {},
  "VALIDATION_RESULTS_NOTIFICATION": {},
  "REMOVE_EXPIRED_RESERVED_VALUES": {},
  "DATA_SYNC": {},
  "SEND_SCHEDULED_MESSAGE": {},
  "DATAVALUE_IMPORT_INTERNAL": {},
  "PROGRAM_NOTIFICATIONS": {},
  "META_DATA_SYNC": {},
  "ANALYTICS_TABLE": {},
  "PREDICTOR": {}
}]
```

### Visualiser les résumés des tâches asynchrones { #view-asynchronous-task-summaries } 

La ressource résumés de tâches vous permet de récupérer un résumé d'une invocation 
d'une tâche asynchrone. Vous devez spécifier la catégorie et, 
éventuellement l'identifiant de la tâche. L'identifiant de la tâche peut être
récupéré à partir de la réponse de la requête API qui a initié la 
tâche asynchrone.

Pour récupérer le résumé d'une tâche spécifique, vous pouvez envoyer une requête à :

    /api/33/system/taskSummaries/{task-category-id}/{task-id}

Un exemple de requête pourrait ressembler à ceci :

    /api/33/system/taskSummaries/DATAVALUE_IMPORT/k72jHfF13J1

La réponse ressemblera à ceci :

```json
{
  "responseType": "ImportSummary",
  "status": "SUCCESS",
  "importOptions": {
    "idSchemes": {},
    "dryRun": false,
    "async": true,
    "importStrategy": "CREATE_AND_UPDATE",
    "mergeMode": "REPLACE",
    "reportMode": "FULL",
    "skipExistingCheck": false,
    "sharing": false,
    "skipNotifications": false,
    "datasetAllowsPeriods": false,
    "strictPeriods": false,
    "strictCategoryOptionCombos": false,
    "strictAttributeOptionCombos": false,
    "strictOrganisationUnits": false,
    "requireCategoryOptionCombo": false,
    "requireAttributeOptionCombo": false,
    "skipPatternValidation": false
  },
  "description": "Import process completed successfully",
  "importCount": {
    "imported": 0,
    "updated": 431,
    "ignored": 0,
    "deleted": 0
  },
  "dataSetComplete": "false"
}
```

Vous pouvez également récupérer des résumés d'importation pour plusieurs tâches d'une
catégorie spécifique avec une requête comme
celle-ci :

    /api/33/system/taskSummaries/{task-category-id}

### Obtenir des informations sur la présentation { #webapi_system_resource_get_appearance_information } 

<!--DHIS2-SECTION-ID:webapi_system_resource_get_appearance_information-->

Vous pouvez récupérer les icônes de drapeaux disponibles au format JSON à l'aide d'une 
requête GET :

    /api/33/system/flags

Vous pouvez récupérer les styles d'interface utilisateur disponibles au format JSON à l'aide 
d'une requête GET :

    /api/33/system/styles

## Locales { #webapi_locales } 

<!--DHIS2-SECTION-ID:webapi_locales-->

DHIS2 supports translations both for the user interface and for database
content.

### UI locales { #ui-locales } 

You can retrieve the available locales for the user interface through
the following resource with a GET request. XML and JSON resource
representations are supported.

    /api/33/locales/ui

### Database content locales { #database-content-locales } 

You can retrieve and create locales for the database content with GET and
POST requests through the following resource. XML and JSON resource
representations are supported.

    /api/33/locales/db

## Les traductions { #webapi_translations } 

<!--DHIS2-SECTION-ID:webapi_translations-->

DHIS2 allows for translations of database content. You can work with
translations through the Web API using the *translations* resource.

    /api/33/translations

### Create a translation { #create-a-translation } 

You can create a translation with a POST request in JSON format:

```json
{
  "objectId": "P3jJH5Tu5VC",
  "className": "DataElement",
  "locale": "es",
  "property": "name",
  "value": "Casos de fiebre amarilla"
}
```

    POST /api/33/translations

The properties which support translations are listed in the table below.

<table>
<caption>Property names</caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Property name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>name</td>
<td>Object name</td>
</tr>
<tr class="even">
<td>shortName</td>
<td>Object short name</td>
</tr>
<tr class="odd">
<td>description</td>
<td>Object description</td>
</tr>
</tbody>
</table>

The classes which support translations are listed in the table below.

<table>
<caption>Class names</caption>
<colgroup>
<col style="width: 34%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th>Class name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DataElementCategoryOption</td>
<td>Category option</td>
</tr>
<tr class="even">
<td>DataElementCategory</td>
<td>Category</td>
</tr>
<tr class="odd">
<td>DataElementCategoryCombo</td>
<td>Category combination</td>
</tr>
<tr class="even">
<td>DataElement</td>
<td>Data element</td>
</tr>
<tr class="odd">
<td>DataElementGroup</td>
<td>Data element group</td>
</tr>
<tr class="even">
<td>DataElementGroupSet</td>
<td>Data element group set</td>
</tr>
<tr class="odd">
<td>Indicator</td>
<td>Indicator</td>
</tr>
<tr class="even">
<td>IndicatorType</td>
<td>Indicator type</td>
</tr>
<tr class="odd">
<td>IndicatorGroup</td>
<td>Indicator group</td>
</tr>
<tr class="even">
<td>IndicatorGroupSet</td>
<td>Indicator group set</td>
</tr>
<tr class="odd">
<td>OrganisationUnit</td>
<td>Organisation unit</td>
</tr>
<tr class="even">
<td>OrganisationUnitGroup</td>
<td>Organisation unit group</td>
</tr>
<tr class="odd">
<td>OrganisationUnitGroupSet</td>
<td>Organisation unit group set</td>
</tr>
<tr class="even">
<td>DataSet</td>
<td>Data set</td>
</tr>
<tr class="odd">
<td>Section</td>
<td>Data set section</td>
</tr>
<tr class="even">
<td>ValidationRule</td>
<td>Validation rule</td>
</tr>
<tr class="odd">
<td>ValidationRuleGroup</td>
<td>Validation rule group</td>
</tr>
<tr class="even">
<td>Program</td>
<td>Program</td>
</tr>
<tr class="odd">
<td>ProgramStage</td>
<td>Program stage</td>
</tr>
<tr class="even">
<td>TrackedEntityAttribute</td>
<td>Tracked entity attribute</td>
</tr>
<tr class="odd">
<td>TrackedEntity</td>
<td>Tracked entity</td>
</tr>
<tr class="even">
<td>RelationshipType</td>
<td>Relationship type for tracked entity instances</td>
</tr>
<tr class="odd">
<td>OptionSet</td>
<td>Option set</td>
</tr>
<tr class="even">
<td>Attribute</td>
<td>Attribute for metadata</td>
</tr>
</tbody>
</table>

### Get translations { #get-translations } 

You can browse all translations through the translations resource:

    GET /api/33/translations

You can use the standard filtering technique to fetch translations of
interest. E.g. to get all translations for data elements in the Spanish
locale you can use this request:

    /api/33/translations.json?fields=*&filter=className:eq:DataElement&filter=locale:eq:es

To get translations for a specific object for all properties:

    /api/33/translations.json?fields=*&filter=className:eq:DataElement
      &filter=locale:eq:fr&filter=objectId:eq:fbfJHSPpUQD

## Service de messages courts (SMS) { #webapi_sms } 

<!--DHIS2-SECTION-ID:webapi_sms-->

Cette section porte sur l'API Web SMS, qui permet d'envoyer et de recevoir des messages 
texte courts.

### Service de SMS sortant { #outbound-sms-service } 

L'API Web prend en charge l'envoi de SMS sortants à l'aide de la méthode POST. Les SMS peuvent 
être envoyés à un ou plusieurs destinataires. Une ou plusieurs passerelles doivent 
être configurées avant d'utiliser le service. Un SMS ne sera pas envoyé si 
aucune passerelle n'est configurée. Il nécessite un ensemble de destinataires et 
un texte de message au format JSON, comme indiqué ci-dessous.

    /api/sms/sortant

```json
{
  "message":"Texte du Sms",
  "destinataires": [
    "004712341234",
    "004712341235"
  ]
}
```

> **Remarque**
>
> La liste des destinataires sera divisée si la taille dépasse la limite `DESTINATAIRES_MAXIMUM_AUTORISÉS` de 200.

L'API Web prend également en charge une version de paramètre de requête, mais 
l'API paramétrée ne peut être utilisée que pour envoyer des SMS à un seul 
destinataire.

    /api/sms/outbound?message=text&recipient=004712341234

Les messages sortants peuvent être récupérés à l'aide de la ressource GET.

    GET /api/sms/outbound
    GET /api/sms/outbound?filter=status:eq:SENT
    GET /api/sms/outbound?filter=status:eq:SENT&fields=*

Les messages sortants peuvent être supprimés à l'aide de la ressource SUPPRIMER.

    DELETE /api/sms/outbound/{uid}
    DELETE /api/sms/outbound?ids=uid1,uid2  

#### Codes de réponse de la passerelle { #gateway-response-codes } 

La passerelle peut répondre avec les codes de réponse suivants.

<table>
<caption>Gateway response codes</caption>
<colgroup>
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 73%" />
</colgroup>
<thead>
<tr class="header">
<th>Response code</th>
<th>Response Message</th>
<th>Detail Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>RESULT_CODE_0</td>
<td>success</td>
<td>Message has been sent successfully</td>
</tr>
<tr class="even">
<td>RESULT_CODE_1</td>
<td>scheduled</td>
<td>Message has been scheduled successfully</td>
</tr>
<tr class="odd">
<td>RESULT_CODE_22</td>
<td>internal fatal error</td>
<td>Internal fatal error</td>
</tr>
<tr class="even">
<td>RESULT_CODE_23</td>
<td>authentication failure</td>
<td>Authentication credentials are incorrect</td>
</tr>
<tr class="odd">
<td>RESULT_CODE_24</td>
<td>data validation failed</td>
<td>Parameters provided in request are incorrect</td>
</tr>
<tr class="even">
<td>RESULT_CODE_25</td>
<td>insufficient credits</td>
<td>Credit is not enough to send message</td>
</tr>
<tr class="odd">
<td>RESULT_CODE_26</td>
<td>upstream credits not available</td>
<td>Upstream credits not available</td>
</tr>
<tr class="even">
<td>RESULT_CODE_27</td>
<td>exceeded your daily quota</td>
<td>You have exceeded your daily quota</td>
</tr>
<tr class="odd">
<td>RESULT_CODE_40</td>
<td>temporarily unavailable</td>
<td>Service is temporarily down</td>
</tr>
<tr class="even">
<td>RESULT_CODE_201</td>
<td>maximum batch size exceeded</td>
<td>Maximum batch size exceeded</td>
</tr>
<tr class="odd">
<td>RESULT_CODE_200</td>
<td>success</td>
<td>The request was successfully completed</td>
</tr>
<tr class="even">
<td>RESULT_CODE_202</td>
<td>accepted</td>
<td>The message(s) will be processed</td>
</tr>
<tr class="odd">
<td>RESULT_CODE_207</td>
<td>multi-status</td>
<td>More than one message was submitted to the API; however, not all messages have the same status</td>
</tr>
<tr class="even">
<td>RESULT_CODE_400</td>
<td>bad request</td>
<td>Validation failure (such as missing/invalid parameters or headers)</td>
</tr>
<tr class="odd">
<td>RESULT_CODE_401</td>
<td>unauthorized</td>
<td>Authentication failure. This can also be caused by IP lockdown settings</td>
</tr>
<tr class="even">
<td>RESULT_CODE_402</td>
<td>payment required</td>
<td>Not enough credit to send message</td>
</tr>
<tr class="odd">
<td>RESULT_CODE_404</td>
<td>not found</td>
<td>Resource does not exist</td>
</tr>
<tr class="even">
<td>RESULT_CODE_405</td>
<td>method not allowed</td>
<td>Http method is not support on the resource</td>
</tr>
<tr class="odd">
<td>RESULT_CODE_410</td>
<td>gone</td>
<td>Mobile number is blocked</td>
</tr>
<tr class="even">
<td>RESULT_CODE_429</td>
<td>too many requests</td>
<td>Generic rate limiting error</td>
</tr>
<tr class="odd">
<td>RESULT_CODE_503</td>
<td>service unavailable</td>
<td>A temporary error has occurred on our platform - please retry</td>
</tr>
</tbody>
</table>

### Service de SMS entrants { #inbound-sms-service } 

L'API Web prend en charge la collecte des messages SMS entrants à l'aide de la méthode 
POST. Les messages entrants acheminés vers l'API Web DHIS2 peuvent être 
reçus à l'aide de cette API. L'API collecte les messages SMS entrants et 
les fournit aux auditeurs pour qu'ils les analysent, en fonction du contenu du SMS (commande SMS). Un exemple de charge utile au format JSON est donné ci-dessous. Le 
texte, l'expéditeur, la date de réception et la date d'envoi sont des paramètres obligatoires. 
Les autres sont facultatifs, mais le système utilisera la valeur par défaut pour ces 
paramètres.

    /api/sms/entrant

```json
{
  "texte" : "texte de l'échantillon",
  "auteur": "004712341234",
  "iddelapasserelle " : " inconnu",
  "date de réception": "2016-05-01",
  "date d'envoi":"2016-05-01",
  "codage sms": "1",
  "statut sms":"1"
}
```

Les messages entrants peuvent être récupérés à l'aide de la ressource GET.

    GET /api/sms/inbound
    GET /api/sms/inbound?fields=*&filter=smsstatus=INCOMING

Les messages entrants peuvent être supprimés à l'aide de la ressource SUPPRIMER.

    SUPPRIMER /api/sms/inbound/{uid}
    SUPPRIMER /api/sms/inbound?ids=uid1,uid2

Pour importer tous les messages non traités

    POST /api/sms/entrant/importer

<table>
<caption>User query parameters</caption>
<colgroup>
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 73%" />
</colgroup>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>message</td>
<td>String</td>
<td>This is mandatory parameter which carries the actual text message.</td>
</tr>
<tr class="even">
<td>originator</td>
<td>String</td>
<td>This is mandatory parameter which shows by whom this message was actually sent from.</td>
</tr>
<tr class="odd">
<td>gateway</td>
<td>String</td>
<td>This is an optional parameter which gives gateway id. If not present default text &quot;UNKNOWN&quot; will be stored</td>
</tr>
<tr class="even">
<td>receiveTime</td>
<td>Date</td>
<td>This is an optional parameter. It is timestamp at which message was received at the gateway.</td>
</tr>
</tbody>
</table>

### Administration du service de la passerelle { #gateway-service-administration } 

L'API Web expose des ressources qui permettent de configurer et 
de mettre à jour les configurations de la passerelle SMS.

La liste des différentes passerelles configurées peut être obtenue à l'aide de la méthode 
GET

    GET /api/33/gateways

Les configurations peuvent également être récupérées pour un type de passerelle spécifique à l'aide de la
méthode GET.

    GET /api/33/gateways/{uid}

De nouvelles configurations de passerelles peuvent être ajoutées à l'aide de POST. L'api POST nécessite un paramètre de requête de type et actuellement sa valeur peut être *http,bulksms,clickatell,smpp*. La première passerelle ajoutée sera définie par défaut. Une seule passerelle peut être définie par défaut à la fois. La passerelle par défaut ne peut être modifiée que par l'intermédiaire de son interface utilisateur. Si la passerelle par défaut est supprimée, la suivante dans la liste deviendra automatiquement la passerelle par défaut.

    POST /api/33/gateways

La configuration peut être mise à jour en fournissant l'uid et la configuration de la passerelle comme indiqué ci-dessous

    PUT /api/33/gateways/{uids}

Les configurations peuvent être supprimées pour un type de passerelle spécifique à l'aide de la méthode 
SUPPRIMER

    DELETE /api/33/gateways/{uid}

La passerelle par défaut peut être récupérée et mise à jour.

    GET /api/33/gateways/default

Default gateway can be set using the PUT method.

    PUT /api/33/gateways/default/{uid}

### Configuration de la passerelle { #gateway-configuration } 

L'API Web vous permet de créer et de mettre à jour les configurations de la passerelle. Pour chaque
type de passerelle, les paramètres de la charge utile JSON sont différents.
Des exemples de charges utiles JSON pour chaque passerelle sont donnés ci-dessous. POST est utilisé pour
créer et PUT pour mettre à jour les configurations. Le paramètre En-tête peut être utilisé dans
le cas de "GenericHttpGateway" pour envoyer un ou plusieurs paramètres en tant qu'en-tête http.

#### Clickatell { #clickatell } 

```json
{
  "type" : "clickatell",
  "nom" : "clickatell",
  "nom d'utilisateur": "utilisateur de clickatell",
  "authToken": "XXXXXXXXXXXXXXXXXXXX",
  "modèle d'url": "https://platform.clickatell.com/messages"
}
```

#### Bulksms { #bulksms } 

```json
{
  "type": "bulksms",
  "nom": "bulkSMS",
  "nom d'utilisateur": "utilisateur bulk",
  "mot de passe": "abc123"
}
```

#### Passerelle SMPP { #smpp-gateway } 

```json
{
  "type": "smpp",
  "nom": "smpp gateway2",
  "systemId": "smppclient1",
  "hôte" : " hôte local",
  "type de système": "cp",
  "Indicateur de plan de numérotation": "INCONNU",
  "typeDeNombre": "INCONNU",
  "type de lien": "BIND_TX",
  "port": 2775,
  "mot de passe" : "mot de passe",
  "compressé" : faux
}
```

#### Générique HTTP { #generic-http } 

```json
{
  "type": "http",
  "nom": "Générique",
  "modèle de configuration": "nom d'utilisateur=${nom d'utilisateur}&mot de passe=${mot de passe}&to=${destinataires}&code pays=880&message=${text$}&identifiant du message=0",
  "useGet": faux,
  "paramètres d'envoi d'URL":faux,
  "type de contenu": "APPLICATION_JSON",
  "modèle d'url":"https://samplegateway.com/messages",
  "paramètres": [
    {
      "en-tête": vrai,
      "code": faux,
      "clé": "nom d'utilisateur",
      "valeur": "utilisateur_uio",
      "confidentiel": vrai
    },
    {
      "en-tête": vrai,
      "code": faux,
      "clé": "mot de passe",
      "valeur": "123abcxyz",
      "confidentiel": vrai
    },
    {
      "en-tête": faux,
      "code": faux,
      "clé": "rapport de diffusion",
      "valeur": "oui",
      "confidentiel": faux
    }
  ],
  "estParDéfaut": faux
}
```

In generic http gateway any number of parameters can be added. 

<table>
<caption>Generic SMS gateway parameters</caption>
<colgroup>
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 73%" />
</colgroup>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>name</td>
<td>String</td>
<td>name of the gateway</td>
</tr>
<tr class="even">
<td>configurationTemplate</td>
<td>String</td>
<td>Configuration template which get populated with parameter values. For example configuration template given above will be populated like this { "to": "+27001234567", "body": "Hello World!"}</td>
</tr>
<tr class="odd">
<td>useGet</td>
<td>Boolean</td>
<td>Http POST nethod will be used by default. In order to change it and Http GET, user can set useGet flag to true.</td>
</tr>
<tr class="even">
<td>contentType</td>
<td>String</td>
<td>Content type specify what type of data is being sent. Supported types are APPLICATION_JSON, APPLICATION_XML, FORM_URL_ENCODED, TEXT_PLAIN</td>
</tr>
<tr class="odd">
<td>urlTemplate</td>
<td>String</td>
<td>Url template</td>
</tr>
<tr class="even">
<td>header</td>
<td>Boolean</td>
<td>If parameter needs to be sent in Http headers</td>
</tr>
<tr class="odd">
<td>encode</td>
<td>Boolean</td>
<td>If parameter needs to be encoded</td>
</tr>
<tr class="even">
<td>key</td>
<td>String</td>
<td>parameter key</td>
</tr>
<tr class="odd">
<td>value</td>
<td>String</td>
<td>parameter value</td>
</tr>
<tr class="even">
<td>confidential</td>
<td>Boolean</td>
<td>If parameter is confidential. This parameter will not be exposed through API</td>
</tr>
<tr class="odd">
<td>sendUrlParameters</td>
<td>Boolean</td>
<td>If this flag is checked then urlTemplate can be appended with query parameters. This is usefull if gateway API only support HTTP GET. Sample urlTemplate looks like this "urlTemplate":"https://samplegateway.com/messages?apiKey={apiKey}&to={recipients},content={text},deliveryreport={dp}"</td>
</tr>
</tbody>
</table>

HTTP.OK sera renvoyé si les configurations sont sauvegardées avec succès, sinon *Erreur*

## Les commandes SMS { #webapi_sms_commands } 

<!--DHIS2-SECTION-ID:webapi_sms_commands-->

Les commandes SMS sont utilisées pour collecter des données par SMS. Ces commandes 
appartiennent à un type d'analyseur spécifique. Chaque analyseur a des fonctionnalités différentes.

La liste des commandes peut être récupérée à l'aide de la fonction GET.

    GET /api/smsCommands

Une commande particulière peut être récupérée à l'aide de GET.

    GET /api/smsCommands/uid

Une commande particulière peut être mise à jour à l'aide de PUT.

    PUT /api/smsCommands/uid

La commande peut être créée en utilisant POST.

    POST /api/smsCommands

Une commande particulière peut être supprimée à l'aide de la commande SUPPRIMER.

    DELETE /api/smsCommands/uid

#### Types de commande SMS { #sms-command-types } 

| Type | Utilisation |
|---|---|
|ANALYSEUR_CLÉ_DE VALEUR | Pour la collecte de données agrégées.|
|ANALYSEUR_D'ALERTES | Pour envoyer des messages d'alerte.|
|ANALYSEUR_NON ENREGISTRÉ | Pour la surveillance des maladies et la notification des cas.|
|ANALYSEUR_D'ENREGISTREMENT_D'ENTITÉS_SUIVIES | Pour l'enregistrement de l'entité du tracker.|
|ANALYSEUR_DE SAISIE DE DONNÉES_DE L'ÉTAPE_DU PROGRAMME | Collecte de données pour l'étape du programme. ( L'IES est identifié sur la base du numéro de téléphone )|
|ANALYSEUR_D'ENREGISTREMENT_D'ÉVÉNEMENTS | Enregistrement d'un événement unique. Elle est utilisée pour les programmes d'événements.|

#### Types de commandes SMS pour Android { #sms-command-types-for-android } 

Ces types de commandes peuvent être utilisés par l'application Android pour l'envoi de données par SMS lorsque la connexion internet n'est pas disponible. Le SMS est composé par l'application Android.

| Type | Utilisation |
|---|---|
|ENSEMBLE DE DONNÉES_AGRÉGÉ | Pour la collecte de données agrégées.|
|INSCRIPTION | Pour l'enregistrement de l'entité du tracker.|
|ÉVÉNEMENT_TRACKER | Inscription à un événement pour les programmes tracker.|
|ÉVÉNEMENT_SIMPLE | Inscription aux programmes d'événements.|
|RELATION | Pour créer des relations.|
|SUPPRIMER | Supprimer un événement.|

## Program Messages { #webapi_program_messages } 

<!--DHIS2-SECTION-ID:webapi_program_messages-->

"Message de programme" vous permet d'envoyer des messages à des instances d'entités suivies, à des adresses associées à des unités d'organisation, à des numéros de téléphone et à des adresses électroniques. Vous pouvez envoyer des messages via la ressource `messages`.

    /api/33/messages

### Envoi de messages de programme { #sending-program-messages } 

Les messages de programme peuvent être envoyés à l'aide de deux canaux :

  - SMS (SMS)

  - Adresse électronique (EMAIL)

Les messages de programme peuvent être envoyés à différents destinataires :

  - Instance d'entité suivie : Le système recherchera les attributs de 
    type PHONE_NUMBER ou EMAIL (en fonction des canaux spécifiés) et utilisera les valeurs d'attribut correspondantes.
    spécifiés) et utilisera les valeurs d'attribut correspondantes.

  - Unité d'organisation : Le système utilisera le numéro de téléphone ou l'adresse électronique
    enregistrés pour l'unité d'organisation.

  - Liste de numéros de téléphone : Le système utilisera les numéros de téléphone définis.
     

  - Liste d'adresses électroniques : Le système utilisera les adresses électroniques définies.
     

Vous trouverez ci-dessous un exemple de charge JSON pour l'envoi de messages à l'aide de requêtes POST. Notez que la ressource "message" accepte un objet enveloppeur nommé `programMessages` qui peut contenir un nombre quelconque de messages de programme.

    POST /api/33/messages

```json
{
  "programMessages": [{
    "recipients": {
      "trackedEntityInstance": {
        "id": "UN810PwyVYO"
      },
      "organisationUnit": {
        "id": "Rp268JB6Ne4"
      },
      "phoneNumbers": [
        "55512345",
        "55545678"
      ],
      "emailAddresses": [
        "johndoe@mail.com",
        "markdoe@mail.com"
      ]
    },
    "programInstance": {
      "id": "f3rg8gFag8j"
    },
    "programStageInstance": {
      "id": "pSllsjpfLH2"
    },
    "deliveryChannels": [
      "SMS", "EMAIL"
    ],
    "subject": "Outbreak alert",
    "text": "An outbreak has been detected",
    "storeCopy": false
  }]
}
```

Les champs sont expliqués dans le tableau suivant.

<table>
<caption>Program message payload</caption>
<colgroup>
<col style="width: 21%" />
<col style="width: 21%" />
<col style="width: 31%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr class="header">
<th>Field</th>
<th>Required</th>
<th>Description</th>
<th>Values</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>recipients</td>
<td>Yes</td>
<td>Recipients of the program message. At least one recipient must be specified. Any number of recipients / types can be specified for a message.</td>
<td>Can be trackedEntityInstance, organisationUnit, an array of phoneNumbers or an array of emailAddresses.</td>
</tr>
<tr class="even">
<td>programInstance</td>
<td>Either this or programStageInstance required</td>
<td>The program instance / enrollment.</td>
<td>Enrollment ID.</td>
</tr>
<tr class="odd">
<td>programStageInstance</td>
<td>Either this or programInstance required</td>
<td>The program stage instance / event.</td>
<td>Event ID.</td>
</tr>
<tr class="even">
<td>deliveryChannels</td>
<td>Yes</td>
<td>Array of delivery channels.</td>
<td>SMS | EMAIL</td>
</tr>
<tr class="odd">
<td>subject</td>
<td>No</td>
<td>The message subject. Not applicable for SMS delivery channel.</td>
<td>Text.</td>
</tr>
<tr class="even">
<td>text</td>
<td>Yes</td>
<td>The message text.</td>
<td>Text.</td>
</tr>
<tr class="odd">
<td>storeCopy</td>
<td>No</td>
<td>Whether to store a copy of the program message in DHIS2.</td>
<td>false (default) | true</td>
</tr>
</tbody>
</table>

Un exemple minimaliste d'envoi de message par SMS à une instance d'entité suivie ressemble à ceci :

```bash
curl -d @message.json "https://play.dhis2.org/demo/api/33/messages"
  -H "Content-Type:application/json" -u admin:district
```

```json
{
  "programMessages": [{
    "recipients": {
      "trackedEntityInstance": {
        "id": "PQfMcpmXeFE"
      }
    },
    "programInstance": {
      "id": "JMgRZyeLWOo"
    },
    "deliveryChannels": [
      "SMS"
    ],
    "text": "Please make a visit on Thursday"
  }]
}
```

### Récupération et suppression des messages de programme { #retrieving-and-deleting-program-messages } 

La liste des messages peut être récupérée à l'aide de la fonction GET.

    GET /api/33/messages

To get list of all scheduled message 

    GET /api/33/messages/scheduled
    GET /api/33/messages/scheduled?scheduledAt=2020-12-12 

Un message spécifique peut également être récupéré à l'aide de la méthode GET.

    GET /api/33/messages/{uid}

Un message peut être supprimé à l'aide de la méthode DELETE.

    DELETE /api/33/messages/{uid}


### Requête pour des messages de programme { #querying-program-messages } 

L'API des messages de programme prend en charge les requêtes de messages de programme en utilisant des paramètres de requête. Les messages peuvent être filtrés en fonction des paramètres de requête mentionnés ci-dessous. Toutes les requêtes doivent utiliser la méthode GET HTTP pour récupérer les informations.

<table>
<caption>Query program messages API</caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="header">
<th>Parameter</th>
<th>URL</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>programInstance</td>
<td>/api/33/messages?programInstance=6yWDMa0LP7</td>
</tr>
<tr class="even">
<td>programStageInstance</td>
<td>/api/33/messages?programStageInstance=SllsjpfLH2</td>
</tr>
<tr class="odd">
<td>trackedEntityInstance</td>
<td>/api/33/messages?trackedEntityInstance=xdfejpfLH2</td>
</tr>
<tr class="even">
<td>organisationUnit</td>
<td>/api/33/messages?ou=Sllsjdhoe3</td>
</tr>
<tr class="odd">
<td>processedDate</td>
<td>/api/33/messages?processedDate=2016-02-01</td>
</tr>
</tbody>
</table>

## Utilisateurs { #webapi_users } 

<!--DHIS2-SECTION-ID:webapi_users-->

Cette section couvre les méthodes de ressources de l'utilisateur.

    /api/33/users

### Requête de l'utilisateur { #webapi_users_query } 

<!--DHIS2-SECTION-ID:webapi_users_query-->

La ressource *utilisateurs* offre des paramètres de requête supplémentaires en plus des
paramètres standard (par exemple, la pagination). Pour rechercher des utilisateurs 
dans la ressource vous pouvez utiliser les paramètres suivants.

<table>
<caption>User query parameters</caption>
<colgroup>
<col style="width: 18%" />
<col style="width: 17%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>query</td>
<td>Text</td>
<td>Query value for first name, surname, username and email, case in-sensitive.</td>
</tr>
<tr class="even">
<td>phoneNumber</td>
<td>Text</td>
<td>Query for phone number.</td>
</tr>
<tr class="odd">
<td>canManage</td>
<td>false | true</td>
<td>Filter on whether the current user can manage the returned users through the managed user group relationships.</td>
</tr>
<tr class="even">
<td>authSubset</td>
<td>false | true</td>
<td>Filter on whether the returned users have a subset of the authorities of the current user.</td>
</tr>
<tr class="odd">
<td>lastLogin</td>
<td>Date</td>
<td>Filter on users who have logged in later than the given date.</td>
</tr>
<tr class="even">
<td>inactiveMonths</td>
<td>Number</td>
<td>Filter on users who have not logged in for the given number of months.</td>
</tr>
<tr class="odd">
<td>inactiveSince</td>
<td>Date</td>
<td>Filter on users who have not logged in later than the given date.</td>
</tr>
<tr class="even">
<td>selfRegistered</td>
<td>false | true</td>
<td>Filter on users who have self-registered their user account.</td>
</tr>
<tr class="odd">
<td>invitationStatus</td>
<td>none | all | expired</td>
<td>Filter on user invitations, including all or expired invitations.</td>
</tr>
<tr class="even">
<td>ou</td>
<td>Identifier</td>
<td>Filter on users who are associated with the organisation unit with the given identifier.</td>
</tr>
<tr class="odd">
<td>userOrgUnits</td>
<td>false | true</td>
<td>Filter on users who are associated with the organisation units linked to the currently logged in user.</td>
</tr>
<tr class="even">
<td>includeChildren</td>
<td>false | true</td>
<td>Includes users from all children organisation units of the ou parameter.</td>
</tr>
<tr class="odd">
<td>page</td>
<td>Number</td>
<td>The page number.</td>
</tr>
<tr class="even">
<td>pageSize</td>
<td>Number</td>
<td>The page size.</td>
</tr>
</tbody>
</table>

Une requête pour un maximum de 10 utilisateurs avec "konan" comme prénom ou nom de famille (sensible 
à la casse) qui ont un sous-ensemble d'autorisations par rapport à l'utilisateur 
actuel :

    /api/33/users?query=konan&authSubset=true&pageSize=10

### Recherche d'utilisateurs { #user-lookup } 

The user lookup API provides an endpoint for retrieving users where the
response contains a minimal set of information. It does not require a 
specific authority and is suitable  for allowing clients to look up information 
such as user first and surname,  without exposing potentially sensitive 
user information.

```
/api/userLookup
```

Le système de recherche de l'utilisateur comporte deux méthodes.

#### Recherche des utilisateurs par identifiant { #user-lookup-by-identifier } 

Vous pouvez effectuer une recherche d'utilisateur par identifiant en utilisant la requête API suivante :

```
GET /api/userLookup/{id}
```

L'`ID` de l'utilisateur sera recherché par rapport aux propriétés d'utilisateur 
suivantes dans l'ordre indiqué :

- UID
- UUID
- Nom d'utilisateur

Voici donc un exemple de requête :

```
/api/userLookup/QqvaU7JjkUV
```

La réponse comportera un minimum d'informations relatives à l'utilisateur.

```json
{
  "id": "QqvaU7JjkUV",
  "nom d'utilisateur": "nkono",
  "prénom": "Thomas",
  "nom de famille": "Nkono",
  "nom affiché": "Thomas Nkono"
}
```

#### Requête de recherche d'utilisateurs { #user-lookup-query } 

Vous pouvez réaliser une requête des utilisateurs à partir de la requête API suivante :

```
GET /api/userLookup?query={string}
```

Le paramètre de requête `query` est obligatoire. La chaîne de requête `query` sera comparée 
aux propriétés utilisateur suivantes :

- Prénom
- Nom
- Adresses électronique
- Nom d'utilisateur

Voici donc un exemple de requête :

```
/api/userLookup?query=John
```

La réponse comportera des informations relatives aux utilisateurs et correspondants à la requête.

```json
{
  "utilisateurs": [
    {
      "id": "DXyJmlo9rge",
      "nom d'utilisateur": "jbarnes",
      "prénom": "John",
      "nom de famille": "Barnes",
      "nom affiché": "John Barnes"
    },
    {
      "id": "N3PZBUlN8vq",
      "nom d'utilisateur": "jkamara",
      "prénom": "John",
      "nom de famille": "Kamara",
      "nom affiché": "John Kamara"
    }
  ]
}
```

### Créer et mettre à jour un compte utilisateur { #webapi_users_create_update } 

<!--DHIS2-SECTION-ID:webapi_users_create_update-->

Creating and updating users are supported through the API. A basic 
payload to create a user looks like the below example. Note that the password 
will be sent in plain text so remember to enable SSL/HTTPS for network transport.

```json
{
  "identifiant": "Mj8balLULKp",
  "Prénom": "John",
  "nom ": "Doe",
  "email": "johndoe@mail.com",
  "informations d'identification de l'utilisateur": {
    "identifiant": "lWCkJ4etppc",
    "infoUtilisateur": {
    "identifiant": "Mj8balLULKp"
  },
  "nom d'utilisateur": "johndoe123",
  "mot de passe": "Your-password-123",
  "skype": "john.doe",
  "telegram": "joh.doe",
  "whatsApp": "+1-541-754-3010",
  "facebookMessenger": "john.doe",
  "avatar": {
    "identifiant": "<fileResource id>"
  },
  "rôles d'utilisateur": [
    {
      "identifiant": "Ufph3mGRmMo"
    }
  ]
  },
  "unités d'organisation": [
    {
      "identifiant": "Rp268JB6Ne4"
    }
  ],
  "groupes d'utilisateurs": [
    {
      "identifiant": "wl5cDMuUhmF"
    }
  ]
}
```

```bash
curl -X POST -d @u.json "http://server/api/33/users" -u user:pass 
  -H "Content-Type: application/json" 
```

In the user creation payload, user groups are only supported when importing 
or *POSTing* a single user at a time. If you attempt to create more than one 
user while specifiying user groups, you will not recieve an error and the 
users will be created but no user groups will be assigned. This is by design 
and is limited because of the many-to-many relationship between users and 
user groups whereby user groups is the owner of the relationship. To update 
or create mulitple users and their user groups, consider a program to *POST* 
one at a time, or *POST* all users followed by another action to 
update their user groups while specifiying the new user's identifiers.

Après la création de l'utilisateur, une entête *Location* est renvoyée avec l'identifiant 
nouvellement généré (vous pouvez également fournir le vôtre en utilisant le point d'extrémité 
`/api/system/id`). La même charge utile peut alors être utilisée pour faire des mises à jour, mais n'oubliez pas 
d'utiliser *PUT* au lieu de *POST* et le point d'extrémité est désormais `/api/users/ID`.

```bash
curl -X PUT -d @u.json "http://server/api/33/users/ID" -u user:pass 
  -H "Content-Type: application/json" 
```

Pour plus d'informations sur l'ensemble des données disponibles, voir `/api/schemas/user`.

Pour plus d'informations sur le téléchargement et la récupération des avatars des utilisateurs, veuillez consulter le 
point d'extrémité `/fileResources`.

### Invitations pour les comptes d'utilisateurs { #webapi_user_invitations } 

<!--DHIS2-SECTION-ID:webapi_user_invitations-->

L'API Web permet d'inviter des personnes à créer des comptes d'utilisateur par le biais de la ressource
`invite`. Pour créer une invitation, vous devez POSTER un utilisateur au format XML
ou JSON à la ressource "invite". Un nom d'utilisateur spécifique peut être imposé
en définissant le nom d'utilisateur dans l'entité postée. En omettant le nom d'utilisateur,
la personne pourra le spécifier elle-même. Le système enverra
une invitation par courrier électronique. Il faut pour cela que les paramètres de messagerie soient
correctement configurés.

La ressource "invite" est utile pour permettre en toute sécurité
à des personnes de créer des comptes sans que personne d'autre ne connaisse le mot de passe
ou en transférant le mot de passe en texte clair. La charge utile à utiliser pour
l'invitation est la même que pour la création d'utilisateurs. Un exemple de charge utile en JSON
ressemble à ceci :

```json
{
  "prénom": "John",
  "nom": "Doe",
  "email": "johndoe@mail.com",
  "informations d'identification de l'utilisateur": {
    "nom d'utilisateur": "johndoe",
    "roles d'utilisateur": [{
      "id": "Euq3XfEIEbx"
    }]
  },
  "unités d'organisation": [ {
    "id": "ImspTQPwCqd"
  } ],
  "groupes d'utilisateurs": [ {
    "id": "vAvEltyXGbD"
  }]
}
```

L'entité d'invitation de l'utilisateur peut être affichée comme suit :

```bash
curl -d @invite.json "localhost/api/33/users/invite" -u admin:district
  -H "Content-Type:application/json" 
```

Pour envoyer des invitations à plusieurs utilisateurs en même temps, vous devez utiliser un 
format légèrement différent. Pour JSON :

```json
{
  "utilisateurs": [ {
    "prénom": "John",
    "nom": "Doe",
    "email": "johndoe@mail.com",
    "informations d'identification de l'utilisateur": {
      "nom d'utilisateur": "johndoe",
      "rôles d'utilisateur": [ {
        "id": "Euq3XfEIEbx"
      } ]
    },
    "unités d'organisation": [ {
      "id": "ImspTQPwCqd"
      } ]
    }, {
    "prénom": "Tom",
    "nom": "Johnson",
    "email": "tomj@mail.com",
    "informations d'identification de l'utilisateur": {
      "rôles d'utilisateur": [ {
        "id": "Euq3XfEIEbx"
      } ]
    },
    "unités d'organisation": [ {
      "id": "ImspTQPwCqd"
      } ]
    }
  ]
}
```

Pour créer plusieurs invitations, vous pouvez envoyer la charge utile à la ressource
api/users/invites comme ceci :

```bash
curl -d @invites.json "localhost/api/33/users/invites" -u admin:district
  -H "Content-Type:application/json"
```

Certaines conditions doivent être remplies pour que les invitations à ouvrir un compte d'utilisateur soient 
envoyées :

  - Le serveur SMTP doit être configuré correctement sur le serveur.

  - L'utilisateur à inviter doit avoir indiqué un e-mail valide.

  - Si le nom d'utilisateur est spécifié, il ne doit pas être déjà pris par un autre
    utilisateur existant.

Si l'une de ces conditions n'est pas remplie, la ressource invitée renvoie 
un code d'état *409 Conflict* accompagné d'un message descriptif.

### Réplication de l'utilisateur { #webapi_user_replication } 

<!--DHIS2-SECTION-ID:webapi_user_replication-->

Pour répliquer un utilisateur, vous pouvez utiliser la ressource *replica*. Répliquer un
utilisateur peut être utile pour déboguer ou reproduire des problèmes signalés par un
particulier. Vous devez fournir un nouveau nom d'utilisateur et un nouveau mot de passe à l'utilisateur 
répliqué, que vous allez utiliser pour vous authentifier ultérieurement. Notez que vous
avez besoin de l'autorisation ALL pour effectuer cette action. Pour répliquer un utilisateur, vous
vous pouvez envoyer une charge utile JSON comme ci-dessous :

```json
{
  "nom d'utilisateur" : " utilisateur_replica",
  "mot de passe" : " Motdepassesecret "
}
```

Cette charge utile peut être envoyée à la ressource réplique, où vous fournissez
l'identifiant de l'utilisateur à répliquer dans l'URL :

    /api/33/users/<uid>/replica

Voici un exemple de reproduction d'un utilisateur à l'aide de curl :

```bash
curl -d @replica.json "localhost/api/33/users/N3PZBUlN8vq/replica"
  -H "Content-Type:application/json" -u admin:district
```

## Informations sur l'utilisateur actuel { #webapi_current_user_information } 

<!--DHIS2-SECTION-ID:webapi_current_user_information-->

Pour obtenir des informations sur l'utilisateur actuellement authentifié et ses associations 
avec d'autres ressources, vous pouvez utiliser la ressource *me* 
(vous pouvez également l'appeler par son ancien nom *currentUser*). Les 
ressources liées à l'utilisateur actuel fournissent des informations utiles lors 
de la création de clients, par exemple pour la saisie de données et la gestion des utilisateurs. Les 
paragraphes suivants décrivent ces ressources et leur objectif.

Fournit des informations de base sur l'utilisateur sous lequel vous êtes actuellement connecté.
en tant qu'utilisateur, y compris le nom d'utilisateur, les informations d'identification de l'utilisateur, les unités d'organisation 
affectées:

    /api/me

Donne des informations sur les messages non lus et les interprétations :

    /api/me/tableau de bord

Pour modifier le mot de passe, ce point d'extrémité peut être utilisé pour valider le mot de passe nouvellement saisi.
le nouveau mot de passe. La validation du mot de passe sera effectuée sur la base des
PasswordValidationRules configurées dans le système. Ce point d'extrémité prend en charge
POST et la chaîne du mot de passe doit être envoyée dans le corps de POST.

    /api/me/valider le mot de passe

Lors d'un changement de mot de passe, ce point final (support POST) peut être utilisé pour
vérifier l'ancien mot de passe. La chaîne du mot de passe doit être envoyée dans le corps du POST.

    /api/me/verifier le mot de passe

Renvoie l'ensemble des autorisations accordées à l'utilisateur actuel :

    /api/me/authorisation

Renvoie vrai ou faux, indiquant si l'utilisateur actuel a 
reçu l'autorisation `<auth>` donnée:

    /api/me/authorisation/<auth>

Indique les niveaux d'approbation des données correspondant à l'utilisateur actuel :

    /api/me/Niveaux d'approbation des données

## Paramètres du système { #webapi_system_settings } 

<!--DHIS2-SECTION-ID:webapi_system_settings-->

Vous pouvez manipuler les paramètres du système en interagissant avec la ressource
*systemSettings*. Un paramètre système est une simple paire clé-valeur,
où la clé et la valeur sont des chaînes de texte en clair. Pour enregistrer ou
mettre à jour un paramètre système, vous pouvez envoyer une requête *POST* à l'URL suivante :

    /api/33/systemSettings/my-key?value=my-val

Vous pouvez également soumettre la valeur du paramètre dans le corps de la requête,
où le type de contenu est défini sur "texte/clair". Par exemple, vous pouvez utiliser
curl comme suit :

```bash
curl "play.dhis2.org/demo/api/33/systemSettings/my-key" -d "My long value"
  -H "Content-Type: text/plain" -u admin:district
```

Pour définir les paramètres du système en bloc, vous pouvez envoyer un objet JSON avec une 
propriété et une valeur pour chaque paire clé-valeur de paramètre du système à l'aide d'une requête POST :

```json
{
  "notification de l'application clé" : "Bienvenue",
  "intro de l'application clé": "DHIS2",
  "pied de page de l'application clé" : "En savoir plus sur dhis2.org"
}
```

Translations for translatable Setting keys can be set by specifying locale as 
a query parameter and translated value which can be specified 
either as a query param or withing the body payload. See an example URL:

    /api/33/systemSettings/<my-key>?locale=<my-locale>&value=<my-translated-value> 

You should replace my-key with your real key and my-val with your real
value. To retrieve the value for a given key (in JSON or plain text) 
you can make a *GET* request to the following URL:

    /api/33/systemSettings/my-key

Alternativement, vous pouvez spécifier la clé en tant que paramètre de requête :

    /api/33/systemSettings?key=my-key

Vous pouvez récupérer des paramètres système spécifiques sous forme de JSON en répétant la clé
paramètre de la requête :

```bash
curl "play.dhis2.org/demo/api/33/systemSettings?key=keyApplicationNotification&key=keyApplicationIntro"
  -u admin:district
```

Vous pouvez récupérer tous les paramètres du système à l'aide d'une requête GET :

    /api/33/systemSettings

To retrieve a specific translation for a given translatable key you can specify 
a locale as query param:

    /api/33/systemSettings/<my-key>?locale=<my-locale>

If present, the translation for the given locale is returned. Otherwise, a default 
value is returned. If no locale is specified for the translatable key, the user default 
UI locale is used to fetch the correct translation. If the given translation is not 
present, again, the default value is returned.

La priorité pour les clés traduisibles est la suivante :

 locale spécifiée > UI local par défaut de l'utilisateur > valeur par défaut

To delete a system setting, you can make a *DELETE* request to the URL
similar to the one used above for retrieval. If a translatable key is 
used, all present translations will be deleted as well.

To delete only a specific translation of translatable key, the same URL 
as for adding a translation should be used and the empty value should be 
provided:

    /api/33/systemSettings/<my-key>?locale=<my-locale>&value=

Les paramètres système disponibles sont énumérés ci-dessous.

<table>
<caption>System settings</caption>
<colgroup>
<col style="width: 43%" />
<col style="width: 43%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr class="header">
<th>Key</th>
<th>Description</th>
<th>Translatable</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>keyUiLocale</td>
<td>Locale for the user interface</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyDbLocale</td>
<td>Locale for the database</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyAnalysisDisplayProperty</td>
<td>The property to display in analysis. Default: &quot;name&quot;</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyAnalysisDigitGroupSeparator</td>
<td>The separator used to separate digit groups</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyCurrentDomainType</td>
<td>Not yet in use</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyTrackerDashboardLayout</td>
<td>Used by tracker capture</td>
<td>No</td>
</tr>
<tr class="odd">
<td>applicationTitle</td>
<td>The application title. Default: &quot;DHIS2&quot;</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>keyApplicationIntro</td>
<td>The application introduction</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td>keyApplicationNotification</td>
<td>Application notification</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>keyApplicationFooter</td>
<td>Application left footer</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td>keyApplicationRightFooter</td>
<td>Application right footer</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>keyFlag</td>
<td>Application flag</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyFlagImage</td>
<td>Flag used in dashboard menu</td>
<td>No</td>
</tr>
<tr class="even">
<td>startModule</td>
<td>The startpage of the application. Default: &quot;dhis-web-dashboard-integration&quot;</td>
<td>No</td>
</tr>
<tr class="odd">
<td>factorDeviation</td>
<td>Data analysis standard deviation factor. Default: &quot;2d&quot;</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyEmailHostName</td>
<td>Email server hostname</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyEmailPort</td>
<td>Email server port</td>
<td>No</td>
<tr class="even">
<td>keyEmailTls</td>
<td>Use TLS. Default: &quot;true&quot;</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyEmailSender</td>
<td>Email sender</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyEmailUsername</td>
<td>Email server username</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyEmailPassword</td>
<td>Email server password</td>
<td>No</td>
</tr>
<tr class="even">
<td>minPasswordLength</td>
<td>Minimum length of password</td>
<td>No</td>
</tr>
<tr class="odd">
<td>maxPasswordLength</td>
<td>Maximum length of password</td>
<td>No</td>
</tr>
<tr class="even">
<td>keySmsSetting</td>
<td>SMS configuration</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyCacheStrategy</td>
<td>Cache strategy. Default: &quot;CACHE_6AM_TOMORROW&quot;</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyCacheability</td>
<td>PUBLIC or PRIVATE. Determines if proxy servers are allowed to cache data or not.</td>
<td>No</td>
</tr>
<tr class="odd">
<td>phoneNumberAreaCode</td>
<td>Phonenumber area code</td>
<td>No</td>
</tr>
<tr class="even">
<td>multiOrganisationUnitForms</td>
<td>Enable multi-organisation unit forms. Default: &quot;false&quot;</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyConfig</td>
<td></td>
<td>No</td>
</tr>
<tr class="even">
<td>keyAccountRecovery</td>
<td>Enable user account recovery. Default: &quot;false&quot;</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyLockMultipleFailedLogins</td>
<td>Enable locking access after multiple failed logins</td>
<td>No</td>
</tr>
<tr class="even">
<td>googleAnalyticsUA</td>
<td>Google Analytic UA key for tracking site-usage</td>
<td>No</td>
</tr>
<tr class="odd">
<td>credentialsExpires</td>
<td>Require user account password change. Default: &quot;0&quot; (Never)</td>
<td>No</td>
</tr>
<tr class="even">
<td>credentialsExpiryAlert</td>
<td>Enable alert when credentials are close to expiration date</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keySelfRegistrationNoRecaptcha</td>
<td>Do not require recaptcha for self registration. Default: &quot;false&quot;</td>
<td>No</td>
</tr>
<tr class="even">
<td>recaptchaSecret</td>
<td>Google API recaptcha secret. Default: dhis2 play instance API secret, but this will only works on you local instance and not in production.</td>
<td>No</td>
</tr>
<tr class="odd">
<td>recaptchaSite</td>
<td>Google API recaptcha site. Default: dhis2 play instance API site, but this will only works on you local instance and not in production.</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyCanGrantOwnUserAuthorityGroups</td>
<td>Allow users to grant own user roles. Default: &quot;false&quot;</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keySqlViewMaxLimit</td>
<td>Max limit for SQL view</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyRespectMetaDataStartEndDatesInAnalyticsTableExport</td>
<td>When &quot;true&quot;, analytics will skip data not within category option's start and end dates. Default: &quot;false&quot;</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keySkipDataTypeValidationInAnalyticsTableExport</td>
<td>Skips data type validation in analytics table export</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyCustomLoginPageLogo</td>
<td>Logo for custom login page</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyCustomTopMenuLogo</td>
<td>Logo for custom top menu</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyCacheAnalyticsDataYearThreshold</td>
<td>Analytics data older than this value (in years) will always be cached. &quot;0&quot; disabled this setting. Default: 0</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyCacheAnalyticsDataYearThreshold</td>
<td>Analytics data older than this value (in years) will always be cached. &quot;0&quot; disabled this setting. Default: 0</td>
<td>No</td>
</tr>
<tr class="even">
<td>analyticsFinancialYearStart</td>
<td>Set financial year start. Default: October</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyIgnoreAnalyticsApprovalYearThreshold</td>
<td>&quot;0&quot; check approval for all data. &quot;-1&quot; disable approval checking. &quot;1&quot; or higher checks approval for all data that is newer than &quot;1&quot; year.</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyAnalyticsMaxLimit</td>
<td>Maximum number of analytics recors. Default: &quot;50000&quot;</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyAnalyticsMaintenanceMode</td>
<td>Put analytics in maintenance mode. Default: &quot;false&quot;</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyDatabaseServerCpus</td>
<td>Number of database server CPUs. Default: &quot;0&quot; (Automatic)</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyLastSuccessfulAnalyticsTablesRuntime</td>
<td>Keeps timestamp of last successful analytics tables run</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyLastSuccessfulLatestAnalyticsPartitionRuntime</td>
<td>Keeps timestamp of last successful latest analytics partition run</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyLastMonitoringRun</td>
<td>Keeps timestamp of last monitoring run</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyLastSuccessfulDataSynch</td>
<td>Keeps timestamp of last successful data values synchronization</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyLastSuccessfulEventsDataSynch</td>
<td>Keeps timestamp of last successful Event programs data synchronization</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyLastCompleteDataSetRegistrationSyncSuccess</td>
<td>Keeps timestamp of last successful completeness synchronization</td>
<td>No</td>
</tr>
<tr class="odd">
<td>syncSkipSyncForDataChangedBefore</td>
<td>Specifies timestamp used to skip synchronization of all the data changed before this point in time</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyLastSuccessfulAnalyticsTablesUpdate</td>
<td>Keeps timestamp of last successful analytics tables update</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyLastSuccessfulLatestAnalyticsPartitionUpdate</td>
<td>Keeps timestamp of last successful latest analytics partition update</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyLastSuccessfulResourceTablesUpdate</td>
<td>Keeps timestamp of last successful resource tables update</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyLastSuccessfulSystemMonitoringPush</td>
<td>Keeps timestamp of last successful system monitoring push</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyLastSuccessfulMonitoring</td>
<td>Keeps timestamp of last successful monitoring</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyNextAnalyticsTableUpdate</td>
<td>Keeps timestamp of next analytics table update</td>
<td>No</td>
</tr>
<tr class="even">
<td>helpPageLink</td>
<td>Link to help page. Default: &quot;<a href="http://dhis2.github.io/dhis2-docs/master/en/user/html/dhis2_user_manual_en.html">https://dhis2.github.io/dhis2-docs/master/en/user/html/dhis2_user_manual_en.html</a></td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyAcceptanceRequiredForApproval</td>
<td>Acceptance required before approval. Default: &quot;false&quot;</td>
<td>No</td>
</tr>
<tr class="even">
<td>keySystemNotificationsEmail</td>
<td>Where to email system notifications</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyAnalysisRelativePeriod</td>
<td>Default relative period for analysis. Default: &quot;LAST_12_MONTHS&quot;</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyRequireAddToView</td>
<td>Require authority to add to view object lists. Default: &quot;false&quot;</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyAllowObjectAssignment</td>
<td>Allow assigning object to related objects during add or update. Default: &quot;false&quot;</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyUseCustomLogoFront</td>
<td>Enables the usage of a custom logo on the front page. Default: &quot;false&quot;</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyUseCustomLogoBanner</td>
<td>Enables the usage of a custom banner on the website. Default: &quot;false&quot;</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyDataImportStrictPeriods</td>
<td></td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyDataImportStrictPeriods</td>
<td>Require periods to match period type of data set. Default: &quot;false&quot;</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyDataImportStrictDataElements</td>
<td>Require data elements to be part of data set. Default: &quot;false&quot;</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyDataImportStrictCategoryOptionCombos</td>
<td>Require category option combos to match category combo of data element. Default: &quot;false&quot;</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyDataImportStrictOrganisationUnits</td>
<td>Require organisation units to match assignment of data set. Default: &quot;false&quot;</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyDataImportStrictAttributeOptionsCombos</td>
<td>Require attribute option combis to match category combo of data set. Default: &quot;false&quot;</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyDataImportRequireCategoryOptionCombo</td>
<td>Require category option combo to be specified. Default: &quot;false&quot;</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyDataImportRequireAttributeOptionCombo</td>
<td>Require attribute option combo to be specified. Default: &quot;false&quot;</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyCustomJs</td>
<td>Custom JavaScript to be used on the website</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyCustomCss</td>
<td>Custom CSS to be used on the website</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyCalendar</td>
<td>The calendar type. Default: &quot;iso8601&quot;.</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyDateFormat</td>
<td>The format in which dates should be displayed. Default: &quot;yyyy-MM-dd&quot;.</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyStyle</td>
<td>The style used on the DHIS2 webpages. Default: &quot;light_blue/light_blue.css&quot;.</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyRemoteInstanceUrl</td>
<td>Url used to connect to remote instance</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyRemoteInstanceUsername</td>
<td>Username used to connect to remote DHIS2 instance</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyRemoteInstancePassword</td>
<td>Password used to connect to remote DHIS2 instance</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyGoogleMapsApiKey</td>
<td>Google Maps API key</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyGoogleCloudApiKey</td>
<td>Google Cloud API key</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyLastMetaDataSyncSuccess</td>
<td>Keeps timestamp of last successful metadata synchronization </td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyVersionEnabled</td>
<td>Enables metadata versioning</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyMetadataFailedVersion</td>
<td>Keeps details about failed metadata version sync</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyMetadataLastFailedTime</td>
<td>Keeps timestamp of last metadata synchronization failure</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyLastSuccessfulScheduledProgramNotifications</td>
<td>Not in use</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyLastSuccessfulScheduledDataSetNotifications</td>
<td>Not in use</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyRemoteMetadataVersion</td>
<td>Details about metadata version of remote instance</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keySystemMetadataVersion</td>
<td>Details about metadata version of the system</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyStopMetadataSync</td>
<td>Flag to stop metadata synchronization</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyFileResourceRetentionStrategy</td>
<td>Determines how long file resources associated with deleted or updated values are kept. NONE, THREE_MONTHS, ONE_YEAR, or FOREVER.</td>
<td>No</td>
</tr>
<tr class="even">
<td>syncMaxRemoteServerAvailabilityCheckAttempts</td>
<td>Specifies how many times the availability of remote server will be checked before synchronization jobs fail.</td>
<td>No</td>
</tr>
<tr class="odd">
<td>syncMaxAttempts</td>
<td>Specifies max attempts for synchronization jobs</td>
<td>No</td>
</tr>
<tr class="even">
<td>syncDelayBetweenRemoteServerAvailabilityCheckAttempts</td>
<td>Delay between remote server availability checks</td>
<td>No</td>
</tr>
<tr class="odd">
<td>lastSuccessfulDataStatistics</td>
<td>Keeps timestamp of last successful data analytics</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyHideDailyPeriods</td>
<td>Not in use</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyHideWeeklyPeriods</td>
<td>Not in use</td>
<td>No</td>
</tr>
<tr class="even">
<td>keyHideMonthlyPeriods</td>
<td>Not in use</td>
<td>No</td>
</tr>
<tr class="odd">
<td>keyHideBiMonthlyPeriods</td>
<td>Not in use</td>
<td>No</td>
</tr>
</tbody>
</table>

## Paramètres de l'utilisateur { #webapi_user_settings } 

<!--DHIS2-SECTION-ID:webapi_user_settings-->

Vous pouvez manipuler les paramètres de l'utilisateur en interagissant avec la ressource *userSettings*. Un paramètre utilisateur est une simple paire clé-valeur, où la clé et la valeur sont des chaînes de texte en clair. Le paramètre utilisateur sera lié à l'utilisateur authentifié pour la requête de l'API Web. Pour obtenir une liste de tous les paramètres utilisateur, vous pouvez envoyer une requête *GET* à l'URL suivante :

    /api/33/userSettings

Les paramètres non définis par l'utilisateur seront remplacés par les paramètres équivalents 
du système. Pour ne renvoyer que les valeurs définies explicitement par l'utilisateur, 
vous pouvez ajouter ?useFallback=false à l'URL ci-dessus, comme ceci :

    /api/33/userSettings?useFallback=false

Pour enregistrer ou mettre à jour un paramètre pour l'utilisateur actuellement authentifié, vous pouvez
envoyer une requête *POST* à l'URL suivante :

    /api/33/userSettings/my-key?value=my-val

Vous pouvez spécifier explicitement l'utilisateur pour lequel le paramètre doit être sauvegardé en utilisant 
cette syntaxe :

    /api/33/userSettings/my-key?user=username&value=my-val

Vous pouvez également soumettre la valeur du paramètre dans le corps de la requête,
où le type de contenu est défini sur "texte/clair". Par exemple, vous pouvez utiliser
curl comme suit :

```bash
curl "https://play.dhis2.org/demo/api/33/userSettings/my-key" -d "My long value"
  -H "Content-Type: text/plain" -u admin:district
```

Par exemple, pour définir les paramètres linguistiques de l'interface utilisateur de l'utilisateur actuel en français, vous 
pouvez utiliser la commande suivante.

```bash
curl "https://play.dhis2.org/demo/api/33/userSettings/keyUiLocale?value=fr" 
  -X POST -u admin:district
```

Vous devez remplacer my-key par votre véritable clé et my-val par votre valeur 
réelle. Pour récupérer la valeur d'une clé donnée en texte brut, vous pouvez envoyer une 
requête *GET* à l'URL suivante :

    /api/33/userSettings/my-key

Pour supprimer un paramètre utilisateur, vous pouvez envoyer une requête *DELETE* à l'URL
similaire à celle utilisée ci-dessus pour la récupération.

Les paramètres système disponibles sont énumérés ci-dessous.

<table style="width:100%;">
<caption>User settings</caption>
<colgroup>
<col style="width: 21%" />
<col style="width: 28%" />
<col style="width: 49%" />
</colgroup>
<thead>
<tr class="header">
<th>Key</th>
<th>Options</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>keyStyle</td>
<td>light_blue/light_blue.css | green/green.css | vietnam/vietnam.css</td>
<td>User interface stylesheet.</td>
</tr>
<tr class="even">
<td>keyMessageEmailNotification</td>
<td>false | true</td>
<td>Whether to send email notifications.</td>
</tr>
<tr class="odd">
<td>keyMessageSmsNotification</td>
<td>false | true</td>
<td>Whether to send SMS notifications.</td>
</tr>
<tr class="even">
<td>keyUiLocale</td>
<td>Locale value</td>
<td>User interface locale.</td>
</tr>
<tr class="odd">
<td>keyDbLocale</td>
<td>Locale value</td>
<td>Database content locale.</td>
</tr>
<tr class="even">
<td>keyAnalysisDisplayProperty</td>
<td>name | shortName</td>
<td>Property to display for metadata in analysis apps.</td>
</tr>
<tr class="odd">
<td>keyCurrentDomainType</td>
<td>all | aggregate | tracker</td>
<td>Data element domain type to display in lists.</td>
</tr>
<tr class="even">
<td>keyAutoSaveCaseEntryForm</td>
<td>false | true</td>
<td>Save case entry forms periodically.</td>
</tr>
<tr class="odd">
<td>keyAutoSaveTrackedEntityForm</td>
<td>false | true</td>
<td>Save person registration forms periodically.</td>
</tr>
<tr class="even">
<td>keyAutoSaveDataEntryForm</td>
<td>false | true</td>
<td>Save aggregate data entry forms periodically.</td>
</tr>
<tr class="odd">
<td>keyTrackerDashboardLayout</td>
<td>false | true</td>
<td>Tracker dasboard layout.</td>
</tr>
</tbody>
</table>

## Les unités d’organisation { #webapi_organisation_units } 

<!--DHIS2-SECTION-ID:webapi_organisation_units-->

La ressource *organisationUnits* suit les conventions standard des autres ressources de métadonnées présents dans DHIS2. Cette ressource prend en charge des paramètres de requête supplémentaires.

### Obtenir la liste des unités d'organisation { #webapi_list_of_organisation_units } 

<!--DHIS2-SECTION-ID:webapi_list_of_organisation_units-->

Pour obtenir une liste des unités d'organisation, vous pouvez utiliser la ressource suivante :

    /api/33/organisationUnits

<table>
<caption>Organisation units query parameters</caption>
<colgroup>
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th>Query parameter</th>
<th>Options</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>userOnly</td>
<td>false | true</td>
<td>Data capture organisation units associated with current user only.</td>
</tr>
<tr class="even">
<td>userDataViewOnly</td>
<td>false | true</td>
<td>Data view organisation units associated with current user only.</td>
</tr>
<tr class="odd">
<td>userDataViewFallback</td>
<td>false | true</td>
<td>Data view organisation units associated with current user only with fallback to data capture organisation units.</td>
</tr>
<tr class="even">
<td>query</td>
<td>string</td>
<td>Query against the name, code and ID properties.</td>
</tr>
<tr class="odd">
<td>level</td>
<td>integer</td>
<td>Organisation units at the given level in the hierarchy.</td>
</tr>
<tr class="even">
<td>maxLevel</td>
<td>integer</td>
<td>Organisation units at the given max level or levels higher up in the hierarchy.</td>
</tr>
<tr class="odd">
<td>withinUserHierarchy</td>
<td>false | true</td>
<td>Limits search and retrieval to organisation units that are within the users data capture scope.</td>
</tr>
<tr class="even">
<td>withinUserSearchHierarchy</td>
<td>false | true</td>
<td>Limits search and retrieval to organisation units that are within the current users search scope. Note: "withinUserHierarchy", if true, takes higher precedence.</td>
</tr>
<tr class="odd">
<td>memberCollection</td>
<td>string</td>
<td>For displaying count of members within a collection, refers to the name of the collection associated with organisation units.</td>
</tr>
<tr class="even">
<td>memberObject</td>
<td>UID</td>
<td>For displaying count of members within a collection, refers to the identifier of the object member of the collection.</td>
</tr>
</tbody>
</table>

### Get organisation unit with relations { #webapi_organisation_units_with_relations } 

<!--DHIS2-SECTION-ID:webapi_organisation_units_with_relations-->

To get an organisation unit with related organisation units you can use
the following resource.

    /api/33/organisationUnits/{id}

<table>
<caption>Organisation unit parameters</caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="header">
<th>Query parameter</th>
<th>Options</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>includeChildren</td>
<td>false | true</td>
<td>Include immediate children of the specified organisation unit, i.e. the units at the immediate level below in the subhierarchy.</td>
</tr>
<tr class="even">
<td>includeDescendants</td>
<td>false | true</td>
<td>Include all children of the specified organisation unit, i.e. all units in the sub-hierarchy.</td>
</tr>
<tr class="odd">
<td>includeAncestors</td>
<td>false | true</td>
<td>Include all parents of the specified organisation unit.</td>
</tr>
<tr class="even">
<td>level</td>
<td>integer</td>
<td>Include children of the specified organisation unit at the given level of the sub-hierarchy (relative to the organisation unit where the immediate level below is level 1).</td>
</tr>
</tbody>
</table>

## Ensembles de données { #webapi_data_sets } 

<!--DHIS2-SECTION-ID:webapi_data_sets-->

La ressource *dataSets* suit les conventions standard des autres ressources de métadonnées présents dans DHIS2. Cette ressource prend en charge des paramètres de requête supplémentaires.

    /api/33/dataSets

Pour récupérer la version d'un ensemble de données, vous pouvez envoyer une requête GET :

    GET /api/33/dataSets/<uid>/version

Pour augmenter (d'une unité) la version d'un ensemble de données, vous pouvez effectuer une requête POST :

    POST /api/33/dataSets/<uid>/version

### DataSet Notification Template { #webapi_dataset_notifications } 

<!--DHIS2-SECTION-ID:webapi_dataset_notifications-->

La ressource *modèles de notification des ensembles de données* suit les conventions standard des autres ressources de métadonnées présentes dans DHIS2.

    GET /api/33/dataSetNotficationTemplates

Pour récupérer un modèle de notification d'ensemble de données, vous pouvez effectuer une requête GET :

    GET /api/33/dataSetNotficationTemplates/<uid>

Pour ajouter un modèle de notification d'ensemble de données, vous pouvez effectuer une requête POST :

    POST /api/33/dataSetNotficationTemplates

Pour supprimer un modèle de notification d'ensemble de données, vous pouvez effectuer une requête DELETE :

    DELETE /api/33/dataSetNotficationTemplates/<uid>

Ci-dessous, un exemple de charge JSON :

```json
{
  "name": "dataSetNotificationTemplate1",
  "notificationTrigger": "COMPLETION",
  "relativeScheduledDays": 0,
  "notificationRecipient": "ORGANISATION_UNIT_CONTACT",
  "dataSets": [{
    "id": "eZDhcZi6FLP"
  }],
  "deliveryChannels": ["SMS"],
  "subjectTemplate": "V{data_name}",
  "messageTemplate": "V{data_name}V{complete_registration_period}",
  "sendStrategy": "SINGLE_NOTIFICATION"
}

```

## Niveaux d'unités d'organisation renseignés{ #webapi_filled_organisation_unit_levels } 

<!--DHIS2-SECTION-ID:webapi_filled_organisation_unit_levels-->

La ressource *filledOrganisationUnitLevels* fournit une liste ordonnée de niveaux d'unités d'organisation, où les niveaux générés sont introduits dans la liste pour remplir les positions pour lesquelles il n'existe pas de niveau.

    GET /api/33/filledOrganisationUnitLevels

To set the organisation unit levels you can issue a POST request with a
JSON payload looking like this.

```json
{
  "organisationUnitLevels": [{
    "name": "National",
    "level": 1,
    "offlineLevels": 3
  }, {
    "name": "District",
    "level": 2
  }, {
    "name": "Chiefdom",
    "level": 3
  }, {
    "name": "Facility",
    "level": 4
  }]
}
```

To do functional testing with curl you can issue the following command.

```bash
curl "http://localhost/api/33/filledOrganisationUnitLevels" -H "Content-Type:application/json"
  -d @levels.json -u admin:district
```

## Contenu statique { #webapi_static_content } 

<!--DHIS2-SECTION-ID:webapi_static_content-->

La ressource *staticContent* vous permet de télécharger et d'extraire des logos 
personnalisés utilisés dans DHIS2. La ressource permet à l'utilisateur de télécharger un fichier avec une 
clé associée, qui peut ensuite être extraite à l'aide de la clé. Seuls les fichiers PNG 
sont pris en charge et ne peuvent être téléchargés que vers les clés `logo_banner` et 
`logo_front`.

    /api/33/staticContent

<table>
<caption>Static content keys</caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Key</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>logo_banner</td>
<td>Logo in the application top menu on the left side.</td>
</tr>
<tr class="even">
<td>logo_front</td>
<td>Logo on the login-page above the login form.</td>
</tr>
</tbody>
</table>

Pour télécharger un fichier, envoyez-le avec une requête *POST* à :

    POST /api/33/staticContent/<key>

Exemple de requête pour télécharger logo.png dans la clé `logo_front` :

```bash
curl -F "file=@logo.png;type=image/png" "https://play.dhis2.org/demo/api/33/staticContent/logo_front"
  -X POST -H "Content-Type: multipart/form-data" -u admin:district
```

Le téléchargement de plusieurs fichiers avec la même clé écrasera le fichier 
existant. Ainsi, la recherche d'un fichier pour une clé donnée ne renverra que 
le dernier fichier téléchargé.

To retrieve a logo, you can *GET* the following:

    GET /api/33/staticContent/<key>

Exemple de requêtes pour récupérer le fichier stocké pour `logo_front` :

* Ajout de « Accept : text/html » à l'en-tête HTTP.*__ Dans ce cas, le point d'extrémité renverra une image par défaut si rien n'est défini. Il renvoie un flux d'images lorsqu'une image personnalisée ou par défaut est trouvée.

```bash
curl "https://play.dhis2.org/demo/api/33/staticContent/logo_front" 
  -H "Accept: text/html" -L -u admin:district
```

* Ajout de « Accepter : application/json » à l'en-tête HTTP.*__ Avec ce paramètre, le point d'extrémité ne renverra jamais d'image par défaut si le logo personnalisé n'est pas trouvé. Au lieu de cela, un message d'erreur sera renvoyé. Lorsque l'image personnalisée est trouvée, ce point d'extrémité renvoie une réponse JSON contenant le chemin/URL de l'image correspondante.

```bash
curl "https://play.dhis2.org/demo/api/33/staticContent/logo_front" 
  -H "Accept: application/json" -L -u admin:district
```

Les messages de succès et d'erreur se présentent comme suit :

```json
{
  "images": {
    "png": "http://localhost:8080/dhis/api/staticContent/logo_front"
  }
}
```

```json
{
  "httpStatus": "Non trouvé",
  "httpStatusCode": 404,
  "statut": "ERREUR",
  "message": "Aucun fichier personnalisé n'a été trouvé."
}
```

Pour utiliser des logos personnalisés, vous devez activer les paramètres système 
correspondants en leur attribuant la valeur *vrai*. Si le paramètre correspondant est faux, 
le logo par défaut sera utilisé.

## Configuration { #webapi_configuration } 

<!--DHIS2-SECTION-ID:webapi_configuration-->

Pour accéder à la configuration, vous pouvez interagir avec la ressource 
*configuration*. Vous pouvez obtenir des réponses XML et JSON via l'en-tête *Accepter* 
ou en utilisant les extensions .json ou .xml. Vous pouvez *OBTENIR* toutes les propriétés 
de la configuration depuis : 

    /api/33/configuration

Vous pouvez envoyer des requêtes *GET* et *POST* aux ressources spécifiques 
suivantes :

    GET /api/33/configuration/systemId

    GET POST DELETE /api/33/configuration/feedbackRecipients

    GET POST DELETE /api/33/configuration/offlineOrganisationUnitLevel

    GET POST /api/33/configuration/infrastructuralDataElements

    GET POST /api/33/configuration/infrastructuralIndicators

    GET POST /api/33/configuration/infrastructuralPeriodType

    GET POST DELETE /api/33/configuration/selfRegistrationRole

    GET POST DELETE /api/33/configuration/selfRegistrationOrgUnit

Pour la configuration de la liste blanche CORS, vous pouvez effectuer une requête POST avec  
une série  d'URL à inscrire sur la liste blanche comme charge utile en utilisant « application/json » comme 
type de contenu, par exemple :

```json
["www.google.com", "www.dhis2.org", "www.who.int"]
```

    GET POST /api/33/configuration/corsWhitelist

Pour les requêtes POST, la valeur de configuration doit être envoyée sous forme de texte 
dans la charge utile de la requête. Le tableau suivant indique les valeurs de configuration 
appropriées pour chaque propriété.

<table>
<caption>Configuration values</caption>
<colgroup>
<col style="width: 30%" />
<col style="width: 69%" />
</colgroup>
<thead>
<tr class="header">
<th>Configuration property</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>feedbackRecipients</td>
<td>User group ID</td>
</tr>
<tr class="even">
<td>offlineOrganisationUnitLevel</td>
<td>Organisation unit level ID</td>
</tr>
<tr class="odd">
<td>infrastructuralDataElements</td>
<td>Data element group ID</td>
</tr>
<tr class="even">
<td>infrastructuralIndicators</td>
<td>Indicator group ID</td>
</tr>
<tr class="odd">
<td>infrastructuralPeriodType</td>
<td>Period type name (e.g. &quot;Monthly&quot;)</td>
</tr>
<tr class="even">
<td>selfRegistrationRole</td>
<td>User role ID</td>
</tr>
<tr class="odd">
<td>selfRegistrationOrgUnit</td>
<td>Organisation unit ID</td>
</tr>
<tr class="even">
<td>smtpPassword</td>
<td>SMTP email server password</td>
</tr>
<tr class="odd">
<td>remoteServerUrl</td>
<td>URL to remote server</td>
</tr>
<tr class="even">
<td>remoteServerUsername</td>
<td>Username for remote server authentication</td>
</tr>
<tr class="odd">
<td>remoteServerPassword</td>
<td>Password for remote server authentication</td>
</tr>
<tr class="even">
<td>corsWhitelist</td>
<td>JSON list of URLs</td>
</tr>
</tbody>
</table>

Par exemple, pour définir le groupe d'utilisateurs des destinataires du retour d'information, vous pouvez invoquer 
la commande curl suivante :

```bash
curl "localhost/api/33/configuration/feedbackRecipients" -d "wl5cDMuUhmF"
  -H "Content-Type:text/plain"-u admin:district
```

## Read-Only configuration service { #webapi_readonly_configuration_interface } 

<!--DHIS2-SECTION-ID:webapi_readonly_configuration_interface-->

To access configuration you can now use read-only service. This service
will provide read-only access to *UserSettings, SystemSettings and DHIS2
server configurations* You can get XML and JSON responses through the
*Accept* header. You can *GET* all settings from:

    /api/33/configuration/settings

Vous pouvez obtenir des paramètres filtrés en fonction du type de paramètre :

    GET /api/33/configuration/settings/filter?type=USER_SETTING

    GET /api/33/configuration/settings/filter?type=CONFIGURATION

More than one type can be
    provided

    GET /api/33/configuration/settings/filter?type=USER_SETTING&type=SYSTEM_SETTING

<table>
<caption>SettingType values</caption>
<colgroup>
<col style="width: 30%" />
<col style="width: 69%" />
</colgroup>
<thead>
<tr class="header">
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>USER_SETTING</td>
<td>To get user settings</td>
</tr>
<tr class="even">
<td>SYSTEM_SETTING</td>
<td>To get system settings</td>
</tr>
<tr class="odd">
<td>CONFIGURATION</td>
<td>To get DHIS server settings</td>
</tr>
</tbody>
</table>

> **Remarque**
>
> Les champs confidentiels seront fournis dans le résultat, mais sans valeur.

## Internationalization { #webapi_i18n } 

<!--DHIS2-SECTION-ID:webapi_i18n-->

In order to retrieve key-value pairs for translated strings you can use
the *i18n* resource.

    /api/33/i18n

The endpoint is located at */api/i18n* and the request format is a simple
array of the key-value pairs:

```json
[
  "access_denied",
  "uploading_data_notification"
]
```

The request must be of type *POST* and use *application/json* as
content-type. An example using curl, assuming the request data is saved
as a file `keys.json`:

```bash
curl -d @keys.json "play.dhis2.org/demo/api/33/i18n" -X POST
  -H "Content-Type: application/json" -u admin:district
```

The result will look like this:

```json
{
  "access_denied":"Access denied",
  "uploading_data_notification":"Uploading locally stored data to the server"
}
```

## Conversion SVG { #webapi_svg_conversion } 

<!--DHIS2-SECTION-ID:webapi_svg_conversion-->

L'API Web fournit une ressource qui peut être utilisée pour convertir le contenu SVG dans des formats plus utilisés tels que PNG et PDF. Idéalement, cette conversion devrait avoir lieu côté client, mais toutes les technologies côté client ne sont pas en mesure d'effectuer cette tâche. Actuellement, les formats de sortie PNG et PDF sont pris en charge. Le contenu SVG lui-même doit être transmis avec un paramètre de requête *svg*, et un paramètre de requête facultatif *filename* peut être utilisé pour spécifier le nom de fichier de la pièce jointe à la réponse. Notez que l'extension du fichier doit être omise. Pour obtenir une réponse dans le format PNG, vous pouvez envoyer une requête *POST* à l'URL suivante avec pour type de contenu `application/x-www-form-urlencoded`. Ce processus est identique à la soumission d'un formulaire HTML classique.

    api/svg.png

Pour obtenir la réponse dans le format PDF, vous pouvez envoyer une requête *POST* à l'URL suivante avec pour type de contenu `application/x-www-form-urlencoded`.

    api/svg.pdf

<table>
<caption>Query parameters</caption>
<colgroup>
<col style="width: 21%" />
<col style="width: 11%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="header">
<th>Query parameter</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>svg</td>
<td>Yes</td>
<td>The SVG content</td>
</tr>
<tr class="even">
<td>filename</td>
<td>No</td>
<td>The file name for the returned attachment without file extension</td>
</tr>
</tbody>
</table>

## Tracker Web API { #webapi_tracker_api } 

<!--DHIS2-SECTION-ID:webapi_tracker_api-->

L'API Web du Tracker est constitué de 3 points d'extrémité qui ont un support CRUD complet (créer, lire, mettre à jour, supprimer). Les 3 points d'extrémité sont `/api/trackedEntityInstances`, `/api/enrollments` et `/api/events` et ils prennent en charge les instances d'entités suivies, les inscriptions et les événements.

### Tracked entity instance management { #webapi_tracked_entity_instance_management } 

<!--DHIS2-SECTION-ID:webapi_tracked_entity_instance_management-->

Les instances d'entités suivies bénéficient d'une prise en charge CRUD complète dans l'API. Avec l'API d'inscription, la plupart des opérations nécessaires pour travailler avec les instances d'entités suivies et les programmes sont prises en charge.

    /api/33/trackedEntityInstances

#### Creating a new tracked entity instance { #webapi_creating_tei } 

<!--DHIS2-SECTION-ID:webapi_creating_tei-->

Pour créer une nouvelle personne dans le système, vous devez utiliser la ressource *trackedEntityInstances* (instances d'entités suivies). Un modèle de charge est présenté ci-dessous :

```json
{
  "trackedEntity": "tracked-entity-id",
  "orgUnit": "org-unit-id",
  "geometry": "<Geo JSON>",
  "attributes": [{
    "attribute": "attribute-id",
    "value": "attribute-value"
  }]
}
```

Le champ "geometry" accepte un objet GeoJson, dont le type doit correspondre au featureType (type de fonctionnalité) du TrackedEntityType (type d'entité suivie). Voici un exemple d'objet GeoJson :

```json
{
  "type": "Point",
  "coordinates": [1, 1]
}
```

The "coordinates" field was introduced in 2.29, and accepts a coordinate 
or a polygon as a value.

For getting the IDs for `relationship` and `attributes` you can have a look
at the respective resources `relationshipTypes`, `trackedEntityAttributes`.
To create a tracked entity instance you must use the HTTP *POST* method. 
You can post the payload the following URL:

    /api/trackedEntityInstances

Par exemple, créons une nouvelle instance pour une entité suivie de personne et spécifions ses attributs 'prénom' et 'nom' :

```json
{
  "trackedEntity": "nEenWmSyUEp",
  "orgUnit": "DiszpKrYNg8",
  "attributes": [
    {
      "attribute": "w75KJ2mc4zz",
      "value": "Joe"
    },
    {
      "attribute": "zDhUuAYrxNC",
      "value": "Smith"
    }
  ]
}
```

Pour envoyer ces données au serveur, vous pouvez utiliser la commande cURL comme suit :

```bash
curl -d @tei.json "https://play.dhis2.org/demo/api/trackedEntityInstances" -X POST
  -H "Content-Type: application/json" -u admin:district
```

Pour créer plusieurs instances à l'aide d'une seule requête, vous pouvez envelopper la charge dans un tableau extérieur comme ceci et effectuer une requête POST à la même ressource comme ci-dessus :[]()

```json
{
  "trackedEntityInstances": [
    {
      "trackedEntity": "nEenWmSyUEp",
      "orgUnit": "DiszpKrYNg8",
      "attributes": [
        {
          "attribute": "w75KJ2mc4zz",
          "value": "Joe"
        },
        {
          "attribute": "zDhUuAYrxNC",
          "value": "Smith"
        }
      ]
    },
    {
      "trackedEntity": "nEenWmSyUEp",
      "orgUnit": "DiszpKrYNg8",
      "attributes": [
        {
          "attribute": "w75KJ2mc4zz",
          "value": "Jennifer"
        },
        {
          "attribute": "zDhUuAYrxNC",
          "value": "Johnson"
        }
      ]
    }
  ]
}
```

Le système ne permet pas la création d'une instance d'entité suivie (ainsi que l'inscription et l'événement) avec un UID déjà utilisé dans le système. Cela signifie que les UID ne peuvent pas être réutilisés.

#### Updating a tracked entity instance { #webapi_updating_tei } 

<!--DHIS2-SECTION-ID:webapi_updating_tei-->

Pour la mise à jour d'une instance d'entité suivie, la charge est identique à celle de la section précédente. La différence est que vous devez utiliser la méthode HTTP *PUT* pour la requête lors de l'envoi de la charge. Vous devrez également ajouter l'identifiant de la personne à la ressource *trackedEntityInstances* dans l'URL comme suit, où `<tracked-entity-instance-identifier>` doit être remplacé par l'identifiant de l'instance d'entité suivie :

    /api/trackedEntityInstances/<tracked-entity-instance-id>

La charge doit contenir tous les attributs et relations, même ceux qui n'ont pas été modifiés. Les attributs ou les relations qui étaient présents auparavant et qui ne sont plus présents dans la charge actuelle seront supprimés du système. Cela signifie que si des attributs/relations sont vides dans la charge actuelle, tous les attributs/relations existants seront supprimés du système. Depuis la version 2.31, il est possible d'ignorer les attributs/relations vides dans la charge en cours d'utilisation. Vous pouvez définir le paramètre de requête `ignoreEmptyCollection` sur `true` si vous ne voulez pas envoyer des attributs ou des relations et que vous ne voulez pas non plus qu'ils soient supprimés du système.

Il n'est pas autorisé de mettre à jour une instance d'entité suivie déjà supprimée. Il n'est pas non plus autorisé de marquer une instance d'entité suivie comme supprimée via une requête de mise à jour. Les mêmes règles s'appliquent aux inscriptions et aux événements.

#### Deleting a tracked entity instance { #webapi_deleting_tei } 

<!--DHIS2-SECTION-ID:webapi_deleting_tei-->

Pour supprimer une instance d'entité suivie, envoyez une requête à l'URL qui identifie cette instance d'entité suivie avec la méthode *DELETE*. L'URL est la même que celle utilisée plus haut pour la mise à jour.

#### Create and enroll tracked entity instances { #webapi_create_enroll_tei } 

<!--DHIS2-SECTION-ID:webapi_create_enroll_tei-->

Il est également possible de créer (et de mettre à jour) une instance d'entité suivie et de l'inscrire en même temps à un programme

```json
{
  "trackedEntity": "tracked-entity-id",
  "orgUnit": "org-unit-id",
  "attributes": [{
    "attribute": "attribute-id",
    "value": "attribute-value"
  }],
  "enrollments": [{
    "orgUnit": "org-unit-id",
    "program": "program-id",
    "enrollmentDate": "2013-09-17",
    "incidentDate": "2013-09-17"
   }, {
    "orgUnit": "org-unit-id",
    "program": "program-id",
    "enrollmentDate": "2013-09-17",
    "incidentDate": "2013-09-17"
   }]
}
```

Vous l'enverrez au serveur comme vous le feriez normalement lors de la création ou de la mise à jour d'une nouvelle instance d'entité suivie.

```bash
curl -X POST -d @tei.json -H "Content-Type: application/json"
  -u user:pass "http://server/api/33/trackedEntityInstances"
```

#### Complete example of payload including: tracked entity instance, enrollment and event { #webapi_create_enroll_tei_create_event } 

<!--DHIS2-SECTION-ID:webapi_create_enroll_tei_create_event-->

Il est également possible de créer (et de mettre à jour) une instance d'entité suivie, de l'inscrire en même temps à un programme et de créer un événement.

```json
{
  "trackedEntityType": "nEenWmSyUEp",
  "orgUnit": "DiszpKrYNg8",
  "attributes": [
    {
      "attribute": "w75KJ2mc4zz",
      "value": "Joe"
    },
    {
      "attribute": "zDhUuAYrxNC",
      "value": "Rufus"
    },
    {
     "attribute":"cejWyOfXge6",
     "value":"Male"
    }
  ],
  "enrollments":[
    {
      "orgUnit":"DiszpKrYNg8",
      "program":"ur1Edk5Oe2n",
      "enrollmentDate":"2017-09-15",
      "incidentDate":"2017-09-15",
      "events":[
        {
          "program":"ur1Edk5Oe2n",
          "orgUnit":"DiszpKrYNg8",
          "eventDate":"2017-10-17",
          "status":"COMPLETED",
          "storedBy":"admin",
          "programStage":"EPEcjy3FWmI",
          "coordinate": {
            "latitude":"59.8",
            "longitude":"10.9"
          },
          "dataValues": [
            {
              "dataElement":"qrur9Dvnyt5",
              "value":"22"
            },
            {
              "dataElement":"oZg33kd9taw",
              "value":"Male"
            }
         ]
      },
      {
         "program":"ur1Edk5Oe2n",
         "orgUnit":"DiszpKrYNg8",
         "eventDate":"2017-10-17",
         "status":"COMPLETED",
         "storedBy":"admin",
         "programStage":"EPEcjy3FWmI",
         "coordinate": {
           "latitude":"59.8",
           "longitude":"10.9"
         },
         "dataValues":[
           {
             "dataElement":"qrur9Dvnyt5",
             "value":"26"
           },
           {
             "dataElement":"oZg33kd9taw",
             "value":"Female"
           }
         ]
       }
     ]
    }
  ]  
}
```

Vous l'enverrez au serveur comme vous le feriez normalement lors de la création ou de la mise à jour d'une nouvelle instance d'entité suivie.

```bash
curl -X POST -d @tei.json -H "Content-Type: application/json"
  -u user:pass "http://server/api/33/trackedEntityInstances"
```

#### Generated tracked entity instance attributes { #webapi_generate_tei_attributes } 

<!--DHIS2-SECTION-ID:webapi_generate_tei_attributes-->

Les attributs d'instances d'entités suivies dont les valeurs uniques sont générées automatiquement ont trois points d'extrémité qui sont utilisés par les applications. Ces points d'extrémité sont tous utilisés pour générer et réserver des valeurs.

Dans la version 2.29, nous avons introduit TextPattern pour définir et générer ces modèles. Tous les modèles existants seront convertis en modèles TextPattern valides lors de la mise à jour vers la version 2.29.

> **Remarque**
>
> À partir de la version 2.29, tous ces points d'extrémité vous demanderont d'inclure toutes les 
> variables rapportées par le point d'extrémité `requiredValues` et qui sont listées comme
> obligatoires. Les modèles existants, composés uniquement de `#`, seront mis à jour
> vers la nouvelle syntaxe TextPattern `RANDOM(<old-pattern>)`. Le > segment RANDOM
du TextPattern n'est pas une variable obligatoire, donc ce   > point d'extrémité fonctionnera comme auparavant pour les modèles définis avant la version 2.29.

##### Recherche des valeurs obligatoires { #finding-required-values } 

Un TextPattern peut contenir des variables qui changent en fonction de différents facteurs. Certains de ces facteurs sont inconnus du serveur. Pour cela, les valeurs de ces variables doivent être fournies lors de la génération et de la réservation des valeurs.

Cet point d'extrémité va renvoyer un plan de valeurs obligatoires et optionnelles, que le serveur va intégrer dans le TextPattern lorsqu'il génère de nouvelles valeurs. Les variables obligatoires doivent être fournies pour la génération, mais les variables optionnelles ne doivent être fournies que si vous savez ce que vous faites.

    GET /api/33/trackedEntityAttributes/Gs1ICEQTPlG/requiredValues

```json
{
  "REQUIRED": [
    "ORG_UNIT_CODE"
  ],
  "OPTIONAL": [
    "RANDOM"
  ]
}
```

##### Generate value endpoint { #webapi_generate_values } 

<!--DHIS2-SECTION-ID:webapi_generate_values-->

Les applications web en ligne et les autres clients qui souhaitent générer une valeur qui sera utilisée immédiatement peuvent utiliser le point d'extrémité de génération simple. Ce point d'extrémité génère une valeur dont l'unicité est garantie au moment de la génération. La valeur ne sera pas non plus réservée. Depuis la version 2.29, ce point d'extrémité réserve également la valeur générée pendant 3 jours.

Si votre TextPattern comprend des valeurs obligatoires, vous pouvez les utiliser comme paramètres dans l'exemple ci-dessous :

Le délai d'expiration peut également être modifié au moment de la génération, en ajoutant l'option `?expiration=<number-of-days>` à la requête.

    GET /api/33/trackedEntityAttributes/Gs1ICEQTPlG/generate?ORG_UNIT_CODE=OSLO

```json
{
  "ownerObject": "TRACKEDENTITYATTRIBUTE",
  "ownerUid": "Gs1ICEQTPlG",
  "key": "RANDOM(X)-OSL",
  "value": "C-OSL",
  "created": "2018-03-02T12:01:36.680",
  "expiryDate": "2018-03-05T12:01:36.678"
}
```

##### Generate and reserve value endpoint { #webapi_generate_reserve_values } 

<!--DHIS2-SECTION-ID:webapi_generate_reserve_values-->

Le point d'extrémité de génération et de réservation est utilisé par les clients hors ligne qui ont besoin d'enregistrer des entités suivies avec des identifiants uniques. Ils réservent un certain nombre d'identifiants uniques que ce dispositif utilisera ensuite lors de l'enregistrement de nouvelles instances d'entités suivies. Une requête est envoyée à ce point d'extrémité afin de récupérer un certain nombre de valeurs réservées pour les instances d'entités suivies. Un paramètre facultatif, "numberToReserve", indique le nombre d'identifiants à générer (par défaut, ce paramètre est défini sur 1).

Si votre TextPattern comprend des valeurs obligatoires, vous pouvez les utiliser comme paramètres dans l'exemple ci-dessous :

Similar to the /generate endpoint, this endpoint can also specify the
expiration time in the same way. By adding the `?expiration=<number-of-days>` 
you can override the default 60 days.

    GET /api/33/trackedEntityAttributes/Gs1ICEQTPlG/generateAndReserve?numberToReserve=3&ORG_UNIT_CODE=OSLO

```json
[
  {
    "ownerObject": "TRACKEDENTITYATTRIBUTE",
    "ownerUid": "Gs1ICEQTPlG",
    "key": "RANDOM(X)-OSL",
    "value": "B-OSL",
    "created": "2018-03-02T13:22:35.175",
    "expiryDate": "2018-05-01T13:22:35.174"
  },
  {
    "ownerObject": "TRACKEDENTITYATTRIBUTE",
    "ownerUid": "Gs1ICEQTPlG",
    "key": "RANDOM(X)-OSL",
    "value": "Q-OSL",
    "created": "2018-03-02T13:22:35.175",
    "expiryDate": "2018-05-01T13:22:35.174"
  },
  {
    "ownerObject": "TRACKEDENTITYATTRIBUTE",
    "ownerUid": "Gs1ICEQTPlG",
    "key": "RANDOM(X)-OSL",
    "value": "S-OSL",
    "created": "2018-03-02T13:22:35.175",
    "expiryDate": "2018-05-01T13:22:35.174"
  }
]
```

##### Valeurs réservées { #reserved-values } 

Les valeurs réservées ne sont actuellement pas accessibles via l'API, mais elles sont renvoyées par les points d'extrémité `generate` (génération) et `generate And Reserve` (génération et réservation). Le tableau suivant explique les propriétés de l'objet de valeur réservée :

##### { # } 

<table style="width:100%;">
<caption>Reserved values</caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="header">
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ownerObject</td>
<td>The metadata type referenced when generating and reserving the value. Currently only TRACKEDENTITYATTRIBUTE is supported.</td>
</tr>
<tr class="even">
<td>ownerUid</td>
<td>The uid of the metadata object referenced when generating and reserving the value.</td>
</tr>
<tr class="odd">
<td>key</td>
<td>A partially generated value where generated segments are not yet added.</td>
</tr>
<tr class="even">
<td>value</td>
<td>The fully resolved value reserved. This is the value you send to the server when storing data.</td>
</tr>
<tr class="odd">
<td>created</td>
<td>The timestamp when the reservation was made</td>
</tr>
<tr class="even">
<td>expiryDate</td>
<td>The timestamp when the reservation will no longer be reserved</td>
</tr>
</tbody>
</table>

Les réservations expirées sont supprimées quotidiennement. Si un modèle change, les valeurs déjà réservées seront acceptées lors du stockage des données, même si elles ne correspondent pas au nouveau modèle, tant que la réservation n'a pas expiré.

#### Attributs d'image { #image-attributes } 

Travailler avec des attributs d'image ressemble beaucoup à travailler avec des valeurs de données de fichier. La valeur d'un attribut de type image est l'identifiant de la ressource de fichier associée. Une requête GET au point d'extrémité `/api/trackedEntityInstances/<entityId>/<attributeId>/image` renverra l'image proprement dite. Les paramètres facultatifs height (hauteur) et width (largeur) peuvent être utilisés pour spécifier les dimensions de l'image.

```bash
curl "http://server/api/33/trackedEntityInstances/ZRyCnJ1qUXS/zDhUuAYrxNC/image?height=200&width=200"
  > image.jpg
```

The API also supports a *dimension* parameter. It can take three possible values: `small` (254x254), `medium` (512x512), `large` (1024x1024) or `original`. Image type attributes will be stored in pre-generated sizes
and will be furnished upon request based on the value of the `dimension` parameter.

```bash
curl "http://server/api/33/trackedEntityInstances/ZRyCnJ1qUXS/zDhUuAYrxNC/image?dimension=medium"
```

#### Tracked entity instance query { #webapi_tracked_entity_instance_query } 

<!--DHIS2-SECTION-ID:webapi_tracked_entity_instance_query-->

Pour rechercher des instances d'entités suivies, vous pouvez interagir avec la ressource `/api/trackedEntityInstances`.

    /api/33/trackedEntityInstances

##### Request syntax { #webapi_tei_query_request_syntax } 

<!--DHIS2-SECTION-ID:webapi_tei_query_request_syntax-->

<table style="width:100%;">
<caption>Tracked entity instances query parameters</caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="header">
<th>Query parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>filter</td>
<td>Attributes to use as a filter for the query. Param can be repeated any number of times. Filters can be applied to a dimension on the format &lt;attribute-id&gt;:&lt;operator&gt;:&lt;filter&gt;[:&lt;operator&gt;:&lt;filter&gt;]. Filter values are case-insensitive and can be repeated together with operator any number of times. Operators can be EQ | GT | GE | LT | LE | NE | LIKE | IN.</td>
</tr>
<tr class="even">
<td>ou</td>
<td>Organisation unit identifiers, separated by &quot;;&quot;.</td>
</tr>
<tr class="odd">
<td>ouMode</td>
<td>The mode of selecting organisation units, can be SELECTED | CHILDREN | DESCENDANTS | ACCESSIBLE | CAPTURE | ALL. Default is SELECTED, which refers to the selected selected organisation units only. See table below for explanations.</td>
</tr>
<tr class="even">
<td>program</td>
<td>Program identifier. Restricts instances to being enrolled in the given program.</td>
</tr>
<tr class="odd">
<td>programStatus</td>
<td>Status of the instance for the given program. Can be ACTIVE | COMPLETED | CANCELLED.</td>
</tr>
<tr class="even">
<td>followUp</td>
<td>Follow up status of the instance for the given program. Can be true | false or omitted.</td>
</tr>
<tr class="odd">
<td>programStartDate</td>
<td>Start date of enrollment in the given program for the tracked entity instance.</td>
</tr>
<tr class="even">
<td>programEndDate</td>
<td>End date of enrollment in the given program for the tracked entity instance.</td>
</tr>
<tr class="odd">
<td>trackedEntity</td>
<td>Tracked entity identifier. Restricts instances to the given tracked instance type.</td>
</tr>
<tr class="even">
<td>page</td>
<td>The page number. Default page is 1.</td>
</tr>
<tr class="odd">
<td>pageSize</td>
<td>The page size. Default size is 50 rows per page.</td>
</tr>
<tr class="even">
<td>totalPages</td>
<td>Indicates whether to include the total number of pages in the paging response (implies higher response time).</td>
</tr>
<tr class="odd">
<td>skipPaging</td>
<td>Indicates whether paging should be ignored and all rows should be returned.</td>
</tr>
<tr class="even">
<td>lastUpdatedStartDate</td>
<td>Filter for events which were updated after this date. Cannot be used together with <em>lastUpdatedDuration</em>.</td>
</tr>
<tr class="odd">
<td>lastUpdatedEndDate</td>
<td>Filter for events which were updated up until this date. Cannot be used together with <em>lastUpdatedDuration</em>.</td>
</tr>
<tr class="even">
<td>lastUpdatedDuration</td>
<td>Include only items which are updated within the given duration. The format is <value><time-unit>, where the supported time units are “d” (days), “h” (hours), “m” (minutes) and “s” (seconds). Cannot be used together with <em>lastUpdatedStartDate</em> and/or <em>lastUpdatedEndDate</em>.</td>
</tr>
<tr class="odd">
<td>assignedUserMode</td>
<td>Restricts result to tei with events assigned based on the assigned user selection mode, can be CURRENT | PROVIDED | NONE | ANY.</td>
</tr>
<tr class="even">
<td>assignedUser</td>
<td>Filter the result down to a limited set of teis with events that are assigned to the given user IDs by using <em>assignedUser=id1;id2</em>.This parameter will be considered only if assignedUserMode is either PROVIDED or null. The API will error out, if for example, assignedUserMode=CURRENT and assignedUser=someId</td>
</tr>
<tr class="odd">
<td>trackedEntityInstance</td>
<td>Filter the result down to a limited set of teis using explicit uids of the tracked entity instances by using <em>trackedEntityInstance=id1;id2</em>. This parameter will at the very least create the outer boundary of the results, forming the list of all teis using the uids provided. If other parameters/filters from this table are used, they will further limit the results from the explicit outer boundary. </td>
</tr>
</tbody>
</table>

Les modes de sélection d'unités d'organisation disponibles sont expliqués dans le tableau suivant.

<table>
<caption>Organisation unit selection modes</caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 79%" />
</colgroup>
<thead>
<tr class="header">
<th>Mode</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SELECTED</td>
<td>Organisation units defined in the request.</td>
</tr>
<tr class="even">
<td>CHILDREN</td>
<td>The selected organisation units and the immediate children, i.e. the organisation units at the level below.</td>
</tr>
<tr class="odd">
<td>DESCENDANTS</td>
<td>The selected organisation units and all children, i.e. all organisation units in the sub-hierarchy.</td>
</tr>
<tr class="even">
<td>ACCESSIBLE</td>
<td>The data view organisation units associated with the current user and all children, i.e. all organisation units in the sub-hierarchy. Will fall back to data capture organisation units associated with the current user if the former is not defined.</td>
</tr>
<tr class="odd">
<td>CAPTURE</td>
<td>The data capture organisation units associated with the current user and all children, i.e. all organisation units in the sub-hierarchy.</td>
</tr>
<tr class="even">
<td>ALL</td>
<td>All organisation units in the system. Requires the ALL authority.</td>
</tr>
</tbody>
</table>

La requête n'est pas sensible à la casse. Les règles suivantes s'appliquent aux paramètres de la requête.

  - Au moins une unité d'organisation doit être spécifiée à l'aide de l'attribut *ou*.
    (un ou plusieurs), ou *ouMode=ALL* doit être spécifié.

  - Un seul des paramètres *program* et *trackedEntity* peut être
    spécifié (zéro ou un).

  - Si *programStatus* est spécifié, alors *program* doit également être
    spécifiés.

  - Si *followUp* est spécifié, alors *program* doit également être spécifié.

  - Si *programStartDate* ou *programEndDate* est spécifié, alors
    *program* doit également être spécifié.

  - Les éléments du filtre ne peuvent être spécifiés qu'une seule fois.

Une requête pour toutes les instances associées à une unité d'organisation spécifique peut ressembler à ceci :

    /api/33/trackedEntityInstances.json?ou=DiszpKrYNg8

Pour lancer une requête pour des instances à l'aide d'un attribut avec filtre et d'un attribut sans filtre, avec une unité d'organisation en utilisant le mode de requête de l'unité d'organisation subordonnée, utilisez ceci :

    /api/33/trackedEntityInstances.json?filter=zHXD5Ve1Efw:EQ:A
      &filter=AMpUYgxuCaE&ou=DiszpKrYNg8;yMCshbaVExv

Une requête pour les instances où un attribut est inclus dans la réponse et où un attribut est utilisé comme filtre :

    /api/33/trackedEntityInstances.json?filter=zHXD5Ve1Efw:EQ:A
      &filter=AMpUYgxuCaE:LIKE:Road&ou=DiszpKrYNg8

Une requête dans laquelle plusieurs opérandes et filtres sont spécifiés pour un élément de filtre :

    api/33/trackedEntityInstances.json?ou=DiszpKrYNg8&program=ur1Edk5Oe2n
      &filter=lw1SqmMlnfh:GT:150:LT:190

Pour lancer une requête sur un attribut en utilisant plusieurs valeurs dans un filtre *IN* :

    api/33/trackedEntityInstances.json?ou=DiszpKrYNg8
      &filter=dv3nChNSIxy:IN:Scott;Jimmy;Santiago

Pour limiter la réponse aux instances qui font partie d'un programme spécifique, vous pouvez inclure un paramètre de requête de programme :

    api/33/trackedEntityInstances.json?filter=zHXD5Ve1Efw:EQ:A&ou=O6uvpzGd5pu
      &ouMode=DESCENDANTS&program=ur1Edk5Oe2n

Pour spécifier les dates d'inscription au programme dans la requête :

    api/33/trackedEntityInstances.json?filter=zHXD5Ve1Efw:EQ:A&ou=O6uvpzGd5pu
      &program=ur1Edk5Oe2n&programStartDate=2013-01-01&programEndDate=2013-09-01

Pour limiter la réponse aux instances d'une entité suivie spécifique, vous pouvez inclure un paramètre de requête d'entité suivie :

    api/33/trackedEntityInstances.json?filter=zHXD5Ve1Efw:EQ:A&ou=O6uvpzGd5pu
      &ouMode=DESCENDANTS&trackedEntity=cyl5vuJ5ETQ

Par défaut, les instances sont renvoyées dans des pages de taille 50. Pour modifier cela, vous pouvez utiliser les paramètres de requête de page et de taille de page (pageSize) :

    api/33/trackedEntityInstances.json?filter=zHXD5Ve1Efw:EQ:A&ou=O6uvpzGd5pu
      &ouMode=DESCENDANTS&page=2&pageSize=3

Vous pouvez utiliser une gamme d'opérateurs pour le filtrage :

<table>
<caption>Filter operators</caption>
<colgroup>
<col style="width: 19%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="header">
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>EQ</td>
<td>Equal to</td>
</tr>
<tr class="even">
<td>GT</td>
<td>Greater than</td>
</tr>
<tr class="odd">
<td>GE</td>
<td>Greater than or equal to</td>
</tr>
<tr class="even">
<td>LT</td>
<td>Less than</td>
</tr>
<tr class="odd">
<td>LE</td>
<td>Less than or equal to</td>
</tr>
<tr class="even">
<td>NE</td>
<td>Not equal to</td>
</tr>
<tr class="odd">
<td>LIKE</td>
<td>Like (free text match)</td>
</tr>
<tr class="even">
<td>IN</td>
<td>Equal to one of multiple values separated by &quot;;&quot;</td>
</tr>
</tbody>
</table>

##### Response format { #webapi_tei_query_response_format } 

<!--DHIS2-SECTION-ID:webapi_tei_query_response_format-->

Cette ressource prend en charge les représentations JSON, JSONP, XLS et CSV.

  - json (application/json)

  - jsonp (application/javascript)

  - xml (application/xml)

La réponse en JSON/XML est au format objet et peut ressembler à ce qui suit. Le filtrage des champs est possible, donc si vous voulez un affichage complet, vous pouvez ajouter `fields=*` à la requête :

```json
{
  "trackedEntityInstances": [
    {
      "lastUpdated": "2014-03-28 12:27:52.399",
      "trackedEntity": "cyl5vuJ5ETQ",
      "created": "2014-03-26 15:40:19.997",
      "orgUnit": "ueuQlqb8ccl",
      "trackedEntityInstance": "tphfdyIiVL6",
      "relationships": [],
      "attributes": [
        {
          "displayName": "Address",
          "attribute": "AMpUYgxuCaE",
          "type": "string",
          "value": "2033 Akasia St"
        },
        {
          "displayName": "TB number",
          "attribute": "ruQQnf6rswq",
          "type": "string",
          "value": "1Z 989 408 56 9356 521 9"
        },
        {
          "displayName": "Weight in kg",
          "attribute": "OvY4VVhSDeJ",
          "type": "number",
          "value": "68.1"
        },
        {
          "displayName": "Email",
          "attribute": "NDXw0cluzSw",
          "type": "string",
          "value": "LiyaEfrem@armyspy.com"
        },
        {
          "displayName": "Gender",
          "attribute": "cejWyOfXge6",
          "type": "optionSet",
          "value": "Female"
        },
        {
          "displayName": "Phone number",
          "attribute": "P2cwLGskgxn",
          "type": "phoneNumber",
          "value": "085 813 9447"
        },
        {
          "displayName": "First name",
          "attribute": "dv3nChNSIxy",
          "type": "string",
          "value": "Liya"
        },
        {
          "displayName": "Last name",
          "attribute": "hwlRTFIFSUq",
          "type": "string",
          "value": "Efrem"
        },
        {
          "code": "Height in cm",
          "displayName": "Height in cm",
          "attribute": "lw1SqmMlnfh",
          "type": "number",
          "value": "164"
        },
        {
          "code": "City",
          "displayName": "City",
          "attribute": "VUvgVao8Y5z",
          "type": "string",
          "value": "Kranskop"
        },
        {
          "code": "State",
          "displayName": "State",
          "attribute": "GUOBQt5K2WI",
          "type": "number",
          "value": "KwaZulu-Natal"
        },
        {
          "code": "Zip code",
          "displayName": "Zip code",
          "attribute": "n9nUvfpTsxQ",
          "type": "number",
          "value": "3282"
        },
        {
          "code": "National identifier",
          "displayName": "National identifier",
          "attribute": "AuPLng5hLbE",
          "type": "string",
          "value": "465700042"
        },
        {
          "code": "Blood type",
          "displayName": "Blood type",
          "attribute": "H9IlTX2X6SL",
          "type": "string",
          "value": "B-"
        },
        {
          "code": "Latitude",
          "displayName": "Latitude",
          "attribute": "Qo571yj6Zcn",
          "type": "string",
          "value": "-30.659626"
        },
        {
          "code": "Longitude",
          "displayName": "Longitude",
          "attribute": "RG7uGl4w5Jq",
          "type": "string",
          "value": "26.916172"
        }
      ]
    }
  ]
}
```

#### Tracked entity instance grid query { #webapi_tracked_entity_instance_grid_query } 

<!--DHIS2-SECTION-ID:webapi_tracked_entity_instance_grid_query-->

Pour effectuer une requête sur les instances d'entités suivies, vous pouvez interagir avec la ressource */api/trackedEntityInstances/grid*. Il existe deux types de requêtes : L'une où un paramètre de requête *query* et éventuellement des paramètres *attribute* sont définis, et l'autre où des paramètres *attribute* et *filter* sont définis. Ce point d'extrémité utilise un format de "grille" plus compact et constitue une alternative à la requête de la section précédente.

    /api/33/trackedEntityInstances/query

##### Request syntax { #webapi_tei_grid_query_request_syntax } 

<!--DHIS2-SECTION-ID:webapi_tei_grid_query_request_syntax-->

<table style="width:100%;">
<caption>Tracked entity instances query parameters</caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="header">
<th>Query parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>query</td>
<td>Query string. Attribute query parameter can be used to define which attributes to include in the response. If no attributes but a program is defined, the attributes from the program will be used. If no program is defined, all attributes will be used. There are two formats. The first is a plan query string. The second is on the format &lt;operator&gt;:&lt;query&gt;. Operators can be EQ | LIKE. EQ implies exact matches on words, LIKE implies partial matches on words. The query will be split on space, where each word will form a logical AND query.</td>
</tr>
<tr class="even">
<td>attribute</td>
<td>Attributes to be included in the response. Can also be used as a filter for the query. Param can be repeated any number of times. Filters can be applied to a dimension on the format &lt;attribute-id&gt;:&lt;operator&gt;:&lt;filter&gt;[:&lt;operator&gt;:&lt;filter&gt;]. Filter values are case-insensitive and can be repeated together with operator any number of times. Operators can be EQ | GT | GE | LT | LE | NE | LIKE | IN. Filters can be omitted in order to simply include the attribute in the response without any constraints.</td>
</tr>
<tr class="odd">
<td>filter</td>
<td>Attributes to use as a filter for the query. Param can be repeated any number of times. Filters can be applied to a dimension on the format &lt;attribute-id&gt;:&lt;operator&gt;:&lt;filter&gt;[:&lt;operator&gt;:&lt;filter&gt;]. Filter values are case-insensitive and can be repeated together with operator any number of times. Operators can be EQ | GT | GE | LT | LE | NE | LIKE | IN.</td>
</tr>
<tr class="even">
<td>ou</td>
<td>Organisation unit identifiers, separated by &quot;;&quot;.</td>
</tr>
<tr class="odd">
<td>ouMode</td>
<td>The mode of selecting organisation units, can be SELECTED | CHILDREN | DESCENDANTS | ACCESSIBLE | ALL. Default is SELECTED, which refers to the selected organisation units only. See table below for explanations.</td>
</tr>
<tr class="even">
<td>program</td>
<td>Program identifier. Restricts instances to being enrolled in the given program.</td>
</tr>
<tr class="odd">
<td>programStatus</td>
<td>Status of the instance for the given program. Can be ACTIVE | COMPLETED | CANCELLED.</td>
</tr>
<tr class="even">
<td>followUp</td>
<td>Follow up status of the instance for the given program. Can be true | false or omitted.</td>
</tr>
<tr class="odd">
<td>programStartDate</td>
<td>Start date of enrollment in the given program for the tracked entity instance.</td>
</tr>
<tr class="even">
<td>programEndDate</td>
<td>End date of enrollment in the given program for the tracked entity instance.</td>
</tr>
<tr class="odd">
<td>trackedEntity</td>
<td>Tracked entity identifier. Restricts instances to the given tracked instance type.</td>
</tr>
<tr class="even">
<td>eventStatus</td>
<td>Status of any event associated with the given program and the tracked entity instance. Can be ACTIVE | COMPLETED | VISITED | SCHEDULED | OVERDUE | SKIPPED.</td>
</tr>
<tr class="odd">
<td>eventStartDate</td>
<td>Start date of event associated with the given program and event status.</td>
</tr>
<tr class="even">
<td>eventEndDate</td>
<td>End date of event associated with the given program and event status.</td>
</tr>
<tr class="odd">
<td>programStage</td>
<td>The programStage for which the event related filters should be applied to. If not provided all stages will be considered.</td>
</tr>
<tr class="even">
<td>skipMeta</td>
<td>Indicates whether meta data for the response should be included.</td>
</tr>
<tr class="odd">
<td>page</td>
<td>The page number. Default page is 1.</td>
</tr>
<tr class="even">
<td>pageSize</td>
<td>The page size. Default size is 50 rows per page.</td>
</tr>
<tr class="odd">
<td>totalPages</td>
<td>Indicates whether to include the total number of pages in the paging response (implies higher response time).</td>
</tr>
<tr class="even">
<td>skipPaging</td>
<td>Indicates whether paging should be ignored and all rows should be returned.</td>
</tr>
<tr class="odd">
<td>assignedUserMode</td>
<td>Restricts result to tei with events assigned based on the assigned user selection mode, can be CURRENT | PROVIDED | NONE | ANY.</td>
</tr>
<tr class="even">
<td>assignedUser</td>
<td>Filter the result down to a limited set of teis with events that are assigned to the given user IDs by using <em>assignedUser=id1;id2</em>.This parameter will be considered only if assignedUserMode is either PROVIDED or null. The API will error out, if for example, assignedUserMode=CURRENT and assignedUser=someId</td>
</tr>
<tr class="odd">
<td>trackedEntityInstance</td>
<td>Filter the result down to a limited set of teis using explicit uids of the tracked entity instances by using <em>trackedEntityInstance=id1;id2</em>. This parameter will at the very least create the outer boundary of the results, forming the list of all teis using the uids provided. If other parameters/filters from this table are used, they will further limit the results from the explicit outer boundary. </td>
</tr>
</tbody>
</table>

Les modes de sélection d'unités d'organisation disponibles sont expliqués dans le tableau suivant.

<table>
<caption>Organisation unit selection modes</caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 79%" />
</colgroup>
<thead>
<tr class="header">
<th>Mode</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SELECTED</td>
<td>Organisation units defined in the request.</td>
</tr>
<tr class="even">
<td>CHILDREN</td>
<td>Immediate children, i.e. only the first level below, of the organisation units defined in the request.</td>
</tr>
<tr class="odd">
<td>DESCENDANTS</td>
<td>All children, i.e. at only levels below, e.g. including children of children, of the organisation units defined in the request.</td>
</tr>
<tr class="even">
<td>ACCESSIBLE</td>
<td>All descendants of the data view organisation units associated with the current user. Will fall back to data capture organisation units associated with the current user if the former is not defined.</td>
</tr>
<tr class="odd">
<td>CAPTURE</td>
<td>The data capture organisation units associated with the current user and all children, i.e. all organisation units in the sub-hierarchy.</td>
</tr>
<tr class="even">
<td>ALL</td>
<td>All organisation units in the system. Requires authority.</td>
</tr>
</tbody>
</table>

Vous pouvez spécifier "attribut" avec des filtres ou directement utiliser les paramètres de filtrage pour restreindre les instances à renvoyer.

Certaines règles s'appliquent aux attributs renvoyés.

  - If "query" is specified without any attributes or program, then all attributes that 
    sont marqués comme "Afficher dans la liste sans programme" seront inclus dans la réponse.

  - Si le programme est spécifié, tous les attributs liés au programme seront
    inclus dans la réponse.

  - If tracked entity type is specified, then all tracked entity type attributes 
    seront inclus dans la réponse.

Vous pouvez spécifier des requêtes avec des mots séparés par des espaces - dans ce cas, le système recherchera chaque mot indépendamment et renverra les enregistrements où chaque mot est contenu dans n'importe quel attribut. Un élément de requête peut être spécifié une fois en tant qu'attribut et une fois en tant que filtre si nécessaire. La requête est insensible à la casse. Les règles suivantes s'appliquent aux paramètres de requête.

  - Au moins une unité d'organisation doit être spécifiée à l'aide de l'attribut *ou*.
    (un ou plusieurs), ou *ouMode=ALL* doit être spécifié.

  - Un seul des paramètres *program* et *trackedEntity* peut être
    spécifié (zéro ou un).

  - Si *programStatus* est spécifié, alors *program* doit également être
    spécifiés.

  - Si *followUp* est spécifié, alors *program* doit également être spécifié.

  - Si *programStartDate* ou *programEndDate* est spécifié, alors
    *program* doit également être spécifié.

  - Si *eventStatus* est spécifié, alors *eventStartDate* et
    *eventEndDate* doivent également être spécifiés.

  - Une requête ne peut pas être spécifiée en même temps que des filtres.

  - Les éléments d'attributs ne peuvent être spécifiés qu'une seule fois.

  - Les éléments du filtre ne peuvent être spécifiés qu'une seule fois.

Une requête pour toutes les instances associées à une unité d'organisation spécifique peut ressembler à ceci :

    /api/33/trackedEntityInstances/query.json?ou=DiszpKrYNg8

Une requête sur tous les attributs pour une valeur et une unité d'organisation spécifiques, en utilisant une correspondance exacte des mots :

    /api/33/trackedEntityInstances/query.json?query=scott&ou=DiszpKrYNg8

Une requête sur tous les attributs pour une valeur spécifique, en utilisant un mot partiel :

    /api/33/trackedEntityInstances/query.json?query=LIKE:scott&ou=DiszpKrYNg8

You can query on multiple words separated by the URL character for
space which is %20, will use a logical AND query for each
    word:

    /api/33/trackedEntityInstances/query.json?query=isabel%20may&ou=DiszpKrYNg8

Une requête dans laquelle sont spécifiés les attributs à inclure dans la réponse :

    /api/33/trackedEntityInstances/query.json?query=isabel
      &attribute=dv3nChNSIxy&attribute=AMpUYgxuCaE&ou=DiszpKrYNg8

Pour effectuer une requête sur des instances à l'aide d'un attribut avec filtre et d'un attribut sans filtre, avec une unité d'organisation en utilisant le mode de requête de l'unité d'organisation subordonnée, utilisez ceci :

    /api/33/trackedEntityInstances/query.json?attribute=zHXD5Ve1Efw:EQ:A
      &attribute=AMpUYgxuCaE&ou=DiszpKrYNg8;yMCshbaVExv

Une requête pour les instances où un attribut est inclus dans la réponse et où un attribut est utilisé comme filtre :

    /api/33/trackedEntityInstances/query.json?attribute=zHXD5Ve1Efw:EQ:A
      &filter=AMpUYgxuCaE:LIKE:Road&ou=DiszpKrYNg8

Une requête dans laquelle plusieurs opérandes et filtres sont spécifiés pour un élément de filtre :

    /api/33/trackedEntityInstances/query.json?ou=DiszpKrYNg8&program=ur1Edk5Oe2n
      &filter=lw1SqmMlnfh:GT:150:LT:190

Pour effectuer une requête sur un attribut en utilisant plusieurs valeurs dans un filtre IN :

    /api/33/trackedEntityInstances/query.json?ou=DiszpKrYNg8
      &attribute=dv3nChNSIxy:IN:Scott;Jimmy;Santiago

Pour limiter la réponse aux instances qui font partie d'un programme spécifique, vous pouvez inclure un paramètre de requête de programme :

    /api/33/trackedEntityInstances/query.json?filter=zHXD5Ve1Efw:EQ:A
      &ou=O6uvpzGd5pu&ouMode=DESCENDANTS&program=ur1Edk5Oe2n

Pour spécifier les dates d'inscription au programme dans la requête :

    /api/33/trackedEntityInstances/query.json?filter=zHXD5Ve1Efw:EQ:A
      &ou=O6uvpzGd5pu&program=ur1Edk5Oe2n&programStartDate=2013-01-01
      &programEndDate=2013-09-01

Pour limiter la réponse aux instances d'une entité suivie spécifique, vous pouvez inclure un paramètre de requête d'entité suivie :

    /api/33/trackedEntityInstances/query.json?attribute=zHXD5Ve1Efw:EQ:A
      &ou=O6uvpzGd5pu&ouMode=DESCENDANTS&trackedEntity=cyl5vuJ5ETQ

Par défaut, les instances sont renvoyées dans des pages de taille 50. Pour modifier cela, vous pouvez utiliser les paramètres de requête de page et de taille de page (pageSize) :

    /api/33/trackedEntityInstances/query.json?attribute=zHXD5Ve1Efw:EQ:A
      &ou=O6uvpzGd5pu&ouMode=DESCENDANTS&page=2&pageSize=3

Pour effectuer une requête sur les instances qui ont des événements d'un statut donné dans un intervalle de temps donné :

    /api/33/trackedEntityInstances/query.json?ou=O6uvpzGd5pu
      &program=ur1Edk5Oe2n&eventStatus=LATE_VISIT
      &eventStartDate=2014-01-01&eventEndDate=2014-09-01

Vous pouvez utiliser une gamme d'opérateurs pour le filtrage :

<table>
<caption>Filter operators</caption>
<colgroup>
<col style="width: 19%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="header">
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>EQ</td>
<td>Equal to</td>
</tr>
<tr class="even">
<td>GT</td>
<td>Greater than</td>
</tr>
<tr class="odd">
<td>GE</td>
<td>Greater than or equal to</td>
</tr>
<tr class="even">
<td>LT</td>
<td>Less than</td>
</tr>
<tr class="odd">
<td>LE</td>
<td>Less than or equal to</td>
</tr>
<tr class="even">
<td>NE</td>
<td>Not equal to</td>
</tr>
<tr class="odd">
<td>LIKE</td>
<td>Like (free text match)</td>
</tr>
<tr class="even">
<td>IN</td>
<td>Equal to one of multiple values separated by &quot;;&quot;</td>
</tr>
</tbody>
</table>

##### Response format { #webapi_tei_grid_query_response_format } 

<!--DHIS2-SECTION-ID:webapi_tei_grid_query_response_format-->

Cette ressource prend en charge les représentations JSON, JSONP, XLS et CSV.

  - json (application/json)

  - jsonp (application/javascript)

  - xml (application/xml)

  - csv (application/csv)

  - xls (application/vnd.ms-excel)

La réponse au format JSON se présente sous la forme d'un tableau et peut ressembler à ce qui suit. La section *headers* décrit le contenu de chaque colonne. Les colonnes "instance", "créé", "dernière mise à jour", "unité d'organisation" et "entité suivie" sont toujours présentes. Les colonnes suivantes correspondent aux attributs spécifiés dans la requête. La section *rows* contient une ligne par instance.

```json
{
  "headers": [{
    "name": "instance",
    "column": "Instance",
    "type": "java.lang.String"
  }, {
    "name": "created",
    "column": "Created",
    "type": "java.lang.String"
  }, {
    "name": "lastupdated",
    "column": "Last updated",
    "type": "java.lang.String"
  }, {
    "name": "ou",
    "column": "Org unit",
    "type": "java.lang.String"
  }, {
    "name": "te",
    "column": "Tracked entity",
    "type": "java.lang.String"
  }, {
    "name": "zHXD5Ve1Efw",
    "column": "Date of birth type",
    "type": "java.lang.String"
  }, {
    "name": "AMpUYgxuCaE",
    "column": "Address",
    "type": "java.lang.String"
  }],
  "metaData": {
    "names": {
      "cyl5vuJ5ETQ": "Person"
    }
  },
  "width": 7,
  "height": 7,
  "rows": [
    ["yNCtJ6vhRJu", "2013-09-08 21:40:28.0", "2014-01-09 19:39:32.19", "DiszpKrYNg8", "cyl5vuJ5ETQ", "A", "21 Kenyatta Road"],
    ["fSofnQR6lAU", "2013-09-08 21:40:28.0", "2014-01-09 19:40:19.62", "DiszpKrYNg8", "cyl5vuJ5ETQ", "A", "56 Upper Road"],
    ["X5wZwS5lgm2", "2013-09-08 21:40:28.0", "2014-01-09 19:40:31.11", "DiszpKrYNg8", "cyl5vuJ5ETQ", "A", "56 Main Road"],
    ["pCbogmlIXga", "2013-09-08 21:40:28.0", "2014-01-09 19:40:45.02", "DiszpKrYNg8", "cyl5vuJ5ETQ", "A", "12 Lower Main Road"],
    ["WnUXrY4XBMM", "2013-09-08 21:40:28.0", "2014-01-09 19:41:06.97", "DiszpKrYNg8", "cyl5vuJ5ETQ", "A", "13 Main Road"],
    ["xLNXbDs9uDF", "2013-09-08 21:40:28.0", "2014-01-09 19:42:25.66", "DiszpKrYNg8", "cyl5vuJ5ETQ", "A", "14 Mombasa Road"],
    ["foc5zag6gbE", "2013-09-08 21:40:28.0", "2014-01-09 19:42:36.93", "DiszpKrYNg8", "cyl5vuJ5ETQ", "A", "15 Upper Hill"]
  ]
}
```

#### Tracked entity instance filters { #webapi_tei_filters } 

<!--DHIS2-SECTION-ID:webapi_tei_filters-->

To create, read, update and delete tracked entity instance filters you
can interact with the */api/trackedEntityInstanceFilters* resource.

    /api/33/trackedEntityInstanceFilters

##### Créer et mettre à jour une définition de filtre d'instance d'entité suivie { #create-and-update-a-tracked-entity-instance-filter-definition } 

Pour créer et mettre à jour un filtre d'instance d'entité suivie dans le système, vous devez utiliser la ressource *trackedEntityInstanceFilters*. Les définitions des filtres d'instances d'entités suivies sont utilisées dans l'application Saisie Tracker pour afficher les "listes de tâches" prédéfinies pertinentes sur l'interface utilisateur du Tracker.

<table>
<caption>Payload</caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Payload values</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>name</td>
<td>Name of the filter. Required.</td>
<td></td>
</tr>
<tr class="even">
<td>description</td>
<td>A description of the filter.</td>
<td></td>
</tr>
<tr class="odd">
<td>sortOrder</td>
<td>The sort order of the filter. Used in Tracker Capture to order the filters in the program dashboard.</td>
<td></td>
</tr>
<tr class="even">
<td>style</td>
<td>Object containing css style.</td>
<td>( &quot;color&quot;: &quot;blue&quot;, &quot;icon&quot;: &quot;fa fa-calendar&quot;}</td>
</tr>
<tr class="odd">
<td>program</td>
<td>Object containing the id of the program. Required.</td>
<td>{ &quot;id&quot; : &quot;uy2gU8kTjF&quot;}</td>
</tr>
<tr class="even">
<td>enrollmentStatus</td>
<td>The TEIs enrollment status. Can be none(any enrollmentstatus) or ACTIVE|COMPLETED|CANCELED</td>
<td></td>
</tr>
<tr class="odd">
<td>followup</td>
<td>When this parameter is true, the filter only returns TEIs that have an enrollment with status followup.</td>
<td></td>
</tr>
<tr class="even">
<td>enrollmentCreatedPeriod</td>
<td>Period object containing a period in which the enrollment must be created. See <em>Period</em> definition table below.</td>
<td>{ &quot;periodFrom&quot;: -15, &quot;periodTo&quot;: 15}</td>
</tr>
<tr class="odd">
<td>eventFilters</td>
<td>A list of eventFilters. See <em>Event filters</em> definition table below.</td>
<td>[{&quot;programStage&quot;: &quot;eaDH9089uMp&quot;, &quot;eventStatus&quot;: &quot;OVERDUE&quot;, &quot;eventCreatedPeriod&quot;: {&quot;periodFrom&quot;: -15, &quot;periodTo&quot;: 15}}]</td>
</tr>
</tbody>
</table>

<table>
<caption>Event filters definition</caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<tbody>
<tr class="odd">
<td>programStage</td>
<td>Which programStage the TEI needs an event in to be returned.</td>
<td>&quot;eaDH9089uMp&quot;</td>
</tr>
<tr class="even">
<td>eventStatus</td>
<td>The events status. Can be none(any event status) or ACTIVE|COMPLETED|SCHEDULED|OVERDUE</td>
<td>ACTIVE</td>
</tr>
<tr class="odd">
<td>eventCreatedPeriod</td>
<td>Period object containing a period in which the event must be created. See <em>Period</em> definition below.</td>
<td>{ &quot;periodFrom&quot;: -15, &quot;periodTo&quot;: 15}</td>
</tr>
<tr class="even">
<td>assignedUserMode</td>
<td>To specify the assigned user selection mode for events. Possible values are CURRENT (events assigned to current user)| PROVIDED (events assigned to users provided in "assignedUsers" list) | NONE (events assigned to no one) | ANY (events assigned to anyone). If PROVIDED (or null), non-empty assignedUsers in the payload will be considered.</td>
<td>"assignedUserMode": "PROVIDED"</td>
</tr>
<tr class="odd">
<td>assignedUsers</td>
<td>To specify a list of assigned users for events. To be used along with PROVIDED assignedUserMode above.</td>
<td>"assignedUsers": ["a3kGcGDCuk7", "a3kGcGDCuk8"]</td>
</tr>
</tbody>
</table>

<table>
<caption>Period definition</caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<tbody>
<tr class="odd">
<td>periodFrom</td>
<td>Number of days from current day. Can be positive or negative integer.</td>
<td>-15</td>
</tr>
<tr class="even">
<td>periodTo</td>
<td>Number of days from current day. Must be bigger than periodFrom. Can be positive or negative integer.</td>
<td>15</td>
</tr>
</tbody>
</table>

##### Requête sur les filtres d'instances d'entités suivie { #tracked-entity-instance-filters-query } 

Pour rechercher des filtres d'instances d'entités suivies dans le système, vous pouvez interagir avec la ressource */api/trackedEntityInstanceFilters*.

<table>
<caption>Tracked entity instance filters query parameters</caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Query parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>program</td>
<td>Program identifier. Restricts filters to the given program.</td>
</tr>
</tbody>
</table>

### Enrollment management { #webapi_enrollment_management } 

<!--DHIS2-SECTION-ID:webapi_enrollment_management-->

Les inscriptions bénéficient d'une prise en charge CRUD complète dans l'API. Avec l'API des instances d'entités suivies, la plupart des opérations nécessaires pour travailler avec les instances d'entités suivies et les programmes sont prises en charge.

    /api/33/enrollments

#### Enrolling a tracked entity instance into a program { #webapi_enrolling_tei } 

<!--DHIS2-SECTION-ID:webapi_enrolling_tei-->

Pour inscrire des personnes à un programme, vous devez d'abord obtenir l'identifiant de la personne à partir de la ressource *trackedEntityInstances*. Ensuite, vous devez obtenir l'identifiant du programme à partir de la ressource *programs*. Un modèle de charge utile est présenté ci-dessous :

```json
{
  "trackedEntityInstance": "ZRyCnJ1qUXS",
  "orgUnit": "ImspTQPwCqd",
  "program": "S8uo8AlvYMz",
  "enrollmentDate": "2013-09-17",
  "incidentDate": "2013-09-17"
}
```

Cette charge doit être utilisée dans une requête *POST* à la ressource des inscriptions identifiée par l'URL suivante :

    /api/33/enrollments

Pour annuler ou terminer une inscription, vous pouvez adresser une requête *PUT* à la ressource `enrollments`, en indiquant l'identifiant de l'inscription et l'action que vous voulez réaliser. Pour annuler une inscription pour une entité suivie :

    /api/33/enrollments/<enrollment-id>/cancelled

Pour terminer l'inscription d'une instance d'entité suivie, vous pouvez envoyez une requête *PUT* à l'URL suivante :

    /api/33/enrollments/<enrollment-id>/completed

Pour supprimer une inscription, vous pouvez envoyer une requête *DELETE* à l'URL suivante :

    /api/33/enrollments/<enrollment-id>

#### Enrollment instance query { #webapi_enrollment_instance_query } 

<!--DHIS2-SECTION-ID:webapi_enrollment_instance_query-->

Pour rechercher des inscriptions, vous pouvez interagir avec la ressource */api/enrollments*.

    /api/33/enrollments

##### Request syntax { #webapi_enrollment_query_request_syntax } 

<!--DHIS2-SECTION-ID:webapi_enrollment_query_request_syntax-->

<table style="width:100%;">
<caption>Enrollment query parameters</caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="header">
<th>Query parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ou</td>
<td>Organisation unit identifiers, separated by &quot;;&quot;.</td>
</tr>
<tr class="even">
<td>ouMode</td>
<td>The mode of selecting organisation units, can be SELECTED | CHILDREN | DESCENDANTS | ACCESSIBLE | CAPTURE | ALL. Default is SELECTED, which refers to the selected organisation units only. See table below for explanations.</td>
</tr>
<tr class="odd">
<td>program</td>
<td>Program identifier. Restricts instances to being enrolled in the given program.</td>
</tr>
<tr class="even">
<td>programStatus</td>
<td>Status of the instance for the given program. Can be ACTIVE | COMPLETED | CANCELLED.</td>
</tr>
<tr class="odd">
<td>followUp</td>
<td>Follow up status of the instance for the given program. Can be true | false or omitted.</td>
</tr>
<tr class="even">
<td>programStartDate</td>
<td>Start date of enrollment in the given program for the tracked entity instance.</td>
</tr>
<tr class="odd">
<td>programEndDate</td>
<td>End date of enrollment in the given program for the tracked entity instance.</td>
</tr>
<tr class="even">
<td>lastUpdatedDuration</td>
<td>Include only items which are updated within the given duration. The format is <value><time-unit>, where the supported time units are “d” (days), “h” (hours), “m” (minutes) and “s” (seconds).</td>
</tr>
<tr class="odd">
<td>trackedEntity</td>
<td>Tracked entity identifier. Restricts instances to the given tracked instance type.</td>
</tr>
<tr class="even">
<td>trackedEntityInstance</td>
<td>Tracked entity instance identifier. Should not be used together with trackedEntity.</td>
</tr>
<tr class="odd">
<td>page</td>
<td>The page number. Default page is 1.</td>
</tr>
<tr class="even">
<td>pageSize</td>
<td>The page size. Default size is 50 rows per page.</td>
</tr>
<tr class="odd">
<td>totalPages</td>
<td>Indicates whether to include the total number of pages in the paging response (implies higher response time).</td>
</tr>
<tr class="even">
<td>skipPaging</td>
<td>Indicates whether paging should be ignored and all rows should be returned.</td>
</tr>
<tr class="odd">
<td>includeDeleted</td>
<td>Indicates whether to include soft deleted enrollments or not. It is false by default.</td>
</tr>
</tbody>
</table>

Les modes de sélection d'unités d'organisation disponibles sont expliqués dans le tableau suivant.

<table>
<caption>Organisation unit selection modes</caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 79%" />
</colgroup>
<thead>
<tr class="header">
<th>Mode</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SELECTED</td>
<td>Organisation units defined in the request (default).</td>
</tr>
<tr class="even">
<td>CHILDREN</td>
<td>Immediate children, i.e. only the first level below, of the organisation units defined in the request.</td>
</tr>
<tr class="odd">
<td>DESCENDANTS</td>
<td>All children, i.e. at only levels below, e.g. including children of children, of the organisation units defined in the request.</td>
</tr>
<tr class="even">
<td>ACCESSIBLE</td>
<td>All descendants of the data view organisation units associated with the current user. Will fall back to data capture organisation units associated with the current user if the former is not defined.</td>
</tr>
<tr class="odd">
<td>ALL</td>
<td>All organisation units in the system. Requires authority.</td>
</tr>
</tbody>
</table>

La requête n'est pas sensible à la casse. Les règles suivantes s'appliquent aux paramètres de la requête.

  - Au moins une unité d'organisation doit être spécifiée à l'aide de l'attribut *ou*.
    (un ou plusieurs), ou *ouMode=ALL* doit être spécifié.

  - Un seul des paramètres *program* et *trackedEntity* peut être
    spécifié (zéro ou un).

  - Si *programStatus* est spécifié, alors *program* doit également être
    spécifiés.

  - Si *followUp* est spécifié, alors *program* doit également être spécifié.

  - Si *programStartDate* ou *programEndDate* est spécifié, alors
    *program* doit également être spécifié.

Une requête pour toutes les inscriptions associées à une unité d'organisation spécifique peut ressembler à ceci :

    /api/33/enrollments.json?ou=DiszpKrYNg8

Pour limiter la réponse aux inscriptions qui font partie d'un programme spécifique, vous pouvez inclure un paramètre de requête de programme :

    /api/33/enrollments.json?ou=O6uvpzGd5pu&ouMode=DESCENDANTS&program=ur1Edk5Oe2n

Pour spécifier les dates d'inscription au programme dans la requête :

    /api/33/enrollments.json?&ou=O6uvpzGd5pu&program=ur1Edk5Oe2n
      &programStartDate=2013-01-01&programEndDate=2013-09-01

Pour limiter la réponse aux inscriptions d'une entité suivie spécifique, vous pouvez inclure un paramètre de requête d'entité suivie :

    /api/33/enrollments.json?ou=O6uvpzGd5pu&ouMode=DESCENDANTS&trackedEntity=cyl5vuJ5ETQ

Pour limiter la réponse aux inscriptions d'une entité suivie spécifique, vous pouvez inclure un paramètre de requête d'instance d'entité suivie. Dans ce cas, nous avons limité la réponse aux inscriptions disponibles pour l'utilisateur actuel :

    /api/33/enrollments.json?ouMode=ACCESSIBLE&trackedEntityInstance=tphfdyIiVL6

Par défaut, les inscriptions sont renvoyées dans des pages de taille 50. Pour modifier cela, vous pouvez utiliser les paramètres de requête 'page' et 'taille de page' (pageSize) :

    /api/33/enrollments.json?ou=O6uvpzGd5pu&ouMode=DESCENDANTS&page=2&pageSize=3

##### Response format { #webapi_enrollment_query_response_format } 

<!--DHIS2-SECTION-ID:webapi_enrollment_query_response_format-->

Cette ressource prend en charge les représentations JSON, JSONP, XLS et CSV.

  - json (application/json)

  - jsonp (application/javascript)

  - xml (application/xml)

La réponse en JSON/XML est au format objet et peut ressembler à ce qui suit. Le filtrage des champs est possible, donc si vous voulez un affichage complet, vous pouvez ajouter `fields=*` à la requête :

```json
{
  "enrollments": [
    {
      "lastUpdated": "2014-03-28T05:27:48.512+0000",
      "trackedEntity": "cyl5vuJ5ETQ",
      "created": "2014-03-28T05:27:48.500+0000",
      "orgUnit": "DiszpKrYNg8",
      "program": "ur1Edk5Oe2n",
      "enrollment": "HLFOK0XThjr",
      "trackedEntityInstance": "qv0j4JBXQX0",
      "followup": false,
      "enrollmentDate": "2013-05-23T05:27:48.490+0000",
      "incidentDate": "2013-05-10T05:27:48.490+0000",
      "status": "ACTIVE"
    }
  ]
}
```

### Événements { #webapi_events } 

<!--DHIS2-SECTION-ID:webapi_events-->

Cette section traite de l'envoi et de la lecture d'événements.

    /api/33/events

#### Sending events { #webapi_sending_events } 

<!--DHIS2-SECTION-ID:webapi_sending_events-->

DHIS2 prend en charge trois types d'événements : les événements uniques sans enregistrement (également appelés événements anonymes), les événements uniques avec enregistrement et les événements multiples avec enregistrement. L'enregistrement implique que les données sont rattachées à une instance d'entité suivie qui est identifiée à l'aide d'un identifiant.

Pour envoyer des événements à DHIS2, vous devez interagir avec la ressource *events*. L'approche utilisée pour envoyer des événements est similaire à celle utilisée pour envoyer des valeurs de données agrégées. Vous aurez besoin d'un *programme* qui peut être recherché à l'aide de la ressource *programs*, d'une *unité d'organisation* qui peut être recherchée à l'aide de la ressource *organisationUnits*, et d'une liste d'identifiants d'éléments de données valides qui peuvent être recherchés à l'aide de la ressource *dataElements*. Pour les événements avec enregistrement, un identifiant d'*instance d'entité suivie* est nécessaire. Pour savoir comment l'obtenir, consultez la section sur la ressource *trackedEntityInstances*. Pour envoyer des événements à des programmes comportant plusieurs étapes, il vous faudra également inclure l'identifiant *programStage* (étape de programme). Les identifiants des étapes de programme se trouvent dans la ressource *programStages*.

Voici un exemple simple d'événement unique sans enregistrement au format XML. Dans cet exemple, nous envoyons vers la base de données de démonstration, des événements du programme "Morbidité et mortalité des patients hospitalisés" pour l'établissement "Ngelehun CHC"  :

```xml
<?xml version="1.0" encoding="utf-8"?>
<event program="eBAyeGv0exc" orgUnit="DiszpKrYNg8"
  eventDate="2013-05-17" status="COMPLETED" storedBy="admin">
  <coordinate latitude="59.8" longitude="10.9" />
  <dataValues>
    <dataValue dataElement="qrur9Dvnyt5" value="22" />
    <dataValue dataElement="oZg33kd9taw" value="Male" />
    <dataValue dataElement="msodh3rEMJa" value="2013-05-18" />
  </dataValues>
</event>
```

To perform some testing we can save the XML payload as a file
called*event.xml* and send it as a POST request to the events resource
in the API using curl with the following command:

```bash
curl -d @event.xml "https://play.dhis2.org/demo/api/33/events"
  -H "Content-Type:application/xml" -u admin:district
```

La même charge au format JSON se présente comme suit :

```json
{
  "program": "eBAyeGv0exc",
  "orgUnit": "DiszpKrYNg8",
  "eventDate": "2013-05-17",
  "status": "COMPLETED",
  "completedDate": "2013-05-18",
  "storedBy": "admin",
  "coordinate": {
    "latitude": 59.8,
    "longitude": 10.9
  },
  "dataValues": [
    {
      "dataElement": "qrur9Dvnyt5", 
      "value": "22"
    },
    {
      "dataElement": "oZg33kd9taw", 
      "value": "Male"
    }, 
    {
      "dataElement": "msodh3rEMJa", 
      "value": "2013-05-18"
    }
  ]
}
```

Pour l'envoyer, vous pouvez l'enregistrer dans un fichier appelé *event.json* et utiliser curl comme suit :

```bash
curl -d @event.json "localhost/api/33/events" -H "Content-Type:application/json"
  -u admin:district
```

Nous pouvons également envoyer plusieurs événements en même temps. Une charge au format XML pourrait ressembler à ceci :

```xml
<?xml version="1.0" encoding="utf-8"?>
<events>
  <event program="eBAyeGv0exc" orgUnit="DiszpKrYNg8"
    eventDate="2013-05-17" status="COMPLETED" storedBy="admin">
    <coordinate latitude="59.8" longitude="10.9" />
    <dataValues>
      <dataValue dataElement="qrur9Dvnyt5" value="22" />
      <dataValue dataElement="oZg33kd9taw" value="Male" />
    </dataValues>
  </event>
  <event program="eBAyeGv0exc" orgUnit="DiszpKrYNg8"
    eventDate="2013-05-17" status="COMPLETED" storedBy="admin">
    <coordinate latitude="59.8" longitude="10.9" />
    <dataValues>
      <dataValue dataElement="qrur9Dvnyt5" value="26" />
      <dataValue dataElement="oZg33kd9taw" value="Female" />
    </dataValues>
  </event>
</events>
```

Vous recevrez un récapitulatif de l'importation avec la réponse qui peut être inspecté afin d'obtenir des informations sur le résultat de la requête, par exemple le nombre de valeurs qui ont été importées avec succès. La charge au format JSON ressemble à ceci :

```json
{
  "events": [
  {
    "program": "eBAyeGv0exc",
    "orgUnit": "DiszpKrYNg8",
    "eventDate": "2013-05-17",
    "status": "COMPLETED",
    "storedBy": "admin",
    "coordinate": {
      "latitude": "59.8",
      "longitude": "10.9"
    },
    "dataValues": [
      {
        "dataElement": "qrur9Dvnyt5", 
        "value": "22"
      },
      {
        "dataElement": "oZg33kd9taw", 
        "value": "Male"
      }
    ]
  },
  {
    "program": "eBAyeGv0exc",
    "orgUnit": "DiszpKrYNg8",
    "eventDate": "2013-05-17",
    "status": "COMPLETED",
    "storedBy": "admin",
    "coordinate": {
      "latitude": "59.8",
      "longitude": "10.9"
    },
    "dataValues": [
      {
        "dataElement": "qrur9Dvnyt5", 
        "value": "26"
      },
      {
        "dataElement": "oZg33kd9taw", 
        "value": "Female"
      }
    ]
  } ]
}
```

Vous pouvez également utiliser GeoJson pour stocker tout type de géométrie sur votre événement. Voici un exemple de charge utilisant GeoJson et non les anciennes propriétés de latitude et de longitude :

```json
{
  "program": "eBAyeGv0exc",
  "orgUnit": "DiszpKrYNg8",
  "eventDate": "2013-05-17",
  "status": "COMPLETED",
  "storedBy": "admin",
  "geometry": {
    "type": "POINT",
    "coordinates": [59.8, 10.9]
  },
  "dataValues": [
    {
      "dataElement": "qrur9Dvnyt5", 
      "value": "22"
    }, 
    { 
      "dataElement": "oZg33kd9taw", 
      "value": "Male"
    }, 
    {
      "dataElement": "msodh3rEMJa", 
      "value": "2013-05-18"
    }
  ]
}
```

Le récapitulatif de l'importation contient également l'identifiant *reference* de l'événement que vous venez d'envoyer, ainsi qu'un élément *href* qui indique l'emplacement du serveur de cet événement. Le tableau ci-dessous décrit la signification de chaque élément.

<table>
<caption>Events resource format</caption>
<colgroup>
<col style="width: 13%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 30%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Type</th>
<th>Required</th>
<th>Options (default first)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>program</td>
<td>string</td>
<td>true</td>
<td></td>
<td>Identifier of the single event with no registration program</td>
</tr>
<tr class="even">
<td>orgUnit</td>
<td>string</td>
<td>true</td>
<td></td>
<td>Identifier of the organisation unit where the event took place</td>
</tr>
<tr class="odd">
<td>eventDate</td>
<td>date</td>
<td>true</td>
<td></td>
<td>The date of when the event occurred</td>
</tr>
<tr class="even">
<td>completedDate</td>
<td>date</td>
<td>false</td>
<td></td>
<td>The date of when the event is completed. If not provided, the current date is selected as the event completed date</td>
</tr>
<tr class="odd">
<td>status</td>
<td>enum</td>
<td>false</td>
<td>ACTIVE | COMPLETED | VISITED | SCHEDULE | OVERDUE | SKIPPED</td>
<td>Whether the event is complete or not</td>
</tr>
<tr class="even">
<td>storedBy</td>
<td>string</td>
<td>false</td>
<td>Defaults to current user</td>
<td>Who stored this event (can be username, system-name, etc)</td>
</tr>
<tr class="odd">
<td>coordinate</td>
<td>double</td>
<td>false</td>
<td></td>
<td>Refers to where the event took place geographically (latitude and longitude)</td>
</tr>
<tr class="even">
<td>dataElement</td>
<td>string</td>
<td>true</td>
<td></td>
<td>Identifier of data element</td>
</tr>
<tr class="odd">
<td>value</td>
<td>string</td>
<td>true</td>
<td></td>
<td>Data value or measure for this event</td>
</tr>
</tbody>
</table>

##### Correspondance des unités d'organisation (paramètre orgUnit) { #orgunit-matching } 

Par défaut, le paramètre orgUnit correspondra à l'identifiant. Vous pouvez également sélectionner le schéma de correspondance de l'identifiant de l'unité d'organisation en utilisant le paramètre orgUnitIdScheme=SCHEME, où les options sont : *ID*, *UID*, *UUID*, *CODE* et *NAME*. Il existe également le schéma *ATTRIBUTE:*, qui correspond à une valeur d'attribut de métadonnées *unique*.

#### Updating events { #webapi_updating_events } 

<!--DHIS2-SECTION-ID:webapi_updating_events-->

Pour mettre à jour un événement existant, le format de la charge reste le même, mais il faudra ajouter l'identifiant à la fin de la chaîne de l'URL à laquelle vous adressez la requête, et la requête doit être de type PUT.

La charge doit contenir tous les attributs, même ceux qui n'ont pas été modifiés. Les attributs qui étaient présents auparavant et qui ne sont plus présents dans la charge actuelle seront supprimés par le système.

Il n'est pas autorisé de mettre à jour un événement déjà supprimé. Il en va de même pour les instances d'entité suivie et les inscriptions.

```bash
curl -X PUT -d @updated_event.xml "localhost/api/33/events/ID"
  -H "Content-Type: application/xml" -u admin:district
```

```bash
curl -X PUT -d @updated_event.json "localhost/api/33/events/ID"
  -H "Content-Type: application/json" -u admin:district
```

#### Deleting events { #webapi_deleting_events } 

<!--DHIS2-SECTION-ID:webapi_deleting_events-->

Pour supprimer un événement existant, il suffit d'envoyer une requête DELETE avec une référence d'identifiant au serveur que vous utilisez.

```bash
curl -X DELETE "localhost/api/33/events/ID" -u admin:district
```

#### Assigning user to events { #webapi_user_assign_event } 

<!--DHIS2-SECTION-ID:webapi_user_assign_event-->

A user can be assigned to an event. This can be done by including the appropriate property in the payload when updating or creating the event. 

      "assignedUser": "<id>"

L'id fait référence à l'identifiant de l'utilisateur. Un seul utilisateur peut être affecté à un événement à la fois.

L'affectation des utilisateurs doit être activée dans la phase de programmation avant que les utilisateurs puissent être affectés à des événements.
#### Getting events { #webapi_getting_events } 

<!--DHIS2-SECTION-ID:webapi_getting_events-->

Pour obtenir un événement existant, vous pouvez envoyer une requête GET comprenant l'identifiant comme ceci :

```bash
curl "http://localhost/api/33/events/ID" -H "Content-Type: application/xml" -u admin:district
```

#### Querying and reading events { #webapi_querying_reading_events } 

<!--DHIS2-SECTION-ID:webapi_querying_reading_events-->

Cette section explique comment lire les événements qui ont été stockés dans l'instance DHIS2. Pour pouvoir utiliser les données d'événements de manière plus avancée, veuillez consulter la section consacrée à l'analyse des événements. Le format de sortie du point d'extrémité `/api/events` correspondra au format utilisé pour lui envoyer des événements (ce format n'est pas pris en charge par l'api d'analyse d'événements). Les formats XML et JSON sont pris en charge. Pour pouvoir les utiliser, il suffit d'ajouter un fichier .json/.xml ou de définir l'en-tête *Accept* approprié. La requête est paginée par défaut et la taille de la page par défaut est de 50 événements. Le filtrage par *champs* fonctionne comme avec les métadonnées ; ajoutez le paramètre *fields* et spécifiez les propriétés que vous voulez, ce qui nous donne *fields=program,status*.

<table>
<caption>Events resource query parameters</caption>
<thead>
<tr class="header">
<th>Key</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>program</td>
<td>identifier</td>
<td>true (if not programStage is provided)</td>
<td>Identifier of program</td>
</tr>
<tr class="even">
<td>programStage</td>
<td>identifier</td>
<td>false</td>
<td>Identifier of program stage</td>
</tr>
<tr class="odd">
<td>programStatus</td>
<td>enum</td>
<td>false</td>
<td>Status of event in program, ca be ACTIVE | COMPLETED | CANCELLED</td>
</tr>
<tr class="even">
<td>followUp</td>
<td>boolean</td>
<td>false</td>
<td>Whether event is considered for follow up in program, can be true | false or omitted.</td>
</tr>
<tr class="odd">
<td>trackedEntityInstance</td>
<td>identifier</td>
<td>false</td>
<td>Identifier of tracked entity instance</td>
</tr>
<tr class="even">
<td>orgUnit</td>
<td>identifier</td>
<td>true</td>
<td>Identifier of organisation unit</td>
</tr>
<tr class="odd">
<td>ouMode</td>
<td>enum</td>
<td>false</td>
<td>Org unit selection mode, can be SELECTED | CHILDREN | DESCENDANTS</td>
</tr>
<tr class="even">
<td>startDate</td>
<td>date</td>
<td>false</td>
<td>Only events newer than this date</td>
</tr>
<tr class="odd">
<td>endDate</td>
<td>date</td>
<td>false</td>
<td>Only events older than this date</td>
</tr>
<tr class="even">
<td>status</td>
<td>enum</td>
<td>false</td>
<td>Status of event, can be ACTIVE | COMPLETED | VISITED | SCHEDULED | OVERDUE | SKIPPED</td>
</tr>
<tr class="odd">
<td>lastUpdatedStartDate</td>
<td>date</td>
<td>false</td>
<td>Filter for events which were updated after this date. Cannot be used together with <em>lastUpdatedDuration</em>.</td>
</tr>
<tr class="even">
<td>lastUpdatedEndDate</td>
<td>date</td>
<td>false</td>
<td>Filter for events which were updated up until this date. Cannot be used together with <em>lastUpdatedDuration</em>.</td>
</tr>
<tr class="odd">
<td>lastUpdatedDuration</td>
<td>string</td>
<td>false</td>
<td>Include only items which are updated within the given duration. The format is <value><time-unit>, where the supported time units are “d” (days), “h” (hours), “m” (minutes) and “s” (seconds). Cannot be used together with <em>lastUpdatedStartDate</em> and/or <em>lastUpdatedEndDate</em>.</td>
</tr>
<tr class="even">
<td>skipMeta</td>
<td>boolean</td>
<td>false</td>
<td>Exclude the meta data part of response (improves performance)</td>
</tr>
<tr class="odd">
<td>page</td>
<td>integer</td>
<td>false</td>
<td>Page number</td>
</tr>
<tr class="even">
<td>pageSize</td>
<td>integer</td>
<td>false</td>
<td>Number of items in each page</td>
</tr>
<tr class="odd">
<td>totalPages</td>
<td>boolean</td>
<td>false</td>
<td>Indicates whether to include the total number of pages in the paging response.</td>
</tr>
<tr class="even">
<td>skipPaging</td>
<td>boolean</td>
<td>false</td>
<td>Indicates whether to skip paging in the query and return all events.</td>
</tr>
<tr class="odd">
<td>dataElementIdScheme</td>
<td>string</td>
<td>false</td>
<td>Data element ID scheme to use for export, valid options are UID, CODE and ATTRIBUTE:{ID}</td>
</tr>
<tr class="even">
<td>categoryOptionComboIdScheme</td>
<td>string</td>
<td>false</td>
<td>Category Option Combo ID scheme to use for export, valid options are UID, CODE and 
ATTRIBUTE:{ID}</td>
</tr>
<tr class="odd">
<td>orgUnitIdScheme</td>
<td>string</td>
<td>false</td>
<td>Organisation Unit ID scheme to use for export, valid options are UID, CODE and 
ATTRIBUTE:{ID}</td>
</tr>
<tr class="even">
<td>programIdScheme</td>
<td>string</td>
<td>false</td>
<td>Program ID scheme to use for export, valid options are UID, CODE and ATTRIBUTE:{ID}</td>
</tr>
<tr class="odd">
<td>programStageIdScheme</td>
<td>string</td>
<td>false</td>
<td>Program Stage ID scheme to use for export, valid options are UID, CODE and ATTRIBUTE:{ID}</td>
</tr>
<tr class="even">
<td>idScheme</td>
<td>string</td>
<td>false</td>
<td>Allows to set id scheme for data element, category option combo, orgUnit, program and program 
stage at once.</td>
</tr>
<tr class="odd">
<td>order</td>
<td>string</td>
<td>false</td>
<td>The order of which to retrieve the events from the API. Usage: order=&lt;property&gt;:asc/desc - Ascending order is default.
<p>Properties: event | program | programStage | enrollment | enrollmentStatus | orgUnit | orgUnitName | trackedEntityInstance | eventDate | followup | status | dueDate | storedBy | created | lastUpdated | completedBy | completedDate</p>
<pre><code>order=orgUnitName:DESC</code></pre>
<pre><code>order=lastUpdated:ASC</code></pre></td>
</tr>
<tr class="even">
<td>event</td>
<td>comma delimited string</td>
<td>false</td>
<td>Filter the result down to a limited set of IDs by using <em>event=id1;id2</em>.</td>
</tr>
<tr class="odd">
<td>skipEventId</td>
<td>boolean</td>
<td>false</td>
<td>Skips event identifiers in the response</td>
</tr>
<tr class="even">
<td>attributeCc (**)</td>
<td>string</td>
<td>false</td>
<td>Attribute category combo identifier (must be combined with <em>attributeCos</em>)</td>
</tr>
<tr class="odd">
<td>attributeCos (**)</td>
<td>string</td>
<td>false</td>
<td>Attribute category option identifiers, separated with ; (must be combined with <em>attributeCc</em>)</td>
</tr>
<tr class="even">
<td>async</td>
<td>false | true</td>
<td>false</td>
<td>Indicates whether the import should be done asynchronous or synchronous.</td>
</tr>
<tr class="odd">
<td>includeDeleted</td>
<td>boolean</td>
<td>false</td>
<td>When true, soft deleted events will be included in your query result.</td>
</tr>
<tr class="even">
<td>assignedUserMode</td>
<td>enum</td>
<td>false</td>
<td>Assigned user selection mode, can be CURRENT | PROVIDED | NONE | ANY.</td>
</tr>
<tr class="odd">
<td>assignedUser</td>
<td>comma delimited strings</td>
<td>false</td>
<td>Filter the result down to a limited set of events that are assigned to the given user IDs by using <em>assignedUser=id1;id2</em>. This parameter will be considered only if assignedUserMode is either PROVIDED or null. The API will error out, if for example, assignedUserMode=CURRENT and assignedUser=someId</td>
</tr>
</tbody>
</table>

> **Remarque**
>
> Si la requête ne contient ni `attributeCC` ni `attributeCos`, le serveur renvoie des événements pour toutes les combinaisons d'options d'attribut pour lesquelles l'utilisateur a un accès en lecture.

##### Exemples { #examples }

Requête sur de tous les événements associés aux subordonnées d'une unité d'organisation donnée :

    /api/29/events.json?orgUnit=YuQRtpLP10I&ouMode=CHILDREN

Requête pour tous les événements associés à tous les descendants d'une unité d'organisation donnée, c'est-à-dire toutes les unités d'organisation qui lui sont inférieurs dans la hiérarchie :

    /api/33/events.json?orgUnit=O6uvpzGd5pu&ouMode=DESCENDANTS

La requête pour tous les événements disposant d'un programme et d'une unité d'organisation :

    /api/33/events.json?orgUnit=DiszpKrYNg8&program=eBAyeGv0exc

Requête pour tous les événements associés à un programme et à une unité d'organisation, ordonnés par date d'échéance en ordre croissant :

    /api/33/events.json?orgUnit=DiszpKrYNg8&program=eBAyeGv0exc&order=dueDate

La requête pour les 10 événements avec la date d'événement la plus récente dans un programme et une unité d'organisation - par pagination et ordonnés par date d'échéance en ordre décroissant :

    /api/33/events.json?orgUnit=DiszpKrYNg8&program=eBAyeGv0exc
      &order=eventDate:desc&pageSize=10&page=1

La requête pour tous les événements avec un programme et une unité d'organisation pour une instance d'entité suivie donnée :

    /api/33/events.json?orgUnit=DiszpKrYNg8
      &program=eBAyeGv0exc&trackedEntityInstance=gfVxE3ALA9m

Requête pour tous les événements associés à un programme et une unité d'organisation plus ancien(ne) ou égal(e) au 03/02/2014 :

    /api/33/events.json?orgUnit=DiszpKrYNg8&program=eBAyeGv0exc&endDate=2014-02-03

La requête pour tous les événements avec une étape de programme, une unité d'organisation et une instance d'entité suivie de l'an 2014 :

    /api/33/events.json?orgUnit=DiszpKrYNg8&program=eBAyeGv0exc
      &trackedEntityInstance=gfVxE3ALA9m&startDate=2014-01-01&endDate=2014-12-31

Query files associated with event data values. In the specific case of fetching an image file an 
additional parameter can be provided to fetch the image with different dimensions. If dimension is 
not provided, the system will return the original image. The parameter will be ignored in case of 
fetching non-image files e.g pdf. Possible dimension values are *small(254 x 254), 
medium(512 x 512), large(1024 x 1024) or original*. Any value other than those mentioned will be 
discarded and the original image will be returned.

    /api/33/events/files?eventUid=hcmcWlYkg9u&dataElementUid=C0W4aFuVm4P&dimension=small

Retrieve events with specified Organisation unit and Program, and use _Attribute:Gq0oWTf2DtN_ as 
identifier scheme

    /api/events?orgUnit=DiszpKrYNg8&program=lxAQ7Zs9VYR&idScheme=Attribute:Gq0oWTf2DtN

Retrieve events with specified Organisation unit and Program, and use UID as identifier scheme for 
orgUnits, Code as identifier scheme for Program stages, and _Attribute:Gq0oWTf2DtN_ as identifier 
scheme for the rest of the metadata with assigned attribute.

    api/events.json?orgUnit=DiszpKrYNg8&program=lxAQ7Zs9VYR&idScheme=Attribute:Gq0oWTf2DtN
      &orgUnitIdScheme=UID&programStageIdScheme=Code

#### Requête pour les grilles d'événements { #event-grid-query } 

En plus du point d'extrémité des requêtes d'événements ci-dessus, il existe un point d'extrémité pour les requêtes de grilles d'événements où un format de "grille" d'événements plus compact  est renvoyé. Vous pouvez le faire en interagissant avec /api/events/query.json|xml|xls|csv.

    /api/33/events/query

La plupart des paramètres de requête mentionnés dans la section sur la requête et la lecture d'événements ci-dessus sont valables ici. Toutefois, étant donné que la grille à renvoyer comporte un ensemble spécifique de colonnes qui s'appliquent à toutes les lignes (événements), il est obligatoire de spécifier une étape de programme. Il n'est pas possible de combiner des événements de différents programmes ou étapes de programme dans le renvoi.

Le renvoi d'événements appartenant à une même étape de programme ouvre également la voie à de nouvelles fonctionnalités, par exemple le tri et la recherche d'événements sur la base des valeurs de leurs éléments de données. api/events/query prend en charge ces fonctionnalités. Voici quelques exemples :

Une requête pour obtenir une grille d'événements qui contient uniquement des éléments de données sélectionnés pour une étape de programme :

    /api/33/events/query.json?orgUnit=DiszpKrYNg8&programStage=Zj7UnCAulEk
      &dataElement=qrur9Dvnyt5,fWIAEtYVEGk,K6uUAvq500H&order=lastUpdated:desc
      &pageSize=50&page=1&totalPages=true

Une requête qui renvoie une grille d'événements qui contient tous les éléments de données d'une étape de programme :

    /api/33/events/query.json?orgUnit=DiszpKrYNg8&programStage=Zj7UnCAulEk
      &includeAllDataElements=true

Une requête pour filtrer les événements sur la base de la valeur de l'élément de données

    /api/33/events/query.json?orgUnit=DiszpKrYNg8&programStage=Zj7UnCAulEk
      &filter=qrur9Dvnyt5:GT:20:LT:50

Outre le filtrage, l'exemple ci-dessus illustre également une chose : le fait qu'il n'y a pas d'éléments de données mentionnés à renvoyer dans la grille. Dans ce cas, par défaut, le système ne renvoie que les éléments de données marqués "Afficher dans le rapport" dans la configuration des étapes de programme.

Nous pouvons également étendre la requête ci-dessus pour obtenir une grille triée (par ordre ascendant ou descendant) sur la base des valeurs de l'élément de données

    /api/33/events/query.json?orgUnit=DiszpKrYNg8&programStage=Zj7UnCAulEk
      &filter=qrur9Dvnyt5:GT:20:LT:50&order=qrur9Dvnyt5:desc

#### Event filters { #webapi_event_filters } 

<!--DHIS2-SECTION-ID:webapi_event_filters-->

Pour créer, lire, mettre à jour et supprimer des filtres d'événements, vous pouvez interagir avec la ressource `/api/eventFilters`.

    /api/33/eventFilters

##### Création et mise à jour d'une définition de filtre d'événement { #create-and-update-an-event-filter-definition } 

Pour créer et mettre à jour un filtre d'événement dans le système, vous devez utiliser la ressource *eventFilters*. La méthode *POST* est utilisée pour créer et la méthode *PUT* est utilisée pour la mise à jour. Les définitions des filtres d'événements sont utilisées dans l'application Saisie Tracker pour afficher les "listes de tâches" prédéfinies pertinentes sur l'interface utilisateur du Tracker.

<table>
<caption>Request Payload</caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Request Property</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>name</td>
<td>Name of the filter.</td>
<td>"name":"My working list"</td>
</tr>
<tr class="even">
<td>description</td>
<td>A description of the filter.</td>
<td>"description":"for listing all events assigned to me".</td>
</tr>
<tr class="odd">
<td>program</td>
<td>The uid of the program.</td>
<td>"program" : "a3kGcGDCuk6"</td>
</tr>
<tr class="even">
<td>programStage</td>
<td>The uid of the program stage.</td>
<td>"programStage" : "a3kGcGDCuk6"</td>
</tr>
<tr class="even">
<td>eventQueryCriteria</td>
<td>Object containing parameters for querying, sorting and filtering events.</td>
<td>  
  "eventQueryCriteria": {
    "organisationUnit":"a3kGcGDCuk6",
    "status": "COMPLETED",
    "createdDate": {
      "from": "2014-05-01",
      "to": "2019-03-20"
    },
    "dataElements": ["a3kGcGDCuk6:EQ:1", "a3kGcGDCuk6"],
    "filters": ["a3kGcGDCuk6:EQ:1"],
    "programStatus": "ACTIVE",
    "ouMode": "SELECTED",
    "assignedUserMode": "PROVIDED",
    "assignedUsers" : ["a3kGcGDCuk7", "a3kGcGDCuk8"],
    "followUp": false,
    "trackedEntityInstance": "a3kGcGDCuk6",
    "events": ["a3kGcGDCuk7", "a3kGcGDCuk8"],
    "fields": "eventDate,dueDate",
    "order": "dueDate:asc,createdDate:desc"
  }
</td>
</tr>
</tbody>
</table>

<table>
<caption>Event Query Criteria definition</caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<tbody>
<tr class="odd">
<td>followUp</td>
<td>Used to filter events based on enrollment followUp flag. Possible values are true|false.</td>
<td>"followUp": true</td>
</tr>
<tr class="even">
<td>organisationUnit</td>
<td>To specify the uid of the organisation unit</td>
<td>"organisationUnit": "a3kGcGDCuk7"</td>
</tr>
<tr class="odd">
<td>ouMode</td>
<td>To specify the OU selection mode. Possible values are SELECTED| CHILDREN|DESCENDANTS|ACCESSIBLE|CAPTURE|ALL</td>
<td>"ouMode": "SELECTED"</td>
</tr>
<tr class="even">
<td>assignedUserMode</td>
<td>To specify the assigned user selection mode for events. Possible values are CURRENT| PROVIDED| NONE | ANY. See table below to understand what each value indicates. If PROVIDED (or null), non-empty assignedUsers in the payload will be considered.</td>
<td>"assignedUserMode": "PROVIDED"</td>
</tr>
<tr class="odd">
<td>assignedUsers</td>
<td>To specify a list of assigned users for events. To be used along with PROVIDED assignedUserMode above.</td>
<td>"assignedUsers": ["a3kGcGDCuk7", "a3kGcGDCuk8"]</td>
</tr>
<tr class="even">
<td>displayOrderColumns</td>
<td>To specify the output ordering of columns</td>
<td>"displayOrderColumns": ["eventDate", "dueDate", "program"]</td>
</tr>
<tr class="odd">
<td>order</td>
<td>To specify ordering/sorting of fields and its directions in comma separated values. A single item in order is of the form "dataItem:direction".</td>
<td>"order"="a3kGcGDCuk6:desc,eventDate:asc"</td>
</tr>
<tr class="even">
<td>dataFilters</td>
<td>To specify filters to be applied when listing events</td>
<td>"dataFilters"=[{
      "dataItem": "abcDataElementUid",
      "le": "20",
      "ge": "10",
      "lt": "20",
      "gt": "10",
      "in": ["India", "Norway"],
      "like": "abc",
      "dateFilter": {
        "startDate": "2014-05-01",
        "endDate": "2019-03-20",
        "startBuffer": -5,
        "endBuffer": 5,
        "period": "LAST_WEEK",
        "type": "RELATIVE"
      }
    }]</td>
</tr>
<tr class="odd">
<td>status</td>
<td> Any valid EventStatus</td>
<td>  "eventStatus": "COMPLETED"</td>
</tr>
<tr class="even">
<td>events</td>
<td>To specify list of events</td>
<td>"events"=["a3kGcGDCuk6"]</td>
</tr>
<tr class="odd">
<td>completedDate</td>
<td>DateFilterPeriod object date filtering based on completed date.</td>
<td>
  "completedDate": {
    "startDate": "2014-05-01",
    "endDate": "2019-03-20",
    "startBuffer": -5,
    "endBuffer": 5,
    "period": "LAST_WEEK",
    "type": "RELATIVE"
  }
</td>
</tr>
<tr class="even">
<td>eventDate</td>
<td>DateFilterPeriod object date filtering based on event date.</td>
<td>
  "eventDate": {
    "startBuffer": -5,
    "endBuffer": 5,
    "type": "RELATIVE"
  }
</td>
</tr>
<tr class="odd">
<td>dueDate</td>
<td>DateFilterPeriod object date filtering based on due date.</td>
<td>
  "dueDate": {
    "period": "LAST_WEEK",
    "type": "RELATIVE"
  }
</td>
</tr>
<tr class="even">
<td>lastUpdatedDate</td>
<td>DateFilterPeriod object date filtering based on last updated date.</td>
<td>
  "lastUpdatedDate": {
    "startDate": "2014-05-01",
    "endDate": "2019-03-20",
    "type": "ABSOLUTE"
  }
</td>
</tr>

</tbody>
</table>

<table>
<caption>DateFilterPeriod object definition</caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<tbody>
<tr class="odd">
<td>type</td>
<td>Specify whether the date period type is ABSOLUTE | RELATIVE</td>
<td>"type" : "RELATIVE"</td>
</tr>
<tr class="even">
<td>period</td>
<td>Specify if a relative system defined period is to be used. Applicable only when "type" is RELATIVE. (see <a href="#webapi_date_relative_period_values">Relative Periods</a> for supported relative periods)</td>
<td>"period" : "THIS_WEEK"</td>
</tr>
<tr class="odd">
<td>startDate</td>
<td>Absolute start date. Applicable only when "type" is ABSOLUTE</td>
<td>"startDate":"2014-05-01"</td>
</tr>
<tr class="even">
<td>endDate</td>
<td>Absolute end date. Applicable only when "type" is ABSOLUTE</td>
<td>"startDate":"2014-05-01"</td>
</tr>
<tr class="odd">
<td>startBuffer</td>
<td>Relative custom start date. Applicable only when "type" is RELATIVE</td>
<td>"startBuffer":-10</td>
</tr>
<tr class="even">
<td>endBuffer</td>
<td>Relative custom end date. Applicable only when "type" is RELATIVE</td>
<td>"startDate":+10</td>
</tr>
</tbody>
</table>

Les modes de sélection des utilisateurs assignés disponibles sont expliqués dans le tableau suivant.

<table>
<caption>Assigned user selection modes (event assignment)</caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 79%" />
</colgroup>
<thead>
<tr class="header">
<th>Mode</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CURRENT</td>
<td>Assigned to the current logged in user</td>
</tr>
<tr class="even">
<td>PROVIDED</td>
<td>Assigned to the users provided in the "assignedUser" parameter</td>
</tr>
<tr class="odd">
<td>NONE</td>
<td>Assigned to no users.</td>
</tr>
<tr class="even">
<td>ANY</td>
<td>Assigned to any users.</td>
</tr>
</tbody>
</table>

Un exemple de charge pouvant être utilisée pour créer/mettre à jour un filtre d'événement est présenté ci-dessous.

```json
{
  "program": "ur1Edk5Oe2n",
  "description": "Simple Filter for TB events",
  "name": "TB events",
  "eventQueryCriteria": {
    "organisationUnit":"DiszpKrYNg8",
    "eventStatus": "COMPLETED",
    "eventDate": {
      "startDate": "2014-05-01",
      "endDate": "2019-03-20",
      "startBuffer": -5,
      "endBuffer": 5,
      "period": "LAST_WEEK",
      "type": "RELATIVE"
    },
    "dataFilters": [{
      "dataItem": "abcDataElementUid",
      "le": "20",
      "ge": "10",
      "lt": "20",
      "gt": "10",
      "in": ["India", "Norway"],
      "like": "abc"
    },
    {
      "dataItem": "dateDataElementUid",
      "dateFilter": {
        "startDate": "2014-05-01",
        "endDate": "2019-03-20",
        "type": "ABSOLUTE"
      }
    },
    {
      "dataItem": "anotherDateDataElementUid",
      "dateFilter": {
        "startBuffer": -5,
        "endBuffer": 5,
        "type": "RELATIVE"
      }
    },
    {
      "dataItem": "yetAnotherDateDataElementUid",
      "dateFilter": {
        "period": "LAST_WEEK",
        "type": "RELATIVE"
      }
    }],
    "programStatus": "ACTIVE"
  }
}
```


##### Récupération et suppression des filtres d'événements { #retrieving-and-deleting-event-filters } 

Un filtre d'événement spécifique peut être récupéré en utilisant l'API suivante

    GET /api/33/eventFilters/{uid}

Tous les filtres d'événements peuvent être récupérés en utilisant l'API suivante.

    GET /api/33/eventFilters?fields=*

Tous les filtres d'événements pour un programme spécifique peuvent être récupérés à l'aide de l'API suivante :

    GET /api/33/eventFilters?filter=program:eq:IpHINAT79UW

Un filtre d'événement peut être supprimé à l'aide de l'API suivante

    DELETE /api/33/eventFilters/{uid}

### Relations { #relationships } 
Les relations sont des liens entre deux entités dans le Tracker. Ces entités peuvent être des instances d'entités suivies, des inscriptions et des événements.

Il existe plusieurs points d'extrémité qui vous permettent de voir, de créer, de supprimer et de mettre à jour les relations. Le plus courant est /api/trackedEntityInstances, où vous pouvez inclure des relations dans la charge pour les créer, les mettre à jour ou les supprimer si vous les omettez - de la même manière que vous travaillez avec les inscriptions et les événements dans le même point d'extrémité. Tous les points d'extrémité du Tracker, c'est-à-dire /api/trackedEntityInstances, /api/enrollments et /api/events listent également leurs relations si une requête est spécifiée dans le filtre de champ.

Toutefois, le point d'extrémité communément utilisé pour les relations est /api/relationships. Il fournit toutes les opérations CRUD normales pour les relations.

List all relationships require you to provide the UID of the trackedEntityInstance, Enrollment or event that you want to list all the relationships for:  

    GET /api/relationships?tei=ABCDEF12345
    GET /api/relationships?enrollment=ABCDEF12345
    GET /api/relationships?event=ABCDEF12345

Cette requête renverra une liste de toutes les relations que vous pouvez voir. Cela inclut l'instance d'entité suivie, l'inscription ou l'événement que vous avez spécifié. Chaque relation est représentée par le JSON suivant :

```json
{
  "relationshipType": "dDrh5UyCyvQ",
  "relationshipName": "Mother-Child",
  "relationship": "t0HIBrc65Rm",
  "bidirectional": false,
  "from": {
    "trackedEntityInstance": {
      "trackedEntityInstance": "vOxUH373fy5"
    }
  },
  "to": {
    "trackedEntityInstance": {
      "trackedEntityInstance": "pybd813kIWx"
    }
  },
  "created": "2019-04-26T09:30:56.267",
  "lastUpdated": "2019-04-26T09:30:56.267"
}
```

Vous pouvez également visualiser les relations spécifiées en utilisant le point d'extrémité suivant :

    GET /api/relationships/<id>

Pour créer ou mettre à jour une relation, vous pouvez utiliser les points d'extrémité suivants :

    POST /api/relationships
    PUT /api/relationships

Et utilisez la structure de charge suivante :

```json
{
  "relationshipType": "dDrh5UyCyvQ",
  "from": {
    "trackedEntityInstance": {
      "trackedEntityInstance": "vOxUH373fy5"
    }
  },
  "to": {
    "trackedEntityInstance": {
      "trackedEntityInstance": "pybd813kIWx"
    }
  }
}
```

Pour supprimer une relation, vous pouvez utiliser ce point d'extrémité :

      DELETE /api/relationships/<id>

Dans nos exemples de charges, nous utilisons une relation entre instances d'entités suivies. C'est pourquoi les propriétés "from" et "to" de nos charges incluent des objets "trackedEntityInstance". Si votre relation inclut d'autres entités, vous pouvez utiliser les propriétés suivantes :

```json
{
  "enrollment": {
    "enrollment": "<id>"
  }
}
```

```json
{
  "event": {
    "event": "<id>"
  }
}
```

### Update strategies { #webapi_tei_update_strategies } 

<!--DHIS2-SECTION-ID:webapi_tei_update_strategies-->

Deux stratégies de mise à jour sont prises en charge pour les trois points d'extrémité du Tracker : l'inscription et la création d'événements. Ceci est utile lorsque vous avez généré un identifiant au niveau du client et que vous n'êtes pas sûr s'il a été créé ou non sur le serveur.

<table>
<caption>Available tracker strategies</caption>
<colgroup>
<col style="width: 24%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CREATE</td>
<td>Create only, this is the default behavior.</td>
</tr>
<tr class="even">
<td>CREATE_AND_UPDATE</td>
<td>Try and match the ID, if it exist then update, if not create.</td>
</tr>
</tbody>
</table>

Pour modifier ce paramètre, utilisez le paramètre de stratégie :

    POST /api/33/trackedEntityInstances?strategy=CREATE_AND_UPDATE

### Tracker bulk deletion { #webapi_tracker_bulk_deletion } 

<!--DHIS2-SECTION-ID:webapi_tracker_bulk_deletion-->

La suppression en bloc d'objets Tracker fonctionne de la même manière que l'ajout et la mise à jour d'objets Tracker. La seule différence est que la stratégie d'importation (`importStrategy`) est *DELETE*.

*Exemple : Suppression en bloc d'instances d'entités suivies :*

```json
{
  "trackedEntityInstances": [
    {
      "trackedEntityInstance": "ID1"
    }, { 
      "trackedEntityInstance": "ID2"
    }, { 
      "trackedEntityInstance": "ID3"
    }
  ]
}
```

```bash
curl -X POST -d @data.json -H "Content-Type: application/json"
  "http://server/api/33/trackedEntityInstances?strategy=DELETE"
```

*Exemple : Suppression en bloc d'inscriptions :*

```json
{
  "enrollments": [
    {
       "enrollment": "ID1"
    }, { 
      "enrollment": "ID2" 
    }, { 
      "enrollment": "ID3"
    }
  ]
}
```

```bash
curl -X POST -d @data.json -H "Content-Type: application/json"
  "http://server/api/33/enrollments?strategy=DELETE"
```

*Exemple : Suppression en bloc d'événements:*

```json
{
  "events": [
    {
      "event": "ID1"
    }, { 
      "event": "ID2"
    }, { 
      "event": "ID3"
    }
  ]
}
```

```bash
curl -X POST -d @data.json -H "Content-Type: application/json"
  "http://server/api/33/events?strategy=DELETE"
```

### Identifier reuse and item deletion via POST and PUT methods { #webapi_updating_and_deleting_items } 

<!--DHIS2-SECTION-ID:webapi_updating_and_deleting_items-->

Les points d'extrémité du Tracker */trackedEntityInstances*, */enrollments*, */events* prennent en charge les opérations CRUD. Le système garde la trace des identifiants utilisés. Ainsi, un élément qui a été créé puis supprimé (par exemple, un événement ou une inscription) ne peut pas être créé ou mis à jour à nouveau. Si l'on tente de supprimer un élément déjà supprimé, le système renvoie une réponse de succès, car la suppression d'un élément déjà supprimé n'implique aucun changement.

Le système ne permet pas de supprimer un élément via une méthode de mise à jour (*PUT*) ou de création (*POST*). Par conséquent, l'attribut *deleted* est ignoré dans les méthodes *PUT* et *POST*, et dans la méthode *POST*, il est défini par défaut sur *false*.

### Import parameters { #webapi_import_parameters } 

<!--DHIS2-SECTION-ID:webapi_import_parameters-->

Le processus d'importation peut être personnalisé à l'aide d'un ensemble de paramètres d'importation :

<table>
<caption>Import parameters</caption>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Values (default first)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>dataElementIdScheme</td>
<td>id | name | code | attribute:ID</td>
<td>Property of the data element object to use to map the data values.</td>
</tr>
<tr class="even">
<td>orgUnitIdScheme</td>
<td>id | name | code | attribute:ID</td>
<td>Property of the org unit object to use to map the data values.</td>
</tr>
<tr class="odd">
<td>idScheme</td>
<td>id | name | code| attribute:ID</td>
<td>Property of all objects including data elements, org units and category option combos, to use to map the data values.</td>
</tr>
<tr class="even">
<td>dryRun</td>
<td>false | true</td>
<td>Whether to save changes on the server or just return the import summary.</td>
</tr>
<tr class="odd">
<td>strategy</td>
<td>CREATE | UPDATE | CREATE_AND_UPDATE | DELETE</td>
<td>Save objects of all, new or update import status on the server.</td>
</tr>
<tr class="even">
<td>skipNotifications</td>
<td>true | false</td>
<td>Indicates whether to send notifications for completed events.</td>
</tr>
<tr class="odd">
<td>skipFirst</td>
<td>true | false</td>
<td>Relevant for CSV import only. Indicates whether CSV file contains a header row which should be skipped.</td>
</tr>
<tr class="even">
<td>importReportMode</td>
<td>FULL, ERRORS, DEBUG</td>
<td>Sets the `ImportReport` mode, controls how much is reported back after the import is done. `ERRORS` only includes <em>ObjectReports</em> for object which has errors. `FULL` returns an <em>ObjectReport</em> for all objects imported, and `DEBUG` returns the same plus a name for the object (if available).</td>
</tr>
</tbody>
</table>

#### CSV Import / Export { #webapi_events_csv_import_export } 

<!--DHIS2-SECTION-ID:webapi_events_csv_import_export-->

Outre les formats XML et JSON pour l'importation et l'exportation d'événements, le format CSV a été introduit dans DHIS2.17. La prise en charge de ce format s'appuie sur ce qui a été décrit dans la dernière section, nous ne parlerons donc ici que des parties spécifiques au format CSV.

Pour utiliser le format CSV, vous devez soit utiliser le point d'extrémité `/api/events.csv` ou ajouter *content-type : text/csv* pour l'importation, et *accept :text/csv* pour l'exportation, lorsque vous utilisez le point d'extrémité `/api/events`.

The order of column in the CSV which are used for both export and import
is as follows:

<table>
<caption>CSV column</caption>
<thead>
<tr class="header">
<th>Index</th>
<th>Key</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>event</td>
<td>identifier</td>
<td>Identifier of event</td>
</tr>
<tr class="even">
<td>2</td>
<td>status</td>
<td>enum</td>
<td>Status of event, can be ACTIVE | COMPLETED | VISITED | SCHEDULED | OVERDUE | SKIPPED</td>
</tr>
<tr class="odd">
<td>3</td>
<td>program</td>
<td>identifier</td>
<td>Identifier of program</td>
</tr>
<tr class="even">
<td>4</td>
<td>programStage</td>
<td>identifier</td>
<td>Identifier of program stage</td>
</tr>
<tr class="odd">
<td>5</td>
<td>enrollment</td>
<td>identifier</td>
<td>Identifier of enrollment (program instance)</td>
</tr>
<tr class="even">
<td>6</td>
<td>orgUnit</td>
<td>identifier</td>
<td>Identifier of organisation unit</td>
</tr>
<tr class="odd">
<td>7</td>
<td>eventDate</td>
<td>date</td>
<td>Event date</td>
</tr>
<tr class="even">
<td>8</td>
<td>dueDate</td>
<td>date</td>
<td>Due Date</td>
</tr>
<tr class="odd">
<td>9</td>
<td>latitude</td>
<td>double</td>
<td>Latitude where event happened</td>
</tr>
<tr class="even">
<td>10</td>
<td>longitude</td>
<td>double</td>
<td>Longitude where event happened</td>
</tr>
<tr class="odd">
<td>11</td>
<td>dataElement</td>
<td>identifier</td>
<td>Identifier of data element</td>
</tr>
<tr class="even">
<td>12</td>
<td>value</td>
<td>string</td>
<td>Value / measure of event</td>
</tr>
<tr class="odd">
<td>13</td>
<td>storedBy</td>
<td>string</td>
<td>Event was stored by (defaults to current user)</td>
</tr>
<tr class="even">
<td>14</td>
<td>providedElsewhere</td>
<td>boolean</td>
<td>Was this value collected somewhere else</td>
</tr>
<tr class="odd">
<td>14</td>
<td>completedDate</td>
<td>date</td>
<td>Completed date of event</td>
</tr>
<tr class="even">
<td>14</td>
<td>completedBy</td>
<td>string</td>
<td>Username of user who completed event</td>
</tr>
</tbody>
</table>

*Exemple de 2 événements avec 2 valeurs de données différentes chacun :*

```csv
EJNxP3WreNP,COMPLETED,<pid>,<psid>,<enrollment-id>,<ou>,2016-01-01,2016-01-01,,,<de>,1,,
EJNxP3WreNP,COMPLETED,<pid>,<psid>,<enrollment-id>,<ou>,2016-01-01,2016-01-01,,,<de>,2,,
qPEdI1xn7k0,COMPLETED,<pid>,<psid>,<enrollment-id>,<ou>,2016-01-01,2016-01-01,,,<de>,3,,
qPEdI1xn7k0,COMPLETED,<pid>,<psid>,<enrollment-id>,<ou>,2016-01-01,2016-01-01,,,<de>,4,,
```

#### Import strategy: SYNC { #webapi_sync_import_strategy } 

<!--DHIS2-SECTION-ID:webapi_sync_import_strategy-->

La stratégie d'importation SYNC ne doit être utilisée que par la tâche de synchronisation interne et non pour l'importation régulière. La stratégie SYNC permet aux 3 opérations (CREATE, UPDATE, DELETE) d'être présentes dans la charge au moment moment.

### Tracker Ownership Management { #webapi_tracker_ownership_management } 

<!--DHIS2-SECTION-ID:webapi_tracker_ownership_management-->

Un nouveau concept appelé "Propriété du Tracker" est introduit à partir de la version 2.30. Désormais, il n'y aura plus qu'une seule unité d'organisation propriétaire pour une instance d'entité suivie dans le cadre d'un programme. Les programmes configurés avec un niveau d'accès *PROTECTED* (protégé) ou *CLOSED* (fermé) respecteront les privilèges de propriété. Seuls les utilisateurs appartenant à l'unité d'organisation propriétaire d'une combinaison entité suivie-programme pourront accéder aux données liées à ce programme pour cette entité suivie.

#### Tracker Ownership Override : Break the Glass { #webapi_tracker_ownership_override_api } 

<!--DHIS2-SECTION-ID:webapi_tracker_ownership_override_api-->

Il est possible d'annuler temporairement ce privilège de propriété pour un programme configuré avec un niveau d'accès *PROTECTED*. Tout utilisateur sera en mesure d'obtenir temporairement l'accès aux données liées au programme s'il fournit une raison d'accéder aux données de la combinaison Entité suivie - Programme. Ce fait d'obtenir temporairement l'accès est appelé *briser la glace*. Actuellement, l'accès temporaire est accordé pour une durée de 3 heures. DHIS2 vérifie l'aspect "briser la glace" ainsi que la raison fournie par l'utilisateur. Il n'est pas possible d'obtenir un accès temporaire à un programme qui a été configuré avec un niveau d'accès *CLOSED*. Pour briser la glace d'une combinaison Entité suivie - Programme, la requête POST suivante peut être utilisée :

    /api/33/tracker/ownership/override?trackedEntityInstance=DiszpKrYNg8
      &program=eBAyeGv0exc&reason=patient+showed+up+for+emergency+care

#### Tracker Ownership Transfer { #webapi_tracker_ownership_transfer_api } 

<!--DHIS2-SECTION-ID:webapi_tracker_ownership_transfer_api-->

Il est possible de transférer la propriété d'une combinaison Entité suivie - Programme d'une unité d'organisation à une autre. Cela peut s'avérer utile en cas de transfert de patients ou de migration. Seul un propriétaire (ou un utilisateur qui a utilisé la fonction de brise glace) peut transférer la propriété. Pour transférer la propriété d'une combinaison Entité suivie - Programme à une autre unité d'organisation, vous pouvez utiliser la requête "PUT" suivante :

    /api/33/tracker/ownership/transfer?trackedEntityInstance=DiszpKrYNg8
      &program=eBAyeGv0exc&ou=EJNxP3WreNP


## Doublons potentiels { #potential-duplicates } 

Les doublons potentiels sont les enregistrements sur les lesquels nous travaillons dans le cadre de la déduplication des données. En raison de la nature de la fonction de déduplication, ce point d'extrémité d'API est quelque peu restreint.

A potential duplicate represents a single or pair of records which are suspected to be a duplicate.

La charge d'un doublon potentiel se présente comme suit :

```json
{
  "teiA": "<id>",
  "teiB": "<id>",
  "status": "OPEN|INVALID|MERGED"
}
```

Vous pouvez récupérer une liste de doublons potentiels en utilisant le point d'extrémité suivant :

    GET /api/potentialDuplicates

Additionally you can inspect individual records:

    GET /api/potentialDuplicates/<id>

Pour créer un nouveau doublon potentiel, vous pouvez utiliser ce point d'extrémité :

    POST /api/potentialDuplicates

The payload you provide needs at least _teiA_ to be a valid tracked entity instance; _teiB_ is optional. If _teiB_ is set, it also needs to point to an existing tracked entity instance.

```json
{
  "teiA": "<id>",
  "teiB": "<id>"
}
```

You can mark a potential duplicate as _invalid_ to tell the system that the potential duplicate has been investigated and deemed to be not a duplicate. To do so you can use the following endpoint:

    PUT /api/potentialDuplicates/<id>/invalidation

To hard delete a potential duplicate:

    DELETE /api/potentialDuplicates/<id>

## Adresses électronique { #webapi_email } 

<!--DHIS2-SECTION-ID:webapi_email-->

L'API Web propose une ressource pour l'envoi de courriers électroniques. Pour que des courriels puissent 
être envoyés, il faut que la configuration SMTP soit correctement établie 
et qu'une adresse électronique de notification du système soit définie pour 
l'instance DHIS2. Vous pouvez définir les paramètres SMTP à partir de l'écran des paramètres 
de messagerie et l'adresse électronique de notification du système à partir de l'écran des paramètres généraux 
de DHIS2.

    /api/33/email

### Notification du système { #webapi_email_system_notification } 

<!--DHIS2-SECTION-ID:webapi_email_system_notification-->

La ressource *notification* vous permet d'envoyer des notifications par courriel au système 
avec un sujet et un texte donnés en JSON ou XML. Le courriel sera envoyé à 
l'adresse électronique de notification définie dans les paramètres généraux du système 
DHIS2 :

```json
{
  "subject": "Integrity check summary",
  "text": "All checks ran successfully"
}
```

Vous pouvez envoyer une notification par courrier électronique au système en envoyant un message à la ressource notification
comme suit :

```bash
curl -d @email.json "localhost/api/33/email/notification" -X POST 
  -H "Content-Type:application/json" -u admin:district
```

### E-mails sortants { #outbound-emails } 

Vous pouvez également envoyer une notification générale par courrier électronique en postant dans la ressource de notification
comme indiqué ci-dessous. `F_SEND_EMAIL` ou `ALL`
doit être présente dans le système pour pouvoir utiliser cette API. Le paramètre
est facultatif. La chaîne "DHIS 2" sera envoyée comme sujet par défaut
s'il n'est pas fourni dans l'url. L'url doit être encodée pour pouvoir utiliser cette
API.

```bash
curl "localhost/api/33/email/notification?recipients=xyz%40abc.com&message=sample%20email&subject=Test%20Email" 
  -X POST -u admin:district
```

### Message de test { #webapi_email_test_message } 

<!--DHIS2-SECTION-ID:webapi_email_test_message-->

Pour tester si la configuration SMTP est correcte en vous envoyant à 
vous-même un e-mail de test, vous pouvez interagir avec la ressource *test*. Pour envoyer des courriels de test, 
il faut que votre compte utilisateur DHIS2 soit associé à une adresse 
électronique valide. Vous pouvez envoyer un courriel de test comme suit :

```bash
curl "localhost/api/33/email/test" -X POST -H "Content-Type:application/json" -u admin:district
```

## Partage { #webapi_sharing } 

<!--DHIS2-SECTION-ID:webapi_sharing-->

La solution de partage vous permet de partager la plupart des objets du système avec 
des groupes d'utilisateurs spécifiques et de définir si les objets doivent être accessibles 
au public ou privés. Pour obtenir et définir le statut de partage des objets, vous pouvez 
interagir avec la ressource de *partage*.

    /api/33/sharing

### Obtenir le statut de partage { #webapi_get_sharing_status } 

<!--DHIS2-SECTION-ID:webapi_get_sharing_status-->

Pour demander le statut de partage d'un objet, faites une requête GET à :

    /api/33/sharing?type=dataElement&id=fbfJHSPpUQD

La réponse se présente comme suit.

```json
{
  "meta": {
    "autoriserl'accèspublic": vrai,
    "autoriserl'accèsexterne": faux
  },
  "objet": {
    "id": "fbfJHSPpUQD",
    "nom": "CPN 1ère visite",
    "accèspublic": "rw------",
    "accèsexterne": faux,
    "utilisateur": {},
    "accès au groupe d'utilisateurs": [
      {
        "id": "hj0nnsVsPLU",
        "accès": "rw------"
      },
      {
        "id": "qMjBflJMOfB",
        "accès": "r-------"
      }
    ]
  }
}
```

### Définir le statut de partage { #webapi_set_sharing_status } 

<!--DHIS2-SECTION-ID:webapi_set_sharing_status-->

Vous pouvez définir le statut de partage d'un objet en utilisant la même URL avec 
une requête POST, où la charge utile au format JSON ressemble à ceci :

```json
{
  "objet": {
    "accèspublic": "rw------",
    "accèsexterne": faux,
    "utilisateur": {},
    "accès au groupe d'utilisateurs": [
      {
        "id": "hj0nnsVsPLU",
        "accès": "rw------"
      },
      {
        "id": "qMjBflJMOfB",
        "accès": "r-------"
      }
    ]
  }
}
```

Dans cet exemple, la charge utile définit l'objet comme ayant un accès public en lecture et 
en modification, aucun accès externe (sans connexion), un accès en lecture et en modification à 
un groupe d'utilisateurs et un accès en lecture uniquement à un autre groupe d'utilisateurs. Vous pouvez 
soumettre ceci à la ressource de partage en utilisant curl :

```bash
curl -d @sharing.json "localhost/api/33/sharing?type=dataElement&id=fbfJHSPpUQD"
  -H "Content-Type:application/json" -u admin:district
```

## Programmation { #webapi_scheduling } 

<!--DHIS2-SECTION-ID:webapi_scheduling-->

DHIS2 permet de programmer des tâches de différents types. Chaque type de tâche possède des propriétés de configuration différentes, ce qui vous permet de contrôler plus finement la façon dont les tâches sont exécutées. En outre, vous pouvez configurer une même tâche de manière à ce qu'elle s'exécute avec différentes configurations et à différents intervalles, si nécessaire.

<table>
<caption>Main properties</caption>
<thead>
<tr class="header">
<th>Property</th>
<th>Description</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>name</td>
<td>Name of the job.</td>
<td>String</td>
</tr>
<tr class="even">
<td>cronExpression</td>
<td>The cron expression which defines the interval for when the job should run.</td>
<td>String (Cron expression)</td>
</tr>
<tr class="odd">
<td>jobType</td>
<td>The job type represent which task is run. In the next table, you can get an overview of existing job types. Each job type can have a specific set of parameters for job configuration.</td>
<td>String (Enum)</td>
</tr>
<tr class="even">
<td>jobParameters</td>
<td>Job parameters, if applicable for job type.</td>
<td>(See list of job types)</td>
</tr>
<tr class="odd">
<td>enabled</td>
<td>A job can be added to the system without it being scheduled by setting `enabled` to false in the JSON payload. Use this if you want to temporarily stop scheduling for a job, or if a job configuration is not complete yet.</td>
<td>Boolean</td>
</tr>
</tbody>
</table>

<table>
<caption>Available job types</caption>
<thead>
<tr class="header">
<th>Job type</th>
<th>Parameters</th>
<th>Param(Type:Default)</th>
</tr>
</thead>
<tbody>
<tr>
<td>DATA_INTEGRITY</td>
<td>NONE</td>
<td></td>
</tr>
<tr>
<td>ANALYTICS_TABLE</td>
<td><ul>
<li><p>lastYears: Number of years back to include</p></li>
<li><p>skipTableTypes: Skip generation of tables</p><p>Possible values: DATA_VALUE, COMPLETENESS, COMPLETENESS_TARGET, ORG_UNIT_TARGET, EVENT, ENROLLMENT, VALIDATION_RESULT</p></li>
<li><p>skipResourceTables: Skip generation of resource tables</p></li>
</ul></td>
<td><ul>
<li><p>lastYears (int:0)</p></li>
<li><p>skipTableTypes (Array of String (Enum):None )</p></li>
<li><p>skipResourceTables (Boolean)</p></li>
</ul></td>
</tr>
<tr>
<td>CONTINUOUS_ANALYTICS_TABLE</td>
<td><ul>
<li><p>fullUpdateHourOfDay: Hour of day for full update of analytics tables (0-23)</p></li>
<li><p>lastYears: Number of years back to include</p></li>
<li><p>skipTableTypes: Skip generation of tables</p><p>Possible values: DATA_VALUE, COMPLETENESS, COMPLETENESS_TARGET, ORG_UNIT_TARGET, EVENT, ENROLLMENT, VALIDATION_RESULT</p></li>
<li><p>skipResourceTables: Skip generation of resource tables</p></li>
</ul></td>
<td><ul>
<li><p>lastYears (int:0)</p></li>
<li><p>skipTableTypes (Array of String (Enum):None )</p></li>
<li><p>skipResourceTables (Boolean)</p></li>
</ul></td>
</tr>
<tr>
<td>DATA_SYNC</td>
<td>NONE</td>
<td></td>
</tr>
<tr >
<td>META_DATA_SYNC</td>
<td>NONE</td>
<td></td>
</tr>
<tr>
<td>SEND_SCHEDULED_MESSAGE</td>
<td>NONE</td>
<td></td>
</tr>
<tr>
<td>PROGRAM_NOTIFICATIONS</td>
<td>NONE</td>
<td></td>
</tr>
<tr>
<td>MONITORING (Validation rule analysis)</td>
<td><ul>
<li><p>relativeStart: A number related to date of execution which resembles the start of the period to monitor</p></li>
<li><p>relativeEnd: A number related to date of execution which resembles the end of the period to monitor</p></li>
<li><p>validationRuleGroups: Validation rule groups(UIDs) to include in job</p></li>
<li><p>sendNotification: Set &quot;true&quot; if job should send notifications based on validation rule groups</p></li>
<li><p>persistsResults: Set &quot;true&quot; if job should persist validation results</p></li>
</ul></td>
<td><ul>
<li><p>relativeStart (int:0)</p></li>
<li><p>relativeEnd (int:0)</p></li>
<li><p>validationRuleGroups (Array of String (UIDs):None )</p></li>
<li><p>sendNotification (Boolean:false)</p></li>
<li><p>persistsResults (Boolean:false)</p></li>
</ul></td>
</tr>
<tr>
<td>PUSH_ANALYSIS</td>
<td><ul>
<li><p>pushAnalysis: The uid of the push analysis you want to run</p></li>
</ul></td>
<td><ul>
<li><p>pushAnalysis (String:None)</p></li>
</ul></td>
</tr>
<tr>
<td>PREDICTOR</td>
<td><ul>
<li><p>relativeStart: A number related to date of execution which resembles the start of the period to monitor</p></li>
<li><p>relativeEnd: A number related to date of execution which resembles the start of the period to monitor</p></li>
<li><p>predictors: Predictors(UIDs) to include in job</p></li>
</ul></td>
<td><ul>
<li><p>relativeStart (int:0)</p></li>
<li><p>relativeEnd (int:0)</p></li>
<li><p>predictors (Array of String (UIDs):None )</p></li>
</ul></td>
</tr>
</tbody>
</table>

### Get available job types { #get-available-job-types } 

Pour obtenir une liste de tous les types de travaux disponibles, vous pouvez utiliser le point d'extrémité suivant :

    GET /api/jobConfigurations/jobTypes

The response contains information about each job type including name, job type, key, scheduling type and available parameters. The scheduling type can either be `CRON`, meaning jobs can be scheduled using a cron expression with the `cronExpression` field, or `FIXED_DELAY`, meaning jobs can be scheduled to run with a fixed delay in between with the `delay` field. The field delay is given in seconds. 

Une réponse ressemblera à ceci :

```json
{
  "jobTypes": [
    {
      "name": "Data integrity",
      "jobType": "DATA_INTEGRITY",
      "key": "dataIntegrityJob",
      "schedulingType": "CRON"
    }, {
      "name": "Resource table",
      "jobType": "RESOURCE_TABLE",
      "key": "resourceTableJob",
      "schedulingType": "CRON"
    }, {
      "name": "Continuous analytics table",
      "jobType": "CONTINUOUS_ANALYTICS_TABLE",
      "key": "continuousAnalyticsTableJob",
      "schedulingType": "FIXED_DELAY"
    }
  ]
}
```

### Create job { #create-job } 

Pour configurer les tâches, vous pouvez envoyer une requête POST à la ressource suivante :

    /api/jobConfigurations

Une tâche sans paramètres au format JSON ressemble à ceci :

```json
{
  "name": "",
  "jobType": "JOBTYPE",
  "cronExpression": "0 * * ? * *",
}
```

Exemple d'un tableau d'analyse de tâches avec des paramètres au format JSON :

```json
{
  "name": "Analytics tables last two years",
  "jobType": "ANALYTICS_TABLE",
  "cronExpression": "0 * * ? * *",
  "jobParameters": {
    "lastYears": "2",
    "skipTableTypes": [],
    "skipResourceTables": false
  }
}
```

Exemple d'une tâche d'analyse push avec des paramètres au format JSON :

```json
{
   "name": "Push anlysis charts",
   "jobType": "PUSH_ANALYSIS",
   "cronExpression": "0 * * ? * *",
   "jobParameters": {
     "pushAnalysis": [
       "jtcMAKhWwnc"
     ]
    }
 }
```

Exemple de tâche avec le type de programmation `FIXED_DELAY` et un délai de 120 secondes :

```json
{
  "name": "Continuous analytics table",
  "jobType": "CONTINUOUS_ANALYTICS_TABLE",
  "delay": "120",
  "jobParameters": {
    "fullUpdateHourOfDay": 4
  }
}
```

### Get jobs { #get-jobs } 

Liste de toutes les configurations de tâches :

    GET /api/jobConfigurations

Retrouver une tâche :

    GET /api/jobConfigurations/{id}

Le contenu de la réponse se présente comme suit :

```json
{
  "lastUpdated": "2018-02-22T15:15:34.067",
  "id": "KBcP6Qw37gT",
  "href": "http://localhost:8080/api/jobConfigurations/KBcP6Qw37gT",
  "created": "2018-02-22T15:15:34.067",
  "name": "analytics last two years",
  "jobStatus": "SCHEDULED",
  "displayName": "analytics last two years",
  "enabled": true,
  "externalAccess": false,
  "jobType": "ANALYTICS_TABLE",
  "nextExecutionTime": "2018-02-26T03:00:00.000",
  "cronExpression": "0 0 3 ? * MON",
  "jobParameters": {
    "lastYears": 2,
    "skipTableTypes": [],
    "skipResourceTables": false
  },
  "favorite": false,
  "configurable": true,
  "access": {
    "read": true,
    "update": true,
    "externalize": true,
    "delete": true,
    "write": true,
    "manage": true
  },
  "lastUpdatedBy": {
    "id": "GOLswS44mh8"
  },
  "favorites": [],
  "translations": [],
  "userGroupAccesses": [],
  "attributeValues": [],
  "userAccesses": []
}
```

### Update job { #update-job } 

Mettre à jour une tâche avec des paramètres en utilisant le point d'extrémité suivant et le format de charge utile JSON :

    PUT /api/jobConfiguration/{id}

```json
{
  "name": "analytics last two years",
  "enabled": true,
  "cronExpression": "0 0 3 ? * MON",
  "jobType": "ANALYTICS_TABLE",
  "jobParameters": {
    "lastYears": "3",
    "skipTableTypes": [],
    "skipResourceTables": false
  }
}
```

### Delete job { #delete-job } 

Supprimer une tâche en utilisant :

    DELETE /api/jobConfiguration/{id}

Notez que certaines tâches avec des paramètres de configuration personnalisés peuvent ne pas être ajoutées si 
les paramètres système requis ne sont pas configurés. C'est le cas par exemple de la synchronisation des 
données, qui nécessite la configuration d'un serveur distant.

## Schéma { #webapi_schema } 

<!--DHIS2-SECTION-ID:webapi_schema-->

Pour effectuer une introspection sur tous les objets DXF 2 disponibles, vous pouvez utiliser une ressource disponible à l'adresse `/api/schemas`. Pour obtenir des ressources spécifiques, vous pouvez consulter `/api/schemas/<type>`.

Pour obtenir tous les schémas disponibles au format XML :

    GET /api/schemas.xml

Pour obtenir tous les schémas disponibles au format JSON :

    GET /api/schemas.json

Pour obtenir le schéma JSON d'une classe spécifique :

    GET /api/schemas/dataElement.json

## Personnalisation de l'IU { #webapi_ui_customization } 

<!--DHIS2-SECTION-ID:webapi_ui_customization-->

To customize the UI of the DHIS2 application you can insert custom
JavaScript and CSS styles through the *files* resource. 

```
POST GET DELETE /api/33/files/script
POST GET DELETE /api/33/files/style
```

Le contenu JavaScript et CSS inséré par le biais de cette ressource sera chargé par 
l'application web DHIS2. Cela peut être particulièrement utile dans certaines situations :

  - Remplacer les styles CSS de l'application DHIS2, tels que la balise
    page de connexion ou la page principale.

  - Définir des fonctions JavaScript communes à plusieurs formulaires de saisie de données 
    personnalisés et à des rapports basés sur HTML.

  - Y compris les styles CSS utilisés dans les formulaires de saisie de données personnalisés et 
    les rapports basés sur HTML.

### Javascript { #webapi_customization_javascript } 

<!--DHIS2-SECTION-ID:webapi_customization_javascript-->

Pour insérer Javascript à partir d'un fichier appelé *script.js*, vous pouvez interagir 
avec la ressource *files/script* à l'aide d'une requête POST :

```bash
curl --data-binary @script.js "localhost/api/33/files/script"
  -H "Content-Type:application/javascript" -u admin:district
```

Notez que nous utilisons l'option `--data-binary` pour préserver le formatage du 
contenu du fichier. Vous pouvez récupérer le contenu du JavaScript à l'aide d'une requête GET :

    /api/33/files/script

Pour supprimer le contenu JavaScript, vous pouvez utiliser une requête de type SUPPRIMER (DELETE).

### CSS { #webapi_customization_css } 

<!--DHIS2-SECTION-ID:webapi_customization_css-->

Pour insérer une feuille de style CSS à partir d'un fichier appelé *style.css*, vous pouvez interagir avec la ressource
*files/style* en utilisant une requête POST :

```bash
curl --data-binary @style.css "localhost/api/33/files/style"
  -H "Content-Type:text/css" -u admin:district
```

Vous pouvez récupérer le contenu CSS à l'aide d'une requête GET :

    /api/33/files/style

Pour supprimer le contenu JavaScript, vous pouvez utiliser une requête de type SUPPRIMER (DELETE).

## Synchronization { #webapi_synchronization } 

<!--DHIS2-SECTION-ID:webapi_synchronization-->

This section covers pull and push of data and metadata.

### Data value push { #webapi_sync_data_push } 

<!--DHIS2-SECTION-ID:webapi_sync_data_push-->

To initiate a data value push to a remote server one must first configure the
URL and credentials for the relevant server from System settings >
Synchronization, then make a POST request to the following resource:

    /api/33/synchronization/dataPush

### Metadata pull { #webapi_sync_metadata_pull } 

<!--DHIS2-SECTION-ID:webapi_sync_metadata_pull-->

To initiate a metadata pull from a remote JSON document you can make a
POST request with a *url* as request payload to the following resource:

    /api/33/synchronization/metadataPull

### Availability check { #webapi_sync_availability_check } 

<!--DHIS2-SECTION-ID:webapi_sync_availability_check-->

To check the availability of the remote data server and verify user
credentials you can make a GET request to the following resource:

    /api/33/synchronization/availability

## Applications { #webapi_apps } 

<!--DHIS2-SECTION-ID:webapi_apps-->

Le endpoint `/api/apps` peut être utilisé pour installer, supprimer et 
lister des applications. La clé de l'application est basée sur le nom de l'application, mais tous 
les caractères non alphanumériques sont supprimés, et les espaces sont remplacés par un tiret. 
*My app!* renverra la clé *My-app*.

> **Remarque**
>
> Avant la version 2.28, la clé d'application était dérivée du nom de l'archive ZIP
> , à l'exclusion de l'extension du fichier. Les URLs utilisant l'ancien format
> devraient toujours renvoyer l'application correcte dans l'api.

    /api/33/apps

### Obtenir les applications { #webapi_get_apps } 

<!--DHIS2-SECTION-ID:webapi_get_apps-->

> **Remarque**
>
> Avant la version 2.28, la propriété d'application folderName faisait référence au chemin réel
> de l'application installée. Avec la possibilité de stocker les applications sur des services en nuage, 
> l'objectif de folderName a changé et fait désormais référence à la clé de
> l'application.

Vous pouvez lire les clés des applications en listant toutes les applications de la ressource apps
et en recherchant la propriété *key*. Pour lister toutes les applications installées au format
JSON :

```bash
curl -u user:pass -H "Accept: application/json" "http://server.com/api/33/apps"
```

Vous pouvez aussi simplement orienter votre navigateur web vers l'URL de la ressource :

    http://server.com/api/33/apps

La liste des applications peut également être filtrée par type d'application et par nom, en ajoutant 
un ou plusieurs paramètres *filtre* à l'URL :

    http://server.com/api/33/apps?filter=appType:eq:DASHBOARD_APP&filter=name:ilike:youtube

Les noms d'applications prennent en charge les opérateurs de filtrage *eq* et *ilike*, tandis que *appType*
ne prend en charge que *eq*.

### Installer une application { #webapi_install_app } 

<!--DHIS2-SECTION-ID:webapi_install_app-->

Pour installer une application, la commande suivante peut être exécutée :

```bash
curl -X POST -u user:pass -F file=@app.zip "http://server.com/api/33/apps"
```

### Supprimer une application { #webapi_delete_app } 

<!--DHIS2-SECTION-ID:webapi_delete_app-->

Pour supprimer une application, vous pouvez exécuter la commande suivante :

```bash
curl -X DELETE -u user:pass "http://server.com/api/33/apps/<app-key>"
```

### Recharger les applications { #webapi_reload_apps } 

<!--DHIS2-SECTION-ID:webapi_reload_apps-->

Pour forcer le rechargement des applications actuellement installées, vous pouvez lancer la 
commande suivante. Cette commande est utile si vous avez ajouté manuellement un fichier directement 
dans le système de fichiers, au lieu de le télécharger via l'interface utilisateur de 
DHIS2.

```bash
curl -X PUT -u user:pass "http://server.com/api/33/apps"
```

### Partager des applications entre instances { #webapi_share_apps_between_instances } 

<!--DHIS2-SECTION-ID:webapi_share_apps_between_instances-->

Si l'instance DHIS2 a été configurée pour utiliser le stockage en nuage, les applications
seront désormais installées et stockées sur le service en nuage. Cela permettra à
plusieurs instances de partager les mêmes versions des applications installées, au lieu 
d'installer les mêmes applications sur chaque instance individuelle.

> **Remarque**
>
> Avant la version 2.28, les applications installées étaient uniquement stockées sur le système de fichiers 
> local de l'instance. Les applications installées avant la version 2.28 seront toujours disponibles sur
> l'instance où elles ont été installées, mais elles ne seront pas partagées avec d'autres
> instances, car elles sont toujours situées sur le système de fichiers local de l'instance.

## App store { #webapi_app_store } 

<!--DHIS2-SECTION-ID:webapi_app_store-->

The Web API exposes the content of the DHIS2 App Store as a JSON
representation which can found at the `/api/appStore` resource.

    /api/33/appStore

### Obtenir les applications { #webapi_get_app_store_apps } 

<!--DHIS2-SECTION-ID:webapi_get_app_store_apps-->

Vous pouvez extraire les applications à l'aide d'une requête GET :

    GET /api/33/appStore

Un exemple de réponse JSON est décrit ci-dessous.

```json
{
  [
    {
      "name": "Tabular Tracker Capture",
      "description": "Tabular Tracker Capture is an app that makes you more effective.",
      "sourceUrl": "https://github.com/dhis2/App-repository",
      "appType": "DASHBOARD_WIDGET",
      "status": "PENDING",
      "id": "NSD06BVoV21",
      "developer": {
        "name": "DHIS",
        "organisation": "Uio",
        "address": "Oslo",
        "email": "dhis@abc.com",
      },
      "versions": [
        {
          "id": "upAPqrVgwK6",
          "version": "1.2",
          "minDhisVersion": "2.17",
          "maxDhisVersion": "2.20",
          "downloadUrl": "https://dhis2.org/download/appstore/tabular-capture-12.zip",
          "demoUrl": "http://play.dhis2.org/demo"
        }
      ],
      "images": [
        {
          "id": "upAPqrVgwK6",
          "logo": "true",
          "imageUrl": "https://dhis2.org/download/appstore/tabular-capture-12.png",
          "description": "added feature snapshot",
          "caption": "dialog",
        }
      ]
    }
  ]
}
```

### Installer des applications { #webapi_install_app_store_apps } 

<!--DHIS2-SECTION-ID:webapi_install_app_store_apps-->

Vous pouvez installer des applications sur votre instance DHIS2 en supposant que vous avez les 
permissions appropriées. Une application est référencée en utilisant la propriété `id` 
de la version correspondante de l'application. Une application est installée par une requête 
POST avec l'identifiant de la version à la ressource suivante :

    POST /api/33/appStore/{app-version-id}

## Magasin de données { #webapi_data_store } 

<!--DHIS2-SECTION-ID:webapi_data_store-->

Using the *dataStore* resource, developers can store arbitrary data for
their apps. Access to a datastore's key is based on its sharing settings. 
By default all keys created are publicly accessible (read and write). 
Additionally,  access to a datastore's namespace is limited to the user's 
access to the corresponding app, if the app has reserved the namespace. 
For example a user with access to the "sampleApp" application will also
be able to use the sampleApp namespace in the datastore. If a namespace
is not reserved, no specific access is required to use it.

    /api/33/dataStore

### Structure du magasin de données { #webapi_data_store_structure } 

<!--DHIS2-SECTION-ID:webapi_data_store_structure-->

Les données du magasin de données se composent d'un espace de noms, d'une clé et d'une valeur. La 
combinaison de l'espace de noms et de la clé est unique. Le type de données de la valeur est JSON.

<table>
<caption>Data store structure</caption>
<colgroup>
<col style="width: 22%" />
<col style="width: 40%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="header">
<th>Item</th>
<th>Description</th>
<th>Data type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Namespace</td>
<td>Namespace for organization of entries.</td>
<td>String</td>
</tr>
<tr class="even">
<td>Key</td>
<td>Key for identification of values.</td>
<td>String</td>
</tr>
<tr class="odd">
<td>Value</td>
<td>Value holding the information for the entry.</td>
<td>JSON</td>
</tr>
<tr class="even">
<td>Encrypted</td>
<td>Indicates whether the value of the given key should be encrypted</td>
<td>Boolean</td>
</tr>
</tbody>
</table>

### Obtenir des clés et des espaces de noms  { #webapi_data_store_get_keys_and_namespaces } 

<!--DHIS2-SECTION-ID:webapi_data_store_get_keys_and_namespaces-->

Pour obtenir une liste de tous les espaces de noms existants :

    GET /api/33/dataStore

Exemple de requête curl pour le listing :

```bash
curl "play.dhis2.org/demo/api/33/dataStore" -u admin:district
```

Exemple de réponse : 

```json
[
  "foo",
  "bar"
]
```

Pour obtenir la liste de toutes les clés d'un espace de noms :

    GET /api/33/dataStore/<namespace>

Exemple de requête curl pour le listing :

```bash
curl "play.dhis2.org/demo/api/33/dataStore/foo" -u admin:district
```

Exemple de réponse : 

```json
[
  "key_1",
  "key_2"
]
```

Pour récupérer une valeur pour une clé existante dans un espace de noms :

    GET /api/33/dataStore/<namespace>/<key>

Exemple de requête curl pour l'extraction :

```bash
curl "play.dhis2.org/demo/api/33/dataStore/foo/key_1"-u admin:district
```

Exemple de réponse : 

```json
{
  "foo":"bar"
}
```

Pour récupérer les métadonnées d'une clé existante dans un espace de noms :

    GET /api/33/dataStore/<namespace>/<key>/metaData

Exemple de requête curl pour l'extraction :

```bash
curl "play.dhis2.org/demo/api/33/dataStore/foo/key_1/metaData" -u admin:district
```

Exemple de réponse : 

```json
{
  "created": "...",
  "user": {...},
  "namespace": "foo",
  "key": "key_1"
}
```

### Créer des valeurs { #webapi_data_store_create_values } 

<!--DHIS2-SECTION-ID:webapi_data_store_create_values-->

Pour créer une nouvelle clé et une nouvelle valeur pour un espace de noms :

    POST /api/33/dataStore/<namespace>/<key>

Exemple de requête curl pour créer, en présumant que la charge JSON est valide :

```bash
curl "https://play.dhis2.org/demo/api/33/dataStore/foo/key_1" -X POST
  -H "Content-Type: application/json" -d "{\"foo\":\"bar\"}" -u admin:district
```

Exemple de réponse : 

```json
{
  "httpStatus": "OK",
  "httpStatusCode": 201,
  "status": "OK",
  "message": "Key 'key_1' created."
}
```

Si vous souhaitez que les données que vous stockez soient cryptées (par exemple les informations 
d'identification de l'utilisateur ou autres), vous pouvez ajouter une requête à l'URL comme suit :

    GET /api/33/dataStore/<namespace>/<key>?encrypt=true

### Mettre à jour les valeurs { #webapi_data_store_update_values } 

<!--DHIS2-SECTION-ID:webapi_data_store_update_values-->

Pour mettre à jour une clé qui existe dans un espace de noms :

    PUT /api/33/dataStore/<namespace>/<key>

Exemple de requête curl pour mettre à jour, en présumant que la charge JSON est valide :

```bash
curl "https://play.dhis2.org/demo/api/33/dataStore/foo/key_1" -X PUT -d "[1, 2, 3]"
  -H "Content-Type: application/json" -u admin:district
```

Exemple de réponse : 

```json
{
  "httpStatus": "OK",
  "httpStatusCode": 200,
  "status": "OK",
  "message": "Key 'key_1' updated."
}
```

### Touches de suppression { #webapi_data_store_delete_keys } 

<!--DHIS2-SECTION-ID:webapi_data_store_delete_keys-->

Pour supprimer une clé existante d'un espace de noms :

    DELETE /api/33/dataStore/<namespace>/<key>

Exemple de requête curl pour la suppression :

```bash
curl "play.dhis2.org/demo/api/33/dataStore/foo/key_1" -X DELETE -u admin:district
```

Exemple de réponse : 

```json
{
  "httpStatus": "OK",
  "httpStatusCode": 200,
  "status": "OK",
  "message": "Key 'key_1' deleted from namespace 'foo'."
}
```

Pour supprimer toutes les clés d'un espace de noms :

    DELETE /api/33/dataStore/<namespace>

Exemple de requête curl pour la suppression :

```bash
curl "play.dhis2.org/demo/api/33/dataStore/foo" -X DELETE -u admin:district
```

Exemple de réponse : 

```json
{
  "httpStatus": "OK",
  "httpStatusCode": 200,
  "status": "OK",
  "message": "Namespace 'foo' deleted."
}
```

### Sharing datastore keys { #webapi_data_store_sharing } 

<!--DHIS2-SECTION-ID:webapi_data_store_sharing-->

Sharing of datastore keys follows the same principle as for other metadata sharing (see
[Sharing](#webapi_sharing)).

To get sharing settings for a specific datastore key:

    GET /api/33/sharing?type=dataStore&id=<uid>

To modify sharing settings for a specific datastore key:

    POST /api/33/sharing?type=dataStore&id=<uid> 

avec la requête suivante:

```json
{
  "object": {
    "publicAccess": "rw------",
    "externalAccess": false,
    "user": {},
    "userAccesses": [],
    "userGroupAccesses": [
      {
        "id": "hj0nnsVsPLU",
        "access": "rw------"
      },
      {
        "id": "qMjBflJMOfB",
        "access": "r-------"
      }
    ]
  }
}
```

## Magasin de données de l'utilisateur { #webapi_user_data_store } 

<!--DHIS2-SECTION-ID:webapi_user_data_store-->

Outre le *magasin de données* qui est partagé par tous les utilisateurs du 
système, un magasin de données basé sur l'utilisateur est également disponible. Les données stockées dans le 
*magasin de données de l'utilisateur* sont associées à des utilisateurs individuels, afin que chaque utilisateur 
puisse avoir des données différentes dans le même espace de noms et la même combinaison de touches. Tous 
les appels au *magasin de données de l'utilisateur* seront associés à l'utilisateur 
connecté. Cela signifie que l'on ne peut voir, modifier, supprimer et ajouter que les valeurs 
associées à l'utilisateur connecté.

    /api/33/userDataStore

### Structure du magasin de données de l'utilisateur { #webapi_user_data_store_structure } 

<!--DHIS2-SECTION-ID:webapi_user_data_store_structure-->

Le *magasin de données de l'utilisateur* se compose d'un utilisateur, d'un espace de noms, de clés et de valeurs
associées. La combinaison d'un utilisateur, d'un espace de noms et d'une clé est unique.

<table>
<caption>User data store structure</caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Item</th>
<th>Description</th>
<th>Data Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>User</td>
<td>The user this data is associated with</td>
<td>String</td>
</tr>
<tr class="even">
<td>Namespace</td>
<td>The namespace the key belongs to</td>
<td>String</td>
</tr>
<tr class="odd">
<td>Key</td>
<td>The key a value is stored on</td>
<td>String</td>
</tr>
<tr class="even">
<td>Value</td>
<td>The value stored</td>
<td>JSON</td>
</tr>
<tr class="odd">
<td>Encrypted</td>
<td>Indicates whether the value should be encrypted</td>
<td>Boolean</td>
</tr>
</tbody>
</table>

### Obtenir des espaces de noms { #webapi_user_data_store_get_namespaces } 

<!--DHIS2-SECTION-ID:webapi_user_data_store_get_namespaces-->

Renvoie un tableau de tous les espaces de noms existants

    GET /api/33/userDataStore

Exemple
    requête:

```bash
curl -H "Content-Type: application/json" -u admin:district "play.dhis2.org/api/33/userDataStore"
```

```json
[
  "foo",
  "bar"
]
```

### Obtenir des clés { #webapi_user_data_store_get_keys } 

<!--DHIS2-SECTION-ID:webapi_user_data_store_get_keys-->

Renvoie un tableau de toutes les clés existantes dans un espace de noms donné

    GET /api/userDataStore/<namespace>

Exemple de requête:

```bash
curl -H "Content-Type: application/json" -u admin:district "play.dhis2.org/api/33/userDataStore/foo"
```

```json
[
  "key_1",
  "key_2"
]
```

### Obtenir des valeurs { #webapi_user_data_store_get_values } 

<!--DHIS2-SECTION-ID:webapi_user_data_store_get_values-->

Renvoie la valeur d'un espace de noms et d'une clé donnés

    GET /api/33/userDataStore/<namespace>/<key>

Exemple de requête:

```bash
curl -H "Content-Type: application/json" -u admin:district "play.dhis2.org/api/33/userDataStore/foo/bar"
```

```json
{
  "some": "value"
}
```

### Créer une valeur { #webapi_user_data_store_create_values } 

<!--DHIS2-SECTION-ID:webapi_user_data_store_create_values-->

Ajoute une nouvelle valeur à une clé donnée dans un espace de noms donné.

    POST /api/33/userDataStore/<namespace>/<key>

Exemple de requête:

```bash
curl -X POST -H "Content-Type: application/json" -u admin:district -d "['some value']"
  "play.dhis2.org/api/33/userDataStore/foo/bar"
```

```json
{
  "httpStatus": "Created",
  "httpStatusCode": 201,
  "status": "OK",
  "message": "Key 'bar' in namespace 'foo' created."
}
```

Si vous souhaitez que la valeur soit cryptée (par exemple, les informations d'identification de l'utilisateur
et autres), vous pouvez ajouter une requête à l'url comme ceci :

    GET /api/33/userDataStore/<namespace>/<key>?encrypt=true

### Mettre à jour les valeurs  { #webapi_user_data_store_update_values } 

<!--DHIS2-SECTION-ID:webapi_user_data_store_update_values-->

Met à jour une valeur existante

    PUT /api/33/userDataStore/<namespace>/<key>

Exemple de requête:

```bash
curl -X PUT -H "Content-Type: application/json" -u admin:district -d "['new value']"
  "play.dhis2.org/api/33/userDataStore/foo/bar"
```

```json
{
  "httpStatus":"Created",
  "httpStatusCode":201,
  "status":"OK",
  "message":"Key 'bar' in namespace 'foo' updated."
}
```

### Clé de suppression { #webapi_user_data_store_delete_key } 

<!--DHIS2-SECTION-ID:webapi_user_data_store_delete_key-->

Supprimer une clé

    DELETE /api/33/userDataStore/<namespace>/<key>

Exemple de requête:

```bash
curl -X DELETE -u admin:district "play.dhis2.org/api/33/userDataStore/foo/bar"
```

```json
{
  "httpStatus":"OK",
  "httpStatusCode":200,
  "status":"OK",
  "message":"Key 'bar' deleted from the namespace 'foo."
}
```

### Supprimer un espace de noms { #webapi_user_data_store_delete_namespace } 

<!--DHIS2-SECTION-ID:webapi_user_data_store_delete_namespace-->

Supprimer toutes les clés de l'espace de noms donné

    DELETE /api/33/userDataStore/<namespace>

Exemple de requête:

```bash
curl -X DELETE -u admin:district "play.dhis2.org/api/33/userDataStore/foo"
```

```json
{
  "httpStatus":"OK",
  "httpStatusCode":200,
  "status":"OK",
  "message":"All keys from namespace 'foo' deleted."
}
```

## Les prédicteurs { #webapi_predictors } 

<!--DHIS2-SECTION-ID:webapi_predictors-->

Un prédicteur permet de générer des valeurs de données sur la base d'une expression.
Il peut être utilisé, par exemple, pour générer des cibles, des seuils ou des estimations de valeurs.

Pour récupérer les prédicteurs, vous pouvez effectuer une requête GET à la ressource des prédicteurs comme suit :

    /api/predictors

### Création d'un prédicteur { #webapi_create_predictor } 

<!--DHIS2-SECTION-ID:webapi_create_predictor-->

Vous pouvez créer un prédicteur à l'aide d'une requête POST à la ressource des prédicteurs :

    POST /api/predictors

Voici un exemple de charge :

```json
{
  "id": "AG10KUJCrRk",
  "name": "Malaria Outbreak Threshold Predictor",
  "shortName": "Malaria Outbreak Predictor",
  "description": "Computes the threshold for potential malaria outbreaks based on the mean plus 1.5x the std dev",
  "output": {
    "id": "nXJJZNVAy0Y"
  },
  "generator": {
    "expression": "AVG(#{r6nrJANOqMw})+1.5*STDDEV(#{r6nrJANOqMw})",
    "description": "Maximum normal malaria case count",
    "missingValueStrategy": "NEVER_SKIP",
    "slidingWindow": false
  },
  "periodType": "Monthly",
  "sequentialSampleCount": 4,
  "sequentialSkipCount": 1,
  "annualSampleCount": 3,
  "organisationUnitLevels": [4]
}
```

L'élément de sortie fait référence à l'identifiant de l'élément de données pour lequel des valeurs de données prédites doivent être sauvegardées.
L'élément générateur fait référence à l'expression qui sera utilisée pour calculer les valeurs prédites.

### Expressions du prédicteur { #webapi_predictor_expressions } 

<!--DHIS2-SECTION-ID:webapi_predictor_expressions-->

Un prédicteur possède toujours une expression génératrice qui décrit le mode de calcul de la valeur prédite. Le prédicteur peut également avoir une expression permettant de tester la fonction de saut, laquelle expression renvoie une valeur booléenne. Lorsque l'expression de test de saut est présente, elle est évaluée dans chacune des périodes échantillonnées pour déterminer si les valeurs de cette période doivent être ignorées.

Les variables suivantes peuvent être utilisées dans une expression génératrice ou dans une expression de test de saut :

| Variable    | Objet     | Description |
| ----------- | ---------- | ----------- |
| #{\<dataelement-id>} | Élément de données agrégées | Fait référence à la valeur totale d'un élément de données agrégé pour toutes les combinaisons d'options de catégorie. |
| #{\<dataelement-id>.\<categoryoptcombo-id> | Opérande de l'élément de données | Fait référence à une combinaison entre un élément de données agrégé et une combinaison d'options de catégorie. |
| D{\<program-id>.\<dataelement-id>} | Élément de données de programme | Fait référence à la valeur d'un élément de données Tracker au sein d'un programme. |
| A{\<program-id>.\<attribute-id>} | Attribut d'entité suivie d'un programme | Fait référence à la valeur d'un attribut d'entité suivie au sein d'un programme. |
| I{\<program-indicator-id>} | Indicateur de programme | Fait référence à la valeur d'un indicateur de programme. |
| R{\<dataset-id>.\<metric>} | Taux de déclaration | Fait référence à une mesure de taux de déclaration. La mesure peut être REPORTING_RATE (taux de déclaration), REPORTING_RATE_ON_TIME (taux de déclarations à temps), ACTUAL_REPORTS (rapports envoyés), ACTUAL_REPORTS_ON_TIME (rapports envoyés à temps), EXPECTED_REPORTS (rapports attendus). |
| C{\<constant-id>} | Constante | Fait référence à une valeur constante. |
| OUG{\<orgunitgroup-id>} | Groupe d'unités d'organisation | Fait référence au nombre d'unités d'organisation présentes dans un groupe d'unités d'organisation. |
| [days] | Nombre de jours | Le nombre de jours dans la période actuelle. |

### Génération de valeurs prédites { #webapi_generating_predicted_values } 

<!--DHIS2-SECTION-ID:webapi_generating_predicted_values-->

Pour exécuter tous les prédicteurs (générer des valeurs prédites), vous pouvez effectuer une requête POST à la ressource d'exécution :

    POST /api/predictors/run

Pour exécuter un seul prédicteur, vous pouvez envoyer une requête POST à la ressource d'exécution et préciser le prédicteur :

    POST /api/predictors/AG10KUJCrRk/run

## Éléments de données min-max { #webapi_min_max_data_elements } 

<!--DHIS2-SECTION-ID:webapi_min_max_data_elements-->

La ressource éléments de données min-max vous permet de définir des plages de valeurs minimales et maximales 
pour les éléments de données. Elle est unique en raison de la combinaison de 
l'unité d'organisation, de l'élément de données et de l'option de catégorie.

    /api/minMaxDataElements

<table>
<caption>Min-max data element data structure</caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Item</th>
<th>Description</th>
<th>Data type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>source</td>
<td>Organisation unit identifier</td>
<td>String</td>
</tr>
<tr class="even">
<td>dataElement</td>
<td>Data element identifier</td>
<td>String</td>
</tr>
<tr class="odd">
<td>optionCombo</td>
<td>Data element category option combo identifier</td>
<td>String</td>
</tr>
<tr class="even">
<td>min</td>
<td>Minimum value</td>
<td>Integer</td>
</tr>
<tr class="odd">
<td>max</td>
<td>Maximum value</td>
<td>Integer</td>
</tr>
<tr class="even">
<td>generated</td>
<td>Indicates whether this object is generated by the system (and not set manually).</td>
<td>Boolean</td>
</tr>
</tbody>
</table>

Vous pouvez obtenir une liste de tous les éléments de données min-max à partir de la 
ressource suivante :

    GET /api/minMaxDataElements.json

Vous pouvez filtrer la réponse comme suit :

    GET /api/minMaxDataElements.json?filter=dataElement.id:eq:UOlfIjgN8X6

    GET /api/minMaxDataElements.json?filter=dataElement.id:in:[UOlfIjgN8X6,xc8gmAKfO95]

Le paramètre de filtrage des éléments de données min-max prend en charge deux opérateurs :
eq et in. Vous pouvez également utiliser le paramètre de requête `fields`.

    GET /api/minMaxDataElements.json?fields=:all,dataElement[id,name]

### Ajouter/mettre à jour l'élément de données min-max { #webapi_add_update_min_max_data_element } 

<!--DHIS2-SECTION-ID:webapi_add_update_min_max_data_element-->

Pour ajouter un nouvel élément de données min-max, utilisez la requête POST à :

    POST /api/minMaxDataElements.json

Le format de contenu JSON se présente comme suit :

```json
{
  "min": 1,
  "generated": false,
  "max": 100,
  "dataElement": {
    "id": "UOlfIjgN8X6"
   },
  "source": {
    "id": "DiszpKrYNg8"
  },
  "optionCombo": {
    "id": "psbwp3CQEhs"
  }
}
```

Si la combinaison de l'élément de données, de l'unité d'organisation et de la catégorie
existe, la valeur min-max sera mise à jour.

### Supprimer l'élément de données min-max { #webapi_delete_min_max_data_element } 

<!--DHIS2-SECTION-ID:webapi_delete_min_max_data_element-->

Pour supprimer un élément de données min-max, envoyez une requête avec la méthode DELETE :

    DELETE /api/minMaxDataElements.json

Le contenu JSON est dans le même format que ci-dessus :

```json
{
  "min": 1,
  "generated": false,
  "max": 100,
  "dataElement": {
    "id": "UOlfIjgN8X6"
   },
  "source": {
    "id": "DiszpKrYNg8"
  },
  "optionCombo": {
    "id": "psbwp3CQEhs"
  }
}
```

## Exceptions de verrouillage { #webapi_lock_exceptions } 

<!--DHIS2-SECTION-ID:webapi_lock_exceptions-->

La ressource exceptions de blocage vous permet d'ouvrir des ensembles de données verrouillés 
pour la saisie de données pour un ensemble de données, une période et une unité d'organisation 
spécifiques. Vous pouvez lire les exceptions de verrouillage à partir de la ressource suivante :

    /api/lockExceptions

Pour créer une nouvelle exception de verrouillage, vous pouvez utiliser une requête POST et spécifier
l'ensemble de données, la période et l'unité d'organisation :

    POST /api/lockExceptions?ds=BfMAe6Itzgt&pe=201709&ou=DiszpKrYNg8

Pour supprimer une exception de verrouillage, vous pouvez utiliser une syntaxe de demande similaire avec une
 requête DELETE :

    DELETE /api/lockExceptions?ds=BfMAe6Itzgt&pe=201709&ou=DiszpKrYNg8

## Jetons { #webapi_tokens } 

<!--DHIS2-SECTION-ID:webapi_tokens-->

La ressource *tokens* fournit des jetons d'accès à différents services.

### Compte Google Service { #webapi_tokens_google_service_account } 

<!--DHIS2-SECTION-ID:webapi_tokens_google_service_account-->

Vous pouvez récupérer un jeton d'accès OAuth 2.0 du compte de service Google à l'aide 
d'une requête GET vers la ressource suivante.

    GET /api/tokens/google

Le jeton est valable pendant un certain temps, après quoi 
un autre jeton doit être demandé à cette ressource. La réponse 
contient un en-tête de contrôle de cache qui correspond à l'expiration du jeton. La 
réponse contiendra les propriétés suivantes au format JSON.

<table>
<caption>Token response</caption>
<colgroup>
<col style="width: 40%" />
<col style="width: 59%" />
</colgroup>
<thead>
<tr class="header">
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>access_token</td>
<td>The OAuth 2.0 access token to be used when authentication against Google services.</td>
</tr>
<tr class="even">
<td>expires_in</td>
<td>The number of seconds until the access token expires, typically 3600 seconds (1 hour).</td>
</tr>
<tr class="odd">
<td>client_id</td>
<td>The Google service account client id.</td>
</tr>
</tbody>
</table>

This assumes that a Google service account has been set up and
configured for DHIS2. Please consult the installation guide for more
info.

## Crochets pour table analytiques { #webapi_analytics_table_hooks }

<!--DHIS2-SECTION-ID:webapi_analytics_table_hooks-->

Les crochets de tableaux analytiques fournissent un mécanisme permettant d'appeler des scripts SQL au cours des différentes phases du processus de génération des tableaux analytiques. Ceci permet de personnaliser les données dans les tableaux de ressources et d'analyse, par exemple pour obtenir une logique spécifique pour les calculs et l'agrégation. Vous pouvez manipuler les crochets de tables analytiques à l'aide du point d'extrémité d'API suivant :

    /api/analyticsTableHooks

L'API des crochets de tableaux analytiques prend en charge les opérations CRUD HTTP standard pour créer (POST), mettre à jour (PUT), récupérer (GET) et supprimer (DELETE) des entités.

### Champs de crochets { #webapi_analytics_table_hook_fields } 

<!--DHIS2-SECTION-ID:webapi_analytics_table_hook_fields-->

Les crochets de tableaux analytiques comportent les champs suivants :

<table style="width:100%;">
<caption>Analytics table hook fields</caption>
<colgroup>
<col style="width: 22%" />
<col style="width: 30%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th>Field</th>
<th>Options</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>name</td>
<td>Text</td>
<td>Name of the hook.</td>
</tr>
<tr class="even">
<td>phase</td>
<td>RESOURCE_TABLE_POPULATED, ANALYTICS_TABLE_POPULATED</td>
<td>The phase for when the SQL script should be invoked.</td>
</tr>
<tr class="odd">
<td>resourceTableType</td>
<td><p>See column &quot;Table type&quot; in table &quot;Phases, table types and temporary tables&quot; below</p></td>
<td>The type of resource table for which to invoke the SQL script. Applies only for hooks defined with the RESOURCE_TABLE_POPULATED phase.</td>
</tr>
<tr class="even">
<td>analyticsTableType</td>
<td>See column &quot;Table type&quot; in table &quot;Phases, table types and temporary tables&quot; below</td>
<td>The type of analytics table for which to invoke the SQL script. Applies only for hooks defined with the ANALYTICS_TABLE_POPULATED phase.</td>
</tr>
<tr class="odd">
<td>sql</td>
<td>Text</td>
<td>The SQL script to invoke.</td>
</tr>
</tbody>
</table>

The *ANALYTICS_TABLE_POPULATED* phase takes place after the analytics
table has been populated, but before indexes have been created and the
temp table has been swapped with the main table. As a result, the SQL
script should refer to the analytics temp table, e.g. *analytics_temp*,
*analytics_completeness_temp*.

Ceci s'applique également à la phase *RESOURCE_TABLE_POPULATED*, qui a lieu après le remplissage de la table de ressources, mais avant la création des index et le remplacement du tableau temporaire par le tableau principal. Le script SQL va désormais faire référence au tableau de ressources temporaire, par exemple *_orgunitstructure_temp*, *_categorystructure_temp*.

Vous ne devez définir qu'un seul champ entre *resourceTableType* et *analyticsTableType*. Vous le ferez en fonction de la *phase* définie.

Vous pouvez faire référence au tableau temporaire de la base de données qui correspond uniquement au type du tableau de crochets spécifié (les autres tableaux temporaires ne seront pas disponibles). Par exemple, si vous spécifiez *ORG_UNIT_STRUCTURE* comme type de tableau de ressources, vous ne pourrez faire référence qu'au tableau temporaire de la base de données *_orgunitstructure_temp*.

Le tableau suivant présente les combinaisons valables de phases, de types de tableaux et de tableaux temporaire.

<table>
<caption>Phases, table types and temporary tables</caption>
<colgroup>
<col style="width: 27%" />
<col style="width: 39%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Phase</th>
<th>Table type</th>
<th>Temporary table</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td rowspan="12">RESOURCE_TABLE_POPULATED</td>
<td>ORG_UNIT_STRUCTURE</td>
<td>_orgunitstructure_temp</td>
</tr>
<tr class="even">
<td>DATA_SET_ORG_UNIT_CATEGORY</td>
<td>_datasetorgunitcategory_temp</td>
</tr>
<tr class="odd">
<td>CATEGORY_OPTION_COMBO_NAME</td>
<td>_categoryoptioncomboname_temp</td>
</tr>
<tr class="even">
<td>DATA_ELEMENT_GROUP_SET_STRUCTURE</td>
<td>_dataelementgroupsetstructure_temp</td>
</tr>
<tr class="odd">
<td>INDICATOR_GROUP_SET_STRUCTURE</td>
<td>_indicatorgroupsetstructure_temp</td>
</tr>
<tr class="even">
<td>ORG_UNIT_GROUP_SET_STRUCTURE</td>
<td>_organisationunitgroupsetstructure_temp</td>
</tr>
<tr class="odd">
<td>CATEGORY_STRUCTURE</td>
<td>_categorystructure_temp</td>
</tr>
<tr class="even">
<td>DATA_ELEMENT_STRUCTURE</td>
<td>_dataelementstructure_temp</td>
</tr>
<tr class="odd">
<td>PERIOD_STRUCTURE</td>
<td>_periodstructure_temp</td>
</tr>
<tr class="even">
<td>DATE_PERIOD_STRUCTURE</td>
<td>_dateperiodstructure_temp</td>
</tr>
<tr class="odd">
<td>DATA_ELEMENT_CATEGORY_OPTION_COMBO</td>
<td>_dataelementcategoryoptioncombo_temp</td>
</tr>
<tr class="even">
<td>DATA_APPROVAL_MIN_LEVEL</td>
<td>_dataapprovalminlevel_temp</td>
</tr>
<tr class="odd">
<td rowspan="7">ANALYTICS_TABLE_POPULATED</td>
<td>DATA_VALUE</td>
<td>analytics_temp</td>
</tr>
<tr class="even">
<td>COMPLETENESS</td>
<td>analytics_completeness_temp</td>
</tr>
<tr class="odd">
<td>COMPLETENESS_TARGET</td>
<td>analytics_completenesstarget_temp</td>
</tr>
<tr class="even">
<td>ORG_UNIT_TARGET</td>
<td>analytics_orgunittarget_temp</td>
</tr>
<tr class="odd">
<td>EVENT</td>
<td>analytics_event_temp_&lt;program-uid&gt;</td>
</tr>
<tr class="even">
<td>ENROLLMENT</td>
<td>analytics_enrollment_temp_&lt;program-uid&gt;</td>
</tr>
<tr class="odd">
<td>VALIDATION_RESULT</td>
<td>analytics_validationresult_temp</td>
</tr>
</tbody>
</table>

### Création de crochets { #webapi_create_analytics_table_hook } 

<!--DHIS2-SECTION-ID:webapi_create_analytics_table_hook-->

To create a hook which should run after the resource tables have been
populated you can do a *POST* request like this using *JSON* format:

```bash
curl -d @hooks.json "localhost/api/analyticsTableHooks" -H "Content-Type:application/json" -u admin:district
```

```json
{
  "name": "Update 'Area' in org unit group set resource table",
  "phase": "RESOURCE_TABLE_POPULATED",
  "resourceTableType": "ORG_UNIT_GROUP_SET_STRUCTURE",
  "sql": "update _organisationunitgroupsetstructure_temp set \"uIuxlbV1vRT\" = 'b0EsAxm8Nge'"
}
```

To create a hook which should run after the data value analytics table
has been populated you can do a *POST* request like this using *JSON*
format:

```json
{
  "name": "Update 'Currently on treatment' data in analytics table",
  "phase": "ANALYTICS_TABLE_POPULATED",
  "analyticsTableType": "DATA_VALUE",
  "sql": "update analytics_temp set monthly = '200212' where \"monthly\" in ('200210', '200211')"
}
```

## Référentiel de métadonnées { #webapi_metadata_repository } 

<!--DHIS2-SECTION-ID:webapi_metadata_repository-->

DHIS2 fournit un référentiel de métadonnées qui contient des packages de métadonnées avec différents contenus. Un package de métadonnées est un document JSON compatible avec DHIS2 qui décrit un ensemble d'objets de métadonnées.

Pour récupérer un index des packages de métadonnées disponibles, vous pouvez envoyer une requête GET à la ressource *metadataRepo* :

    GET /api/synchronization/metadataRepo

L'entrée d'un paquet de métadonnées contient des informations sur le package et une URL vers le package concerné. Un index pourrait ressembler à ceci :

```json
{
  "packages": [
    {
      "id": "sierre-leone-demo",
      "name": "Sierra Leone demo",
      "description": "Sierra Leone demo database",
      "version": "0.1",
      "href": "https://dhis2.org/metadata-repo/221/sierra-leone-demo/metadata.json"
    },
    {
      "id": "trainingland-org-units",
      "name": "Trainingland organisation units",
      "description": "Trainingland organisation units with four levels",
      "version": "0.1",
      "href": "https://dhis2.org/metadata-repo/221/trainingland-org-units/metadata.json"
    }
  ]
}
```

Un client peut suivre les URL et installer un package de métadonnées via une requête POST de type de contenu *text/plain* et avec le package de métadonnées utilisé comme charge de la ressource *metadataPull* :

    POST /api/synchronization/metadataPull

Voici un exemple de commande curl :

```bash
curl "localhost:8080/api/synchronization/metadataPull" -X POST
  -d "https://dhis2.org/metadata-repo/221/trainingland-org-units/metadata.json"
  -H "Content-Type:text/plain" -u admin:district
```

## Icônes { #webapi_icons } 

<!--DHIS2-SECTION-ID:webapi_icons-->

DHIS2 includes a collection of icons that can be used to give visual
context to metadata. These icons can be accessed through the icons
resource.

    GET /api/icons

This endpoint returns a list of information about the available icons.
Each entry contains information about the icon, and a reference to the
actual icon.

```json
{
  key: "mosquito_outline",
  description: "Mosquito outline",
  keywords: [
    "malaria",
    "mosquito",
    "dengue"
  ],
  href: "<dhis server>/api/icons/mosquito_outline/icon.svg"
}
```

The keywords can be used to filter which icons to return. Passing a list
of keywords with the request will only return icons that match all the
keywords:

    GET /api/icons?keywords=shape,small

A list of all unique keywords can be found at the keywords resource:

    GET /api/icons/keywords
