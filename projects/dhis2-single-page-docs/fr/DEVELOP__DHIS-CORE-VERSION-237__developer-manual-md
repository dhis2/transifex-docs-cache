---
revision_date: '2023-01-13'
tags:
- DHIS core version 2.37
- Développement
template: single.html
---

# Aperçu { #webapi } 

L'API Web est un composant qui permet aux systèmes externes d'accéder 
aux données stockées dans une instance DHIS2 et de les manipuler. Plus 
précisément, elle fournit une interface programmatique à un large éventail de 
données exposées et de méthodes de service pour des applications telles que des clients 
logiciels tiers, des portails web et des modules DHIS2 internes.

## Introduction { #webapi_introduction } 

The Web API adheres to many of the principles behind the REST
architectural style. To mention some few and important ones:

1.  Les éléments fondamentaux sont appelés *ressources*. Une 
    ressource peut être tout ce qui est exposé sur le web, d'un document à un 
    processus d'entreprise - tout ce avec quoi un client peut vouloir interagir.
    Les aspects informatifs d'une ressource peuvent être récupérés ou échangés 
    par le biais de *représentations* de la ressource. Une représentation est une vue de 
    resource's state at any given time. For instance, the *reportTable*
    resource in DHIS2 represents a tabular report of aggregated data for
    un certain ensemble de paramètres. Cette ressource peut être récupérée dans 
    variety of representation formats including HTML, PDF, and MS Excel.

2.  Toutes les ressources peuvent être identifiées de manière unique par un *URI* (également 
    appelé *URL*). Toutes les ressources ont une représentation par défaut. Vous pouvez 
    indiquer que vous êtes intéressé par une représentation spécifique en 
    fournissant un en-tête HTTP *Accept*, une extension de fichier ou un paramètre de requête *format*. 
    query parameter. So in order to retrieve the PDF representation of a
    report table you can supply an *Accept: application/pdf* header or
    append *.pdf* or *?format=pdf* to your request URL.

3.  Les interactions avec l'API nécessitent l'utilisation correcte des *méthodes* ou 
    *verbes* HTTP. Cela implique que pour une ressource, vous devez émettre une requête *GET* 
    lorsque vous souhaitez la récupérer, une requête *POST* lorsque vous souhaitez 
    en créer une, une requête *PUT* lorsque vous souhaitez la mettre à jour et une requête *DELETE* lorsque 
    you want to remove it. So if you want to retrieve the default
    representation of a report table you can send a GET request to e.g.
    */reportTable/iu8j/hYgF6t*, where the last part is the report table
    identifier.

4.  Resource representations are *linkable*, meaning that
    representations advertise other resources which are relevant to the
    current one by embedding links into itself (please be aware that you
    need to request *href* in your field filter to have this working.
    This feature greatly improves the usability and robustness of the
    API as we will see later. For instance, you can easily navigate to
    the indicators which are associated with a report table from the
    *reportTable* resource through the embedded links using your
    preferred representation format.

While all of this might sound complicated, the Web API is actually very
simple to use. We will proceed with a few practical examples in a
minute.

## Authentification { #webapi_authentication } 

L'API Web DHIS2 prend en charge trois protocoles d'authentification : 

- [L'authentification de base](#webapi_basic_authentication)
- [Les jetons d'accès personnels (PAT)](#webapi_pat_authentication)
- [OAuth 2](#webapi_oauth2)

Vous pouvez vérifier et obtenir des informations sur l'utilisateur actuellement authentifié 
en envoyant une requête GET à l'URL suivante :

    /api/33/me

Et plus d'informations sur les autorisations (et si un utilisateur a une certaine 
autorisation) en utilisant les points d'extrémité :

    /api/33/me/authorities
    /api/33/me/authorities/ALL

## L'authentification de base { #webapi_basic_authentication } 

L'API Web DHIS2 prend en charge *l'authentification de base*. L'authentification de base 
est une technique permettant aux clients d'envoyer des informations d'identification par HTTP à un 
serveur web. Techniquement parlant, le nom d'utilisateur est suivi de deux points et 
le mot de passe, encodé en Base64, est préfixé par Basic et fourni en tant que valeur 
de l'en-tête HTTP *Autorisation*. De manière plus formelle, il s'agit de : 

    Autorisation : Basic base64encode( nom d'utilisateur:mot de passe)

La plupart des environnements de développement compatibles avec les réseaux prennent en charge 
l'authentification de base, comme *Apache HttpClient* et *Spring RestTemplate*. 
Il est important de noter que ce schéma d'authentification n'offre aucune sécurité 
puisque le nom d'utilisateur et le mot de passe sont envoyés en texte clair et peuvent être facilement 
observés par un pirate. L'utilisation de Basic n'est recommandée que si le serveur 
utilise SSL/TLS (HTTPS) pour crypter la communication avec les clients. Considérez qu'il 
s'agit d'une exigence impérative pour assurer des interactions sécurisées avec l'API 
Web.

## Authentification à deux facteurs { #webapi_2fa } 

DHIS2 prend en charge l'authentification à deux facteurs. Cette fonction peut être activée pour chaque utilisateur. 
Lorsque cette option est activée, les utilisateurs sont invités à saisir un code 2FA lorsqu'ils se connectent. Pour 
en savoir plus sur l'authentification à deux facteurs, cliquez ici (https : www.google.com/landing/2step/).

## Jeton d'accès personnel { #webapi_pat_authentication }
Les jetons d'accès personnels (PAT) sont une alternative à l'utilisation de mots de passe lors 
de l'authentification au système DHIS2 lorsque l'on utilise l'API.

Les jetons d'accès personnel peuvent être une alternative plus sécurisée à l'authentification 
de base HTTP et devraient être votre choix privilégié lorsque vous créez une nouvelle application, un script, etc.

L'authentification de base HTTP est considérée comme non sécurisée car, entre autres, 
elle envoie votre nom d'utilisateur et votre mot de passe de façon indiscrète. Il est possible qu'elle soit abandonnée dans les versions 
futures de DHIS2 ou qu'elle devienne facultative, ce qui signifie que l'authentification de base devra 
être explicitement activée dans la configuration.

#### Problèmes de sécurité majeurs ! { #important-security-concerns } 

Vos jetons hériteront automatiquement de toutes les permissions et autorisations dont dispose votre utilisateur. Il est donc extrêmement important de limiter l'accès que vous accordez à votre jeton en fonction de l'utilisation que vous comptez en faire, voir **Configurer votre jeton**.

**Si vous souhaitez que le jeton n'ait accès qu'à une partie restreinte et spécifique du serveur, il est plutôt recommandé de créer un nouvel utilisateur spécial auquel vous n'attribuerez que les rôles et autorisations auxquels vous souhaitez qu'il ait accès.**


### Créer un jeton { #creating-a-token } 
Pour créer un nouveau PAT, vous avez deux possibilités :
* A. Créez un jeton dans l'interface utilisateur de la page de profil de votre compte.
* B. Create a token via the API

### A. Création d'un jeton sur la page du compte { #a-creating-a-token-on-the-accounts-page } 
Log in with your username and password, go to your profile page
(Click top right corner, and chose "Edit profile" from the dropdown).
On your user profile page, choose "Manage personal access tokens" from the
left side menu.
You should now be on the "Manage personal access tokens" page and see the
text: "You don't have any active personal access tokens".
Click "Generate new token" to make a new token.
A "Generate new token" popup will be shown and present you with two choices:

#### 1. Contexte serveur/script: { #1-serverscript-context } 
_"Ce type est utilisé pour les intégrations et les scripts qui ne seront pas accessibles par un navigateur"._

Si vous prévoyez d'utiliser le jeton dans une application, un script ou autre, ce 
type de jeton devrait être votre choix.

#### 2. Contexte navigateur: { #2-browser-context } 
_"Ce type d'application est utilisé pour les applications, telles que les portails publics, auxquelles on accède à l'aide d'un navigateur web"._

Si vous devez créer un lien vers DHIS2 sur une page web, ou par exemple l'intégrer dans une iframe, 
c'est probablement le type de jeton qu'il vous faut.


### Configuration de votre jeton { #configuring-your-token } 

Après avoir choisi le type de jeton que vous désirez, vous pouvez configurer différentes contraintes d'accès à 
votre jeton. Par contrainte, nous entendons la manière de limiter et de restreindre l'utilisation de votre jeton. 
Cela peut être d'une importance cruciale si vous envisagez d'utiliser le jeton dans un environnement public, 
par exemple sur un tableau de bord public d'un autre site, intégré dans une iframe. 
Étant donné que les jetons ont toujours les mêmes accès/autorisations que ceux dont dispose actuellement votre utilisateur, il convient d'être particulièrement 
vigilant si vous avez l'intention de les utiliser dans un environnement que vous ne contrôlez pas à 100 %.

**NB** : Si quelqu'un d'autre met la main sur votre jeton, il peut faire tout ce que votre utilisateur est capable de faire. 
Il n'est pas possible de faire la distinction entre les actions effectuées à l'aide du jeton et les autres actions
effectuées par votre utilisateur.

**Important** : Il est fortement conseillé de créer un utilisateur distinct et unique ayant uniquement les rôles/autorisations 
si vous envisagez d'utiliser les jetons PAT dans un environnement non sécurisé et/ou public,
par exemple, sur un PC ou un serveur que vous ne contrôlez pas à 100 %, ou « intégré » dans une page web sur un autre serveur.

#### Les différents types de contraintes sont les suivants: { #the-different-constraint-types-are-as-follows } 
* Temps d'expiration
* Adresses UP autorisées
* Méthodes HTTP autorisées
* Référents HTTP autorisés

##### Temps d'expiration { #expiry-time } 
La durée d'expiration définit simplement la durée pendant laquelle vous souhaitez que votre jeton soit utilisable, le délai par défaut étant de 30 
jours. Passé ce délai, le jeton renverra simplement un message 401 (non autorisé).
Vous pouvez définir le délai d'expiration que vous souhaitez, mais il est fortement conseillé de définir un délai d'expiration 
raisonnable pour votre cas d'utilisation.

#### Adresses IP autorisées { #allowed-ip-addresses } 
Il s'agit d'une liste d'adresses IP séparées par des virgules, à partir desquelles vous souhaitez limiter la provenance des requêtes de jetons.

 **Important** La validation de l'adresse IP repose sur l'en-tête X-Transféré-À, qui peut être usurpé. 
Pour des raisons de sécurité, assurez-vous qu'un équilibreur de charge ou un proxy inverse écrase cet en-tête.

#### Méthodes HTTP autorisées { #allowed-http-methods } 
Une liste de méthodes HTTP séparées par des virgules que vous souhaitez que votre jeton puisse utiliser.
Si vous n'avez besoin de votre jeton que pour consulter des données, et non pour les modifier ou les supprimer, la sélection de la méthode GET HTTP 
est judicieuse.

#### Références HTTP autorisées { #allowed-http-referrers } 
Le référent HTTP est un en-tête ajouté à la requête lorsque vous cliquez sur un lien, il indique le site/la page 
sur lequel/laquelle vous étiez lorsque vous avez cliqué sur le lien. 
Pour en savoir plus sur l'en-tête du référent HTTP, cliquez sur le lien suivant : https://en.wikipedia.org/wiki/HTTP_referer

Cela peut servir à limiter l'utilisation d'un jeton « public » intégré à une autre page sur un autre site. 
S'assurer que l'en-tête du référent correspond au nom d'hôte du site d'où le jeton doit provenir peut
éviter l'utilisation abusive du jeton, par exemple si quelqu'un le publie sur un forum public.

**Important** Ceci n'est pas une fonctionnalité de sécurité. L'en-tête `référence` peut être facilement usurpé. 
Ce paramètre est destiné à dissuader les développeurs tiers non autorisés à se connecter 
aux instances d'accès public.

#### Sauvegarder votre jeton: { #saving-your-token } 
Lorsque vous avez fini de configurer votre jeton, vous pouvez l'enregistrer en cliquant sur le bouton « Générer un nouveau jeton »
en bas à droite de la fenêtre contextuelle.
Le jeton sera alors sauvegardé et une clé secrète sera générée sur le serveur.
La nouvelle clé secrète sera affichée en bas de la liste des jetons PAT sur fond vert,
et le texte « Jeton nouvellement créé ».
La clé du jeton secret ressemble à ceci :
```
d2pat_5xVA12xyUbWNedQxy4ohH77WlxRGVvZZ1151814092
```
**Important**: Cette clé de jeton secrète générée ne sera affichée qu'une seule fois. Il est donc important 
que vous la copiez maintenant et que vous la sauvegardiez en lieu sûr pour une utilisation ultérieure. 
La clé de jeton secrète sera hachée de manière sécurisée sur le serveur, et seul le hachage de cette 
clé sera enregistré dans la base de données ; ceci pour minimiser les risques relatifs à la sécurité s'il arrivait qu'une personne obtienne 
un accès non autorisé à la base de données, de la même manière que les mots de passe sont gérés.

### B. Créer un jeton via l'API { #b-creating-a-token-via-the-api } 

Exemple de création d'un nouveau jeton d'accès personnel avec l'API :

```
POST https://play.dhis2.org/dev/api/apiToken
Content-Type: application/json
Authorization: Basic admin district

{}
```
**NB**: N'oubliez pas le corps JSON vide (`{}`) dans la charge utile ! 

Il renverra une réponse contenant un jeton similaire à celui-ci :
```json
{
  "httpStatus": "Created",
  "httpStatusCode": 201,
  "status": "OK",
  "response": {
     "responseType": "ApiTokenCreationResponse",
     "key": "d2pat_5xVA12xyUbWNedQxy4ohH77WlxRGVvZZ1151814092",
     "uid": "jJYrtIVP7qU",
     "klass": "org.hisp.dhis.security.apikey.ApiToken",
     "errorReports": []
  }
}
```

**Important** : La clé symbolique n'apparaît qu'une seule fois dans cette réponse.
Vous devez la copier et l'enregistrer dans un endroit sûr pour pouvoir l'utiliser ultérieurement !

Le jeton lui-même se compose de trois parties :
1. Préfixe : (`d2pat_`) indique de quel type de jeton il s'agit.
2. Octets aléatoires codés en Base64: (`5xVA12xyUbWNedQxy4ohH77WlxRGVvZZ`)
3. Somme de contrôle CRC32 : (`1151814092`) la partie de la somme de contrôle est complétée par 0 de sorte qu'elle conserve toujours une longueur de dix caractères.


#### Configurez votre token via l'API: { #configure-your-token-via-the-api } 
Pour modifier l'une des contraintes de votre jeton, vous pouvez envoyer la requête API HTTP suivante.

**NB**: Seules les contraintes peuvent être modifiées après la création du jeton ! 

```
PUT https://play.dhis2.org/dev/api/apiToken/jJYrtIVP7qU
Content-Type: application/json
Authorization: Basic admin district
```

```json
{
  "version": 1,
  "type": "PERSONAL_ACCESS_TOKEN",
  "expire": 163465349603200,
  "attributes": [
      {
        "type": "IpAllowedList",
        "allowedIps": ["192.168.0.1"]
      },
      {
        "type": "MethodAllowedList",
        "allowedMethods": ["GET"]
      }
  ]
}
```

### Utiliser votre jeton d'accès personnel { #using-your-personal-access-token } 

Pour envoyer un requête avec votre jeton nouvellement créé, utilisez convenablement l'en-tête 
d'autorisation .
Le format de l'en-tête d'autorisation est le suivant :
```
Autorisation : ApiToken [YOUR_SECRET_API_TOKEN_KEY]
```
**Exemple**:
```
GET https://play.dhis2.org/dev/api/apiToken/jJYrtIVP7qU
Content-Type: application/json
Authorization: ApiToken d2pat_5xVA12xyUbWNedQxy4ohH77WlxRGVvZZ1151814092
```


### Supprimer votre jeton d'accès personnel { #deleting-your-personal-access-token } 
Vous pouvez supprimer vos PAT soit dans l'interface utilisateur de votre page de profil où vous les avez créés,
soit via l'API comme ceci :
```
DELETE https://play.dhis2.org/dev/api/apiToken/jJYrtIVP7qU
Content-Type: application/json
Authorization: ApiToken d2pat_5xVA12xyUbWNedQxy4ohH77WlxRGVvZZ1151814092
```


## OAuth2 { #webapi_oauth2 } 

DHIS2 supporte le protocole d'authentification *OAuth2*. OAuth2 est une norme 
ouverte d'autorisation qui permet aux clients tiers de se 
connecter au nom d'un utilisateur DHIS2 et d'obtenir un *jeton porteur* réutilisable 
pour les demandes ultérieures à l'API Web. DHIS2 ne prend pas en charge les rôles 
OAuth2 à granularité fine, mais fournit aux applications un accès basé sur les rôles 
de l'utilisateur DHIS2.

Chaque client pour lequel vous souhaitez autoriser l'authentification OAuth 2 doit être
enregistré dans DHIS2. Pour ajouter un nouveau client OAuth2, allez dans `Applications > Paramètres > Clients OAuth2`
dans l'interface utilisateur, cliquez sur *Ajouter nouveau* et entrez le nom du client souhaité et les types de subventions.

#### Ajouter un client à l'aide de l'API Web { #adding-a-client-using-the-web-api } 

Un client OAuth2 peut être ajouté via l'API Web. Par exemple, nous pouvons
envoyer une charge utile comme celle-ci :

```json
{
  "name": "OAuth2 Demo Client",
  "cid": "demo",
  "secret": "1e6db50c-0fee-11e5-98d0-3c15c2c6caf6",
  "grantTypes": [
    "password",
    "refresh_token",
    "authorization_code"
  ],
  "redirectUris": [
    "http://www.example.org"
  ]
}
```

La charge utile peut être envoyée avec la commande suivante :

```bash
SERVER="https://play.dhis2.org/dev"
curl -X POST -H "Content-Type: application/json" -d @client.json
  -u admin:district "$SERVER/api/oAuth2Clients"
```

Nous utiliserons ce client comme base pour nos prochains exemples de types de subventions.

#### Mot de passe du type d'octroi { #webapi_oauth2_password } 

Le type d'octroi le plus simple est le type d'octroi *mot de passe*. Ce 
type d'octroi est similaire à l'authentification de base en ce sens qu'il 
exige du client qu'il recueille le nom d'utilisateur et le mot de passe de l'utilisateur. Prenons 
l'exemple de notre serveur de démonstration :

```bash
SERVER="https://play.dhis2.org/dev"
SECRET="1e6db50c-0fee-11e5-98d0-3c15c2c6caf6"

curl -X POST -H "Accept: application/json" -u demo:$SECRET "$SERVER/uaa/oauth/token"
  -d grant_type=password -d username=admin -d password=district
```

Vous obtiendrez une réponse similaire à ceci :

```json
{
  "expires_in": 43175,
  "scope": "ALL",
  "access_token": "07fc551c-806c-41a4-9a8c-10658bd15435",
  "refresh_token": "a4e4de45-4743-481d-9345-2cfe34732fcc",
  "token_type": "bearer"
}
```

Pour l'instant, nous allons nous concentrer sur le `access_token`, qui 
sera utilisé comme jeton d'authentification (porteur). A titre d'exemple, nous allons obtenir 
tous les éléments de données en utilisant notre jeton :

```bash
SERVER="https://play.dhis2.org/dev"
curl -H "Authorization: Bearer 07fc551c-806c-41a4-9a8c-10658bd15435" "$SERVER/api/33/dataElements.json"
```

#### Type d'octroi rafraîchir\_jeton { #webapi_refresh_token } 

En général, les jetons d'accès ont une validité limitée. Vous pouvez jeter un coup d'oeil 
à la propriété `expires_in` ( expire en) de la réponse dans l'exemple précédent 
pour comprendre quand un jeton expire. Pour obtenir un nouveau `access_token` (jeton d'accès), vous 
pouvez faire un autre aller-retour vers le serveur et utiliser `refresh_token` (rafraîchir le jeton) 
qui vous permet d'obtenir un jeton mis à jour sans avoir besoin de demander les 
informations d'identification de l'utilisateur une fois de plus.

```bash
SERVER="https://play.dhis2.org/dev"
SECRET="1e6db50c-0fee-11e5-98d0-3c15c2c6caf6"
REFRESH_TOKEN="a4e4de45-4743-481d-9345-2cfe34732fcc"

curl -X POST -H "Accept: application/json" -u demo:$SECRET "$SERVER/uaa/oauth/token"
  -d "grant_type=refresh_token" -d "refresh_token=$REFRESH_TOKEN"
```

La réponse sera exactement la même que lorsque vous obtenez un jeton au départ.

#### Type de subvention code_d'autorisation { #webapi_authorization_code } 

Le type de subvention « code autorisé » est l'approche recommandée si vous ne souhaitez 
pas stocker les informations d'identification de l'utilisateur en externe. Elle permet au DHIS2 de collecter le 
nom d'utilisateur et le mot de passe directement auprès de l'utilisateur au lieu que le client 
les collecte et s'authentifie ensuite au nom de l'utilisateur. Veuillez noter 
que cette approche utilise la partie `redirectUris` de la charge utile du 
client.

Étape 1 : Visitez l'URL suivante à l'aide d'un navigateur web. Si vous avez plus d'un
URI de redirection, vous pouvez ajouter `&redirect_uri=http://www.example.org` 
à l'URL :

```bash
SERVER="https://play.dhis2.org/dev"
$SERVER/uaa/oauth/authorize?client_id=demo&response_type=code
```

Étape 2 : Une fois que l'utilisateur s'est connecté avec succès et a accepté votre accès client
il sera redirigé vers votre uri de redirection comme suit :

    http://www.example.org/?code=XYZ

Étape 3 : Cette étape est similaire à celle de l'octroi du mot de passe,
en utilisant le code fourni, nous allons maintenant demander un jeton d'accès :

```bash
SERVER="https://play.dhis2.org/dev"
SECRET="1e6db50c-0fee-11e5-98d0-3c15c2c6caf6"

curl -X POST -u demo:$SECRET -H "Accept: application/json" $SERVER/uaa/oauth/token
-d "grant_type=authorization_code" -d "code=XYZ"
```

## Messages d'erreur et d'information { #webapi_error_info_messages } 

L'API Web utilise un format cohérent pour tous les messages d'erreur, d'avertissement et 
d'information :

```json
{
  "httpStatus": "Forbidden",
  "message": "Vous n'avez pas la permission de lire ce type d'objet.",
  "httpStatusCode": 403,
  "status": "ERROR"
}
```

Here we can see from the message that the user tried to access a
resource I did not have access to. It uses the http status code 403, the
http status message *forbidden* and a descriptive message.



Tableau : Propriétés de WebMessage

| Nom | Description |
|---|---|
| Statut http | Message de statut HTTP pour cette réponse, voir RFC 2616 (Section 10) pour plus d'informations. |
| Code de statut http | Code de statut HTTP pour cette réponse, voir RFC 2616 (Section 10) pour plus d'informations. |
| statut | Les valeurs possibles du statut DHIS2 sont *OK* &#124 ; *AVERTISSEMENT* &#124 ; *ERREUR*, où `OK` signifie que tout a réussi, `ERREUR` signifie que l'opération ne s'est pas terminée et `AVERTISSEMENT` signifie que l'opération a partiellement réussi, si le message contient une propriété `réponse`, veuillez y jeter un coup d'oeil pour obtenir plus d'informations. |
| message | Un message convivial indiquant si l'opération a réussi ou non. |
| Message dev | Un message plus technique, adapté aux développeurs (non utilisé actuellement). |
| réponse | Extension point for future extension to the WebMessage format. This will be documented when it starts being used. |

## Format de la date et de la période { #webapi_date_perid_format } 

Tout au long de l'API Web, nous faisons référence à des dates et à des périodes. Le format de la date
est le suivant :

    aaaa-MM-jj

Par exemple, si vous voulez exprimer le 20 mars 2014, vous devez utiliser
*2014-03-20*.

Le format de la période est décrit dans le tableau suivant (également disponible sur 
le point d'extrémité de l'API `/api/periodTypes`)



Tableau : Format de la période

| Intervale | Format | Exemple | Description |
|---|---|---|---|
| Jour | aaaaMMjj | 20040315 | 15 Mars, 2004 |
| Semaine | aaaaWn | 2004W10 | Semaine 10 2004 |
| Semaine Mercredi | aaaaMerWn | 2015MerS5 | Semaine 5 avec début le mercredi |
| Semaine Jeudi | aaaaJeuSn | 2015JeuS6 | Semaine 6 avec début le Jeudi |
| Semaine Samedi | aaaaSamSn | 2015SamS7 | Semaine 7 avec début le Samedi |
| Semaine Dimanche | aaaaDimSn | 2015DimS8 | Semaine 8 avec début le Dimanche |
| Bi-hebdomadaire | aaaaBiSn | 2015BiS1 | Semaine 1-2 20015 |
| Mois | aaaaMM | 200403 | Mars 2004 |
| Bi-mensuel | aaaaMMB | 200401B | Janvier-février 2004 |
| Trimestre | aaaaTn | 2004Q1 | Janvier-Mars 2004 |
| Semestre | aaaaSn | 2004S1 | Janvier-juin 2004 |
| Semestre Avril | aaaaAvrilSn | 2004AvrilS1 | Avril-Septembre 2004 |
| Année | aaaa | 2004 | 2004 |
| Année financière Avril | aaaaAvril | 2004Avril | Avril 2004 - mars 2005 |
| Année financière Juillet | aaaaJuillet | 2004Juillet | juillet 2004-juin 2005 |
| Année financière Octobre | aaaaOctobre | 2004Octobre | Octobre 2004-septembre 2005 |


### Périodes relatives { #webapi_date_relative_period_values } 


Dans certaines parties de l'API, comme pour la ressource analytique, vous pouvez 
utiliser des périodes relatives en plus des périodes fixes (définies ci-dessus). 
Les périodes relatives sont relatives à la date actuelle et permettent, par exemple, 
de créer des rapports dynamiques. Les valeurs disponibles pour les périodes relatives sont les suivantes :

    CETTE_SEMAINE, LA SEMAINE_DERNIÈRE, LES _4_ DERNIÈRES SEMAINES, LES _12 _DERNIÈRES SEMAINES, LES _52_ DERNIÈRES SEMAINES,
CE_MOIS, LE MOIS_DERNIER, CE_BIMESTRE, LE MOIS_DERNIER, CE_TRIMESTRE, LE TRIMESTRE_DERNIER,
    CES_SIX_MOIS, LES_SIX_DERNIERS MOIS, MOIS_CETTE_ANNÉE, TRIMESTRES_CETTE_ANNÉE,
    CETTE _ANNÉE, MOIS_ANNÉE_ DERNIÈRE, TRIMESTRES_ANNÉE_DERNIÈRE, ANNÉE_DERNIÈRE, _5_DERNIÈRES ANNÉES, _10_DERNIÈRES ANNÉES, _10_DERNIÈRES ANNÉES_FINANCIÈRES, _12_DERNIERS MOIS, 
    3 _DERNIERS_ MOIS, 6 _DERNIERS_ BIMESTRES, 4 _DERNIERS_ TRIMESTRES, 2 _DERNIERS_ SIX MOIS, CETTE _ANNÉE _FINANCIÈRE,
    DERNIÈRE_ANNÉE_FINANCIÈRE, 5 _DERNIÈRES _ANNÉES_FINANCIÈRES


## Autorités { #authorities } 
Les identifiants et les noms des autorisations du système peuvent être répertoriés à l'aide de la fonction :

    /api/authorities

Il renvoie le format suivant :
```json
{
  "systemAuthorities": [
    {
      "id": "ALL",
      "name": "ALL"
    },
    {
      "id": "F_ACCEPT_DATA_LOWER_LEVELS",
      "name": "Accept data at lower levels"
    }
    //...
  ]
}
```



# Métadonnées { #metadata } 

## Schémas d'identification { #webapi_identifier_schemes } 

This section provides an explanation of the identifier scheme concept.
Identifier schemes are used to map metadata objects to other metadata
during import, and to render metadata as part of exports. Please note
that not all schemes work for all API calls, and not all
schemes can be used for both input and output. This is outlined in the
sections explaining the various Web APIs.

Tous les types d'objets disponibles pour le schéma d'identification sont énumérés ci-dessous. Sont fournis les noms des propriétés à utiliser dans les requêtes :

  - idScheme

  - dataElementIdScheme (Schéma d'identifiant d'élément de données)

  - categoryOptionComboIdScheme (Schéma de l'identifiant de la combinaison d'options de catégorie)

  - orgUnitIdScheme (Schéma de l'identifiant de l'unité d'organisation)

  - programIdScheme (Schéma d'identification du programme)

  - programmeStageIdScheme (Schéma d'identification de l'étape de programme)

  - trackedEntityIdScheme (schéma d'identification de l'entité suivie)

  - trackedEntityAttributeIdScheme (schéma d'identification de l'attribut d'entité suivie)

Le schéma d'identification général (idScheme) s'applique à tous les types d'objets. Il peut être remplacé par des types d'objets spécifiques.

Le schéma par défaut pour tous les paramètres est UID (identifiants stables de DHIS2). Les schémas d'identification pris en charge sont décrits dans le tableau ci-dessous.

Tableau : Valeurs du schéma

| Schéma | Description |
|---|---|
| ID, UID | Correspondre avec l'identifiant permanent DHIS2. il s'agit du schéma d'identification par défaut. |
| CODE | Correspondre avec le code DHIS2, principalement utilisé pour échanger des données avec un système externe. |
| NOM | Correspondre avec le nom DHIS2. Notez que c'est l'élément disponible en tant que *object.name* (nom de l'objet) qui est utilisé, et non le nom traduit. Notez également que les noms ne sont pas toujours uniques et que, dans ce cas, ils ne peuvent pas être utilisés. |
| ATTRIBUT:ID | Correspondre avec l'attribut de métadonnées. Cet attribut doit être assigné au type avec lequel vous établissez la correspondance, d'autant plus que la propriété unique est définie sur  *true*. Cette fonctionnalité permet principalement d'échanger des données avec des systèmes externes. Il présente certains avantages par rapport à *CODE* puisque plusieurs attributs peuvent être ajoutés. Il peut donc se synchroniser avec plus d'un système. |

Note that identifier schemes is not an independent feature but needs to
be used in combination with resources such as data value import and metadata import.

Par exemple, pour spécifier CODE comme schéma d'identification général et le remplacer par UID pour le schéma d'identification de l'unité d'organisation, vous pouvez utiliser les requêtes suivantes : 

    ?idScheme=CODE&orgUnitIdScheme=UID

Autre exemple, pour spécifier un attribut pour le schéma d'identification de l'unité d'organisation, un code pour le schéma d'identification de l'élément de données et utiliser le schéma d'identification par défaut UID pour tous les autres objets, vous pouvez utiliser les paramètres suivants :

    ?orgUnitIdScheme=ATTRIBUTE:j38fk2dKFsG&dataElementIdScheme=CODE

## Navigation dans l'API Web { #webapi_browsing_the_web_api } 

Le point d'entrée pour naviguer dans l'API Web est `/api`. Cette ressource fournit des liens vers toutes les ressources disponibles. Quatre formats de représentation sont systématiquement disponibles pour toutes les ressources : HTML, XML, JSON et JSONP. D'autres formats sont disponibles pour des ressources comme MS Excel, PDF, CSV et PNG. Pour explorer l'API à partir d'un navigateur web, accédez au point d'entrée `/api` et suivez les liens vers la ressource que vous recherchez, par exemple `/api/dataElements`. Pour toutes les ressources qui renvoient une liste d'éléments, certains paramètres de requête peuvent être utilisés pour modifier la réponse :

Tableau : Paramètres de requête

| Param | Valeurs des options | Option par défaut | Description |
|---|---|---|---|
| pagination | vrai &#124; faux | vrai | Indique s'il faut renvoyer les listes d'éléments sous forme de pages. |
| page | nombre | 1 | Définit le numéro de page à renvoyer. |
| taille de la page | nombre | 50 | Définit le nombre d'éléments à renvoyer pour chaque page. |
| Ordre | property:asc/iasc/desc/idesc || Permet d'ordonner la sortie dans un ordre précis. Seules les propriétés conservées et simples (pas de collections, objets d'identification, etc.) sont prises en charge. iasc et idesc sont insensibles à la casse. |

Voici un exemple de comment ces paramètres peuvent être utilisés pour obtenir une liste complète de groupes d'éléments de données dans un format de réponse XML :

    /api/dataElementGroups.xml?links=false&paging=false

Vous pouvez rechercher des éléments à partir de la propriété "nom" au lieu de renvoyer toute une liste d'éléments à l'aide de la variable de requête *query*. Dans cet exemple, nous recherchons tous les éléments de données dont le nom contient le mot "anémie" :

    /api/dataElements?query=anaemia

Vous pouvez obtenir des pages spécifiques et des tailles de page pour des objets en utilisant la requête suivante :

    /api/dataElements.json?page=2&pageSize=20

Vous pouvez désactiver complètement la pagination à l'aide de cette requête :

    /api/indicatorGroups.json?paging=false

Pour que le résultat soit ordonné selon une propriété spécifique :

    /api/indicators.json?order=shortName:desc

La ressource *identifiableObjects* vous permet de rechercher tout objet à partir de son identifiant, quel que soit son type :

    /api/identifiableObjects/<id>

### Traduction { #webapi_translation } 

DHIS2 propose des traductions pour le contenu de la base de données, notamment les éléments de données, les indicateurs et les programmes. Tous les objets de métadonnées qui figurent dans l'API Web ont des propriétés destinées à être utilisées pour l'affichage et l'interface utilisateur. Il s'agit entre autres de *displayName* (nom d'affichage), *displayShortName* (nom d'affichage court), *displayDescription* (description de l'affichage) et *displayFormName* (nom du formulaire d'affichage). Ces propriétés sont utilisées pour les éléments de données et les attributs d'entités suivies.

Tableau : Options de traduction

| Paramètre | Valeurs | Description |
|---|---|---|
| traduction | vrai &#124; faux | Traduire les propriétés display\* dans les sorties de métadonnée (displayName, displayShortName, displayDescription, et displayFormName pour les éléments de données et les attributs d'entités suivies). La valeur par défaut est "true". |
| emplacement | Emplacement à utiliser | Traduire les métadonnées dans une langue donnée (nécessite que la traduction soit définie sur 'vrai'). |

### API de traduction { #webapi_translation_api } 

Les traductions d'un objet sont rendues comme faisant partie de l'objet lui-même dans le tableau *traductions*. Le tableau *traductions* qui figure dans les charges JSON/XML est normalement préfiltré pour vous, ce qui signifie qu'il ne peut pas être utilisé directement pour importer/exporter des traductions (car cela aurait pour effet de remplacer les langues autres que celles des utilisateurs actuellement connectés).

Exemple d'élément de données dont le tableau de traduction est filtré sur la langue de l'utilisateur :

```json
{
  "id": "FTRrcoaog83",
  "displayName": "Accute French",
  "translations": [
    {
      "property": "SHORT_NAME",
      "locale": "fr",
      "value": "Accute French"
    },
    {
      "property": "NAME",
      "locale": "fr",
      "value": "Accute French"
    }
  ]
}
```

Exemple d'élément de données dont les traductions sont désactivées :

```json
{
  "id": "FTRrcoaog83",
  "displayName": "Accute Flaccid Paralysis (Deaths < 5 yrs)",
  "translations": [
    {
      "property": "FORM_NAME",
      "locale": "en_FK",
      "value": "aa"
    },
    {
      "property": "SHORT_NAME",
      "locale": "en_GB",
      "value": "Accute Flaccid Paral"
    },
    {
      "property": "SHORT_NAME",
      "locale": "fr",
      "value": "Accute French"
    },
    {
      "property": "NAME",
      "locale": "fr",
      "value": "Accute French"
    },
    {
      "property": "NAME",
      "locale": "en_FK",
      "value": "aa"
    },
    {
      "property": "DESCRIPTION",
      "locale": "en_FK",
      "value": "aa"
    }
  ]
}
```

Notez que même si vous obtenez un résultat non filtré, et que vous utilisez le type de point d'extrémité approprié, c'est-à-dire `/api/dataElements`, nous n'autorisons pas les mises à jour, car cela pourrait facilement entraîner des erreurs et remplacer les autres langues disponibles.

Pour lire et mettre à jour les traductions, vous pouvez utiliser le point d'extrémité spécial "traductions" pour chaque ressource d'objet. Vous pouvez y accéder en utilisant *GET* ou *PUT* sur le point d'extrémité `/api/<object-type>/<object-id>/translations` approprié.

Par exemple, pour un élément de données dont l'identifiant est  `FTRrcoaog83`, vous pouvez utiliser `/api/dataElements/FTRrcoaog83/translations` pour obtenir les traductions et les mettre à jour. Les champs disponibles sont `property` avec les options *NOM*, *NOM_COURT*, *NOM DU_FORMULAIRE*, *DESCRIPTION*, `locale` qui prend en charge tout ID de langue valide et la propriété traduite `value`.

Exemple de propriété NOM pour la langue française :

```json
{
  "property": "NAME",
  "locale": "fr",
  "value": "Paralysie Flasque Aiguë (Décès <5 ans)"
}
```

Cette charge est ensuite ajoutée à un tableau de traduction et renvoyée au point d'extrémité approprié :

```json
{
  "translations": [
    {
      "property": "NAME",
      "locale": "fr",
      "value": "Paralysie Flasque Aiguë (Décès <5 ans)"
    }
  ]
}
```

Pour un élément de données dont l'ID est *FTRrcoaog83*, vous pouvez effectuer une requête *PUT* comme suit : `/api/dataElements/FTRrcoaog83/translations`. Assurez-vous d'envoyer toutes les traductions disponibles pour cet objet et pas seulement pour une langue (sinon vous risquez de remplacer les langues existantes par d'autres langues).

### Versions de l'API Web { #webapi_api_versions } 

L'API Web est versionnée à partir de DHIS 2.25. La version de l'API suit la numérotation des versions majeures de DHIS2. Par exemple, la version de l'API pour DHIS 2.33 est `33`.

Vous pouvez accéder à une version spécifique de l'API en incluant le numéro de version après `/api`, comme dans l'exemple suivant :

    /api/33/dataElements

Si vous omettez la partie version de l'URL, le système utilisera la version actuelle de l'API. Par exemple, pour DHIS 2.25, si vous omettez la partie de l'API, le système utilisera la version 25 de l'API. Lors du développement de clients API, il est recommandé d'utiliser des versions API explicites (plutôt que d'omettre la version de l'API), car cela protégera le client contre les modifications imprévues de l'API.

Les trois dernières versions de l'API seront prises en charge. Par exemple, la version 2.27 de DHIS va prendre en charge les versions 27, 26 et 25 de l'API.

Notez que le modèle de métadonnées n'est pas versionné et que des changements peuvent survenir, par exemple dans les associations entre objets. Ces changements seront documentés dans les notes de mise à jour de la version principale de DHIS2.

## Filtre sur les objets de métadonnées { #webapi_metadata_object_filter } 

To filter the metadata there are several filter operations that can be
applied to the returned list of metadata. The format of the filter
itself is straight-forward and follows the pattern
*property:operator:value*, where *property* is the property on the
metadata you want to filter on, *operator* is the comparison operator
you want to perform and *value* is the value to check against (not all
operators require value). Please see the *schema* section to discover
which properties are available. Recursive filtering, ie. filtering on
associated objects or collection of objects, is supported as well.

Tableau : Opérateurs disponibles

| Opérateur | Les types | Valeur requise | Description |
|---|---|---|---|
| eq | chaîne | booléen | entier | flottant | énumération | collection (vérification de la taille) | date | vrai | Égalité |
| !eq | chaîne | booléen | entier | flottant | énumération | collection (vérification de la taille) | date | vrai | Inégalité |
| ne | chaîne | booléen | entier | flottant | énumération | collection (vérification de la taille) | date | vrai | Inégalité |
| like | chaîne | vrai | Chaîne sensible à la casse ; peut correspondre avec tout élément |
| !like | chaîne | vrai | Chaîne sensible à la casse ; ne peut pas correspondre avec tous les éléments |
| $like | chaîne | vrai | Chaîne sensible à la casse ; début de la correspondance |
| !$like | chaîne | vrai | Chaîne sensible à la casse, pas de début de correspondance |
| like$ | chaîne | vrai | Chaîne sensible à la casse ; fin de la correspondance |
| !like$ | chaîne | vrai | Case sensitive string, not match end |
| ilike | chaîne | vrai | Chaîne insensible à la casse ; peut correspondre avec tout élément |
| !ilike | chaîne | vrai | Chaîne insensible à la casse ; ne peut pas correspondre avec tous les éléments |
| $ilike | chaîne | vrai | Chaîne insensible à la casse ; début de la correspondance |
| !$ilike | chaîne | vrai | Chaîne insensible à la casse, pas de début de correspondance |
| ilike$ | chaîne | vrai | Case insensitive string, match end |
| !ilike$ | chaîne | vrai | Case insensitive string, not match end |
| gt | chaîne | booléen | entier | flottant | collection (vérification de la taille) | date | vrai | Supérieure à |
| ge | chaîne | booléen | entier | flottant | collection (vérification de la taille) | date | vrai | Supérieur ou égal |
| lt | chaîne | booléen | entier | flottant | collection (vérification de la taille) | date | vrai | Inférieur à |
| le | chaîne | booléen | entier | flottant | collection (vérification de la taille) | date | vrai | inférieur ou égal |
| nulle | tous | faux | La propriété est nulle |
| !null | tous | faux | La propriété n'est pas nulle |
| vide | collection | faux | La collection est vide |
| jeton | chaîne | vrai | Match on multiple tokens in search property |
| !token | chaîne | vrai | Not match on multiple tokens in search property |
| recherche | chaîne | booléen | entier | flottant | date | vrai | Find objects matching 1 or more values |
| !in | chaîne | booléen | entier | flottant | date | vrai | Find objects not matching 1 or more values |

Operators will be applied as logical *and* query, if you need a *or*
query, you can have a look at our *in* filter (also have a look at the
section below). The filtering mechanism allows for recursion. See below
for some examples.

Obtenir des éléments de données avec la propriété ID1 ou ID2 :

    /api/dataElements?filter=id:eq:ID1&filter=id:eq:ID2

Get all data elements which have the dataSet with id ID1:

    /api/dataElements?filter=dataSetElements.dataSet.id:eq:ID1

Get all data elements with aggregation operator "sum" and value type
"int":

    /api/dataElements.json?filter=aggregationOperator:eq:sum&filter=type:eq:int

You can do filtering within collections, e.g. to get data elements which
are members of the "ANC" data element group you can use the following
query using the id property of the associated data element groups:

    /api/dataElements.json?filter=dataElementGroups.id:eq:qfxEYY9xAl6

Étant donné que tous les opérateurs sont *et* par défaut, vous ne pouvez pas trouver un élément de données correspondant à plus d'un identifiant. Pour ce faire, vous pouvez utiliser l'opérateur *dans*.

    /api/dataElements.json?filter=id:in:[fbfJHSPpUQD,cYeuwXTCPkU]

### Opérateurs logiques { #webapi_metadata_logical_operator } 

Comme indiqué dans la section précédente, l'opérateur logique par défaut appliqué aux filtres est *ET*, ce qui signifie que tous les filtres d'objets doivent trouver une correspondance. Cependant, dans certains cas, l'utilisateur peut vouloir utiliser un seul filtre parmi plusieurs (par exemple le champ de l'identifiant et du code). Dans ce cas, il est possible de changer l'opérateur logique racine de *ET* à *OU* à l'aide du paramètre *rootJunction*.

Exemple : Filtrage normal où l'identifiant et le code doivent correspondre pour que le résultat soit renvoyé.

    /api/dataElements.json?filter=id:in:[id1,id2]&filter=code:eq:code1

Exemple : Filtrage où l'opérateur logique a été remplacé par OU, ce qui fait qu'un seul des filtres doit trouver une correspondance pour que le résultat soit renvoyé.

    /api/dataElements.json?filter=id:in:[id1,id2]&filter=code:eq:code1&rootJunction=OR

### Identifiable token filter { #identifiable-token-filter } 

Outre le filtrage spécifique basé sur les propriétés mentionné ci-dessus, nous disposons également d'un filtrage *ET* basé sur *token* à travers un ensemble de propriétés : identifiant, code et nom (ainsi que 'nom court' s'il est disponible). Ces propriétés sont généralement appelées *identifiables*. L'idée est de filtrer les métadonnées dont l'identifiant, le nom, le code ou le nom court contiennent des informations.

Exemple : Filtrage de tous les éléments de données contenant *2em* dans l'un des éléments suivants : identifiant, nom, code et nom court.

    /api/dataElements.json?filter=identifiable:token:2nd

Il est également possible de spécifier plusieurs valeurs de filtrage.

Exemple : Obtenir tous les éléments de données où *visite CPN* se trouve dans l'une des propriétés *identifiables*. Le système renvoie tous les éléments de données dans lesquels les deux unités lexicales (CPN et visite) se trouvent quelque part dans les propriétés identifiables.

    /api/dataElements.json?filter=identifiable:token:ANC visit

Il est également possible de combiner le filtre identifiable avec le filtre basé sur les propriétés et de s'attendre à ce que le paramètre *rootJunction* soit appliqué.

    /api/dataElements.json?filter=identifiable:token:ANC visit&filter=displayName:ilike:tt1

    /api/dataElements.json?filter=identifiable:token:ANC visit
      &filter=displayName:ilike:tt1&rootJunction=OR

## Metadata field filter { #webapi_metadata_field_filter } 

In many situations, the default views of the metadata can be too
verbose. A client might only need a few fields from each object and want
to remove unnecessary fields from the response. To discover which fields
are available for each object please see the *schema* section.

The format for include/exclude allows for infinite recursion. To filter
at the "root" level you can just use the name of the field,
i.e. `?fields=id,name` which would only display the `id` and
`name` fields for every object. For objects that are either collections or
complex objects with properties on their own, you can use the format
`?fields=id,name,dataSets[id,name]` which would return `id`, `name` of
the root, and the `id` and `name` of every data set on that object.
Negation can be done with the exclamation operator, and we have a set of
presets of field select. Both XML and JSON are supported.

**Exemple** : Obtenir l'`id` et le `nom` à partir de la ressource d'indicateurs :

    /api/indicators?fields=id,name

**Example**: Get `id` and `name` from dataElements, and `id` and `name`
from the dataSets on dataElements:

    /api/dataElements?fields=id,name,dataSets[id,name]

Pour exclure un champ de la sortie, vous pouvez utiliser l'opérateur d'exclamation `!`. Ceci est autorisé à n'importe quel emplacement dans la requête et cette propriété ne sera pas incluse tout simplement car elle pourrait avoir été insérée dans des options prédéfinies.

Quelques options prédéfinies (groupes de champs sélectionnés) sont disponibles et peuvent être appliqués à l'aide de l'opérateur `:`.

Tableau : Opérateurs de propriété

| Opérateur | Description |
|---|---|
| <field-name\> | Inclure la propriété avec le nom, si possible. |
| <object\>[<field-name\>, ...] | Inclut un champ dans une collection (qui s'appliquera à tous les objets de cette collection) ou dans un seul objet. |
| !<field-name\>, <object\>[!<field-name\> | Le nom du champ est exclu. Cet opérateur fonctionne également à l'intérieur des objets/collections. Vous pouvez l'utiliser avec une option prédéfinie pour inclure des champs. |
| \*, <object\>[\*] | Inclut tous les champs d'un objet spécifique. S'il est appliqué à une collection, tous les champs de tous les objets de cette collection seront inclus. |
| :<preset\> | Alias pour sélectionner plusieurs champs. Trois paramètres prédéfinis sont actuellement disponibles ; le tableau ci-dessous en fournit les descriptions. |

Tableau : Paramètres prédéfinies des champs

| Paramètre prédéfini | Description |
|---|---|
| tous | Tous les champs de l'objet |
| \* | Alias pour tous |
| identifiable | Inclut les champs pour l'identifiant, le nom, le code, la date de création et de la dernière mise à jour. |
| nommable | Inclut les champs pour l'identifiant, le nom, le nom court, le code, la description, la date de création et de la dernière mise à jour. |
| conservé | Renvoie toutes les propriétés conservées sur un objet ; ne tient pas compte du fait que l'objet soit le propriétaire de la relation ou non. |
| propriétaire | Renvoie toutes les propriétés conservées pour un objet, dans un contexte où cet objet est propriétaire de toutes les propriétés. Cette charge peut être utilisée pour effectuer une mise à jour via l'API. |

**Example**: Include all fields from dataSets except organisationUnits:

    /api/dataSets?fields=:all,!organisationUnits

**Exemple** : Inclure uniquement l'identifiant, le nom et la collection d'unités d'organisation d'un ensemble de données, mais exclure l'identifiant des unités d'organisation :

    /api/dataSets/BfMAe6Itzgt?fields=id,name,organisationUnits[:all,!id]

**Exemple** : Inclure les propriétés nommables de tous les indicateurs :

    /api/indicators.json?fields=:nameable

### Transformateurs de champ { #webapi_field_transformers } 

In DHIS2.17 we introduced field transformers, the idea is to allow
further customization of the properties on the server-side.

    /api/dataElements/ID?fields=id~rename(i),name~rename(n)

La propriété *id* sera renommée *i* et la propriété *nom* sera renommée *n*.

Multiple transformers can be used by repeating the transformer syntax:

    /api/dataElementGroups.json?fields=id,displayName,dataElements~isNotEmpty~rename(haveDataElements)

Tableau : Transformateurs disponibles

| Nom | Arguments | Description |
|---|---|---|
| taille || Donne la taille des chaînes (longueur) et des collections |
| isEmpty (est vide) || La chaîne ou la collection est vide |
| isNotEmpty (n'est pas vide) || La chaîne ou la collection n'est pas vide |
| renommer | Arg1 : nom | Renomme la propriété |
| pagination | Arg1 : page,Arg2 : taille de la page | Pages a collection, default pageSize is 50. |
| pluck | Arg1 facultatif : fieldName (nom du champ) | Convertit un tableau d'objets en un tableau comprenant un champ sélectionné de cet objet. Par défaut, le premier champ renvoyé par la collection est utilisé (normalement l'ID). |

#### Exemples { #webapi_field_transformers_examples } 

Examples of transformer usage.

```
/api/dataElements?fields=dataSets~size

/api/dataElements?fields=dataSets~isEmpty

/api/dataElements?fields=dataSets~isNotEmpty

/api/dataElements/ID?fields=id~rename(i),name~rename(n)

/api/dataElementGroups?fields=id,displayName,dataElements~paging(1;20)

# Include array with IDs of organisation units:
/api/categoryOptions.json?fields=id,organisationUnits~pluck

# Include array with names of organisation units (collection only returns field name):
/api/categoryOptions.json?fields=id,organisationUnits~pluck[name]
```

## Création, lecture, mise à jour, suppression et validation de métadonnées { #webapi_metadata_crud } 

Toutes les entités de métadonnées dans DHIS2 ont leur propre point d'extrémité API qui prend en charge les opérations *CRUD* (création, lecture, mise à jour et suppression). Les URL des points d'extrémité suivent le format suivant :

    /api/<entityName>

Le _nom de l'entité_ utilise la notation camel case. Par exemple, le point d'extrémité pour les _éléments de données_ est :

    /api/dataElements

### Création et mise à jour des paramètres { #webapi_metadata_create_update } 

Les paramètres de requête suivants sont disponibles pour tous les points d'extrémité de métadonnées.

Tableau : Filtres de requête disponibles

| Param | Type | Obligatoire | Options (par défaut en premier) | Description |
|---|---|---|---|---|
| preheatCache | booléen | faux | vrai &#124; faux | Activer/désactiver le préchauffage du cache-map. Cette option est activée par défaut. Si vous la désactivez, le temps de chargement initial de l'importateur sera beaucoup plus court (mais l'importation elle-même sera plus lente). Cette fonction est principalement utilisée lorsque vous avez un petit fichier XML/JSON à importer, et que vous ne voulez pas attendre le préchauffage du cache-map. |
| importStrategy (stratégie d'importation) | enum | faux | CRÉER_ET_METTRE À JOUR | CRÉER | METTRE À JOUR | SUPPRIMER | Stratégie d'importation à utiliser, voir ci-dessous pour plus d'informations. |
| mergeMode (mode de fusion) | enum | faux | REMPLACER, FUSIONNER | Stratégie de fusion des objets lors des mises à jour. REMPLACER va écraser la propriété avec la nouvelle valeur fournie ; FUSIONNER va définir la propriété si elle n'est pas nulle (seulement si la propriété a été fournie). |

### Création et mise à jour d'objets { #webapi_creating_updating_objects } 

Pour créer de nouveaux objets, vous devrez connaître le point d'extrémité, le format du type d'objet et vous assurer que vous disposez des autorisations nécessaires. À titre d'exemple, nous allons créer et mettre à jour une *constante*. Pour connaître le format, nous pouvons utiliser le nouveau point d'extrémité *schéma* pour obtenir la description du format. Nous allons donc commencer par l'obtention de cette information :

    http://<server>/api/schemas/constant.json

À partir de la sortie, vous pouvez voir que les autorités requises pour la création sont `F_CONSTANT_ADD`, et que les propriétés importantes sont : *nom* et *valeur*. En nous basant sur ces informations, nous pouvons créer une charge JSON et la sauvegarder dans un fichier appelé constant.json :

```json
{
  "name": "PI",
  "value": "3.14159265359"
}
```

Le même contenu qu'une charge XML :

```xml
<constant name="PI" xmlns="http://dhis2.org/schema/dxf/2.0">
  <value>3.14159265359</value>
</constant>
```

Nous sommes maintenant prêts à créer la nouvelle *constante* en envoyant une requête POST au point d'extrémité `constantes` avec la charge JSON, en utilisant le curl :

```bash
curl -d @constant.json "http://server/api/constants" -X POST
  -H "Content-Type: application/json" -u user:password
```

Exemple concret d'envoi de la constante au serveur de démonstration :

```bash
curl -d @constant.json "https://play.dhis2.org/api/constants" -X POST
  -H "Content-Type: application/json" -u admin:district
```

Si tout s'est bien passé, vous devriez obtenir le résultat suivant :

```json
{
  "status": "SUCCESS",
  "importCount": {
    "imported": 1,
    "updated": 0,
    "ignored": 0,
    "deleted": 0
  },
  "type": "Constant"
}
```

Le processus sera exactement le même pour la mise à jour, vous apportez vos modifications à la charge JSON/XML, vous trouvez l'*ID* de la constante, puis vous envoyez une requête PUT au point d'extrémité en incluant l'ID :

```bash
curl -X PUT -d @pi.json -H "Content-Type: application/json"
  -u user:password "http://server/api/constants/ID"
```

### Suppression d'objets { #webapi_deleting_objects } 

La suppression d'objets est très simple. Vous devez connaître l'*ID* et le point d'extrémité du type d'objet que vous voulez supprimer. Reprenons l'exemple de la dernière section et utilisons une *constante*. Supposons que l'identifiant soit *abc123*, tout ce que vous avez à faire est d'envoyer la requête DELETE (supprimer) au point d'extrémité + Id :

```bash
curl -X DELETE -u user:password "http://server/api/constants/ID"
```

Une suppression réussie doit renvoyer le statut HTTP 204 (pas de contenu).

### Ajout et suppression d'objets dans les collections { #webapi_adding_removing_objects_collections } 

La ressource des collections vous permet de modifier des collections d'objets.

#### Ajout ou suppression d'objets uniques{ #webapi_collections_adding_removing_single_objects } 

Pour ajouter ou supprimer des objets dans une collection d'objets, vous pouvez utiliser le modèle suivant :

    /api/{collection-object}/{collection-object-id}/{collection-name}/{object-id}

Vous devez utiliser la méthode POST pour ajouter un objet et la méthode DELETE pour le supprimer. Lorsqu'il existe une relation entre plusieurs objets, vous devez d'abord déterminer quel objet est propriétaire de la relation. Si cet objet n'est pas clairement identifiable, essayez les deux méthodes d'appel pour voir laquelle fonctionne.

Les éléments du modèle sont les suivants :

  - objet de la collection : Le type d'objets qui possède la collection que vous
    voulez modifier.

  - id de l'objet de collection : L'identifiant de l'objet qui possède la
    collection que vous voulez modifier.

  - nom de la collection : le nom de la collection que vous voulez modifier.

  - Identifiant d'objet : L'identifiant de l'objet que vous voulez ajouter ou supprimer
    de la collection.

Par exemple, pour supprimer un élément de données avec pour identifiant IDB d'un groupe d'éléments de données dont l'identifiant est IDA, vous pouvez effectuer une requête DELETE :

    DELETE /api/dataElementGroups/IDA/dataElements/IDB

Pour ajouter une option de catégorie avec pour identifiant IDB à une catégorie dont l'identifiant est IDA, vous pouvez effectuer une requête POST :

    POST /api/categories/IDA/categoryOptions/IDB

#### Ajout ou suppression de plusieurs objets { #webapi_collections_adding_removing_multiple_objects } 

Vous pouvez ajouter ou supprimer plusieurs objets d'une collection dans une même requête, en utilisant la charge suivante :

```json
{
  "identifiableObjects": [{
      "id": "IDA"
    }, {
      "id": "IDB"
    }, {
      "id": "IDC"
    }
  ]
}
```

Cette charge utile permet d'ajouter, de remplacer ou de supprimer des éléments :

*Ajouter des éléments:*

    POST /api/categories/IDA/categoryOptions

*Rempld'éléments:*

    PUT /api/categories/IDA/categoryOptions

*Supprimer des éléments :*

    DELETE /api/categories/IDA/categoryOptions

#### Ajout et suppression d'objets dans une même requête { #webapi_collections_adding_removing_objects_single_request } 

Vous pouvez ajouter et supprimer des objets d'une collection dans une même requête POST, en utilisant l'URL suivante :

    POST /api/categories/IDA/categoryOptions

Le format de la charge est le suivant :

```json
{
  "additions": [{
      "id": "IDA"
    }, {
      "id": "IDB"
    }, {
      "id": "IDC"
    }
  ],
  "deletions": [{
      "id": "IDD"
    }, {
      "id": "IDE"
    }, {
      "id": "IDF"
    }
  ]
}
```

### Validation des charges { #webapi_validating_payloads } 

DHIS 2 permet de valider des métadonnées à l'échelle du système, ce qui signifie que les opérations de création et de mise à jour sur les points d'extrémité d'API devront être valides avant que les modifications ne soient autorisées. Pour connaître les validations disponibles pour un point d'extrémité spécifique, consultez ce point d'extrémité : `/api/schemas`. C'est-à-dire que pour connaître les contraintes d'un élément de données, vous devez vous rendre dans `/api/schemas/dataElement`.

Vous pouvez également valider votre charge manuellement en l'envoyant au point d'extrémité du schéma approprié. Si vous vouliez valider la constante dans la section de création précédente, vous devriez l'envoyer comme ceci :

    POST /api/schemas/constant

Voici un exemple simple (sans validation) :

```bash
curl -X POST -d "{\"name\": \"some name\"}" -H "Content-Type: application/json"
  -u admin:district "https://play.dhis2.org/dev/api/schemas/dataElement"
```

Ce qui donnera le résultat suivant :

```json
[
   {
      "message" : "Required property missing.",
      "property" : "type"
   },
   {
      "property" : "aggregationOperator",
      "message" : "Required property missing."
   },
   {
      "property" : "domainType",
      "message" : "Required property missing."
   },
   {
      "property" : "shortName",
      "message" : "Required property missing."
   }
]
```

### Mises à jour partielles { #webapi_partial_updates } 

For our web api endpoints that deal with metadata, we support partial updates (PATCH) using the JSON Patch [standard](https://tools.ietf.org/html/rfc6902). The payload basically outlines a set of operation you want applied to a existing metadata object. For examples of JSON patch please see [jsonpatch.com](http://jsonpatch.com/), we support 3 operators: `add`, `remove` and `replace`.

Below is a few examples relevant to dhis2, please note that any update to a payload should be thought of as a HTTP PUT (i.e. any mutation must result in a valid PUT metadata payload).

The default `importReportMode` for JSON Patch is `ERRORS_NOT_OWNER` which means that if you try and update any property that is not owned by that particular object (for example trying to add a indicator group directly to an indicator) you will get an error.

As per the JSON Patch specification you must always use the mimetype `application/json-patch+json` when sending patches.

#### Exemples { #examples }

##### Mise à jour du nom et du type de valeur d'un élément de données { #update-name-and-value-type-of-data-element } 

```
PATCH /api/dataElements/{id}
```

```json
[
  {"op": "add", "path": "/name", "value": "New Name"},
  {"op": "add", "path": "/valueType", "value": "INTEGER"}
] 
```

##### Ajout d'un nouvel élément de données à un groupe d'éléments de données { #add-new-data-element-to-a-data-element-group } 

```
PATCH /api/dataElementGroups/{id}
```

```json
[
  {"op": "add", "path": "/dataElements/-", "value": {"id": "data-element-id"}}
]
```

##### Suppression de toutes les associations d'éléments de données d'un groupe d'éléments de données { #remove-all-data-element-associations-from-a-data-element-group } 

```
PATCH /api/dataElementGroups/{id}
```

```json
[
  {"op": "remove", "path": "/dataElements"}
]
```

##### Modification du domaine et du type de valeur d'un élément de données { #change-domain-and-value-type-of-a-data-element } 

```
PATCH /api/dataElements/{id}
```

```json
[
    {"op": "add", "path": "/domainType", "value": "TRACKER"},
    {"op": "add", "path": "/valueType", "value": "INTEGER"}
]
```

##### Suppression d'une unité d'organisation spécifique d'un groupe d'unité d'organisation { #remove-a-specific-orgunit-from-an-orgunit-group } 

```
PATCH /api/organisationUnitGroups/{id}
```

```json
[
  {"op": "remove", "path": "/organisationUnits/1"}
]
```


## Exportation de métadonnées { #webapi_metadata_export } 

Cette section décrit l'API de métadonnées qui est disponible ici : `/api/metadata`. Les représentations des ressources XML et JSON sont prises en charge.

    /api/metadata

Les paramètres les plus courants sont décrits dans le tableau "Paramètres d'exportation" ci-dessous. Vous pouvez également appliquer ceci à tous les types disponibles en utilisant `type:fields=<filter>` et `type:filter=<filter>`. Vous pouvez également activer/désactiver l'exportation de certains types à travers ceci : `type=true|false`.

Tableau : Paramètres d'exportation

| Nom | Options | Description |
|---|---|---|
| champs | Identique au filtre du champ de métadonnées | Filtre de champ par défaut à appliquer pour tous les types, la valeur par défaut est `:owner`. |
| filtre | Identique au filtre des objets de métadonnées | Filtre d'objets par défaut à appliquer pour tous les types. La valeur par défaut est `:none` (aucun). |
| Ordre | Identique à l'ordre des métadonnées | Ordre par défaut à appliquer à tous les types. La valeur par défaut est `name` si un nom est disponible, ou `created` sinon. |
| traduction | faux/vrai | Permet les traductions. Cette fonction est désactivée par défaut (dans d'autres points d'extrémité, elle est activée par défaut). |
| emplacement | <locale\> | Permet de passer de la langue de l'utilisateur à la langue que vous définissez. |
| defaults | INCLURE/EXCLURE | Permet de déterminer si l'objet de catégorie généré automatiquement doit être inclus ou non dans la charge. Si vous déplacez des métadonnées entre deux instances non synchronisées, vous pouvez définir ce paramètre sur EXCLURE afin de faciliter la gestion de ces objets générés. |
| skipSharing (ignorer le partage) | faux/vrai | L'activation de ce paramètre supprime les propriétés de partage des objets exportés. Il s'agit de *utilisateur*, *accès publique*, *accès des groupes d'utilisateurs*, *accès utilisateur*, et *accès externe*. |
| download | faux/vrai | L'activation de ce paramètre ajoutera l'en-tête HTTP Contenu-Disposition qui spécifie que les données doivent être traitées comme une pièce jointe et seront proposées par les navigateurs web sous forme de téléchargement. |

### Exemples d'exportation de métadonnées { #webapi_metadata_export_examples } 

Exporter toutes les métadonnées. Attention, la réponse peut être très volumineuse en fonction de la configuration des métadonnées :

    /api/metadata

Exporter toutes les métadonnées classées par ordre décroissant en prenant en compte la dernière mise à jour :

    /api/metadata?defaultOrder=lastUpdated:desc

Exporter uniquement les métadonnées qui contiennent des indicateurs et des groupes d'indicateurs :

    /api/metadata?indicators=true&indicatorGroups=true

Exporter l'identifiant et le nom d'affichage de tous les éléments de données, classés par nom d'affichage :

    /api/metadata?dataElements:fields=id,name&dataElements:order=displayName:desc

Exporter les éléments de données et les indicateurs dont le nom commence par "CPN" :

    /api/metadata?filter=name:^like:ANC&dataElements=true&indicators=true

### Exportation de métadonnées avec des dépendances { #webapi_dataset_program_export_dependencies } 

Lorsque vous voulez échanger des métadonnées avec un ensemble de données, un programme, une combinaison de catégories, un tableau de bord, un ensemble d'options ou un groupe d'éléments de données, d'une instance DHIS2 à une autre, six points d'extrémité dédiés sont disponibles :

```
/api/dataSets/{id}/metadata.json

/api/programs/{id}/metadata.json

/api/categoryCombos/{id}/metadata.json

/api/dashboards/{id}/metadata.json

/api/optionSets/{id}/metadata.json

/api/dataElementGroups/{id}/metadata.json
```

Ces éléments exportés peuvent ensuite être importés en utilisant ceci `/api/metadata`.

Ces points d'extrémité prennent également en charge les paramètres suivants :

Tableau : Paramètres d'exportation

| Nom | Options | Description |
|---|---|---|
| skipSharing (ignorer le partage) | faux/vrai | L'activation de ce paramètre supprime les propriétés de partage des objets exportés. Il s'agit de *utilisateur*, *accès publique*, *accès des groupes d'utilisateurs*, *accès utilisateur*, et *accès externe*. |
| download | faux/vrai | L'activation de ce paramètre ajoutera l'en-tête HTTP Contenu-Disposition qui spécifie que les données doivent être traitées comme une pièce jointe et seront proposées par les navigateurs web sous forme de téléchargement. |

## Importation de métadonnées { #webapi_metadata_import } 

Cette section décrit l'API d'importation des métadonnées. Les représentations des ressources XML et JSON sont prises en charge. Les métadonnées peuvent être importées à l'aide d'une requête *POST*.

    /api/metadata

L'importateur vous permet d'importer des charges de métadonnées qui peuvent inclure plusieurs entités et un nombre quelconque d'objets par entité. Les éléments de métadonnées exportés via l'API d'exportation de métadonnées peuvent être importés directement.

Le point d'extrémité de l'importation des métadonnées prend en charge une variété de paramètres, énumérés ci-dessous.

Tableau : Paramètres d'importation

| Nom | Options (la première est la valeur par défaut) | Description |
|---|---|---|
| Mode d'importation  | COMMIT, VALIDATE (commiter, valider) | Définit le mode d'importation général ; décide s'il faut `VALIDER` ou `COMMITER` les métadonnées. Cet paramètre fonctionne de la même manière que la fonction dryRun (essai). |
| identifiant | UID, CODE, AUTO | Définit le schéma d'identification à utiliser pour la mise en correspondance des références. Il faut d'abord essayer `UID`, puis `CODE` avant de passer à `AUTO`. |
| importReportMode (mode de rapport d'importation) | ERRORS, FULL, DEBUG (erreurs, plein, débogage) | Définit le mode de `rapport d'importation` ; contrôle ce qui est rapporté après l'importation. `ERRORS` n'inclut que les *rapports d'objets* pour les objets qui contiennent des erreurs. `FULL` renvoie un *rapport d'objet* pour tous les objets importés, et `DEBUG` renvoie la même chose plus un nom pour l'objet (si disponible). |
| preheatMode (mode préchauffage) | REFERENCE, ALL, NONE (référence, tous, aucun) | Définit le mode de préchauffage ; il est utilisé pour signaler si le préchauffage doit être fait pour `TOUS` (comme c'était le cas auparavant avec *preheatCache=true*) ou faire un scan plus intelligent des objets pour voir ce qu'il faut préchauffer (actuellement le paramètre par défaut). Il n'est pas recommandé de le définir sur `AUCUN`. |
| importStrategy (stratégie d'importation) | CRÉER_ET_METTRE À JOUR, CRÉER, METTRE À JOUR, SUPPRIMER | Définit la stratégie d'importation ; `CREATE_AND_UPDATE` essaiera de trouver une correspondance avec l'identifiant. Si aucune correspondance n'est trouvée, l'objet sera créé. |
| Mode atomique | ALL, NONE (tous, aucun) | Définit le mode atomique. Dans l'ancien importateur, nous faisions toujours une importation *best effort* (mode au mieux), ce qui signifie que même si certaines références n'existaient pas, l'importation se faisait quand même (par exemple, des éléments de données manquants dans un groupe d'éléments de données). Par défaut, le nouvel importateur ne permet pas cela et rejette les erreurs de validation. Définir le mode `NONE` (aucun) émulait l'ancien fonctionnement. |
| ~~mergeMode~~ (mode de fusion) | ~~REPLACE, MERGE~~ (remplacer, fusionner) | ~~Définit le mode de fusion. Lors des mises à jour nous avons deux façons de fusionner l'ancien objet avec le nouveau. Le mode `MERGE` ne remplacera l'ancienne propriété que si la nouvelle n'est pas nulle. Pour le mode `REPLACE`, toutes les propriétés sont remplacées qu'elles soient nulles ou non.~~ (*) |
| flushMode (mode de vidage) | AUTO, OBJET | Définit le mode de vidage, qui contrôle quand vider le cache interne. Il est *fortement* recommandé de maintenir ce mode sur `AUTO` (qui est le mode par défaut). N'utilisez `OBJECT` qu'à des fins de débogage, lorsque vous voyez des exceptions liées à l'hibernation et que vous voulez localiser l'emplacement exact où l'empilement se produit (l'hibernation ne se déclenche qu'au moment du vidage, il peut donc être difficile de savoir quel objet a eu des problèmes). | 
| skipSharing (ignorer le partage) | faux, vrai | Permet d'ignorer les propriétés de partage, d'éviter la fusion des éléments partagées lors des mises à jour et l'ajout d'un accès à un groupe d'utilisateurs lors de la création de nouveaux objets. |
| skipValidation (ignorer la validation) | faux, vrai | Permet d'ignorer la validation lors de l'importation. Ce paramètre n'est pas recommandé : `NOT RECOMMENDED`. |
| async | faux, vrai | Importation asynchrone ; la réponse est renvoyée immédiatement avec un en-tête *Emplacement* qui pointe vers l'emplacement du *rapport d'importation*. La charge contient également un objet json de la tâche créée. |
| inclusionStrategy (stratégie d'inclusion) | NON_NULL, ALWAYS, NON_EMPTY | *NON_NULL* inclut les propriétés qui ne sont pas nulles, *ALWAYS* inclut toutes les propriétés, *NON_EMPTY* inclut les propriétés qui ne sont pas vides (n'inclut pas les chaînes de longueur 0, les collections de taille 0, etc.) |
| userOverrideMode (utiliser le mode de remplacement) | AUCUN, ACTUEL, SÉLECTIONNÉ | Ceci vous permet de remplacer la propriété utilisateur de chaque objet que vous importez. Les options sont NONE (ne rien faire), CURRENT (utiliser l'utilisateur d'importation), SELECTED (sélectionner un utilisateur spécifique en utilisant overrideUser=X). |
| overrideUser (remplacer l'utilisateur) | ID de l'utilisateur | Si le mode de remplacement de l'utilisateur est sélectionné, utilisez ce paramètre pour sélectionner l'utilisateur avec lequel vous voulez effectuer le remplacement. |

> (*) Currently the `mergeMode=MERGE` option of the import service has limitations and doesn't support all objects. It doesn't work with some object types such as Embedded objects, or objects which are saved as JSONB format in database ( sharing, attributeValues, etc...). Fixing those issues are complicated and would just cause new issues. Therefore, this `mergedMode=MERGE` is deprecated and currently is not recommended to use. The update mode should always be mergedMode=REPLACE. We have developed a new [JSON Patch API](#webapi_partial_updates) which can be used as an alternative approach. This feature is introduced in 2.37 release.


Voici un exemple de charge d'importation de métadonnées. Vous remarquerez que chaque type d'entité possède sa propre propriété avec un tableau d'objets :

```json
{
  "dataElements": [
    {
      "name": "EPI - IPV 3 doses given",
      "shortName": "EPI - IPV 3 doses given",
      "aggregationType": "SUM",
      "domainType": "AGGREGATE",
      "valueType": "INTEGER_ZERO_OR_POSITIVE"
    },
    {
      "name": "EPI - IPV 4 doses given",
      "shortName": "EPI - IPV 4 doses given",
      "aggregationType": "SUM",
      "domainType": "AGGREGATE",
      "valueType": "INTEGER_ZERO_OR_POSITIVE"
    }
  ],
  "indicators": [
    {
      "name": "EPI - ADS stock used",
      "shortName": "ADS stock used",
      "numerator": "#{LTb8XeeqeqI}+#{Fs28ZQJET6V}-#{A3mHIZd2tPg}",
      "numeratorDescription": "ADS 0.05 ml used",
      "denominator": "1",
      "denominatorDescription": "1",
      "annualized": false,
      "indicatorType": {
        "id": "kHy61PbChXr"
      }
    }
  ]
}
```

Lors de l'envoi de cette charge au point d'extrémité des métadonnées, la réponse contiendra des informations sur les paramètres utilisés lors de l'importation et un récapitulatif par type d'entité, lequel contiendra le nombre d'objets créés, mis à jour, supprimés et ignorés :

```json
{
  "importParams": {
    "userOverrideMode": "NONE",
    "importMode": "COMMIT",
    "identifier": "UID",
    "preheatMode": "REFERENCE",
    "importStrategy": "CREATE_AND_UPDATE",
    "atomicMode": "ALL",
    "mergeMode": "REPLACE",
    "flushMode": "AUTO",
    "skipSharing": false,
    "skipTranslation": false,
    "skipValidation": false,
    "metadataSyncImport": false,
    "firstRowIsHeader": true,
    "username": "UNICEF_admin"
  },
  "status": "OK",
  "typeReports": [
    {
      "klass": "org.hisp.dhis.dataelement.DataElement",
      "stats": {
        "created": 2,
        "updated": 0,
        "deleted": 0,
        "ignored": 0,
        "total": 2
      }
    },
    {
      "klass": "org.hisp.dhis.indicator.Indicator",
      "stats": {
        "created": 1,
        "updated": 0,
        "deleted": 0,
        "ignored": 0,
        "total": 1
      }
    }
  ],
  "stats": {
    "created": 3,
    "updated": 0,
    "deleted": 0,
    "ignored": 0,
    "total": 3
  }
}
```


## Schéma { #webapi_schema } 

Pour effectuer une introspection sur tous les objets DXF 2 disponibles, vous pouvez utiliser une ressource disponible à l'adresse `/api/schemas`. Pour obtenir des ressources spécifiques, vous pouvez consulter `/api/schemas/<type>`.

Pour obtenir tous les schémas disponibles au format XML :

    GET /api/schemas.xml

Pour obtenir tous les schémas disponibles au format JSON :

    GET /api/schemas.json

Pour obtenir le schéma JSON d'une classe spécifique :

    GET /api/schemas/dataElement.json


## Icônes { #webapi_icons } 

DHIS2 includes a collection of icons that can be used to give visual
context to metadata. These icons can be accessed through the icons
resource.

    GET /api/icons

This endpoint returns a list of information about the available icons.
Each entry contains information about the icon, and a reference to the
actual icon.

```json
{
  key: "mosquito_outline",
  description: "Mosquito outline",
  keywords: [
    "malaria",
    "mosquito",
    "dengue"
  ],
  href: "<dhis server>/api/icons/mosquito_outline/icon.svg"
}
```

The keywords can be used to filter which icons to return. Passing a list
of keywords with the request will only return icons that match all the
keywords:

    GET /api/icons?keywords=shape,small

A list of all unique keywords can be found at the keywords resource:

    GET /api/icons/keywords

## Type de rendu { #webapi_render_type } 

Certains types de métadonnées ont une propriété appelée *renderType* (type de rendu). Cette propriété établit une correspondance entre un *appareil* et un *type de restitution* (renderingType). Les applications peuvent utiliser ces informations pour savoir comment l'objet doit être rendu sur un appareil spécifique. Par exemple, le rendu d'un élément de données sur un appareil mobile peut être différent de celui d'un ordinateur de bureau.

Il existe actuellement deux types de restitution :

1.  Restitution du type de valeur

2.  Restitution des sections d'étape de programme

Il existe également deux types d'appareils :

1.  MOBILE

2.  DESKTOP

Le tableau suivant énumère les types de métadonnées et de restitution disponibles.
La restitution du type de valeur a des contraintes supplémentaires basées sur la configuration des métadonnées. Elles seront présentées dans un second tableau.

Tableau : Aperçu des métadonnées et des types de restitution

| Type de métadonnées | Types de restitution disponibles |
|---|---|
| Section des étapes de programme | * LISTING (par défaut)<br> * SEQUENTIAL<br> * MATRIX |
| Élément de données | * DEFAULT<br> * DROPDOWN<br> * VERTICAL_RADIOBUTTONS<br> * HORIZONTAL_RADIOBUTTONS<br> * VERTICAL_CHECKBOXES<br> * HORIZONTAL_CHECKBOXES<br> * SHARED_HEADER_RADIOBUTTONS<br> * ICONS_AS_BUTTONS<br> * SPINNER<br> * ICON<br> * TOGGLE<br> * VALUE<br> * SLIDER<br> * LINEAR_SCALE |

Étant donné que la gestion de la restitution par défaut des éléments de données et des attributs d'entités suivies dépend du type de valeur de l'objet, il existe également un type DEFAULT pour indiquer au client qu'il doit être traité normalement. La section des étapes de programme est définie sur LISTING par défaut.

Tableau : Types de restitution autorisés en fonction des types de valeurs

| Type de valeur | L'objet est-il un ensemble d'options ? | Types de restitution autorisés |
|---|---|---|
| TRUE_ONLY (vrai uniquement) | Non | DEFAULT, VERTICAL_RADIOBUTTONS, HORIZONTAL_RADIOBUTTONS, VERTICAL_CHECKBOXES, HORIZONTAL_CHECKBOXES, TOGGLE |
| BOOLÉEN | Non ||
| - | Oui | DEFAULT, DROPDOWN, VERTICAL_RADIOBUTTONS, HORIZONTAL_RADIOBUTTONS, VERTICAL_CHECKBOXES, HORIZONTAL_CHECKBOXES, SHARED_HEADER_RADIOBUTTONS, ICONS_AS_BUTTONS, SPINNER, ICON |
| INTEGER | Non | DEFAULT, VALUE, SLIDER, LINEAR_SCALE, SPINNER |
| INTEGER_POSITIVE | Non ||
| INTEGER_NEGATIVE | Non ||
| INTEGER_ZERO_OR_POSITIVE | Non ||
| NUMBER | Non ||
| UNIT_INTERVAL | Non ||
| PERCENTAGE | Non ||

Vous pouvez également récupérer une référence complète du tableau précédent en utilisant le point d'extrémité suivant :

    GET /api/staticConfiguration/renderingOptions

Quelques propriétés supplémentaires peuvent être définies pour la restitution du type de valeur ; ce qui est souvent nécessaire lors de la restitution de certains types spécifiques :

Tableau : propriétés de l'objet renderType

| Propriété | Description | Type |
|---|---|---|
| type | Le type de restitution de l'objet, tel qu'indiqué dans le premier tableau. Cette propriété est la même pour le type de valeur et la section des étapes de programme, mais c'est la seule propriété disponible pour la section des étapes de programme. | Énumération (voir la liste dans le tableau des métadonnées et des types de restitution) |
| min | Uniquement pour la restitution du type de valeur ; il représente la valeur minimale que ce champ peut avoir. | Entier |
| max | Uniquement pour la restitution du type de valeur ; il représente la valeur maximale que ce champ peut avoir. | Entier |
| étape | Uniquement pour la restitution de type valeur ; il représente la taille des étapes que la valeur doit augmenter, par exemple pour SLIDER ou LINEAR_SCALE. | Entier |
| points décimaux | Uniquement pour la restitution du type de valeur ; il représente le nombre de points décimaux que la valeur doit utiliser. | Entier |

Le *type de restitution* peut être défini lors de la création ou de la mise à jour des métadonnées énumérées dans le premier tableau. Voici un exemple de charge pour le type de restitution de la section des étapes de programme :

```json
{
  "renderingType": {
    "type": "MATRIX"
  }
}
```

Pour les éléments de données et les attributs d'entités suivies :

```json
{
  "renderingType": {
    "type": "SLIDER",
    "min": 0,
    "max": 1000,
    "step": 50,
    "decimalPoints": 0
  }
}
```

## Style d'objet { #webapi_object_style } 

La plupart des métadonnées ont une propriété "style". Cette propriété peut être utilisée par les clients pour représenter l'objet d'une certaine manière. Les propriétés actuellement prises en charge par le style sont les suivantes :

Tableau : Propriétés du style

| Propriété | Description | Type |
|---|---|---|
| couleur | Une couleur, représentée par une valeur hexadécimale. | Chaîne (#000000) |
| icône | Une icône, représentée par un nom d'icône. | Chaîne |

Actuellement, il n'existe pas de liste officielle ni de bibliothèques d'icônes. Il revient donc au client de les fournir. La liste suivante présente tous les objets qui prennent en charge le style :

  - Élément de données

  - Option de catégorie d'éléments de données

  - Ensemble de données

  - Indicateur

  - Option

  - Programme

  - Indicateur du programme

  - Section du programme

  - Étape du programme

  - Section des étapes de programme

  - Relation (Tracker)

  - Attribut d’entité suivie

  - Type d'entité suivie

Lors de la création ou de la mise à jour de l'un de ces objets, vous pouvez inclure la charge suivante pour modifier le style :

```json
{
  "style": {
    "color": "#ffffff",
    "icon": "my-beautiful-icon"
  }
}
```

## Indicateurs { #webapi_indicators } 

Cette section décrit les indicateurs et les expressions d'indicateurs.

### Indicateurs agrégés { #webapi_aggregate_indicators } 

Pour récupérer les indicateurs, vous pouvez lancer une requête GET à la ressource des indicateurs comme suit :

    /api/indicators

Les indicateurs représentent des expressions qui peuvent être calculées et présentées sous forme de résultat. Les expressions des indicateurs sont divisées en un numérateur et un dénominateur. Les numérateurs et les dénominateurs sont des expressions mathématiques qui peuvent contenir des références à des éléments de données, à d'autres indicateurs, à des constantes et à des groupes d'unités d'organisation. Les variables seront remplacées par des valeurs de données lorsqu'elles seront utilisées, par exemple dans des rapports. Les variables autorisées dans les expressions sont décrites dans le tableau suivant.

Traduit avec DeepL.com (version gratuite)

Tableau : Variables d'indicateurs

| Variable | Objet | Description |
|---|---|---|
| #{<data-element-id\>.<category-option-combo-id\>.<attribute-option-combo-id\>} | Opérande de l'élément de données | Fait référence à la combinaison d'un élément de données agrégé et d'une combinaison d'options de catégorie. Les identifiants des combinaisons d'options de catégorie et d'attribut sont facultatifs et le symbole "\*" peut être utilisé pour indiquer n'importe quelle valeur. |
| #{<dataelement-id\>.<category-option-group-id\>.<attribute-option-combo-id\>} | Groupe d'options de catégorie | Fait référence à un élément de données agrégé et à un groupe d'options de catégorie, qui contient plusieurs combinaisons d'options de catégorie. |
| #{<data-element-id\>} | Élément de données agrégées | Fait référence à la valeur totale d'un élément de données agrégé pour toutes les combinaisons d'options de catégorie. |
| D{<program-id\>.<data-element-id\>} | Élément de données de programme | Fait référence à la valeur d'un élément de données Tracker au sein d'un programme. |
| A{<program-id\>.<attribute-id\>} | Attribut d'entité suivie d'un programme | Fait référence à la valeur d'un attribut d'entité suivie au sein d'un programme. |
| I{<program-indicator-id\>} | Indicateur de programme | Fait référence à la valeur d'un indicateur de programme. |
| R{<dataset-id\>.<metric\>} | Taux de déclaration | Fait référence à une mesure de taux de déclaration. La mesure peut être REPORTING_RATE (taux de déclaration), REPORTING_RATE_ON_TIME (taux de déclarations à temps), ACTUAL_REPORTS (rapports envoyés), ACTUAL_REPORTS_ON_TIME (rapports envoyés à temps), EXPECTED_REPORTS (rapports attendus). |
| C{<constant-id\>} | Constante | Fait référence à une valeur constante. |
| N{<indicator-id\>} | Indicateur | Fait référence à un indicateur existant. |
| OUG{<orgunitgroup-id\>} | Groupe d'unités d'organisation | Fait référence au nombre d'unités d'organisation présentes dans un groupe d'unités d'organisation. |

Dans un opérande d'élément de données ou dans un élément de données agrégé, les substitutions suivantes peuvent être effectuées :

| Élément | Valeur | Description |
|---|---|---|
| identifiant de l'élément de données (data-element-id) | identifiant de l'élément de données (data-element-id) | Un élément de données agrégé |
| identifiant de l'élément de données (data-element-id) | deGroup:data-element-group-id | Tous les éléments de données agrégés d'un groupe d'éléments de données |
| category-option-combo-id (identifiant de la combinaison d'options de catégorie) | category-option-combo-id (identifiant de la combinaison d'options de catégorie) | Une combinaison d'options de catégorie |
| category-option-combo-id (identifiant de la combinaison d'options de catégorie) | co:category-option-id | Toutes les combinaisons d'options de catégorie dans une option de catégorie |
| category-option-combo-id (identifiant de la combinaison d'options de catégorie) | coGroup:category-option-group-id | Toutes les combinaisons d'options de catégorie dans un groupe d'options de catégorie |
| category-option-combo-id (identifiant de la combinaison d'options de catégorie) | coGroup:co-group-id1&co-group-id2... | Toutes les combinaisons d'options de catégorie qui font partie de plusieurs groupes d'options de catégorie |

La syntaxe ressemble à ceci :

    #{<dataelement-id>.<catoptcombo-id>} + C{<constant-id>} + OUG{<orgunitgroup-id>}

Un exemple correspondant se présente comme suit :

    #{P3jJH5Tu5VC.S34ULMcHMca} + C{Gfd3ppDfq8E} + OUG{CXw2yu5fodb}

Pour les variables d'éléments de données, l'identifiant de la combinaison d'options de catégorie peut être omis. La variable va alors représenter le total pour l'élément de données, par exemple pour toutes les combinaisons d'options de catégorie. Exemple :

    #{P3jJH5Tu5VC} + 2

Les opérandes des éléments de données peuvent inclure toute combinaison d'options de catégorie et toute combinaison d'options d'attributs. Elles peuvent également utiliser des caractères génériques pour indiquer n'importe quelle valeur :

    #{P3jJH5Tu5VC.S34ULMcHMca} + #{P3jJH5Tu5VC.*.j8vBiBqGf6O} + #{P3jJH5Tu5VC.S34ULMcHMca.*}

Exemple d'utilisation d'un groupe d'éléments de données :

    #{deGroup:oDkJh5Ddh7d} + #{deGroup:GBHN1a1Jddh.j8vBiBqGf6O}

Exemple utilisant une option de catégorie, un groupe d'éléments de données et un groupe d'options de catégorie :

    #{P3jJH5Tu5VC.co:FbLZS3ueWbQ} + #{deGroup:GBHN1a1Jddh.coGroup:OK2Nr4wdfrZ.j8vBiBqGf6O}

Exemple d'utilisation de plusieurs groupes d'options de catégories :

    #{P3jJH5Tu5VC.coGroup:OK2Nr4wdfrZ&j3C417uW6J7&ddAo6zmIHOk}

Exemple utilisant un élément de données de programme et un attribut de programme :

    ( D{eBAyeGv0exc.vV9UWAZohSf} * A{IpHINAT79UW.cejWyOfXge6} ) / D{eBAyeGv0exc.GieVkTxp4HH}

Exemple combinant des indicateurs de programme et des indicateurs agrégés :

    I{EMOt6Fwhs1n} * 1000 / #{WUg3MYWQ7pt}

Exemple utilisant un taux de déclaration :

    R{BfMAe6Itzgt.REPORTING_RATE} * #{P3jJH5Tu5VC.S34ULMcHMca}

Un autre exemple de taux de déclaration qui utilise des rapports sur des ensembles de données et des rapports attendues :

    R{BfMAe6Itzgt.ACTUAL_REPORTS} / R{BfMAe6Itzgt.EXPECTED_REPORTS}

Exemple utilisant un indicateur existant :

    N{Rigf2d2Zbjp} * #{P3jJH5Tu5VC.S34ULMcHMca}

Les expressions peuvent être constituées de tout type d'expression mathématique valide, à titre d'exemple :

    ( 2 * #{P3jJH5Tu5VC.S34ULMcHMca} ) / ( #{FQ2o8UBlcrS.S34ULMcHMca} - 200 ) * 25

### ![](resources/images/pivot_table/table_layout.png) { #webapi_program_indicators } 

Pour récupérer les indicateurs de programme, vous pouvez effectuer une requête GET à la ressource des indicateurs de programme, comme suit :

    /api/programIndicators

Les indicateurs de programme peuvent contenir des informations collectées dans le cadre d'un programme. Les indicateurs ont une expression qui peut contenir des références à des éléments de données, des attributs, des constantes et des variables de programme. Les variables autorisées dans les expressions sont décrites dans le tableau suivant.



Tableau : Variables des indicateurs du programme

| Variable | Description |
|---|---|
| #{<programstage-id\>.<dataelement-id\>} | Fait référence à une combinaison entre l'étape de programme et l'identifiant de l'élément de données. |
| A{<attribute-id\>} | Fait référence à un attribut d'entité suivie. |
| V{<variable-id\>} | Fait référence à une variable de programme. |
| C{<constant-id\>} | Fait référence à une constante. |

La syntaxe ressemble à ceci :

    #{<programstage-id>.<dataelement-id>} + #{<attribute-id>} + V{<varible-id>} + C{<constant-id>}

Voici un exemple correspondant :

    #{A03MvHHogjR.a3kGcGDCuk6} + A{OvY4VVhSDeJ} + V{incident_date} + C{bCqvfPR02Im}

### Expressions { #webapi_expressions } 

Les expressions sont des formules mathématiques qui peuvent contenir des références à des éléments de données, des constantes et des groupes d'unités d'organisation. Pour valider une expression et en obtenir la description sous forme de texte, vous pouvez adresser une requête GET à la ressource des expressions :

    /api/expressions/description?expression=<expression-string>

La réponse suit le format standard des messages web JSON. La propriété *statut* indique le résultat de la validation et sera "OK" en cas de succès et "ERROR" en cas d'échec. La propriété *message* sera "Valid" (valide) si la validation réussit, et en cas d'échec, elle fournira une description textuelle de la raison de cet échec. La propriété *description* fournit une description textuelle de l'expression.

```json
{
  "httpStatus": "OK",
  "httpStatusCode": 200,
  "status": "OK",
  "message": "Valid",
  "description": "Acute Flaccid Paralysis"
}
```

## Les unités d’organisation { #webapi_organisation_units } 

La ressource *organisationUnits* suit les conventions standard des autres ressources de métadonnées présents dans DHIS2. Cette ressource prend en charge des paramètres de requête supplémentaires.

### Obtenir la liste des unités d'organisation { #webapi_list_of_organisation_units } 

Pour obtenir une liste des unités d'organisation, vous pouvez utiliser la ressource suivante :

    /api/33/organisationUnits

Tableau : Paramètres de requête des unités d'organisation

| Paramètre de requête | Options | Description |
|---|---|---|
| userOnly (utilisateur uniquement) | faux &#124; vrai | Unités d'organisation de saisie des données associées à l'utilisateur actuel. |
| userDataViewOnly | faux &#124; vrai | Unités d'organisation de visualisation de données associées à l'utilisateur actuel. |
| userDataViewFallback | faux &#124; vrai | Unités d'organisation de visualisation de données associées à l'utilisateur actuel, avec un retour aux unités d'organisation de saisie de données. |
| requête | chaîne | Requête sur les propriétés de nom, code et ID. |
| District | entier | Unités d'organisation au niveau spécifié de la hiérarchie. |
| maxLevel | entier | Unités d'organisation au niveau maximal ou à des niveaux plus élevés dans la hiérarchie. |
| withinUserHierarchy | faux &#124; vrai | Limite la recherche et l'extraction aux unités d'organisation qui se trouvent dans le champ de saisie de l'utilisateur. |
| withinUserSearchHierarchy | faux &#124; vrai | Limite la recherche et l'extraction aux unités d'organisation qui se trouvent dans le champ de recherche de l'utilisateur actuel. Remarque : Si "withinUserHierarchy" est défini sur "true", il devient prioritaire. |
| memberCollection | chaîne | Permet d'afficher le nombre de membres dans une collection ; renvoie au nom de la collection associée aux unités d'organisation. |
| memberObject | UID | Permet d'afficher le nombre de membres dans une collection ; renvoie à l'identifiant de l'objet qui fait partie de la collection. |

### Obtenir une unité d'organisation avec une sous-hiérarchie { #webapi_organisation_units_with_sub_hierarchy } 

Pour obtenir une unité d'organisation ainsi que les unités d'organisation présentes dans sa sous-hiérarchie, vous pouvez utiliser la ressource suivante.

    /api/33/organisationUnits/{id}

Tableau : Paramètres de l'unité d'organisation

| Paramètre de requête | Options | Description |
|---|---|---|
| Inclut les enfants | faux &#124; vrai | Inclut les subordonnées directs de l'unité d'organisation spécifiée, c'est-à-dire les unités qui lui sont directement inférieures dans la sous-hiérarchie. |
| includeDescendants | faux &#124; vrai | Inclut tous les descendants de l'unité d'organisation spécifiée, c'est-à-dire toutes les unités qui lui sont inférieures dans la hiérarchie. |
| includeAncestors | faux &#124; vrai | Inclut tous les ascendants de l'unité d'organisation spécifiée. |
| District | entier | Inclut les descendants de l'unité d'organisation spécifiée à un niveau précis de la sous-hiérarchie. Ce paramètre dépend de l'unité d'organisation, et commence par le premier niveau qui est directement inférieur à l'unité d'organisation. |

### Obtenir des unités d'organisation par option de catégorie{ #webapi_organisation_units_by_category_options }

Point d'extrémité conçu pour récupérer les associations entre les options de catégorie et les unités d'organisation. Ce point d'extrémité est le moyen idéal pour récupérer les associations entre les programmes et les unités d'organisation.

    /api/33/categoryOptions/orgUnits?categoryOptions={categoryOptionIdA},{categoryOptionIdB}

Les réponses auront le format suivant :

```json
{
  "<categoryOptionIdA>": [
    "<orgUnitUid>",
    "<orgUnitUid>"
  ],
  "<categoryOptionIdB>": [
    "<orgUnitUid>",
    "<orgUnitUid>"
  ],
  "<categoryOptionIdC>": []
}
```

Les options de catégorie accessibles à toutes les unités d'organisation sont renvoyées avec un tableau d'unités d'organisation vide (`[]`).

### Obtenir les unités d'organisation par programme { #webapi_organisation_units_by_programs } 

Point d'extrémité conçu pour récupérer les associations entre les programmes et les unités d'organisation. Ce point d'extrémité est le moyen idéal pour récupérer les associations entre les programmes et les unités d'organisation.

    /api/33/programs/orgUnits?programs={programIdA},{programIdB}

Les réponses auront le format suivant :

```json
{
  "<programIdA>": [
    "<orgUnitUid>",
    "<orgUnitUid>"
  ],
  "<programIdB>": [
    "<orgUnitUid>",
    "<orgUnitUid>"
  ],
  "<programIdC>": []
}
```

Les programmes accessibles à toutes les unités d'organisation sont renvoyées avec un tableau d'unités d'organisation vide (`[]`).

### Fractionner des unités d'organisation { #webapi_organisation_unit_split }

Le point d'extrémité de fractionnement des unités d'organisation vous permet de fractionner des unités d'organisation en un certain nombre d'unités d'organisation cibles.

#### Demande { #request } 

Fractionner des unités d'organisation à l'aide d'une requête POST :

```
POST /api/organisationUnits/split
```

La charge au format JSON ressemble à ceci :

```json
{
  "source": "rspjJHg4WY1",
  "targets": [
    "HT0w9YLMLyn",
    "rEpnzuNpRKM"
  ],
  "primaryTarget": "HT0w9YLMLyn",
  "deleteSource": true
}
```

Les propriétés JSON sont décrites dans le tableau suivant.

Tableau : Fractionnement des champs de la charge

| Champ         | Obligatoire | Valeur |
| ------------- | -------- |------ |
| source        | Oui      | Identifiant de l'unité d'organisation à fractionner (l'unité d'organisation source). |
| cibles       | Oui      | Tableau des identifiants des unités d'organisation qui seront le résultat du fractionnement de l'unité source (les unités d'organisation cibles). |
| primaryTarget | Non       | Identifiant de l'unité d'organisation vers laquelle transférer les données agrégées, les événements et les entités suivies associés à l'unité source. S'il n'est pas spécifié, la première cible sera utilisée. |
| deleteSource  | Non       | Détermine si l'unité d'organisation source doit être supprimée après l'opération. La valeur par défaut est `true` |

L'opération de fractionnement consiste à scinder l'unité d'organisation source en unités d'organisation cibles. Il est recommandé de créer de nouvelles unités d'organisation cibles avant d'effectuer le fractionnement, et de s'assurer au préalable qu'il n'existe pas de données agrégées pour les unités d'organisation cibles. Vous pouvez spécifier un nombre quelconque d'unités d'organisation cibles.

L'opération de fractionnement transfère toutes les associations de métadonnées de l'unité d'organisation source vers les unités d'organisation cibles. Cela inclut les ensembles de données, les programmes, les groupes d'unités d'organisation, les options de catégorie, les utilisateurs, les visualisations, les cartes et les rapports d'événements.

L'opération transfère tous les enregistrements de données de l'unité d'organisation source vers l'unité d'organisation spécifiée comme cible principale ou, si elle n'est pas spécifiée, vers la première unité d'organisation cible spécifiée. Cela inclut les valeurs de données agrégées, les enregistrements relatifs à l'approbation des données, les événements, les entités suivies, etc.

#### Validation { #validation } 

Les contraintes et les codes d'erreur suivants s'appliquent.

Tableau : Contraintes et codes d'erreur

| Code d'erreur | Description                                     |
| ---------- | ----------------------------------------------- |
| E1510      | L'unité d'organisation source doit être spécifiée               |
| E1511      | Au moins deux unités d'organisation cibles doivent être spécifiées |
| E1512      | L'unité d'organisation source ne peut pas être une unité d'organisation cible     |
| E1513      | La cible principale doit être spécifiée                |
| E1514      | La cible principale doit être une unité d'organisation cible        |
| E1515      | L'unité d'organisation cible n'existe pas                  |

### Merge organisation units { #webapi_organisation_unit_merge}

Le point d'extrémité de fusion des unités d'organisation vous permet de fusionner des unités d'organisation en une seule unité d'organisation cible.

#### Demande { #request } 

Fusionner des unités d'organisation à l'aide d'une requête POST :

```
POST /api/organisationUnits/merge
```

La charge au format JSON ressemble à ceci :

```json
{
  "sources": [
    "jNb63DIHuwU",
    "WAjjFMDJKcx"
  ],
  "target": "V9rfpjwHbYg",
  "dataValueMergeStrategy": "LAST_UPDATED",
  "dataApprovalMergeStrategy": "LAST_UPDATED",
  "deleteSources": true
}
```

Les propriétés JSON sont décrites dans le tableau suivant.

Tableau : Fusion des champs de la charge

| Champ                     | Obligatoire | Valeur |
| ------------------------- | -------- | ----- |
| sources                   | Oui      | Tableau des identifiants des unités d'organisation à fusionner (unités d'organisation source). |
| cible                    | Oui      | Identifiant de l'unité d'organisation qui sera le résultat de la fusion des unités source (l'unité d'organisation cible). |
| dataValueMergeStrategy    | Non       | Stratégie de fusion des valeurs de données. Options : `LAST_UPDATED` (par défaut), `DISCARD`. |
| dataApprovalMergeStrategy | Non       | Stratégie de fusion des enregistrements relatifs à l'approbation des données. Options : `LAST_UPDATED` (par défaut), `DISCARD`. |
| deleteSources             | Non       | Détermine si les unités d'organisation source doivent être supprimées après l'opération. La valeur par défaut est `true` |

L'opération de fusion consiste à combiner des unités d'organisation source pour former une seule unité cible. Il est recommandé de créer une nouvelle unité d'organisation cible avant de procéder à la fusion, et de s'assurer au préalable l'unité cible ne contient pas de données agrégées. Vous pouvez spécifier un nombre quelconque d'unités d'organisation source.

L'opération de fusion transfère toutes les associations de métadonnées des unités d'organisation sources vers l'unité d'organisation cible. Cela inclut les ensembles de données, les programmes, les groupes d'unités d'organisation, les options de catégorie, les utilisateurs, les visualisations, les cartes et les rapports d'événements. L'opération transfère également toutes les données d'événements et de tracker, telles que les événements, les inscriptions, l'historique de la propriété, la propriété des programmes et les entités suivies, vers l'unité d'organisation cible.

La stratégie de fusion des valeurs de données spécifiée définit la manière dont les valeurs de données sont traitées. Pour la stratégie `LAST_UPDATED`, les valeurs de données de toutes les unités d'organisation sources sont transférées vers l'unité d'organisation cible, et lorsque des valeurs existent pour les mêmes paramètres, c'est la dernière valeur mise à jour ou créée qui sera utilisée. Ceci permet d'éviter la répétition des données. Pour la stratégie `DISCARD`, les valeurs ne sont pas transférées vers l'unité d'organisation cible, mais elles sont simplement supprimées. La stratégie de fusion de l'approbation des données spécifiée définit la manière dont les enregistrements relatifs à l'approbation des données sont traités, et suit la même logique que les valeurs de données.

#### Validation { #validation } 

Les contraintes et les codes d'erreur suivants s'appliquent.

Tableau : Contraintes et codes d'erreur

| Code d'erreur | Description                                     |
| ---------- | ----------------------------------------------- |
| E1500      | Au moins deux unités d'organisation sources doivent être spécifiées |
| E1501      | L'unité d'organisation cible doit être spécifiée               |
| E1502      | L'unité d'organisation cible ne peut pas être une unité d'organisation source     |
| E1503      | L'unité d'organisation source n'existe pas                  |

## Ensembles de données { #webapi_data_sets } 

La ressource *dataSets* suit les conventions standard des autres ressources de métadonnées présents dans DHIS2. Cette ressource prend en charge des paramètres de requête supplémentaires.

    /api/33/dataSets

Pour récupérer la version d'un ensemble de données, vous pouvez envoyer une requête GET :

    GET /api/33/dataSets/<uid>/version

Pour augmenter (d'une unité) la version d'un ensemble de données, vous pouvez effectuer une requête POST :

    POST /api/33/dataSets/<uid>/version

### Modèle de notification d'un ensemble de données { #webapi_dataset_notifications } 

La ressource *modèles de notification des ensembles de données* suit les conventions standard des autres ressources de métadonnées présentes dans DHIS2.

    GET /api/33/dataSetNotficationTemplates

Pour récupérer un modèle de notification d'ensemble de données, vous pouvez effectuer une requête GET :

    GET /api/33/dataSetNotficationTemplates/<uid>

Pour ajouter un modèle de notification d'ensemble de données, vous pouvez effectuer une requête POST :

    POST /api/33/dataSetNotficationTemplates

Pour supprimer un modèle de notification d'ensemble de données, vous pouvez effectuer une requête DELETE :

    DELETE /api/33/dataSetNotficationTemplates/<uid>

Ci-dessous, un exemple de charge JSON :

```json
{
  "name": "dataSetNotificationTemplate1",
  "notificationTrigger": "COMPLETION",
  "relativeScheduledDays": 0,
  "notificationRecipient": "ORGANISATION_UNIT_CONTACT",
  "dataSets": [{
    "id": "eZDhcZi6FLP"
  }],
  "deliveryChannels": ["SMS"],
  "subjectTemplate": "V{data_name}",
  "messageTemplate": "V{data_name}V{complete_registration_period}",
  "sendStrategy": "SINGLE_NOTIFICATION"
}

```

## Niveaux d'unités d'organisation renseignés{ #webapi_filled_organisation_unit_levels } 

La ressource *filledOrganisationUnitLevels* fournit une liste ordonnée de niveaux d'unités d'organisation, où les niveaux générés sont introduits dans la liste pour remplir les positions pour lesquelles il n'existe pas de niveau.

    GET /api/33/filledOrganisationUnitLevels

Pour définir des niveaux d'unité d'organisation, vous pouvez envoyer une requête POST avec une charge JSON et un type de contenu `application/json` comme ceci :

```json
{
  "organisationUnitLevels": [{
    "name": "National",
    "level": 1,
    "offlineLevels": 3
  }, {
    "name": "District",
    "level": 2
  }, {
    "name": "Chiefdom",
    "level": 3
  }, {
    "name": "Facility",
    "level": 4
  }]
}
```

## Les prédicteurs { #webapi_predictors } 

Un prédicteur permet de générer des valeurs de données sur la base d'une expression.
Il peut être utilisé, par exemple, pour générer des cibles, des seuils ou des estimations de valeurs.

Pour récupérer les prédicteurs, vous pouvez effectuer une requête GET à la ressource des prédicteurs comme suit :

    /api/predictors

### Création d'un prédicteur { #webapi_create_predictor } 

Vous pouvez créer un prédicteur à l'aide d'une requête POST à la ressource des prédicteurs :

    POST /api/predictors

Voici un exemple de charge :

```json
{
  "id": "AG10KUJCrRk",
  "name": "Malaria Outbreak Threshold Predictor",
  "shortName": "Malaria Outbreak Predictor",
  "description": "Computes the threshold for potential malaria outbreaks based on the mean plus 1.5x the std dev",
  "output": {
    "id": "nXJJZNVAy0Y"
  },
  "generator": {
    "expression": "AVG(#{r6nrJANOqMw})+1.5*STDDEV(#{r6nrJANOqMw})",
    "description": "Maximum normal malaria case count",
    "missingValueStrategy": "NEVER_SKIP",
    "slidingWindow": false
  },
  "periodType": "Monthly",
  "sequentialSampleCount": 4,
  "sequentialSkipCount": 1,
  "annualSampleCount": 3,
  "organisationUnitLevels": [4]
}
```

L'élément de sortie fait référence à l'identifiant de l'élément de données pour lequel des valeurs de données prédites doivent être sauvegardées.
L'élément générateur fait référence à l'expression qui sera utilisée pour calculer les valeurs prédites.

### Expressions du prédicteur { #webapi_predictor_expressions } 

Un prédicteur possède toujours une expression génératrice qui décrit le mode de calcul de la valeur prédite. Le prédicteur peut également avoir une expression permettant de tester la fonction de saut, laquelle expression renvoie une valeur booléenne. Lorsque l'expression de test de saut est présente, elle est évaluée dans chacune des périodes échantillonnées pour déterminer si les valeurs de cette période doivent être ignorées.

Les variables suivantes peuvent être utilisées dans une expression génératrice ou dans une expression de test de saut :

| Variable    | Objet     | Description |
| ----------- | ---------- | ----------- |
| #{<dataelement-id>} | Élément de données agrégées | Fait référence à la valeur totale d'un élément de données agrégé pour toutes les combinaisons d'options de catégorie. |
| #{<dataelement-id>.<categoryoptcombo-id> | Opérande de l'élément de données | Fait référence à une combinaison entre un élément de données agrégé et une combinaison d'options de catégorie. |
| D{<program-id>.<dataelement-id>} | Élément de données de programme | Fait référence à la valeur d'un élément de données Tracker au sein d'un programme. |
| A{<program-id>.<attribute-id>} | Attribut d'entité suivie d'un programme | Fait référence à la valeur d'un attribut d'entité suivie au sein d'un programme. |
| I{<program-indicator-id>} | Indicateur de programme | Fait référence à la valeur d'un indicateur de programme. |
| R{<dataset-id>.<metric>} | Taux de déclaration | Fait référence à une mesure de taux de déclaration. La mesure peut être REPORTING_RATE (taux de déclaration), REPORTING_RATE_ON_TIME (taux de déclarations à temps), ACTUAL_REPORTS (rapports envoyés), ACTUAL_REPORTS_ON_TIME (rapports envoyés à temps), EXPECTED_REPORTS (rapports attendus). |
| C{<constant-id>} | Constante | Fait référence à une valeur constante. |
| OUG{<orgunitgroup-id>} | Groupe d'unités d'organisation | Fait référence au nombre d'unités d'organisation présentes dans un groupe d'unités d'organisation. |
| [days] | Nombre de jours | Le nombre de jours dans la période actuelle. |

### Génération de valeurs prédites { #webapi_generating_predicted_values } 

Pour exécuter tous les prédicteurs (générer des valeurs prédites), vous pouvez effectuer une requête POST à la ressource d'exécution :

    POST /api/predictors/run

Pour exécuter un seul prédicteur, vous pouvez envoyer une requête POST à la ressource d'exécution et préciser le prédicteur :

    POST /api/predictors/AG10KUJCrRk/run

## Règles du programme { #webapi_program_rules } 

Cette section traite de l'envoi et de la lecture des règles de programme et explique leur modèle de données. Les règles de programme permettent de configurer un fonctionnement dynamique au sein des programmes de DHIS2.

### Modèle de règles de programme { #webapi_program_rule_model } 

Le modèle de données des règles de programme se compose de variables de règles de programme (programRuleVariables), de règles de programme (programRules) et d'actions de règles de programme (programRuleActions). La règle de programme contient une expression - lorsque cette expression est définie sur "true" (vrai), les actions de règle de programme sous cette expression sont déclenchées. Les variables de règle de programme sont utilisées pour traiter les éléments de données, les valeurs de données des entités suivies et d'autres valeurs de données nécessaires à l'exécution des expressions. Toutes les règles d'un programme partagent la même bibliothèque de variables de règles, et une variable peut être utilisée dans les expressions de plusieurs règles.

![](resources/images/program_rules/program-rule-model.jpg)

#### Détails sur le modèle de règles de programme { #program-rule-model-details } 

Le tableau suivant donne un aperçu détaillé du modèle de règle de programme.

Tableau : Règle de programme

| nom | Description | Obligatoire |
|---|---|---|
| de paludisme) ». | Le programme dans lequel la règle est exécutée. | Obligatoire |
| nom | Le nom sous lequel la règle de programme sera affichée aux configurateurs de dhis2. Il n'est pas visible pour l'utilisateur final du programme. | Obligatoire |
| Description | La description de la règle de programme peut être utilisée par les configurateurs pour décrire la règle. Elle n'est pas visible pour l'utilisateur final du programme. | Obligatoire |
| Étape du programme | Si une étape de programme est définie pour une règle de programme, la règle ne sera évaluée qu'à l'intérieur de l'étape de programme spécifiée. | facultatif |
| condition | L'expression dont l'évaluation doit être définie sur "true" pour que la règle de programme déclenche les actions qu'elle contient. L'expression est écrite à l'aide d'opérateurs, d'appels de fonctions, de valeurs codées en dur, de constantes et de variables de règles de programme. `d2:hasValue('hemoglobin') && #{hemoglobin} <= 7 `| Obligatoire |
| priorité | La priorité d'exécution de la règle lorsque l'ordre des règles est important. 
Dans la plupart des cas, les règles ne dépendent pas de leur exécution avant ou après d'autres règles, et dans ces cas, la priorité d'exécution peut être omise. Si aucune priorité n'est définie pour une règle, celle-ci sera exécutée après toutes les règles pour lesquelles une priorité d'exécution a été définie. Si une priorité (integer) est définie, la règle la moins prioritaire sera exécutée avant les règles plus prioritaires. | facultatif |

#### Détails sur le modèle d'action de la règle de programme { #program-rule-action-model-details } 

Le tableau suivant donne un aperçu détaillé du modèle d'action de la règle de programme.

Tableau : Action de règle de programme

| nom | Description | Obligatoire |
|---|---|---|
| Règle de programme | La règle de programme qui est à l'origine de cette action. | Obligatoire |
| programRule- ActionType (règle de programme - type d'action) | Le type d'action à effectuer.<br> * `DISPLAYTEXT` - Affiche un texte dans un widget.<br> * `DISPLAYKEYVALUEPAIR` - Affiche une paire clé/valeur (comme un indicateur de programme) dans un widget.<br> * `HIDEFIELD` - Cache un élément de données ou un attribut d'entité suivie spécifiés.<br> - *content* (contenu) - s'il est défini, le texte contenu dans *content* sera affiché à l'utilisateur final si une valeur a été saisie dans un champ qui est maintenant sur le point d'être caché (et donc masqué). Si *content* n'est pas défini, un message standard sera affiché à l'utilisateur.<br> - *dataElement* (élément de données) - s'il est défini, l'action HIDEFIELD masquera cet élément de données lorsque la règle sera effective.<br> - *trackedEntityDataValue* (valeur de données de l'entité suivie) - si elle est définie, l'action HIDEFIELD masquera cette trackedEntityDataValue lorsque la règle sera effective.<br> * `HIDESECTION` - Cache une section spécifiée.<br> - *programStageSection* (section d'étape de programme) - doit être défini. Il s'agit de la section d'étape de programme qui sera masquée si la règle mère est effective.<br> * `ASSIGN` - Assigne une valeur à un élément de données (aide l'utilisateur à calculer une valeur ou à remplir une valeur évidente dans un emplacement spécifique)<br> - *content* - s'il est défini, la valeur contenue dans *data* est attribuée à cette variable. Si l'identifiant du contenu est défini, et qu'une variable est donc attribuée pour être utilisée dans d'autres règles, il est important d'attribuer également une *programRule.priority* (priorité de règle de programme) pour s'assurer que la règle avec une action ASSIGN s'exécute avant la règle qui évaluera à son tour la variable attribuée.<br> - *data* - doit être défini. Les données forment une expression qui est évaluée et assignée soit à une variable (#{myVariable}), soit à un élément de données, soit aux deux.<br> - *dataElement* - s'il est défini, la valeur contenue dans *data* est attribuée à cet élément de données.<br> Le contenu ou l'élément de données doit être défini pour que l'action ASSIGN soit effective.<br> * `SHOWWARNING` - Affiche un avertissement à l'utilisateur, sans l'empêcher de terminer l'événement ou l'enregistrement.<br> - *content* - s'il est défini, le contenu devient une partie statique qui sera affichée à la fin du message d'erreur.<br> - *data* - s'il est défini, les données vont former une expression qui sera évaluée et ajoutée à la fin du message d'avertissement.<br> - *dataElement* - s'il est défini, le message d'avertissement sera affiché à côté de cet élément de données.<br> - *trackedEntityAttribute* (attribut d'entité suivie) - s'il est défini, le message d'avertissement va s'afficher à côté de cet attribut d'entité suivie.<br> Il faudra spécifier soit l'élément de données, soit l'attribut de l'entité suivie.<br> * `SHOWERROR` - Affiche une erreur à l'utilisateur, l'empêchant de terminer l'événement ou l'enregistrement.<br> - *content* - s'il est défini, le contenu devient une partie statique qui sera affichée au début du message d'erreur.<br> - *data* - s'il est défini, les données forment une expression qui est évaluée et ajoutée à la fin du message d'erreur.<br> - *dataElement* - s'il est défini, le message d'erreur est relié à cet élément de données.<br> - *trackedEntityAttribute* - s'il est défini, le message d'erreur est relié à cet attribut d'entité suivie.<br> Il faudra spécifier soit l'élément de données, soit l'attribut d'entité suivie.<br> * `WARNINGONCOMPLETE` - Affiche un avertissement à l'utilisateur dans la boîte de dialogue "Complete form" (compléter le formulaire), mais permet à l'utilisateur de terminer l'événement.<br> - *content* - s'il est défini, le contenu devient une partie statique qui sera affichée à la fin du message d'erreur.<br> - *data* - s'il est défini, les données forment une expression qui est évaluée et ajoutée à la fin du message d'avertissement.<br> - *dataElement* - s'il est défini, le message d'avertissement est précédé du nom/nom du formulaire de l'élément de données.<br> * `ERRORONCOMPLETE` - Affiche une erreur à l'utilisateur dans une fenêtre modale lorsque l'utilisateur tente de terminer l'événement. Ceci empêche l'utilisateur de terminer l'événement.<br> - *content* - s'il est défini, le contenu devient une partie statique qui s'affiche au début du message d'erreur.<br> - *data* - s'il est défini, les données forment une expression qui est évaluée et ajoutée à la fin du message d'erreur.<br> - *dataElement* - s'il est défini, le message d'erreur est relié à cet élément de données.<br> * `CREATEEVENT` - Crée un événement dans la même inscription.<br> - *content* <br>- *data* - s'il est défini, il va contenir les valeurs de données à attribuer à l'événement créé. Le format est le suivant : <uid>:<valeur des données>. Lorsque plusieurs valeurs sont spécifiées, elles sont séparées par une virgule.<br>AcMrnleqHqc:100,AqK1IHqCkEE:'Polyhydramnios' - *programStage* - doit être défini ; il désigne l'étape de programme pour laquelle la règle doit créer un événement.<br> * `SETMANDATORYFIELD` - Définit un champ comme obligatoire.<br> - *dataElement* - s'il est défini, cet élément de données sera rendu obligatoire dans le formulaire de saisie de données.<br> - *trackedEntityAttribute* - S'il est défini, cet attribut d'entité suivie sera rendu obligatoire dans le formulaire d'enregistrement ou le profil.<br> * `SENDMESSAGE` - Pour envoyer un message à la fin d'un événement ou d'une inscription ou lors de la mise à jour d'une valeur de données.<br> - *messageTemplate* - s'il est défini, ce modèle sera envoyé par SMS ou EMAIL en fonction de la valeur du DeliveryChannel (canal d'envoi) dans le modèle de message.<br> * `SCHEDULEMESSAGE` - Permet de programmer un message à la fin d'un événement/d'une inscription ou lors de la mise à jour des données.<br> - *messageTemplate* - s'il est défini, ce modèle sera envoyé par SMS ou EMAIL en fonction de la valeur du DeliveryChannel dans le modèle de message.<br> - *Date d'envoi du message* - Il s'agit de l'expression qui sera utilisée pour évaluer la date programmée. Cette expression doit générer une date ; tout autre résultat sera rejeté et la notification ne sera pas programmée. | Obligatoire |
| emplacement | Utilisé pour les types d'action DISPLAYKEYVALUEPAIR et DISPLAYTEXT afin de désigner le widget dans lequel le texte ou la paire de valeurs clés seront affichés. Il est obligatoire pour DISPLAYKEYVALUEPAIR et DISPLAYTEXT. | Voir la description |
| contenu | Utilisé pour les messages de l'utilisateur dans les différentes actions. Consultez l'aperçu des types d'action pour obtenir une explication détaillée de son utilisation dans chacun des types d'action. Il est obligatoire pour SHOWWARNING, SHOWERROR, WARNINGONCOMPLETE, ERRORONCOMPLETE, DISPLAYTEXT et DISPLAYKEYVALUEPAIR  ; et facultatif pour HIDEFIELD et ASSIGN. | Voir la description |
| données | Utilisé pour les expressions dans les différentes actions. Consultez l'aperçu des types d'action pour obtenir une explication détaillée de son utilisation dans chacun des types d'action. Il est obligatoire pour ASSIGN ; et facultatif pour SHOWWARNING, SHOWERROR, WARNINGONCOMPLETE, ERRORONCOMPLETE, DISPLAYTEXT, CREATEEVENT et DISPLAYKEYVALUEPAIR. | Voir la description |
| élément de données | Utilisé pour relier les actions de règles aux éléments de données. Consultez l'aperçu des types d'action pour obtenir une explication détaillée de son utilisation dans chacun des types d'action. Il est facultatif pour SHOWWARNING, SHOWERROR, WARNINGONCOMPLETE, ERRORONCOMPLETE, ASSIGN et HIDEFIELD. | Voir la description |
| Entité suivie - Attribut | Utilisé pour relier les actions des règles aux attributs d'entités suivies. Consultez l'aperçu des types d'action pour obtenir une explication détaillée de son utilisation dans chacun des types d'action. Il est facultatif pour SHOWWARNING, SHOWERROR et HIDEFIELD. | Voir la description |
| option | Utilisé pour relier les actions des règles aux options. Consultez l'aperçu des types d'action pour obtenir une explication détaillée de leur utilisation dans chacun des types d'action. Il est facultatif pour HIDEOPTION | Voir la description |
| optionGroup (groupes d'options) | Utilisé pour relier les actions des règles aux groupes d'options. Consultez l'aperçu des type d'action pour obtenir une explication détaillée de son utilisation dans chacun des types d'action. Il est obligatoire pour SHOWOPTIONGROUP, HIDEOPTIONGROUP. | Voir la description |
| Étape du programme | Utilisée uniquement pour les actions de la règle CREATEEVENT. Elle est obligatoire pour CREATEEEVENT. | Voir la description |
| programStage- Section (étape de programme - section) | Utilisée uniquement pour les actions de la règle HIDESECTION. Elle est obligatoire pour HIDESECTION | Voir la description |

##### Validation des actions des règles de programme { #programruleaction-validation } 
Certaines validations ont été ajoutées au modèle des actions des règles de programme dans la version 2.37. L'objectif principal était d'empêcher l'utilisateur de créer des règles de programme erronées afin de maintenir la cohérence de la base de données. Ces validations dépendent du type d'action de la règle de programme. Chaque type d'action a sa propre validation. 

Tableau : Validations des actions des règles de programme

| nom | contrôle de validation de l'existence de l'identifiant |
|---|---|
|SENDMESSAGE| Identifiant du modèle de notification |
|SCHEDULEMESSAGE| Identifiant du modèle de notification |
|HIDESECTION| Identifiant de la section de l'étape de programme |
|HIDEPROGRAMSTAGE| Identifiant de l'étape de programme |
|HIDEFIELD| Élément de données ou Attribut d'entité suivie |
|HIDEOPTION| Identifiant de l'option |
|HIDEOPTIONGROUP| Identifiant du groupe d'options |
|SHOWOPTIONGROUP| Identifiant du groupe d'options |
|SETMANDATORYFIELD| Élément de données ou Attribut d'entité suivie |
|SHOWERROR| Toujours valide |
|SHOWWARNING| Toujours valide |
|DISPLAYTEXT| Élément de données ou Attribut d'entité suivie |
|DISPLAYKEYVALUEPAIR||
|ASSIGN| Élément de données ou Attribut d'entité suivie |
|WARNINGONCOMPLETE| Élément de données ou Attribut d'entité suivie |
|ERRORONCOMPLETE| Élément de données ou Attribut d'entité suivie |

En plus des validations ci-dessus, le champ `données` dans l'action de la règle de programme qui contient normalement une expression peut également être évalué en utilisant le point d'extrémité de l'api ci-dessous.

    POST /api/programRuleActions/data/expression/description?programId=<uid>


```json
{
  "condition": "1 + 1"
}
```

#### Détails sur le modèle de variables des règles de programme { #program-rule-variable-model-details } 

Le tableau suivant donne un aperçu détaillé du modèle de variables des règles de programme.

Tableau : Variable de règles de programme

| nom | Description | Obligatoire |
|---|---|---|
| nom | le nom de la variable de la règle de programme - ce nom est utilisé dans les expressions. #{myVariable} \> 5 | Obligatoire |
| sourceType (type de source) | Définit comment cette variable est renseignée avec les données de l'inscription et des événements.<br> * DATAELEMENT_NEWEST_EVENT_PROGRAM_STAGE - Dans la saisie Tracker, cette variable obtient la valeur la plus récente qui existe pour un élément de données, dans les événements d'une étape de programme donnée dans l'inscription actuelle. Dans la saisie Evénement, elle obtient la valeur la plus récente parmi les 10 événements les plus récents de l'unité d'organisation.<br> * DATAELEMENT_NEWEST_EVENT_PROGRAM - Dans la saisie Tracker, cette variable obtient la valeur la plus récente d'un élément de données pour toute l'inscription. Dans la saisie Evénement, elle obtient la valeur la plus récente parmi les 10 événements les plus récents de l'unité d'organisation.<br> * DATAELEMENT_CURRENT_EVENT - Obtient la valeur de l'élément de données en question dans l'événement en cours uniquement.<br> * DATAELEMENT_PREVIOUS_EVENT - Dans la saisie Tracker, cette variable obtient la valeur la plus récente parmi les événements du programme qui précède l'événement en cours. Dans la saisie Evénement, elle obtient la valeur la plus récente parmi les 10 événements précédents enregistrés dans l'unité d'organisation.<br> * CALCULATED_VALUE - Utilisée pour réserver un nom de variable qui sera attribué par une action de règle de programme ASSIGN.<br> * TEI_ATTRIBUTE - Obtient la valeur d'un attribut d'entité suivie spécifique. | Obligatoire |
| élément de données | Utilisé pour relier la variable de la règle de programme à un élément de données. Il est obligatoire pour tous les types de sources commençant par DATAELEMENT_. | Voir la description |
| Entité suivie - Attribut | Utilisé pour relier la variable de la règle de programme à un attribut d'entité suivie. Il est obligatoire pour le type de source TEI_ATTRIBUTE. | Voir la description |
| useCodeFor- OptionSet (utiliser le code pour - Ensemble d'options) | Si cette variable est cochée, elle sera remplie avec le code - et non le nom - de tout ensemble d'options qui lui relié. Par défaut, elle n'est pas cochée, ce qui signifie que c'est le nom de l'option est utilisé. ||
| Étape du programme | Utilisé pour spécifier une étape de programme précise à partir de laquelle la valeur de la variable de la règle de programme doit être récupérée. Il est obligatoire pour DATAELEMENT_NEWEST_EVENT_PROGRAM_STAGE. | Voir la description |

### Création de règles de programme { #webapi_creating_program_rules } 

- Pour effectuer des opérations CRUD, vous pouvez utiliser la ressource `programRules`, disponible dans l'API.

Pour récupérer la liste des règles de programmes, vous pouvez effectuer une requête GET comme suit :

    /api/programRules

Pour récupérer une seule règle de programme, vous pouvez effectuer une requête GET comme suit :

    /api/programRules/<program_rule_uid>

Pour sauvegarder ou ajouter une seule règle de programme, vous pouvez effectuer une requête POST comme suit :

    /api/programRules/<program_rule_uid>

Pour mettre à jour une seule règle de programme, vous pouvez effectuer une requête PUT comme suit :

    /api/programRules/<program_rule_uid>

Pour supprimer une seule règle de programme, vous pouvez effectuer une requête DELETE comme suit :

    /api/programRules/<program_rule_uid>

Pour récupérer la description de la condition de la règle de programme, vous pouvez effectuer une requête POST en fournissant la chaîne de la condition dans le corps de la requête.

    /api/programRules/condition/description?<program_rule_uid>

## Formulaires { #webapi_forms } 

Pour récupérer des informations sur un formulaire (qui correspond à un ensemble de données et à ses sections), vous pouvez interagir avec la ressource `form`. La réponse du formulaire est accessible en XML et JSON et fournira des informations sur chaque section (groupe) du formulaire ainsi que sur chaque champ de ces sections, y compris les étiquettes et les identifiants. En fournissant des identifiants de période et d'unité d'organisation, la réponse du formulaire sera constituée de valeurs de données.

Tableau : Paramètres de requête du formulaire

| Paramètre | Option | Description |
|---|---|---|
| pe | Période ISO | Période pour laquelle les valeurs de données du formulaire doivent être renseignées. |
| ou | UID | Unité d'organisation pour laquelle les valeurs de données du formulaire doivent être renseignées. |
| Métadonnées | faux &#124; vrai | Détermine s'il faut inclure ou non des métadonnées sur chaque élément de données des sections du formulaire. |

Pour récupérer le formulaire d'un ensemble de données, vous pouvez effectuer une requête GET comme suit :

    /api/dataSets/<dataset-id>/form.json

Pour récupérer le formulaire pour l'ensemble de données ayant l'identifiant "BfMAe6Itzgt" au format XML :

    /api/dataSets/BfMAe6Itzgt/form

Pour récupérer le formulaire en incluant les métadonnées, au format JSON :

    /api/dataSets/BfMAe6Itzgt/form.json?metaData=true

Pour récupérer le formulaire rempli avec les valeurs de données d'une période et d'une unité d'organisation spécifiques au format XML :

    /api/dataSets/BfMAe6Itzgt/form.xml?ou=DiszpKrYNg8&pe=201401

Cette ressource permet également de créer des formulaires de saisie de données personnalisés, directement pour un ensemble de données. Cela peut se faire à l'aide d'une requête POST ou PUT avec un contenu de type text/html où la charge est le balisage du formulaire personnalisé. En voici l'illustration :

```bash
curl -d @form.html "localhost/api/dataSets/BfMAe6Itzgt/form"
  -H "Content-Type:text/html" -u admin:district -X PUT
```

## Documents { #webapi_documents } 

Les références aux fichiers peuvent être stockées avec la ressource "document".



Tableau : Champs du document

| Nom du champ | Description |
|---|---|
| nom | nom unique du document |
| externe | drapeau identifiant l'emplacement du document. TRUE pour les fichiers externes, FALSE pour les fichiers internes. |
| url | l'emplacement du fichier. URL pour les fichiers externes. Identifiant de la ressource "fichier" pour les fichiers internes (voir [Ressources fichier](#webapi_file_resources)) |

Une requête GET au point d'extrémité des documents renverra tous les documents :

    /api/documents

Une requête POST au point d'extrémité des documents créera un nouveau document :

```bash
curl -X POST -d @document.json -H "Content-type: application/json"
  "http://dhis.domain/api/documents"
```

```json
{
  "name": "dhis home",
  "external": true,
  "url": "https://www.dhis2.org"
}
```

Une requête GET à laquelle est ajouté l'identifiant d'un document renverra des informations sur ce document. Une requête PUT au même point d'extrémité mettra à jour les champs du document :

    /api/documents/<documentId>

Ajouter */data* à la requête GET renverra le contenu réel du document :

    /api/documents/<documentId>/data

## Importation de métadonnées CSV { #webapi_csv_metadata_import } 

DHIS2 prend en charge l'importation de métadonnées au format CSV, telles que les éléments de données, les unités d'organisation et les règles de validation. Les propriétés des différents objets de métadonnées sont identifiées en fonction de l'ordre ou de l'index des colonnes (voir ci-dessous pour plus de détails). Vous pouvez omettre les propriétés d'objets ou les colonnes non nécessaires, mais puisque l'ordre des colonnes est important, une colonne vide doit être incluse. En d'autres termes, si vous voulez spécifier des propriétés ou des colonnes qui apparaissent tard dans l'ordre des colonnes, mais ne pas spécifier certaines colonnes qui apparaissent tôt dans l'ordre, vous pouvez inclure des colonnes vides pour elles.

La première ligne du fichier CSV est considérée comme un en-tête et est ignorée lors de l'importation. Le caractère _virgule_ doit être utilisé comme séparateur de texte. Le texte qui contient des virgules doit être placé entre _guillemets doubles_.

Pour télécharger des métadonnées au format CSV, vous pouvez envoyer une requête POST au point d'extrémité des métadonnées :

    POST /api/metadata?classKey=CLASS-KEY

Les types d'objets suivants sont pris en charge. Le paramètre de requête `classKey` est obligatoire et se trouve à côté de chaque type d'objet dans le tableau ci-dessous.

Tableau : Types d'objets et clés

| Type d'objet | Clé de classe |
|---|---|
| Des éléments de données | DATA_ELEMENT |
| Groupes d'éléments de données | DATA_ELEMENT_GROUP |
| Les options de catégorie | CATEGORY_OPTION |
| Groupes d'options de catégorie | CATEGORY_OPTION_GROUP |
| Unités d’organisation | ORGANISATION_UNIT |
| Groupes d'unités d'organisation | ORGANISATION_UNIT_GROUP |
| Règles de validation | VALIDATION_RULE |
| Ensembles d'options | OPTION_SET |
| Les traductions | TRANSLATION |

> **Astuce**
>
> Si vous utilisez *curl*, l'option `--data-binary` doit être utilisée car elle préserve les sauts de ligne et les nouvelles lignes, ce qui est essentiel pour les données CSV.

Par exemple, pour télécharger un fichier d'éléments de données au format CSV avec `curl`, vous pouvez utiliser la commande suivante :

```bash
curl --data-binary @data_elements.csv "http://localhost/api/metadata?classKey=DATA_ELEMENT"
  -H "Content-Type:application/csv" -u admin:district
```

Les formats des types d'objets actuellement pris en charge pour l'importation en CSV sont énumérés dans les sections suivantes.

### Eléments de données { #webapi_csv_data_elements } 

Tableau : Format CSV des éléments de données

| Index | Colonne | Obligatoire | Valeur (par défaut en premier) | Description |
|---|---|---|---|---|
| 1 | Nom | Oui || Nom. Maximum 230 caractères. Unique. |
| 2 | UID | Non | UID | Identifiant stable. Exactement 11 caractères alphanumériques, commençant par une lettre. Généré par le système s'il n'est pas spécifié. |
| 3 | Code | Non || Code stable. Maximum 50 caractères. |
| 4 | Nom abrégé | Non | 50 premiers caractères du nom | S'il n'est pas spécifié, il est remplacé par les 50 premiers caractères du nom. Maximum 50 caractères. Unique. |
| 5 | Description | Non || Description en texte libre. |
| 6 | Nom du formulaire | Non || Maximum 230 caractères. |
| 7 | Type de domaine | Non | AGRÉGÉ | TRACKER | Type de domaine pour l'élément de données ; il peut s'agir du domaine Agrégé ou du Tracker. Maximum 16 caractères. |
| 8 | Type de valeur | Non | ENTIER | NOMBRE | UNITÉ_INTERVALLE | POURCENTAGE | ENTIER_POSITIF | ENTIER_NÉGATIF | ENTIER_ZÉRO_OU_POSITIF | FICHIER_RESSOURCE | COORDONNÉE | TEXTE | TEXTE_ LONG | LETTRE | NUMÉRO_DE TÉLÉPHONE | EMAIL | BOOLÉEN | VRAI_UNIQUEMENT | DATE | DATE ET HEURE | Type de valeur. Maximum 16 caractères. |
| 9 | Type d'agrégation | Non | SUM &#124; AVERAGE &#124; AVERAGE_SUM_ORG_UNIT &#124; COUNT &#124; STDDEV &#124; VARIANCE &#124; MIN &#124; MAX &#124; NONE | Type d'agrégation indiquant comment agréger les données dans les différentes dimensions. Maximum 16 caractères. |
| 10 | La combinaison de catégories | Non | UID | UID de la combinaison de catégories. La combinaison de catégories par défaut sera utilisée si aucune n'est spécifiée. |
| 11 | Url | Non || URL de la ressource de l'élément de données. Maximum 255 caractères. |
| 12 | Le zéro est significatif | Non | faux &#124; vrai | Indique si les valeurs nulles (zéro) seront stockées pour cet élément de données. |
| 13 | Ensemble d'options | Non | UID | UID de l'ensemble d'options à utiliser pour les données. |
| 14 | Ensemble d'options pour les commentaires | Non | UID | UID de l'ensemble d'options à utiliser pour les commentaires. |

Vous trouverez ci-dessous un exemple de fichier CSV pour les éléments de données. La première ligne sera toujours ignorée. Vous pouvez ignorer des colonnes et compter sur les valeurs par défaut utilisées par le système. Vous pouvez également ignorer les colonnes que vous n'utilisez pas et qui apparaissent à droite de celles

```csv
name,uid,code,shortname,description
"Women participated skill development training",,"D0001","Women participated in training"
"Women participated community organizations",,"D0002","Women participated in organizations"
```

### Les unités d’organisation { #webapi_csv_org_units } 

Tableau : Format CSV de l'unité d'organisation

| Index | Colonne | Obligatoire | Valeur (par défaut en premier) | Description |
|---|---|---|---|---|
| 1 | Nom | Oui || Nom. Maximum 230 caractères. Unique. |
| 2 | UID | Non | UID | Identifiant stable. Maximum 11 caractères. Il est généré par le système s'il n'est pas spécifié. |
| 3 | Code | Non || Code stable. Maximum 50 caractères. |
| 4 | Ascendant direct | Non | UID | UID de l'unité d'organisation mère. |
| 5 | Nom abrégé | Non | 50 premiers caractères du nom | S'il n'est pas spécifié, il est remplacé par les 50 premiers caractères du nom. Maximum 50 caractères. Unique. |
| 6 | Description | Non || Description en texte libre. |
| 7 | Date d'ouverture | Non | 1970-01-01 | Date d'ouverture de l'unité d'organisation au format AAAA-MM-JJ. |
| 8 | Date de clôture | Non || Date de fermeture de l'unité d'organisation au format AAAA-MM-JJ, ignorer si l'unité est actuellement ouverte. |
| 9 | Commentaire | Non || Commentaire en texte libre pour l'unité d'organisation. |
| 10 | Type de fonctionnalité | Non | NONE &#124; MULTI_POLYGON &#124; POLYGON &#124; POINT &#124; SYMBOL | Type d'élément géospatial. |
| 11 | Coordonnées | Non || Coordonnées utilisées pour l'analyse géospatiale au format Geo JSON. |
| 12 | URL | Non || URL de la ressource de l'unité d'organisation. Maximum 255 caractères. |
| 13 | Personne de contact | Non || Personne de contact pour l'unité d'organisation. Maximum 255 caractères. |
| 14 | Addresse | Non || Adresse de l'unité d'organisation. Maximum 255 caractères. |
| 15 | Adresses électronique | Non || Courriel de l'unité d'organisation. Maximum 150 caractères. |
| 16 | Numéro de téléphone | Non || Numéro de téléphone de l'unité d'organisation. Maximum 150 caractères. |

Voici un exemple d'importation d'unités d'organisation avec une unité mère, en utilisant des informations minimales :

```csv
name,uid,code,parent
"West province",,"WESTP","ImspTQPwCqd"
"East province",,"EASTP","ImspTQPwCqd"
```

### Règles de validation { #webapi_csv_validation_rules } 

Tableau : Format CSV de la règle de validation

| Index | Colonne | Obligatoire | Valeur (par défaut en premier) | Description |
|---|---|---|---|---|
| 1 | Nom | Oui || Nom. Maximum 230 caractères. Unique. |
| 2 | UID | Non | UID | Identifiant stable. Maximum 11 caractères. Il est généré par le système s'il n'est pas spécifié. |
| 3 | Code | Non || Code stable. Maximum 50 caractères |
| 4 | Description | Non || Description en texte libre. |
| 5 | Instruction | Non || Instruction en texte libre. |
| 6 | Importance | Non | MOYEN | ÉLEVÉ | FAIBLE | Importance de la règle de validation. |
| 7 | Type de règle (ignoré) | Non | VALIDATION | SURVEILLANCE | Type de règle de validation. |
| 8 | Opérateur | Non | égal_à | non_égal_à | supérieur_à | supérieur_ou_égal_à_ | inférieur_à | inférieur_ou_égal_à_ | paire_obligatoire | paire_exclusive | Opérateur d'expression. |
| 9 | Type de période | Non | Mensuel | Quotidien | Hebdomadaire | Trimestriel | Semestriel | Annuel | Type de période |
| 10 | Expression du côté gauche | Oui || Formule mathématique basée sur les UID des éléments de données et des combinaisons d'options. |
| 11 | Description de l'expression du côté gauche | Oui || Texte libre |
| 12 | Stratégie de la valeur manquante du côté gauche | Non | IGNORER_SI_UNE_VALEUR_EST MANQUANTE | IGNORER_SI_TOUTES_LES VALEURS_SONT MANQUANTES | NE JAMAIS_IGNORER  | Fonctionnement en cas de valeurs manquantes dans l'expression de gauche. |
| 13 | Expression du côté droit | Oui || Formule mathématique basée sur les UID des éléments de données et des combinaisons d'options. |
| 14 | Description de l'expression du côté droit | Oui || Texte libre |
| 15 | Stratégie de valeur manquante du côté droit | Non | IGNORER_SI_UNE_VALEUR_EST MANQUANTE | IGNORER_SI_TOUTES_LES VALEURS_SONT MANQUANTES | NE JAMAIS_IGNORER  | Fonctionnement en cas de valeurs manquantes dans l'expression de droite. |

### Ensembles d'options { #webapi_csv_option_sets } 

Tableau : Format CSV de l'ensemble d'options

| Index | Colonne | Obligatoire | Valeur (par défaut en premier) | Description |
|---|---|---|---|---|
| 1 | Nom de l'ensemble d'options | Oui || Nom. Maximum 230 caractères. Unique. Doit être répété pour chaque option. |
| 2 | UID de l'ensemble d'options | Non | UID | Identifiant stable. Maximum 11 caractères. Il est généré par le système si aucun n'est spécifié. Il doit être répété pour chaque option. |
| 3 | Code de l'ensemble d'options | Non || Code stable. Maximum 50 caractères. Il doit être répété pour chaque option. |
| 4 | Nom de l'option | Oui || Nom de l'option. Maximum 230 caractères. |
| 5 | UID de l'option | Non | UID | Identifiant stable. Maximum 11 caractères. Il est généré par le système s'il n'est pas spécifié. |
| 6 | Code de l'option | Oui || Code stable. Maximum 50 caractères. |

Le format des ensembles d'options est particulier. Les trois premières valeurs représentent un ensemble d'options. Les trois dernières valeurs représentent une option. Les trois premières valeurs représentant l'ensemble d'options doivent être répétées pour chaque option.

```csv
optionsetname,optionsetuid,optionsetcode,optionname,optionuid,optioncode
"Color",,"COLOR","Blue",,"BLUE"
"Color",,"COLOR","Green",,"GREEN"
"Color",,"COLOR","Yellow",,"YELLOW"
"Sex",,,"Male",,"MALE"
"Sex",,,"Female",,"FEMALE"
"Sex",,,"Unknown",,"UNKNOWN"
"Result",,,"High",,"HIGH"
"Result",,,"Medium",,"MEDIUM"
"Result",,,"Low",,"LOW"
"Impact","cJ82jd8sd32","IMPACT","Great",,"GREAT"
"Impact","cJ82jd8sd32","IMPACT","Medium",,"MEDIUM"
"Impact","cJ82jd8sd32","IMPACT","Poor",,"POOR"
```

### Groupe d'options { #option-group } 

Tableau : Format CSV du groupe d'options

| Index | Colonne | Obligatoire | Valeur (par défaut en premier) | Description |
|---|---|---|---|---|
| 1 | Nom du groupe d'options | Oui || Nom. Maximum 230 caractères. Unique. Doit être répété pour chaque option. |
| 2 | Uid du groupe d'options | Non || Identifiant stable. Maximum 11 caractères. Il est généré par le système si aucun n'est spécifié. Il doit être répété pour chaque option. |
| 3 | Code du groupe d'options | Non || Code stable. Maximum 50 caractères. Il doit être répété pour chaque option. |
| 4 | Nom court du groupe d'options | Oui || Nom court. Maximum 50 caractères. Unique. Doit être répété pour chaque option. |
| 5 | Uid de l'ensemble d'options | Oui || Identifiant stable. Maximum 11 caractères. Doit être répété pour chaque option. |
| 6 | Uid de l'option | Non || Identifiant stable. Maximum 11 caractères. |
| 7 | Code de l'option | Non || Code stable. Maximum 50 caractères. |

Exemple de charge CSV d'un groupe d'options

```csv
optionGroupName,optionGroupUid,optionGroupCode,optionGroupShortName,optionSetUid,optionUid,optionCode
optionGroupA,,,groupA,xmRubJIhmaK,,OptionA
optionGroupA,,,groupA,xmRubJIhmaK,,OptionB
optionGroupB,,,groupB,QYDAByFgTr1,,OptionC
```
### Ensemble de groupes d'options { #option-group-set } 



Tableau : Format CSV de l'ensemble de groupes d'options

| Index | Colonne | Obligatoire | Valeur (par défaut en premier) | Description |
|---|---|---|---|---|
| 1 | Nom de l'ensemble de groupes d'options | Oui || Nom. Maximum 230 caractères. Unique. Doit être répété pour chaque option. |
| 2 | Uid de l'ensemble de groupes d'options | Non || Identifiant stable. Maximum 11 caractères. Il est généré par le système si aucun n'est spécifié. Il doit être répété pour chaque option. |
| 3 | Code de l'ensemble de groupes d'options | Non || Code stable. Maximum 50 caractères. Il doit être répété pour chaque option. |
| 4 | Description de l'ensemble de groupes d'options | Non || Description. Doit être répétée pour chaque option. |
| 5 | Dimension de données | Non || VRAI, FAUX |
| 6 | Uid de l'ensemble d'options | Non || UID de l'ensemble d'options. Identifiant stable. Maximum 11 caractères. |

Exemple de charge CSV d'un ensemble de groupes d'options

```csv
name,uid,code,description,datadimension,optionsetuid
optiongroupsetA,,,,,xmRubJIhmaK
optiongroupsetB,,,,false,QYDAByFgTr1
```
Pour ajouter des groupes d'options à un ensemble de groupes d'options importé, suivez les mêmes étapes que pour l'importation de l'appartenance à une collection.

### Appartenance à une collection { #collection-membership } 

Outre l'importation d'objets, vous pouvez également choisir de n'importer que la relation groupe-membre entre un objet et un groupe. Actuellement, les paires de groupes et d'objets suivantes sont prises en charge

  - Groupe d'unités d'organisation - Unité d'organisation

  - Groupe d'éléments de données - Élément de données

  - Groupe d'indicateurs - Indicateur

  - Ensemble de groupes d'options - Groupe d'options

Le format CSV pour ces importations est le même



Tableau : Format CSV des membres d'une collection

| Index | Colonne | Obligatoire | Valeur (par défaut en premier) | Description |
|---|---|---|---|---|
| 1 | UID | Oui | UID | L'UID de la collection à laquelle ajouter un objet |
| 2 | UID | Oui | UID | L'UID de l'objet à ajouter à la collection |

### Autres objets { #webapi_csv_other_objects } 



Table: Data Element Group, Category Option, Category Option Group, Organisation Unit Group CSV Format

| Index | Colonne | Obligatoire | Valeur (par défaut en premier) | Description |
|---|---|---|---|---|
| 1 | Nom | Oui || Nom. Maximum 230 caractères. Unique. |
| 2 | UID | Non | UID | Identifiant stable. Maximum 11 caractères. Il est généré par le système si aucun n'est spécifié. |
| 3 | Code | Non || Code stable. Maximum 50 caractères. |
| 4 | Nom abrégé | Non || Nom court. 50 caractères maximum. |

Voici un exemple d'options de catégorie :

```csv
name,uid,code,shortname
"Male",,"MALE"
"Female",,"FEMALE"
```

## Objets supprimés { #webapi_deleted_objects } 

La ressource des objets supprimés fournit un journal des objets de métadonnées supprimés.

    /api/deletedObjects

Chaque fois qu'un objet de métadonnées est supprimé, un journal est conservé avec l'identifiant, le code, le type et l'heure de la suppression. Cette API est disponible à l'adresse `/api/deletedObjects`. Le filtrage des champs et des objets fonctionne de la même manière que pour les autres ressources de métadonnées.

Obtenir des objets supprimés de type éléments de données :

    GET /api/deletedObjects.json?klass=DataElement

Obtenir un objet de type indicateur qui a été supprimé dans la période allant de 2015 et plus :

    GET /api/deletedObjects.json?klass=Indicator&deletedAt=2015-01-01

## Favoris { #webapi_favorites } 

Certains types d'objets de métadonnées peuvent être marqués comme favoris pour l'utilisateur actuellement connecté. Cela s'applique actuellement aux tableaux de bord.

    /api/dashboards/<uid>/favorite

Pour faire d'un tableau de bord un favori, vous pouvez envoyer une requête *POST* (aucun type de contenu n'est requis) à une URL comme suit :

    /api/dashboards/iMnYyBfSxmM/favorite

Pour supprimer un tableau de bord en tant que favori, vous pouvez effectuer une requête *DELETE* en utilisant l'URL ci-dessus.

Le statut de favori apparaîtra comme un champ booléen *favori* sur l'objet (par exemple, le tableau de bord) dans la réponse de métadonnées.

## Abonnements { #webapi_subscription } 

A logged user can subscribe to certain types of objects. Currently
subscribable objects are those of type Chart, EventChart, EventReport,
Map, ReportTable and Visualization.

> **Note**
>
> The Chart and ReportTable objects are deprecated. Use Visualization instead.

Pour obtenir les abonnés d'un objet (un tableau contenant les UID), vous pouvez effectuer une requête *GET* comme suit :

    /api/<object-type>/<object-id>/subscribers

Voir l'exemple suivant :

    /api/charts/DkPKc1EUmC2/subscribers

Pour vérifier si l'utilisateur actuel est abonné à un objet (obtenir une valeur booléenne), vous pouvez effectuer un appel *GET* :

    /api/<object-type>/<object-id>/subscribed

Voir l'exemple suivant :

    /api/charts/DkPKc1EUmC2/subscribed

Pour s'abonner ou se désabonner d'un objet, effectuez une requête *POST/DELETE* (aucun type de contenu n'est requis) :

    /api/<object-type>/<object-id>/subscriber

## Ressources de fichiers { #webapi_file_resources } 

Les *Ressources de fichiers* sont des objets utilisés pour représenter et stocker du contenu binaire. L'objet *FileResource* (ressource de fichier) contient les métadonnées du fichier (nom, contenu-type, taille, etc.) ainsi qu'une clé permettant d'extraire le contenu à partir d'un magasin de fichiers externe à la base de données. L'objet *FileResource* est stocké dans la base de données comme n'importe quel autre objet, mais le contenu (fichier) est stocké ailleurs et peut être récupéré à l'aide de la référence du contenu *(storageKey)* ou clé de stockage.

    /api/fileResources

Le contenu des ressources de fichiers n'est pas directement accessible, mais il est référencé à partir d'autres objets (tels que les valeurs de données) pour stocker des données binaires d'une taille pratiquement illimitée.

Pour créer une ressource de fichier qui ne nécessite pas de valeur de données correspondante, envoyez une requête POST au point d'extrémité `/api/fileResources` avec un téléchargement en plusieurs parties :

```bash
curl "https://server/api/fileResources" -X POST
  -F "file=@/path/to/file/name-of-file.png"
```

Pour créer à la fois une ressource de fichier et une valeur de données qui fait référence au fichier, envoyez une requête POST au point d'extrémité `/api/dataValues/file` avec DHIS version 2.36 ou une version plus récente :

```bash
curl "https://server/api/dataValues/file?de=xPTAT98T2Jd
  &pe=201301&ou=DiszpKrYNg8&co=Prlt0C1RF0s" -X POST
  -F "file=@/path/to/file/name-of-file.png"
```

Pour le point d'extrémité `api/fileResources`, le seul paramètre de formulaire requis est *file*, qui correspond au fichier à télécharger. Pour le point d'extrémité `api/dataValues/file`, les paramètres requis sont les mêmes que pour une requête POST à `api/dataValues`, avec l'ajout de *file*.

Le nom de fichier et le type de contenu doivent également être inclus dans la requête, mais ils seront remplacés par des valeurs par défaut s'ils ne sont pas fournis.

Lorsque la création d'une ressource fichier est réussie, les données renvoyées contiennent un champ `response` qui contient à son tour `fileResource` comme suit :

```json
{
  "httpStatus": "Accepted",
  "httpStatusCode": 202,
  "status": "OK",
  "response": {
    "responseType": "FileResource",
    "fileResource": {
      "name": "name-of-file.png",
      "created": "2015-10-16T16:34:20.654+0000",
      "lastUpdated": "2015-10-16T16:34:20.667+0000",
      "externalAccess": false,
      "publicAccess": "--------",
      "user": { ... },
      "displayName": "name-of-file.png",
      "contentType": "image/png",
      "contentLength": 512571,
      "contentMd5": "4e1fc1c3f999e5aa3228d531e4adde58",
      "storageStatus": "PENDING",
      "id": "xm4JwRwke0i"
    }
  }
}
```

Notez la réponse *202 Accepted*, qui indique que la ressource renvoyée a été soumise à un traitement en arrière-plan (persistance vers le magasin de fichiers externe dans ce cas). Notez également le champ `storageStatus` qui indique si le contenu a été stocké ou non. À ce stade, la persistance vers le magasin externe n'est pas encore terminée (elle est probablement en train d'être téléchargée vers un magasin basé sur le cloud) comme le montre le statut `PENDING`.

Même si le contenu n'a pas encore été entièrement stocké, la ressource de fichier peut maintenant être utilisée, par exemple comme contenu référencé dans une valeur de données (voir [Travailler avec des valeurs de données de fichier](#datavalue_file)). Si nous avons besoin de vérifier le *storageStatus* mis à jour ou de récupérer les métadonnées du fichier, une requête peut être envoyée au point d'extrémité `fileResources`.

```bash
curl "https://server/api/fileResources/xm4JwRwke0i" -H "Accept: application/json"
```

Cette requête renverra l'objet `FileResource` comme le montre la réponse de l'exemple ci-dessus.

### Contraintes liées aux ressources de fichiers { #webapi_file_resources_constraints } 

  - Les ressources de fichiers *doivent* être référencées (attribuées) à partir d'un autre objet.
    afin d'être conservées à long terme. Un fichier de ressource qui est
    créé mais non référencé par un autre objet, par exemple une valeur de données, est
    est considérée comme étant en *staging*. Toutes les ressources de fichiers dans ce 
    état et datant de plus de *deux heures* seront marqués pour suppression.
    et seront retirées du système.

  - L'ID renvoyé par la création initiale de la ressource de fichier n'est pas
    récupérable à partir de tout autre emplacement, à moins que la ressource de fichier n'ait été
    été référencée (auquel cas l'ID sera stocké en tant que référence), 
    de sorte que sa perte nécessitera que la requête POST soit répétée et qu'un 
    nouvel objet soit créé. La ressource de fichier *orpheline* sera nettoyée automatiquement.
    automatiquement.

  - Les objets de ressources de fichiers sont *immuables*, ce qui signifie qu'ils ne peuvent pas être modifiés 
    et nécessitent plutôt la création d'une ressource entièrement nouvelle.

### Liste noire des ressources de fichiers { #file-resource-blocklist } 

Pour des raisons de sécurité, certains types de fichiers ne peuvent pas être téléchargés.

Les types de contenu suivants sont bloqués.

| Type de contenu | Type de contenu |
| ------------------------------------- | ---- |
| text/html                             | application/x-ms-dos-executable |
| text/css                              | application/vnd.microsoft.portable-executable |
| text/javascript                       | application/vnd.apple.installer+xml |
| font/otf                              | application/vnd.mozilla.xul+xml |
| application/x-shockwave-flash         | application/x-httpd-php  |
| application/vnd.debian.binary-package | application/x-sh |
| application/x-rpm                     | application/x-csh |
| application/java-archive              |  |

Les extensions de fichiers suivantes sont bloquées.

| Extension de fichier | Extension de fichier | Extension de fichier |
| ---- | ---- | ---- |
| html | deb  | xul  |
| htm  | rpm  | php  |
| css  | jar  | bin  |
| js   | jsp  | sh   |
| mjs  | exe  | csh  |
| otf  | msi  | bat  |
| swf  | mpkg |      |

## Versionnage des métadonnées { #webapi_metadata_versioning } 

Cette section explique les API de versionnage des métadonnées.

  - `/api/metadata/version`: This endpoint will return the current metadata
    du système sur lequel il est invoqué.



Tableau : Paramètres de requête

| Nom | Obligatoire | Description |
|---|---|---|
| nom de la version | faux | Si ce paramètre n'est pas spécifié, il renvoie la version actuelle du système ou, dans le cas contraire, les détails du nom de version utilisé comme paramètre. (le nom de la version utilise la syntaxe "Version_<id\>"). |

### Obtenir des exemples de versions de métadonnées { #webapi_metadata_versioning_examples } 

**Exemple:** Obtenir la version actuelle des métadonnées de ce système

Requête :

```
/api/metadata/version
```

Réponse :

```json
{
  "name": "Version_4",
  "created": "2016-06-30T06:01:28.684+0000",
  "lastUpdated": "2016-06-30T06:01:28.685+0000",
  "externalAccess": false,
  "displayName": "Version_4",
  "type": "BEST_EFFORT",
  "hashCode": "848bf6edbaf4faeb7d1a1169445357b0",
  "id": "Ayz2AEMB6ry"
}
```

**Exemple:** Obtenir les détails de la version portant le nom "Version_2".

Requête :

```
/api/metadata/version?versionName=Version_2
```

Réponse :

```json
{
  "name": "Version_2",
  "created": "2016-06-30T05:59:33.238+0000",
  "lastUpdated": "2016-06-30T05:59:33.239+0000",
  "externalAccess": false,
  "displayName": "Version_2",
  "type": "BEST_EFFORT",
  "hashCode": "8050fb1a604e29d5566675c86d02d10b",
  "id": "SaNyhusVxBG"
}
```

  - `/api/metadata/version/history`: This endpoint will return the list of all
    versions des métadonnées du système sur lequel il est appelé.



Tableau : Paramètres de requête

| Nom | Obligatoire | Description |
|---|---|---|
| baseline | faux | Si ce paramètre n'est pas spécifié, la liste de toutes les versions de métadonnées sera renvoyée. Dans le cas contraire, nous devons fournir un paramètre versionName de la forme "Version_<id\>". Il renverra alors la liste des versions présentes dans le système, qui ont été créées après que le nom de la version ait été fourni en tant que paramètre de la requête. |

### Obtenir la liste de toutes les versions de métadonnées { #webapi_get_list_of_metadata_versions } 

**Exemple:** Obtenir la liste de toutes les versions de ce système

Requête :

```
/api/metadata/version/history
```

Réponse :

```json
{
  "metadataversions": [{
    "name": "Version_1",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T05:54:41.139+0000",
    "id": "SjnhUp6r4hG",
    "hashCode": "fd1398ff7ec9fcfd5b59d523c8680798"
  }, {
    "name": "Version_2",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T05:59:33.238+0000",
    "id": "SaNyhusVxBG",
    "hashCode": "8050fb1a604e29d5566675c86d02d10b"
  }, {
    "name": "Version_3",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T06:01:23.680+0000",
    "id": "FVkGzSjAAYg",
    "hashCode": "70b779ea448b0da23d8ae0bd59af6333"
  }]
}
```

**Exemple :** Obtenir la liste de toutes les versions de ce système créées après "Version_2".

Requête :

```
/api/metadata/version/history?baseline=Version_2
```

Réponse :

```json
{
  "metadataversions": [{
    "name": "Version_3",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T06:01:23.680+0000",
    "id": "FVkGzSjAAYg",
    "hashCode": "70b779ea448b0da23d8ae0bd59af6333"
  }, {
    "name": "Version_4",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T06:01:28.684+0000",
    "id": "Ayz2AEMB6ry",
    "hashCode": "848bf6edbaf4faeb7d1a1169445357b0"
  }]
 }
```

  - `/api/metadata/version/create`: This endpoint will create the metadata
    pour le type de version spécifié dans le paramètre.



Tableau : Paramètres de requête

| Nom | Obligatoire | Description |
|---|---|---|
| type | vrai | Le type de version de métadonnées à créer.<br> * BEST_EFFORT<br> * ATOMIQUE |

Les utilisateurs peuvent sélectionner le type de métadonnées à créer. Le type de version des métadonnées régit la manière dont l'importateur traite la version en question. Ce type sera utilisé lors de l'importation des métadonnées. Il existe deux types de métadonnées.

  - *BEST_EFFORT* : Ce type suggère que les références manquantes peuvent être
    ignorées et l'importateur peut continuer à importer les métadonnées (par exemple,
    les éléments de données manquants lors de l'importation d'un groupe d'éléments de données).

  - *ATOMIQUE* : Ce type garantit une vérification stricte des références de métadonnées 
    et l'importation des métadonnées échouera si l'une des références
    n'existe pas.

> **Remarque**
>
> Il est recommandé d'avoir un type de versions ATOMIQUE pour s'assurer que tous les systèmes (centraux et locaux) aient les mêmes métadonnées.
> Les références manquantes sont prises en compte dans la phase de validation elle-même. Veuillez consulter les
> détails de l'importateur pour obtenir une explication complète.
>

### Création d'une version de métadonnées { #webapi_create_metadata_version } 

**Exemple:** Créer une version de métadonnées du type `BEST_EFFORT`.

Requête :

```bash
curl -X POST -u admin:district "https://play.dhis2.org/dev/api/metadata/version/create?type=BEST_EFFORT"
```

Réponse :

```json
{
  "name": "Version_1",
  "created": "2016-06-30T05:54:41.139+0000",
  "lastUpdated": "2016-06-30T05:54:41.333+0000",
  "externalAccess": false,
  "publicAccess": "--------",
  "user": {
    "name": "John Traore",
    "created": "2013-04-18T17:15:08.407+0000",
    "lastUpdated": "2016-04-06T00:06:06.571+0000",
    "externalAccess": false,
    "displayName": "John Traore",
    "id": "xE7jOejl9FI"
  },
  "displayName": "Version_1",
  "type": "BEST_EFFORT",
  "hashCode": "fd1398ff7ec9fcfd5b59d523c8680798",
  "id": "SjnhUp6r4hG"
}
```

  - `/api/metadata/version/{versionName}/data`: This endpoint will download
    les métadonnées spécifiques au nom de version utilisé comme paramètre du chemin d'accès.
     

  - `/api/metadata/version/{versionName}/data.gz`: This endpoint will download
    les métadonnées spécifiques au nom de version utilisé comme paramètre du chemin d'accès.
    dans un format compressé (gzippé).



Tableau : Paramètres du chemin d'accès

| Nom | Obligatoire | Description |
|---|---|---|
| nom de la version | vrai | Paramètre de chemin d'accès de la forme "Version_<id\>" pour que l'API télécharge la version spécifique. |

### Télécharger les métadonnées de la version { #webapi_download_version_metadata } 

**Exemple:** Obtenir les métadonnées pour la "Version 5"

Requête :

```bash
curl -u admin:district "https://play.dhis2.org/dev/api/metadata/version/Version_5/data"
```

Réponse :

```json
{
  "date": "2016-06-30T06:10:23.120+0000",
  "dataElements": [
    {
      "code": "ANC 5th Visit",
      "created": "2016-06-30T06:10:09.870+0000",
      "lastUpdated": "2016-06-30T06:10:09.870+0000",
      "name": "ANC 5th Visit",
      "id": "sCuZKDsix7Y",
      "shortName": "ANC 5th Visit ",
      "aggregationType": "SUM",
      "domainType": "AGGREGATE",
      "zeroIsSignificant": false,
      "valueType": "NUMBER",
      "categoryCombo": {
        "id": "p0KPaWEg3cf"
      },
      "user": {
        "id": "xE7jOejl9FI"
      }
    }
  ]
}
```

## Metadata Synchronization { #webapi_metadata_synchronization } 

Cette section explique l'API de synchronisation des métadonnées disponible à partir de la version 2.24

  - `/api/metadata/sync`: This endpoint performs metadata sync of the
    nom de la version utilisé dans le paramètre de requête. Cela se fait par le téléchargement et 
    l'importation de la version spécifiée à partir du serveur distant, tel que défini dans 
    l'application de paramétrage.



Tableau : Paramètres de requête

| Nom | Obligatoire | Description |
|---|---|---|
| nom de la version | vrai | Le paramètre de requête VersionName est de la forme "Version_<id\>" . L'api télécharge cette version depuis le serveur distant et l'importe dans le système local. |

  - Cette API doit être utilisée avec la plus grande prudence. Sachez qu'il existe 
    une autre façon d'effectuer la synchronisation de manière complètement automatisée en 
    s'appuyant sur la tâche de synchronisation des métadonnées à partir de l'application "Administration des données". 
    Voir le chapitre 22, section 22.17 du manuel de l'utilisateur pour plus de détails concernant la 
    tâche de synchronisation des métadonnées.

  - Cette API de synchronisation peut également être utilisée pour synchroniser les métadonnées pour les 
    versions qui ont échoué dans le planificateur de synchronisation des métadonnées. En raison 
    de sa dépendance à un numéro de version de métadonnées spécifique, il convient de faire 
    attention à l'ordre dans lequel cette API est appelée. Par exemple, si cette API est 
    utilisée pour synchroniser une version supérieure à partir de l'instance centrale, 
    la synchronisation peut échouer car les dépendances des métadonnées ne sont pas présentes dans 
    l'instance locale.

  - Supposons que l'instance locale soit à la `Version_12` et que ce point d'extrémité soit utilisé 
    pour synchroniser la `Version_15` (de type `BEST_EFFORT`) depuis l'instance centrale, 
    le planificateur commencera à synchroniser les métadonnées à partir de la 
    `Version_16`. Donc l'instance locale n'aura pas les versions 
    de métadonnées entre la `Version_12` et la `Version_15`. Vous devez synchroniser manuellement 
    les versions manquantes en utilisant uniquement ces points d'extrémité.

### Synchronisation d'une version de métadonnées { #webapi_metadata_synchronization_version } 

**Exemple:** Synchroniser la Version_6 du système central vers ce système

Requête :

```bash
curl -u admin:district "https://play.dhis2.org/dev/api/metadata/sync?versionName=Version_6"
```

## Référentiel de métadonnées { #webapi_metadata_repository } 

DHIS2 fournit un référentiel de métadonnées qui contient des packages de métadonnées avec différents contenus. Un package de métadonnées est un document JSON compatible avec DHIS2 qui décrit un ensemble d'objets de métadonnées.

Pour récupérer un index des packages de métadonnées disponibles, vous pouvez envoyer une requête GET à la ressource *metadataRepo* :

    GET /api/synchronization/metadataRepo

L'entrée d'un paquet de métadonnées contient des informations sur le package et une URL vers le package concerné. Un index pourrait ressembler à ceci :

```json
{
  "packages": [
    {
      "id": "sierre-leone-demo",
      "name": "Sierra Leone demo",
      "description": "Sierra Leone demo database",
      "version": "0.1",
      "href": "https://dhis2.org/metadata-repo/221/sierra-leone-demo/metadata.json"
    },
    {
      "id": "trainingland-org-units",
      "name": "Trainingland organisation units",
      "description": "Trainingland organisation units with four levels",
      "version": "0.1",
      "href": "https://dhis2.org/metadata-repo/221/trainingland-org-units/metadata.json"
    }
  ]
}
```

Un client peut suivre les URL et installer un package de métadonnées via une requête POST de type de contenu *text/plain* et avec le package de métadonnées utilisé comme charge de la ressource *metadataPull* :

    POST /api/synchronization/metadataPull

Voici un exemple de commande curl :

```bash
curl "localhost:8080/api/synchronization/metadataPull" -X POST
  -d "https://dhis2.org/metadata-repo/221/trainingland-org-units/metadata.json"
  -H "Content-Type:text/plain" -u admin:district
```

## Reference to createdBy User { #reference-to-createdby-user } 

Chaque objet créé dans DHIS2 aura une propriété `user` qui est liée à l'`utilisateur` qui a créé l'objet.

Depuis la version 2.36, nous avons changé le nom de cette propriété en `createdBy` pour éviter toute confusion.

Cependant, afin de conserver la compatibilité rétroactive, l'ancienne propriété `user` est toujours incluse dans la charge et fonctionne normalement comme auparavant.

```json
{
  "createdBy": {
      "displayName": "John Kamara",
      "name": "John Kamara",
      "id": "N3PZBUlN8vq",
      "username": "district"
  },
  "user": {
      "displayName": "John Kamara",
      "name": "John Kamara",
      "id": "N3PZBUlN8vq",
      "username": "district"
  }
}
```

## Metadata Proposal Workflow { #webapi_metadata_proposal_workflow }

Le point d'extrémité du flux de propositions pour les métadonnées permet de proposer et d'accepter des modifications sur les métadonnées.

```
/api/metadata/proposals
```

### Proposition d'une modification sur des métadonnées { #webapi_metadata_proposal_propose }

Une proposition vise toujours un seul objet de métadonnées. La requête suivante peut être utilisée :

    POST /api/metadata/proposals

En fonction de la charge, la proposition peut :

* Ajouter un nouvel objet de métadonnées.
* Mettre à jour les références d'un objet de métadonnées existant par le biais de l'ID.
* Supprimer un objet de métadonnées existant référencé par un ID.

Pour proposer l'ajout d'un nouvel objet de métadonnées, envoyez une charge JSON comme celle-ci :

```json
{
  "type": "ADD",
  "target": "ORGANISATION_UNIT",
  "change": {"name":"My Unit", "shortName":"MyOU", "openingDate": "2020-01-01"}
}
```
La propriété `change` contient le même objet JSON qui peut être directement envoyé au point d'extrémité de création de l'objet.

Pour proposer la mise à jour d'un objet de métadonnées existant, envoyez une charge JSON comme dans l'exemple ci-dessous :

```json
{
  "type": "UPDATE",
  "target": "ORGANISATION_UNIT",
  "targetId": "<id>",
  "change": [
    { "op": "replace", "path": "/name", "value": "New name" }
  ]
}
```
La propriété `targetId` fait référence à l'ID de l'objet qui doit être mis à jour. La propriété `change` contient ici une charge de patch JSON. Il s'agit de la même charge de patch qui peut être envoyée au point d'extrémité correspondant pour appliquer directement la mise à jour.

Pour proposer la suppression d'un objet existant, envoyez une charge comme dans le dernier exemple :

```json
{
  "type": "REMOVE",
  "target": "ORGANISATION_UNIT",
  "targetId": "<id>"
}
```
La propriété `targetId` fait référence à l'ID de l'objet qui doit être supprimé. Un `commentaire` en texte libre peut être ajouté à n'importe quel type de commentaire.

Seul le type de `cible` `ORGANISATION_UNIT` est actuellement pris en charge.

### Acceptation d'une proposition de modification de métadonnées { #webapi_metadata_proposal_accept }
Pour accepter une proposition ouverte, envoyez une requête `POST` à la ressource des propositions.

    POST /api/metadata/proposals/<uid>

En cas de succès, le statut de la proposition passe à `ACCEPTED` (acceptée). Une fois acceptée, la proposition ne peut plus être rejetée.

Si une proposition ne s'applique pas, le statut passe à `NEEDS_UPDATE` (besoin de mise à jour). Le champ `reason` contient un résumé des échecs lorsque cette information est disponible.

### Refus d'une proposition de modification de métadonnées { #webapi_metadata_proposal_oppose }
Si une proposition n'est pas tout à fait correcte et doit être ajustée, vous pouvez effectuer une requête `PATCH` sur la la ressource des propositions.

    PATCH /api/metadata/proposals/<uid>

En option, un texte en clair peut être ajouté pour fournir une `raison` au refus de la proposition.

Une proposition refusée doit avoir au préalable le statut `PROPOSED` (proposée) avant de passer à `NEEDS_UPDATE`.

### Ajustement d'une proposition de modification de métadonnées { #webapi_metadata_proposal_adjust }
Une proposition au statut `NEEDS_UPDATE` doit être ajustée avant d'être acceptée. Pour ajuster la proposition, une requête `PUT` est faite pour la ressource.

    PUT /api/metadata/proposals/<uid>

Un tel ajustement peut être effectué soit sans corps, soit avec un corps JSON contenant un objet dont les propriétés `change` et `targetId` sont mises à jour pour l'ajustement :

```json
{
  "targetId": "<id>",
  "change": ...
}
```
Le type JSON de la valeur `change` dépend du `type` de la proposition, de la même manière que lorsqu'une proposition est initialement faite.

### Rejet d'une proposition de modification de métadonnées { #webapi_metadata_proposal_reject }
Pour rejeter une proposition ouverte, envoyez une requête `DELETE` à la ressource des propositions.

    DELETE /api/metadata/proposals/<uid>

Le statut de la proposition devient alors `REJECTED` (rejetée). Aucune autre modification ne peut être apportée à cette proposition. Elle est conservée comme documentation des événements.

### Listage des propositions de modification de métadonnées { #webapi_metadata_proposal_list }
Toutes les propositions peuvent être listées :

    GET /api/metadata/proposals/

La liste des résultats peut être filtrée à l'aide du paramètre `filter`. Par exemple, pour ne lister que les propositions acceptées, faites la requête suivante :

    GET /api/metadata/proposals?filter=status=ACCEPTED

De même, pour ne montrer que les propositions ouvertes, utilisez ceci :

    GET /api/metadata/proposals?filter=status=PROPOSED

Les filtres peuvent également être appliqués à n'importe quel champ, à l'exception du champ `change`. Les opérateurs de filtre pris en charge sont ceux décrits dans l'API Gist Metadata. Cela inclut également les transformateurs de propriétés décrits dans l'API Gist.

Voici une liste des champs disponibles :

| Champ       | Description |
| ----------- | -------------------------------------------------------------- |
| identifiant          | identifiant unique de la proposition |
| type        | `ADD` (ajouter un nouvel objet, `UPDATE` (mettre à jour) un objet existant, `REMOVE` (supprimer) un objet existant |
| statut      | `PROPOSED` (proposition ouverte), `ACCEPTED` (succès), `NEEDS_UPDATE` (le processus d'acceptation à causé une une erreur ou a été refusé), `REJECTED` (rejet) |
| cible      | type d'objet de métadonnées à ajouter/mettre à jour/supprimer. Actuellement, seul `ORGANISATION_UNIT` peut être utilisé. |
| targetId (id de la cible)    | UID de l'objet mis à jour ou supprimé. Il n'est pas défini pour la fonction `ADD` |
| createdBy (créé par)   | l'utilisateur qui a créé la proposition |
| créé     | la date et l'heure de création de la proposition |
| finalisedBy | l'utilisateur qui a accepté ou rejeté la proposition |
| finalisé   | la date et l'heure auxquelles la proposition a été acceptée ou rejetée. |
| commentaire     | commentaire en texte clair facultatif donné pour la proposition initiale |
| raison      | texte simple facultatif fourni lorsque la proposition a été refusée ou que les erreurs survenues lors de l'acceptation d'une proposition ont échoué | 
| change      | Objet JSON pour la proposition `ADD`, tableau JSON pour la proposition `UPDATE`, rien pour la proposition `REMOVE`. |

### Visualisation des propositions de modification de métadonnées { #webapi_metadata_proposal_show }
Les propositions de modification individuelles peuvent être consultées à l'aide de 

    GET /api/metadata/proposals/<uid>

Le paramètre `fields` peut être utilisé pour restreindre les champs inclus dans l'objet affiché. Par exemple :

    GET /api/metadata/proposals/<uid>?fields=id,type,status,change


# Métadonnées Gist API { #gist_api } 
<!--DHIS2-SECTION-ID:gist_api-->

L'API Gist des métadonnées est une API JSON RESTful en lecture uniquement qui permet de récupérer et de parcourir 
des métadonnées. Les éléments de cette API contiennent la gist du même élément dans l'API Métadonnées.

L'API est spécifiquement conçue pour éviter :

* Les charges utiles des réponses volumineuses en raison de l'inclusion d'objets partiels imbriqués
  imbriqués.
* Traitement des demandes en mémoire, à forte intensité de ressources 
  (par exemple, le filtrage en mémoire ou la navigation dans le graphe d'objets).
* _n + 1_ requêtes de base de données à la suite de la navigation dans le graphe d'objets lors de la restitution de 
  la réponse.

## Comparaison avec l'API des métadonnées { #gist_vs_metadata_api } 
<!--DHIS2-SECTION-ID:gist_vs_metadata_api-->

L'API standard des métadonnées est une API flexible et puissante, conçue pour répondre à 
tous les cas d'utilisation. 
L'inconvénient est que toutes les fonctionnalités et combinaisons ne peuvent pas être mises à l'échelle tout en 
conservant de bonnes performances en présence d'un grand nombre d'éléments. 
En particulier, les listes d'éléments où chaque élément possède une propriété qui est une 
grande collection d'objets complexes se sont avérées problématiques car elles font 
rapidement référence à une grande partie du graphe d'objets entier.

L'API `/gist` a été ajoutée pour fournir une API de métadonnées où la mise à l'échelle est 
notre première priorité. L'inconvénient est qu'il y a des limites plus distinctes à ce qui est 
techniquement raisonnable, ce qui signifie que toutes les fonctionnalités de l'API standard 
de métadonnées n'existent pas pour l'API Gist.

L'API Gist utilise une stratégie de division et de conquête pour éviter les réponses avec de grands 
graphes d'objets partiels. Au lieu d'inclure des objets ou des listes imbriqués, elle fournit
un URI de point de terminaison `/gist` où cet objet ou cette liste peut être visualisé de manière isolée.

**L'API `/gist` se réfère aux données imbriquées en utilisant les URI plutôt que de les inclure.** 
Cela signifie que si un client est intéressé par ces informations imbriquées, il faudra plus de 
requêtes, mais chacune d'entre elles reste raisonnablement petite et s'adaptera 
bien dans le contexte d'un grand nombre d'éléments potentiels.

Les différences connues :

* les éléments n'incluent que les champs des objets identifiables référencés si ceux-ci n'ont 
  pas de point de terminaison propre 
* ils n'incluent jamais directement les collections d'objets identifiables 
* les éléments par défaut n'incluent pas tous les champs disponibles, mais un sous-ensemble qui dépend 
  du contexte et des paramètres 
* les listes ne peuvent pas être utilisées sans pagination (il n'y a donc pas de paramètre `pagination`) 
* les champs avec les collections ne sont pas paginés en utilisant le transformateur `pagination` mais à travers 
  un point de terminaison API paginé pour la propriété particulière de la collection 
* les éléments d'une liste, la taille d'une propriété de collection ou le résultat 
  toujours en compte le partage d'objets (l'ensemble des éléments pris en compte est toujours l'ensemble 
  visible par l'utilisateur)
* Gist propose les transformateurs de champs de collection  `membre(<id>)` et  `non-membre(<id>)`
* Gist propose un filtre de vérification d'accès de type `peutLire` et `peuModifier` au lieu de filtrer 
  selon la propriété `accès`
* La Gist propose d'utiliser les UID des attributs comme noms de champs et de propriétés de filtrage pour permettre 
  l'établissement de listes ou le filtrage en fonction de valeurs d'attributs personnalisées

Les limites connues :

* only persisted or synthetic fields (those based on persisted fields) can be included
* les filtres ne peuvent être appliqués qu'aux champs persistants
* les commandes ne peuvent être appliquées qu'aux champs persistants
* like-filters are always case-insensitive
* les filtres de jeton ne sont pas disponibles
* l'ordre est toujours sensible à la casse
* Le transformateur `pluck` limité aux propriétés de texte
* Les champs contenant des collections d'éléments simples (non identifiables) ne peuvent pas toujours 
  être inclus en fonction de la manière dont ils sont stockés

Lorsque cela est possible, l'utilisation de l'API `/gist` doit être considérée comme la meilleure façon 
d'obtenir des informations sur les métadonnées.


## Points de terminaison { #gist_endpoints } 
<!--DHIS2-SECTION-ID:gist_Points de terminaison-->

L'API `/gist` a 3 types de points de terminaison :

* <code>/api/&lt;object-type><b>/gist </b></code>: liste paginée de tous les objets connus et visibles du type (implicite `auto=S`)
* <code>/api/&lt;object-type&gt;/&lt;object-id&gt;<b>/gist</b></code> : affichage d'un seul objet par identifiant (implicite `auto=L`)
* <code>/api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;<b>/gist</b></code> : liste paginée de tous les éléments connus et visibles dans la collection du champ de l'objet propriétaire (implicite `auto=M` ; dans le cas d'un champ simple, juste la valeur du champ).

Ces points de terminaison correspondent aux points de terminaison de l'API standard de métadonnées sans 
le suffixe `/gist` et partagent la majorité des paramètres et de leurs options avec 
cette API.


## Données de navigation { #gist_browse } 
<!--DHIS2-SECTION-ID:gist_browse-->

Puisque l'API `/gist` évite les structures de données profondément intégrées dans la réponse, les 
détails des objets complexes ou des listes d'objets référencés sont plutôt fournis 
sous la forme d'un URI vers le point de terminaison gist qui renvoie uniquement l'objet complexe ou 
la liste d'objets. Ces URI sont fournies par le champ `pointsdeterminaisonsdel'api` d'un élément qui est 
automatiquement ajouté à un élément lorsque de telles références existent. 
La propriété item elle-même peut contenir un résultat de transformation sur l'objet 
ou la collection tel que sa taille, sa contenance, sa non contenance, son (ses) identifiant(s) 
ou une propriété extraite telle que son nom.

Pour parcourir manuellement les données, il peut être pratique d'utiliser le paramètre `absoluteUrls=true`. 
Les liens entre les parties de la liste peuvent maintenant être suivis directement dans les navigateurs qui 
affichent les réponses JSON.


## Paramètres { #gist_parameters } 
<!--DHIS2-SECTION-ID:gist_paramètres-->

Tous les points de terminaison de l'API `/gist` acceptent le même ensemble de paramètres.
Les paramètres et leurs options qui n'ont pas de sens dans le contexte du point de terminaison sont 
ignorés.


### Aperçu { #overview } 
Les paramètres par ordre alphabétique :

| Paramètre      | Options               |  Par défaut     | Description          |
| -------------- | --------------------- | ------------ | ---------------------|
| `Urls absolus` | `vrai` or `faux`     | `faux`      | `vrai` utilise les chemins relatifs dans les liens, `faux` utilise les URL absolues dans les liens |
| `automatique`         | `XS`, `S`, `M`, `L`, `XL` | (en fonction du contexte) | étendue des champs sélectionnés par `*` le sélecteur de champ  |
| `champs`       | (en fonction du point de terminaison) | `*`          | liste de champs ou de préréglages séparés par des virgules à inclure |
| `filtre`       | `<field>:<operator>` ou `<field>:<operator>:<value>` |   | liste de filtres de champs de requête séparés par des virgules (peut être utilisée plus d'une fois) |
| `sans titre`     | `vrai` or `faux`     | `faux`      | `true` skip wrapping result in a pager (ignores `total`), `false` use a pager wrapper object around the result list |
| `inversé`      | `vrai` or `faux`     | `faux`      | La valeur `vrai` renvoie les éléments **pas** dans la liste, la valeur `faux` renvoie les éléments dans la liste. |
| `locale`       |                       | (langue configurée du compte utilisateur) | remplacement de la langue de traduction |
| `ordre`        | `<field>` or  `<field>:asc` or `<field>:desc` | `:asc` | comma separated list of query order fields (can be used more than once) |
| `page`         | 1-n                   | 1            | numéro de page |
| `taille de la page`     | 1-1000                | 50           | nombre d'éléments sur une page |
| `jonction de racines` | `ET` or `OU`         | `ET`        | combinaison logique de `filtres`, `ET`= tous doivent correspondre, `OU`= au moins un doit correspondre |
| `total`        | `vrai` or `faux`     | `faux`      | `vrai` ajoute le nombre total de correspondances à la pagination, `faux` ne compte pas le nombre total de correspondances |
| `traduire`    | `vrai` or `faux`     | `vrai`       | `vrai` traduit toutes les propriétés traduisibles, `faux` saute la traduction des propriétés traduisibles (pas d'effet sur les noms d'affichage synthétiques) |


### Le paramètre `absoluteUrls` { #gist_parameters_absoluteUrls } 
<!--DHIS2-SECTION-ID:gist_les paramètres_absoluteUrls-->

Par défaut, les URIs dans les `points de terminaison api`, `href` et les membres `précedent` et `suivant` de la`pagination` 
sont relatifs, et commencent par le chemin `/<object-type>/`.

Les URI peuvent être changés en URL absolues en utilisant le paramètre `absoluteUrls`.

Par exemple, `/api/users/rWLrZL8rP3K/gist?fields=id,href` renvoie :

```json
{
  "id": "rWLrZL8rP3K",
  "href": "/users/rWLrZL8rP3K/gist"
}
```

tandis que `/api/users/rWLrZL8rP3K/gist?fields=id,href&absoluteUrls=true` 
renvoie :

```json
{
  "id": "rWLrZL8rP3K",
  "href": "http://localhost:8080/api/users/rWLrZL8rP3K/gist?absoluteUrls=true"
}
```

Comme le montre l'exemple, le paramètre `absoluteUrls` est également transmis ou reporté 
dans les URLs incluses, ce qui permet de parcourir les réponses en suivant les 
URLs fournies.


### Le Paramètre `auto` { #the-auto-parameter } 
Chaque point d'accès définit implicitement une valeur par défaut pour l'étendue des champs correspondant 
au sélecteur de champs`*` / `:tout` :

* `/api/<object-type>/gist` : implique que `auto=S`
* `/api/<object-type>/<object-id>/gist`: implique que `auto=L`
* `/api/<object-type>/<object-id>/<field-name>/gist`: implique que `auto=M`

Le paramètre `auto` est utilisé pour surcharger manuellement la valeur par défaut afin que les éléments 
de la liste incluent plus ou moins de champs. Ce paramètre agit à nouveau comme une valeur par défaut qui peut 
être modifiée pour chaque champ à l'aide d'une transformation explicite.

Les options possibles pour `auto` sont (" les tailles de t-shirt ") :

* `XS` : inclut uniquement les identifiants et les propriétés textuelles
* `S` : exclut les propriétés complexes (objets), les collections sont uniquement liées (non comptabilisées)
* `M` : complexe inclus en tant qu'URL de référence, les références et les collections en tant qu'URL de comptage et de référence
* `L` : comme `M` mais les références et les collections sont incluses en tant qu'identifiants (OBS ! non consolidé en taille)
* `XL` : comme `L` mais les références et les collections sont incluses en tant qu'objets de l'identifiant : `{ "id" : <id>}`

Par exemple, `/api/users/gist` listerait les éléments avec les champs `identifiant`, `nom`, 
`prénom`, `numéro de téléphone`, `email`, `dernière mise à jour` alors que 
`/api/users/gist?auto=XS` ne liste que l' `identifiant`, le `nom`,
le `prénom`, le `numéro de téléphone`, l'`email`. L'utilisation de `/api/users/gist?auto=L` inclurait également `unités d'organisation`, `unités d'organisation de visualisation des données`, 
`Unités d'organisation de recherche d'instances d'entités suivis` et `groupes d'utilisateurs`, chacun avec la liste des identifiants des
membres des listes/ensembles.


### Le paramètre `champs` { #gist_parameters_fields } 
<!--DHIS2-SECTION-ID:gist_les paramètres_champs-->

Spécifie la liste des champs à inclure pour chaque élément de la liste.

Les champs sont inclus dans les résultats des objets JSON pour un élément dans l'ordre indiqué. 
Un preset dans la liste des champs est étendu aux champs qu'il contient en fonction de la 
position qu'il occupe dans la liste `fields`. 
Les champs de la présélection sont classés de simple à complexe.

Si aucun paramètre `fields` n'est fourni, `fields=*` est pris en compte.
Notez que les champs du `*`preset dépendent également du paramètre `auto`.

Pour supprimer un champ, utilisez `!<name>` ou `-<name>` dans la liste des champs.
Par exemple, pour supprimer les groupes d'utilisateurs d'un utilisateur, utilisez :

    /api/users/gist?fields=*,!groupes d'utilisateurs

Le même principe peut être utilisé pour spécifier le transformateur à utiliser pour un 
champ. Par exemple, pour inclure les identifiants des groupes d'utilisateurs de l'utilisateur, utilisez :

    /api/users/gist?fields=*,groupes d'utilisateurs::identifiants

Le paramètre `champs` permet de lister les champs des objets imbriqués. 
Par exemple, pour ajouter `références de l'utilisateur` avec `identifiant` et `nom` d'un utilisateur, utilisez :

    /api/users/gist?fields=*,références de l'utilisateur[identifiant,Nom d'utilisateur]

Cela crée des éléments du genre :

```json
{
  ...
  "références de l'utilisateur": {
    "identifiant": "Z9oOHPi3FHB",
    "Nom d'utilisateur": "invité"
  }
}
```

Lors de l'inclusion de champs imbriqués de collections, le champ imbriqué doit être une 
propriété textuelle.

Par exemple pour inclure tous les `nom`s des `groupes d'utilisateurs` d'un utilisateur par :

    /api/users/gist?fields=*,groupes d'utilisateurs[nom]

La liste des `groupes d'utilisateurs` est la suivante:

```json
{
  "groupes d'utilisateurs ": {
    "nom": [
      "_PROGRAMME_Programme pour les patients hospitalisés",
      "_PROGRAMME_Programme TB",
      "_ENSEMBLE DE DONNÉES_Superutilisateur",
      "_PROGRAMME_Superutilisateur",
      "_ENSEMBLE DE DONNÉES_Agent de saisie des données",
      "_ENSEMBLE DE DONNÉES_Agent M et E"
    ]
  }
}
```
Ce qui précède est fonctionnellement identique à :

    /api/users/gist?fields=*,groupe d'utilisateurs::pluck( nom)~renommer(groupe d'utilisateurs.nom)

Lorsque l'on demande un seul champ, comme `/api/users/gist?fields=nom`, la réponse est une liste (toujours paginée) de valeurs simples :

```json
{
  "pager": {
    "page": 1,
    "taille de la page": 50
  },
  "utilisateurs": [
    "Kamara",
    "Wakiki",
    "Nana",
    "Malai",
    ...
  ]
}
```

Lorsque l'on demande un champ unique de l'objet d'un propriétaire spécifique qui a une valeur simple 
(sans collection), comme par exemple 
`/api/users/rWLrZL8rP3K/gist fields=surname`, la réponse comprend uniquement la valeur 
JSON simple:

```json
"Wakiki"
```

Pour plus de détails sur les préréglages de champs, voir la section [Champs](#gist_fields).

### Le paramètre `filtre` { #gist_parameters_filter } 
<!--DHIS2-SECTION-ID:gist_paramètres_filtre-->

Pour filtrer la liste des éléments renvoyés, ajoutez un ou plusieurs paramètres `filtre`.

Plusieurs filtres peuvent être spécifiés sous la forme d'une liste séparée par des virgules d'un seul paramètre 
ou comme de multiples paramètres `filtre`, chacun avec un seul `filtre`.

Il existe deux types de filtres :

* unitaire: `<field>:<operator>`
* binaire: `<field>:<operator>:<value>`

Un champ peut être : 

* un champ persistant du type d'élément énuméré
* un champ maintenu d'un objet directement référencé (relation 1:1)
* l'UID d'un attribut

Les opérateurs unitaires disponibles sont les suivants :

| Opérateur unitaire | Description                                                 |
| -------- | ----------------------------------------------------------------- |
| `nul`   | le champ est _nul_ (non défini)                                       |
| `!nul`  | le champ est _non nul_ (défini)                                     |
| `vide`  | Le champ est une collection ou une chaîne _vide_                           |
| `!vide` | le champ est une collection ou une chaîne de caractères _non vide_                       |

Les opérateurs binaires disponibles sont les suivants :

| Opérateur binaire   | Description                                              |
| ----------------- | -------------------------------------------------------- |
| `eq`              | champ _égal_ valeur                                     |
| `!eq`, `neq`, `ne`| champ _non égal_ valeur                               |
| `lt`              | champ _inférieur à_ valeur                               |
| `le`, `lte`       | champ _inférieur ou égal à_ valeur                   |
| `gt`              | champ _supérieur à_ valeur                            |
| `ge`, `gte`       | champ _supérieur ou égal à_ valeur                |
| `in`              | le champ est une collection et la valeur est un élément _contenu dans_ la collection |
| `!in`             | le champ est une collection et la valeur est un élément _non contenu dans_ la collection |

Si la `<value>` d'un filtre `in` ou `!in` est une liste, il est donné sous la forme suivante
`[valeur1,valeur2,...]`, par exemple: `groupes d'utilisateurs:dans:[fbfJHSPpUQD,cYeuwXTCPkU]`.

Toute comparaison `>`, `>=`, `<` `<=`, `==` ou `!=` appliquée à un champ de collection 
avec une valeur numérique comparera la taille de la collection à la valeur, par 
exemple : `groupes d'utilisateurs:gt:0`.

Les opérateurs de recherche de motifs binaires disponibles sont les suivants :

| Opérateur binaire                   | Description                              |
| --------------------------------- | ---------------------------------------- |
| `like`, `ilike`                   | champ _contient_ `<value>` ou champ _correspond_ au motif `<value>` (lorsque les caractères génériques `*` ou `?` sont présents dans la valeur) |
| `!like`, `!ilike`                 | le champ ne _contient pas_ `<value>` ou le champ ne _correspond pas_ au motif `<value>` (lorsque les caractères génériques `*` ou `?` sont présents dans la valeur) |
| `$like`, `$ilike`, `démarreAvec`   | le champ _commence avec_ `<value>`            |
| `!$like`, `!$ilike`, `!démarreAvec`| le champ ne_commence pas avec_ `<value>`    |
| `like$`, `ilike$`, `se termine avec`     | le champ _se termine par_ `<value>`              |
| `!like$`, `!ilike$`, `!se termine avec`  | le champ ne_se termine pas par_ `<value>`      |

Les opérateurs `like` et `!like` peuvent être utilisés soit en fournissant un terme de recherche, 
et dans ce cas la correspondance est toute valeur où le terme apparaît à tout endroit, soit 
en fournissant le motif de recherche en utilisant `*` comme _nombre quelconque de caractères_ 
et `?` comme _caractère unique_.

Notez que les filtres sur les valeurs d'attributs utilisent une comparaison basée sur le texte, ce qui signifie que 
tous les filtres textuels sont pris en charge.

Operators have multiple aliases to be backwards compatible with the 
standard metadata API. For the gist API any like is always case-insensitive. 

Par exemple, pour ne répertorier que les organisations de deuxième niveau, utilisez

    /api/organisationUnits/gist?filter=level:eq:2

De même, lorsqu'il s'agit de lister les `enfants` d'une unité d'organisation particulière, la 
collection peut être filtrée. Pour ne lister que les enfants qui sont connectés à
à un programme, on peut utiliser:

    /api/organisationUnits/rZxk3S0qN63/children/gist?filter=programs:gt:0

Opérateurs binaires pour le filtrage basé sur l'accès (le partage) :

| Opérateur binaire   | Description                                              |
| ----------------- | -------------------------------------------------------- |
| `peutLire`         | L'utilisateur `<value>` de métadonnées a t'il le droit de consulter l'objet |
| `peutModifier`        | L'utilisateur `<value>` de métadonnées a t-il le droit de modifier l'objet ? |
| `peut Lire les données`     | L'utilisateur `<value>` des données a t'il le droit de consulter l'objet    |
| `peutModifier les données`    | L'utilisateur `<value>` des données a t-il le droit de modifier l'objet ?   |
| `peutAccéder`       | L'utilisateur a t'il la `<value0>` permission `<value1>` d'accéder à l'objet   |

Lorsque l'identifiant de l'utilisateur `<value>` est omis, la vérification est effectuée pour 
l'utilisateur actuellement connecté. De même, si `<value0>` est omis pour le filtre `peutAccéder`, 
la vérification est effectuée pour l'utilisateur actuellement connecté.

Lorsqu'il est appliqué à une propriété de valeur simple, ici `code`, le filtre limite la réponse à 
ces  éléments de données (propriétaire de l'objet) que l'utilisateur peut lire/modifier :

    /api/dataElements/gist?filter=code:canWrite:OYLGMiazHtW

Lorsqu'il est appliqué à une propriété de référence, ici `combinaison de catégories`, le filtre limite la réponse 
à ces éléments de données ayant une combinaison de catégories que l'utilisateur peut lire/modifier:

    /api/dataElements/gist?filter=categoryCombo:canWrite:OYLGMiazHtW

Lorsqu'il est appliqué à une propriété de collection de référence, ici `groupe d'éléments de données`, le 
filtre limite la réponse à ces éléments de données pour lesquels un groupe d'éléments de données existe dans la 
propriété de collection et que l'utilisateur peut lire/modifier :

    /api/dataElements/gist?filter=dataElementGroups:canWrite:OYLGMiazHtW

La fonction `peutAccéder` demande deux arguments, le premier est l'identifiant de l'utilisateur, le second le modèle d'accès,
par exemple, pour vérifier l'accès en lecture et en modification des métadonnées, le motif est `rw%` :

    /api/dataElements/gist?filter=code:canAccess:[OYLGMiazHtW,rw%]

### Le paramètre `sans titre` { #gist_parameters_headless } 
<!--DHIS2-SECTION-ID:gist_paramètres_sans titre-->

Les points d'extrémité qui renvoient une liste enveloppent par défaut les éléments dans une enveloppe contenant 
le `pager` et la liste, qui est nommée en fonction du type d'objet listé.

Par exemple, l'option `/api/organisationUnits/gist` renvoie :

```json
{
  "pager": {
    "page": 1,
    "taille de la page": 50,
    "page suivante": "/organisationUnits/gist?page=2"
  },
  "unités d'organisation": [
    ...
  ]
}
```

Avec `headless=true`, la réponse à `/api/organisationUnits/gist?headless=true` 
est juste la partie de la liste `[...]` de l'exemple ci-dessus.


### Le Paramètre `inverse`  { #the-inverse-parameter } 
Le `inverse` peut être utilisé dans le contexte d'un champ de collection gist de la forme 
`/api/<object-type>/<object-id>/<field-name>/gist` pour ne pas lister tous les éléments qui
sont contenus dans la collection membre mais tous les éléments qui ne sont **pas** contenus 
dans la collection membre.

Par exemple, alors que 

    /api/organisationUnits/rZxk3S0qN63/children/gist

listerait toutes les unités d'organisation qui sont des enfants de `rZxk3S0qN63` l'inverse

    /api/organisationUnits/rZxk3S0qN63/children/gist?inverse=true

listerait toutes les unités d'organisation qui ne sont pas des enfants de `rZxk3S0qN63`. 
Cela pourrait par exemple être utilisé pour composer une liste de toutes les unités qui peuvent devenir des enfants 
d'une unité particulière.

Les filtres et les commandes s'appliquent normalement, c'est-à-dire qu'ils filtrent ou commandent les éléments
non contenus dans la collection de membres.


### Le paramètre `local`  { #gist_parameters_locale } 
<!--DHIS2-SECTION-ID:gist_paramètres_local-->
Le paramètre `locale` est généralement utilisé à des fins de test pour changer 
de manière ad-hoc la langue de traduction des noms d'affichage. 

Si elle n'est pas spécifiée, la langue de traduction est celle configurée dans les paramètres 
du compte de l'utilisateur.

Exemples:

    /api/organisationUnits/gist?locale=en
    /api/organisationUnits/gist?locale=en_GB

### Le paramètre `ordre`  { #gist_parameters_order } 
<!--DHIS2-SECTION-ID:gist_paramètres_ordre-->

Pour trier la liste des éléments, une ou plusieurs expressions d'ordre peuvent être données.

Une expression d'ordre est soit un simple nom de champ persistant, soit un nom de champ 
suivi de `:asc` (ordre croissant - par défaut) ou de `:desc` 
(ordre décroissant).

Par exemple, pour trier les unités d'organisation par ordre alphabétique de nom, utilisez :

    /api/organisationUnits/gist?order=name

L'ordre alphabétique inverse serait utilisé :

    /api/organisationUnits/gist?order=name:desc

Pour trier les unités d'organisation en premier lieu par niveau, puis par nom, utilisez :

    /api/organisationUnits/gist?order=level,name

On commencera par la (les) racine(s) au niveau 1. Pour commencer avec les unités foliaires, utilisez :

    /api/organisationUnits/gist?order=level:desc,name

Si aucun ordre n'est spécifié, la liste des résultats aura un ordre stable basé sur 
l'organisation interne des données.


### Le paramètre `page`  { #gist_parameters_page } 
<!--DHIS2-SECTION-ID:gist_paramètres_page-->

Fait référence à la page consultée dans la liste des pages, en commençant par `1` pour la première page.

Si le paramètre `page` n'est pas présent, il est égal à `page=1`.

La `page` est toujours en relation avec la `taille de la page`.
Si une `page` est indiquée au-delà du nombre de correspondances existantes, une liste d'éléments vide 
est renvoyée.


### Le paramètre `taille de la page` { #gist_parameters_pageSize } 
<!--DHIS2-SECTION-ID:gist_paramètres_taille de la page-->

Indique le nombre d'éléments d'une `page`. Le maximum est de 1000 éléments.

Si le paramètre `taille de la page` n'est pas présent, il est égal à `taille de la page=50`.


### Le paramètre `jonction de racines`  { #gist_parameters_rootJunction } 
<!--DHIS2-SECTION-ID:gist_paramètres_jonction de racines-->

Le paramètre `jonction de racines` peut être utilisé pour définir explicitement la jonction logique 
utilisée entre les filtres. Les possibilités sont les suivantes :

* `ET` : tous les filtres doivent correspondre à une donnée pour qu'elle soit incluse dans les résultats
* `OU` : l'un des filtres correspond à une donnée pour qu'elle soit incluse dans les résultats

La valeur par défaut est `ET`


### Le paramètre  `total` { #gist_parameters_total } 
<!--DHIS2-SECTION-ID:gist_paramètres_total-->

Par défaut, une requête gist ne comptera **pas** le nombre total de correspondances si celles-
ci dépassent la limite `taille de la page`. Au lieu de cela, nous acceptons les coûts supplémentaires 
que le comptage total implique.

Si l'on ne compte pas le nombre total de correspondances (`Total=faux`), la réponse `pager`
suppose qu'il y a une page `suivante` dans le cas où des éléments `taille de la page` ont été trouvés. Ceci
pourrait cependant s'avérer faux lorsque l'on navigue sur la page. De plus, le champ `total`
indiquant le nombre de correspondances totales n'est pas inclus dans le `pager`.

Par exemple, `/api/organisationUnits/gist` renvoie un `pager` :

```json
{
  "pager": {
    "page": 1,
    "taille de la page": 50,
    "page suivante": "/organisationUnits/gist?page=2"
  }
}
```

Lorsque l'on compte le nombre total de correspondances (`Total=vrai`), la réponse `pager` 
contiendra le champ `total` avec le nombre réel de correspondances totales au prix 
d'une opération supplémentaire sur la base de données.

La réponse à `/api/organisationUnits/gist?total=true` renvoie maintenant ce `pager` :

```json
{
  "pager": {
    "page": 1,
    "taille de la page": 50,
    "total": 1332,
    "page suivante": "/organisationUnits/gist?total=true&page=2",
    "nombre de pages": 27
  }
}
```


### Le paramètre `traduire`  { #gist_parameters_translate } 
<!--DHIS2-SECTION-ID:gist_paramètres_traduire-->

Les champs tels que `nom` ou `Nomcourt` peuvent être traduits (internationalisés).

Par défaut, tout champ traduisible ayant une traduction est renvoyé traduit
à condition que la langue de l'interface soit configurée par l'utilisateur qui demande la gist.

Pour retourner le champ non traduit, utilisez `traduit=faux`.

Par exemple, `/api/organisationUnits/gist` renvoie des éléments comme suit :

```json
{
  "nom": "Un nom traduit",
  ...
}
```

Alors que `/api/organisationUnits/gist?translate=false` renverrait des éléments comme :

```json
{
  "nom"
  "Nom du champ brut",
  ...
}
```

Notez que les champs synthétiques `Afficher le nom` et `Afficher le nom court` renvoient toujours
la valeur traduite, indépendamment du paramètre `traduire`.


## Champs  { #gist_fields } 
<!--DHIS2-SECTION-ID:gist_champs -->

Les champs inclus par défaut (sans le paramètre `champs`) correspondent à 
`champs=*`. 
Cela signifie que la liste des champs affichés dépend du type d'objet, du contexte du point d'extrémité 
ainsi que du paramètre `auto`. 

Notez que l'API `/gist` exclut toujours certains champs qui ne sont généralement pas 
importants pour les clients, comme par exemple les champs `traductions` ou `partage`. 
Ceux-ci peuvent être ajoutés explicitement.

Lorsqu'elle n'est pas explicitement fournie par un nom dans les paramètres `champs`, la liste 
des champs est calculée à partir d'un préréglage.
Un préréglage peut être utilisé dans la liste des champs comme un nom de champ. 
Il se développe en zéro, un ou plusieurs champs en fonction du type d'objet, du point 
d'extrémité utilisé et du sélecteur.


### Préréglages des champs { #field-presets } 

* `*` / `:tous`: les champs par défaut dépendent du contexte et du paramètre `auto`
* `:identifiable` : tous les champs maintenus de l'interface `Objet identifiable` 
* `:propriétaire` : tous les champs maintenus pour lesquels le type listé est le propriétaire
* `:nommable` : tous les champs maintenus de l'interface `ObjetNommable`
* `:maintenus` : littéralement tous les champs maintenus 


### Transformateurs de champ { #field-transformers } 
Un transformateur ou une transformation peut être appliqué à un champ en ajoutant 
l'un des indicateurs `::`, `~` ou `@` suivi de l'expression du transformateur.

Les expressions de transformateur disponibles sont les suivantes :

| Transformateur        | Type de résultat JSON    | Description                       |
| ------------------ | ------------------- | --------------------------------- |
| `renommer(<name>)`   | -                   | renomme le champ dans la réponse en `<name>` |
| `taille`             | `nombre`            | nombre d'éléments dans le champ de la collection |
| `estVide`          | `booléen`           | vide d'un champ de collecte   |
| `n'estPasvide`       | `booléen`           | non-emptiness of a collection field |
| `identifiants`              | `chaîne` or `[chaîne]` | Identifiant d'un objet ou identifiant d'éléments d'une collecte |
| `Identifiant - Objets`       | `[{ "identifiant": <id> }]`  | Identifiants des éléments de la collecte en tant qu'objet |
| `membre(<id>)`     | `booléen`           | a un membre avec `<id>` pour le champ de collecte |
| `pas-membre(<id>)` | `booléen`           | n'a pas de membre avec `<id>` pour le champ de collecte |
| `pluck(<field>)`   | `chaîne` or `[chaîne]` | extrait une seule propriété de texte de l'objet ou de chaque élément de la collecte |

Un champ peut recevoir à la fois le transformateur `renommer` et l'un des autres 
transformateurs, par exemple :

    /api/organisationUnits/gist?fields=*,children::size~rename(child-count)

Les éléments renvoyés n'ont plus de membre `enfants` mais un membre `nombre-d'enfants`
à la place. Notez que `renommer` affecte aussi le nom du membre de la référence de l'URI
donnée dans `l'apidespointsd'Extrémités`


## Champs synthétiques { #gist_syntheticFields } 
<!--DHIS2-SECTION-ID:gist_Champs synthétiques-->

L'API `/gist` est étroitement liée aux propriétés qui existent dans la base de données.
Cela signifie que les propriétés qui ne sont pas stockées dans la base de données ne sont généralement pas 
disponibles.
L'exception à cette règle sont les propriétés "synthétiques" qui sont dynamiquement 
calculées sur la base d'une ou plusieurs propriétés stockées dans la base de données.

Les propriétés synthétiques sont disponibles pour tous les points d'extrémité où existent 
les propriétés maintenues nécessaires au calcul de la propriété synthétique.

A l'exception de la propriété `points d'extrémité de l'api` qui est automatiquement ajoutée si nécessaire 
toutes les autres propriétés synthétiques ne sont pas incluses par défaut et doivent faire 
l'objet d'une demande explicite dans la liste des `champs`. 


### Aperçu { #overview } 
Champs synthétiques par ordre alphabétique :

| Champ              | Description                                             |
| ------------------ | ------------------------------------------------------- |
| `points d'extrémité de l'api`     | contient des liens permettant de parcourir des objets ou des collections complexes imbriqués |
| `href`             | lien vers l'élément de la liste elle-même ( affichage d'un seul élément)         |
| `Nom d'affichage`      | `nom` traduit (toujours traduit)                   |
| `afficherNomCourt` | translated `displayName` (always translated)            |
| `accès`           | résumé sur la capacité de l'utilisateur actuel à lire/saisir/modifier les données |


### Le Champ `href` { #gist_syntheticFields_href } 
<!--DHIS2-SECTION-ID:gist_Champs synthétiques_href-->

Chaque élément d'une réponse `/gist` peut avoir un lien vers lui-même. Ce lien est donné 
dans la propriété `href`.

Pour ajouter le champ `href`, utilisez (par exemple) :

    /api/<object-type>/gist?fields=*,href

### Le champ `afficherNom` et `afficherNomCourt` { #gist_syntheticFields_displayName } 
<!--DHIS2-SECTION-ID:gist_Champs synthétiques_afficherNom-->

Par définition, le `afficherNom` est le `nom` traduit et le `afficherNomCourt` est le `nom court` traduit. 

Pour ajouter `afficherNom` ou `afficherNomCourt` à la liste, utilisez (par exemple) :

    /api/<object-type>/gist?fields=*,afficherNom
    /api/<object-type>/gist?fields=*,afficherNomCourt

Notez que par défaut, toutes les propriétés traduisibles comme `nom` et `nomCourt` 
seront également traduites. Lorsque `traduire=faux` est utilisé pour désactiver cela, 
`afficherNom` et `afficherNomCourt` restent traduits. 


### Le Champ `points d'extrémité de l'api`  { #gist_syntheticFields_apiEndpoints } 
<!--DHIS2-SECTION-ID:gist_Champs synthétiques_points d'extrémité de l'api-->

Cette propriété permet de parcourir des objets complexes ou des listes 
d'éléments qui sont inclus dans la réponse `/gist` sous la forme d'une valeur simple 
transformée comme un nombre d'éléments.

L'objet `points d'extrémité de l'api` aura un membre du même nom pour chaque membre 
de l'élément qui a été transformé en valeur simple.

Par exemple, 

    /api/users/gist?fields=id,userGroups::size,organisationUnits::size 

renvoie les éléments du formulaire :

```json
{
  "identifiant": "rWLrZL8rP3K",
  "groupes d'utilisateurs": 0,
  "unités d'organisation": 1,
  "points d'extrémité de l'api": {
    "unités d'organisation": "/utilisateurs/rWLrZL8rP3K/unités d'organisation/gist",
    "groupes d'utilisateurs": "/utilisateurs/rWLrZL8rP3K/groupes d'utilisateurs/gist"
  }
}
```

La liste des `groupes d'utilisateurs` et des `unités d'organisation` est incluse dans leur `taille`. 
Chacun a un membre correspondant dans `points d'extrémité de l'api` avec un chemin pour parcourir la
liste.

Les chemins peuvent être transformés en URL en utilisant le paramètre `Urls absolus`. 

    /api/users/gist?fields=id,userGroups::size,organisationUnits::size&absoluteUrls=true

renvoie les éléments du formulaire :

```json
{
  "identifiant": "rWLrZL8rP3K",
  "groupes d'utilisateurs": 0,
  "unités d'organisation": 1,
  "points d'extrémité de l'api": {
    "unités d'organisation":"http://{host}/api/users/rWLrZL8rP3K/organisationUnits/gist?absoluteUrls=true",
    "groupes d'utilisateurs": http://{host}/api/users/rWLrZL8rP3K/userGroups/gist?absoluteUrls=true"
  }
}
```

### Le Champ `accès` { #the-access-field } 
Le résumé `accès` est basé sur le `partage` et l'utilisateur actuel.
Cela signifie qu'il n'est applicable qu'aux objets ayant une propriété `partage`.

Par exemple, lors de l'établissement d'une liste d'éléments de données avec le champ `accès`

    /api/dataElements/gist?fields=*,access

les éléments de données renvoyés contiennent un membre `"accès"` comme ci-dessous :

```json
"accès": {
  "gérer": faux,
  "externaliser": faux,
  "modifier": faux,
  "lire": vrai,
  "mettre à jour": faux,
  "supprimer": faux
}
```

### Attributs comme Champs { #gist_attributeFields }
DHIS2 permet de créer et d'ajouter des attributs personnalisés aux objets de métadonnées. 
Leurs valeurs sont contenues dans la propriété `valeurs d'attributs` d'un objet de métadonnées 
sous la forme d'une carte dont la clé est l'UID de l'attribut.

Pour lister directement une ou plusieurs valeurs d'attributs spécifiques de cette carte comme s'il 
s'agissait de champs habituels de l'objet de métadonnées, l'UID de l'attribut peut être utilisé comme s'il 
s'agissait du nom d'un champ habituel.

Par exemple, pour inclure la valeur de l'attribut avec l'UID `Y1LUDU8sWBR` en tant que 
la propriété `unité de mesure` dans la liste, utilisez :

    /api/dataElements/gist?fields=id,name,Y1LUDU8sWBR::rename(unit-of-measure)

Il en résulte des éléments de liste du type
```json
{
  "identifiant": "qrur9Dvnyt5",
  "nom": "Âge en années",
  "unité de mesure" : "années"
}
```

Par défaut, les valeurs sont récupérées au format JSON et extraites de la carte des 
valeurs d'attributs. Cela signifie que la liste contiendra le type JSON approprié pour
le type de valeur d'attribut. Cela implique un surcoût lié à la récupération de toutes 
les valeurs d'attributs. Pour isoler la valeur dans la base de données, la transformation `PLUCK` 
peut être utilisée.

    /api/dataElements/gist?fields=id,name,Y1LUDU8sWBR::rename(unit-of-measure)~pluck

Le résultat sera le même, mais la valeur est désormais extraite sous forme de texte dans la 
base de données, ce qui transforme toute valeur JSON en une chaîne de caractères dans le résultat de la propriété. 

## Exemples { #gist_examples } 
<!--DHIS2-SECTION-ID:gist_exemples-->
Quelques exemples partant de simples listes et allant jusqu'à des cas d'utilisation très spécifiques. 

Il est préférable de toujours fournir une liste explicite de `champs` pour que cette section 
le fasse.

Liste des unités d'organisation avec leur identifiant et leur nom :

    /api/organisationUnits/gist?fields=id,name

Liste des unités d'organisation avec leur identifiant, leur nom et leur nombre total :

    /api/organisationUnits/gist?fields=id,name&total=true

Liste des utilisateurs avec l'identifiant et le nom d'utilisateur :

    /api/users/gist?fields=id,userCredentials.username

Liste des utilisateurs avec l'identifiant, le nom d'utilisateur et la date de la dernière connexion :

    /api/users/gist?fields=id,userCredentials[username,lastLogin]

Ne listez que les unités d'organisation au deuxième niveau avec l'identifiant, le nom et le niveau :

    /api/organisationUnits/gist?fields=id,name,level&filter=level:eq:2

Listez uniquement les unités d'organisation qui ont plus d'un enfant avec l'identifiant, le nom et 
le nombre d'enfants :

    /api/organisationUnits/gist?fields=id,name,children::size&filter=children:gt:1

Listez uniquement les unités d'organisation qui ne sont pas encore enfants d'une autre unité
`zFDYIgyGmXG` :

    /api/organisationUnits/zFDYIgyGmXG/children/gist?fields=id,name&inverse=true

Listez les utilisateurs et indiquez s'ils sont membres d'un groupe d'utilisateurs spécifique. 
`NTC8Gj7p8P` et nommer ce champ `est-membre` dans la réponse :

    /api/users/gist?fields=id,userCredentials.username,userGroups::member(NTC8GjJ7p8P)~rename(is-member)

Listez les liens vers tous les utilisateurs dans des pages de 10 éléments :

    /api/users/gist?fields=href&absoluteUrls&pageSize=10




# Données { #data }

## Valeurs des données { #webapi_data_values }

Cette section traite de l'envoi et de la lecture des données.

    /api/33/dataValueSets

### Envoi de données { #webapi_sending_data_values }

Un cas d'utilisation courant pour l'intégration des systèmes est la nécessité d'envoyer un ensemble de valeurs de données d'un système tiers vers DHIS. Dans cet exemple, nous utiliserons la démonstration DHIS2 sur `http://play.dhis2.org/demo`. Supposons que nous avons collecté des données basées sur les cas à l'aide d'un simple logiciel client installé sur des téléphones portables pour l'ensemble de données *Mortalité <5 ans* dans la communauté du *Ngelehun CHC* (dans la chefferie *Badjia*, district *Bo*) pour le mois de janvier 2014. Nous avons maintenant agrégé nos données dans un rapport statistique et nous voulons envoyer ces données à l'instance DHIS2. L'URL de base de l'API de démonstration est `http://play.dhis2.org/demo/api`. Les liens suivants sont associés à l'URL de base.


La ressource la plus appropriée pour notre objectif d'envoi de valeurs de données est `/api/dataValueSets`. Un ensemble de valeurs de données représente des données qui ont une relation, généralement parce qu'elles ont été saisies dans le même formulaire. Le format ressemble à ceci :

```xml
<dataValueSet xmlns="http://dhis2.org/schema/dxf/2.0" dataSet="dataSetID"
  completeDate="date" period="période" orgUnit="orgUnitID" attributOptionCombo="aocID">
  <dataValue dataElement="dataElementID"
    categoryOptionCombo="cocID" value="1" comment="comment1"/>
  <dataValue dataElement="dataElementID"
    categoryOptionCombo="cocID" value="2" comment="comment2"/>
  <dataValue dataElement="dataElementID"
    categoryOptionCombo="cocID" value="3" comment="comment3"/>
</dataValueSet>
```

JSON est pris en charge dans ce format :

```json
{
  "dataSet": "dataSetID",
  "completeDate": "date",
  "période": "période",
  "orgUnit": "orgUnitID",
  "attributeOptionCombo": "aocID",
  "valeurs de données": [
    {
      "dataElement": "dataElementID",
      "categoryOptionCombo": "cocID",
      "valeur": "1",
      "commentaire": "commentaire1"
    },
    {
      "dataElement": "dataElementID",
      "categoryOptionCombo": "cocID",
      "valeur": "2",
      "commentaire": "commentaire2"
    },
    {
      "dataElement": "dataElementID",
      "categoryOptionCombo": "cocID",
      "valeur": "3",
      "commentaire": "commentaire3"
    }
  ]
}
```

CSV est pris en charge dans ce format :

```csv
"élément de données", "période", "orgunit", "catoptcombo", "attroptcombo", "valeur", "strby", "lstupd", "cmt"
"dataElementID", "période", "orgUnitID", "cocID", "aocID", "1", "nom d'utilisateur", "2015-04-01", "comment1"
"dataElementID", "période", "orgUnitID", "cocID", "aocID", "2", "nom d'utilisateur", "2015-04-01", "comment2"
"dataElementID", "période", "orgUnitID", "cocID", "aocID", "3", "nom d'utilisateur", "2015-04-01", "comment3"
```

> **Remarque**
>
> Veuillez vous référer à la section date et période ci-dessus pour les formats d'heure.

À partir de l'exemple, nous l'importance d'identifier la période, l'ensemble de données, l'unité d'organisation (établissement) et les éléments de données qui nécessite des rapports.

Pour obtenir l'identifiant de l'ensemble de données, nous adressons une requête à la ressource `/api/dataSets`. De là, nous trouverons le lien vers l'ensemble de données *Mortalité < 5 ans* qui nous conduit à `/api/dataSets/pBOMPrpg1QX`.
La ressource de l'ensemble de données *Mortalité < 5 ans* fournit des liens vers les éléments de données qu'elle abrite. D'ici nous pouvons suivre ces liens et obtenir les identifiants des données éléments. Par souci de concision, nous allons déclarer des données pour seulement trois éléments de données : *Rougeole* avec l'identifiant `f7n9E0hX8qk`, *Dysenterie* avec l'identifiant `Ix2HsbDMLea` et *Choléra* avec l'identifiant `eY5ehpbEsB7`.

Il ne nous reste que l'identifiant de l'organisation unité. L'*ensemble de données* fournit un lien vers les unités d'organisation qui produisent des rapports dessus. Nous recherchons donc *Ngelehun CHC* et suivons le lien vers la représentation HTML dans `/api/organisationUnits/DiszpKrYNg8`, qui nous indique que l'identifiant de cette unité d'organisation est `DiszpKrYNg8`.

À partir de nos données basées sur les cas, nous supposons que nous avons 12 cas de rougeole, 14 cas de dysenterie et 16 cas de choléra. Nous avons maintenant assez d'informations pour pouvoir composer le message XML de l'ensemble de valeurs des données :

```xml
<dataValueSet xmlns="http://dhis2.org/schema/dxf/2.0" dataSet="pBOMPrpg1QX"
  completeDate="2014-02-03" period="201401" orgUnit="DiszpKrYNg8">
  <dataValue dataElement="f7n9E0hX8qk" value="12"/>
  <dataValue dataElement="Ix2HsbDMLea" value="14"/>
  <dataValue dataElement="eY5ehpbEsB7" value="16"/>
</dataValueSet>
```

Au format JSON :

```json
{
  "ensembleDeDonnées": "pBOMPrpg1QX",
  "date": "03/02/2014",
  "période": "201401",
  "unitéD'organisation": "DiszpKrYNg8",
  "valeursDeDonnées": [
    {
      "élémentDeDonnées": "f7n9E0hX8qk",
      "valeur": "1"
    },
    {
      "élémentDeDonnées": "Ix2HsbDMLea",
      "valeur": "2"
    },
    {
      "élémentDeDonnées": "eY5ehpbEsB7",
      "valeur": "3"
    }
  ]
}
```

Pour effectuer des tests fonctionnels, nous utiliserons l'outil _curl_ qui permet de transférer facilement des données à l'aide du protocole HTTP. Tout d'abord, nous sauvegardons le contenu XML de l'ensemble de données dans un fichier appelé `datavalueset.xml`. Dans le répertoire où se trouve ce fichier, nous invoquons ce qui suit à partir de la ligne de commande :

```bash
curl -d @datavalueset.xml "https://play.dhis2.org/demo/api/33/dataValueSets"
  -H "Content-Type:application/xml" -u admin:district
```

Pour envoyer du contenu JSON, vous devez définir l'en-tête "type de contenu" comme suit :

```bash
curl -d @datavalueset.json "https://play.dhis2.org/demo/api/33/dataValueSets"
  -H "Content-Type:application/json" -u admin:district
```

La commande enverra une requête à l'API Web de démonstration, définissez `application/xml` comme type de contenu et authentifiez-vous en utilisant `admin`/`district` comme nom d'utilisateur/mot de passe. Si tout se passe bien, le code d'état HTTP `200 OK` sera renvoyé. Vous pouvez vérifier la réception des données en ouvrant le module de saisie de données dans DHIS2 et en sélectionnant l'unité d'organisation, l'ensemble de données et la période utilisés dans cet exemple.

L'API suit la sémantique normale pour la gestion des erreurs et les codes d'état HTTP. Si vous fournissez un nom d'utilisateur ou un mot de passe invalide, `401 Non autorisé` est renvoyé. Si vous fournissez un type de contenu autre que `application/xml`, `415 Type de média non pris en charge` est renvoyé. Si le contenu XML n'est pas valide selon l'espace de noms DXF, `400 Mauvaise requête` est renvoyé. Si vous fournissez un identifiant invalide dans le contenu XML, `409 Conflit` est renvoyé avec un message descriptif.

### Envoi de données en masse { #webapi_sending_bulks_data_values }

L'exemple précédent nous a montré comment envoyer un ensemble de données associées qui partagent la même période et la même unité d’organisation. L'exemple suivant nous montrera comment envoyer de grandes quantités de données qui ne sont pas nécessairement associés.

Encore une fois, nous interagirons avec la ressource `/api/dataValueSets`. Cette fois nous n'allons pas spécifier les attributs `dataSet` et `completeDate`. De plus, nous allons spécifiez les attributs `period` et `orgUnit` comme éléments de données individuelles et non élément d’ensemble de données externes. Cela nous permettra d'envoyer des données pour différentes périodes et unités d'organisation :

```xml
<dataValueSet xmlns="http://dhis2.org/schema/dxf/2.0">
  <dataValue dataElement="f7n9E0hX8qk"
    period="201401" orgUnit="DiszpKrYNg8" value="12"/>
  <dataValue dataElement="f7n9E0hX8qk"
    period="201401" orgUnit="FNnj3jKGS7i" value="14"/>
  <dataValue dataElement="f7n9E0hX8qk"
    period="201402" orgUnit="DiszpKrYNg8" value="16"/>
  <dataValue dataElement="f7n9E0hX8qk"
    period="201402" orgUnit="Jkhdsf8sdf4" value="18"/>
</dataValueSet>
```

Au format JSON :

```json
{
  "dataValues": [
    {
      "dataElement": "f7n9E0hX8qk",
      "période": "201401",
      "orgUnit": "DiszpKrYNg8",
      "valeur": "12"
    },
    {
      "dataElement": "f7n9E0hX8qk",
      "période": "201401",
      "orgUnit": "FNnj3jKGS7i",
      "valeur": "14"
    },
    {
      "dataElement": "f7n9E0hX8qk",
      "période": "201402",
      "orgUnit": "DiszpKrYNg8",
      "valeur": "16"
    },
    {
      "dataElement": "f7n9E0hX8qk",
      "période": "201402",
      "orgUnit": "Jkhdsf8sdf4",
      "valeur": "18"
    }
  ]
}
```

Au format CSV :

```csv
"dataelement","period","orgunit","categoryoptioncombo","attributeoptioncombo","value"
"f7n9E0hX8qk","201401","DiszpKrYNg8","bRowv6yZOF2","bRowv6yZOF2","1"
"Ix2HsbDMLea","201401","DiszpKrYNg8","bRowv6yZOF2","bRowv6yZOF2","2"
"eY5ehpbEsB7","201401","DiszpKrYNg8","bRowv6yZOF2","bRowv6yZOF2","3"
```

Nous effectuons les tests en utilisant "curl" pour envoyer les données au format XML :

```bash
curl -d @datavalueset.xml "https://play.dhis2.org/demo/api/33/dataValueSets"
  -H "Content-Type:application/xml" -u admin:district
```

Notez que lorsque vous utilisez le format CSV, vous devez utiliser l'option de données binaires pour conserver le retour-à-la-ligne dans le fichier CSV :

```bash
curl --data-binary @datavalueset.csv "https://play.dhis2.org/demo/24/api/dataValueSets"
  -H "Content-Type:application/csv" -u admin:district
```

La ressource ensemble de valeurs de données fournit une réponse XML qui est utile lorsque vous voulez vérifier l'impact de votre requête. La première fois que nous envoyons la requête " ensemble de données " ci-dessus, le serveur répondra avec le résumé d'importation suivant :

```xml
<importSummary>
  <dataValueCount imported="2" updated="1" ignored="1"/>
  <dataSetComplete>faux</dataSetComplete>
</importSummary>
```

Ce message nous indique que 3 données ont été importées, 1 donnée a été mise à jour et 0 donnée a été ignorée. La seule mise à jour résulte de l'envoi de cette donnée dans l'exemple précédent. Une donnée sera ignorée si elle fait référence à un élément de données, une période, une unité d'organisation ou un ensemble de données qui n'existent pas. Dans notre cas, cette valeur unique ignorée est due au fait que la dernière donnée faisait référence à une unité d'organisation non valide. L'élément complet de l'ensemble de données affichera la date à laquelle l'ensemble de données a été achevé, ou " faux " si aucun attribut d'élément de données n'a été fourni.

### Paramètres d'importation { #webapi_data_values_import_parameters }

Le processus d'importation peut être personnalisé à l'aide d'un ensemble de paramètres d'importation :



Tableau : Paramètres d'importation

| Paramètre | Valeurs (par défaut en premier) | Description |
|---|---|---|
| dataElementIdScheme (Schéma d'identifiant d'élément de données) | uide &#124; nom &#124; code &#124; attribut:ID | Propriété de l'objet d'élément de données à utiliser pour faire correspondre les données. |
| orgUnitIdScheme (Schéma de l'identifiant de l'unité d'organisation) | uide &#124; nom &#124; code &#124; attribut:ID | Propriété de l'objet d'unité d'organisation à utiliser pour faire correspondre les données. |
| categoryOptionComboIdScheme (Schéma de l'identifiant de la combinaison d'options de catégorie) | uide &#124; nom &#124; code &#124; attribut:ID | Propriété des objets de combinaisons d’options de catégorie et d’options d’attribut à utiliser pour faire correspondre les valeurs de données. |
| dataSetIdScheme (Schéma de l'identifiant de l'ensemble de données) | uide &#124; nom &#124; code&#124; attribut:ID | Propriété de l'objet d'ensemble de données à utiliser pour faire correspondre les données. |
| categoryIdScheme (Schéma de l'identifiant de catégorie) | uide &#124; nom &#124; code&#124; attribut:ID | Propriété de l'objet de catégorie à utiliser pour faire correspondre les données (ADX uniquement). |
| categoryOptionIdScheme (Schéma de l'identifiant d'option de catégorie) | uide &#124; nom &#124; code&#124; attribut:ID | Propriété de l'objet d'option catégorie à utiliser pour faire correspondre les données (ADX uniquement). |
| idScheme | uide &#124; nom &#124; code&#124; attribut:ID | Propriété de l'un des objets ci-dessus s'ils ne sont pas spécifiés, à utiliser pour faire correspondre les données. |
| preheatCache | faux &#124; vrai | Indique s'il faut précharger les caches de métadonnées avant de commencer l'importation des données. Ceci permettra d'accélérer l'importation de grandes quantités de métadonnées. |
| dryRun | faux &#124; vrai | Pour sauvegarder les modifications sur le serveur ou pour renvoyer le résumé de l'importation. |
| importStrategy (stratégie d'importation) | CRÉER &#124; METTRE À JOUR &#124; CRÉER _ET_METTRE À JOUR &#124; SUPPRIMER | Sauvegarde des objets de tous les statuts d'importation, nouveaux ou mis à jour, sur le serveur. |
| skipExistingCheck (ignorer les contrôles existants) | faux &#124; vrai | Ne contrôle pas les données existantes. Améliore les performances. À utiliser uniquement pour les bases de données vides ou lorsque les données à importer n'existent pas encore. |
| skipAudit (ignorer l'audit) | faux &#124; vrai | "Ignorer l'audit" signifie que les valeurs d'audit ne seront pas générées. Améliore les performances au détriment de la capacité à auditer les modifications. Nécessite l'autorité "F_SKIP_DATA_IMPORT_AUDIT". |
| async | faux &#124; vrai | Indique si l'importation doit être effectuée de manière asynchrone ou synchrone. La première option (asynchrone) est adapté aux importations très volumineuses car il garantit que la requête n’expire pas, bien qu’il entraîne une surcharge de performances. La deuxième (synchrone) est plus rapide mais nécessite que la connexion soit maintenue jusqu'à la fin du processus. |
| force | faux &#124; vrai | Indique si l'importation doit être forcée. L'importation de données peut être rejetée pour diverses raisons liées au verrouillage de l'ensemble des données, par exemple en raison de l'approbation, de la période de saisie des données, des jours d'expiration, etc. Pour passer outre ces verrouillages et forcer la saisie des données, il est possible d'utiliser l'importation de données en définissant force=true. Cependant, il faut être un \*superutilisateur\* pour que ce paramètre fonctionne. |

Tous les paramètres sont facultatifs et peuvent être fournis en tant que paramètres de requête dans l'URL de la requête comme ceci :

    /api/33/dataValueSets?dataElementIdScheme=code&orgUnitIdScheme=name
      &dryRun=true&importStrategy=CREATE

Ils peuvent également être fournis en tant qu'attributs XML sur l'élément " ensemble de valeurs de données ", tel qu'indiqué ci-dessous. Les attributs XML remplacent les paramètres de la chaîne de requête.

```xml
<dataValueSet xmlns="http://dhis2.org/schema/dxf/2.0" dataElementIdScheme="code"
  orgUnitIdScheme="name" dryRun="true" importStrategy="CREATE">
</dataValueSet>
```

Notez que le paramètre `preheatCache` peut avoir un impact considérable sur les performances. Pour les petits fichiers d'importation, maintenir "faux" permettra de gagner en rapidité. Pour les gros fichiers d'importation qui contiennent un grand nombre d'éléments de données et d'unités d'organisation distincts, le définir sur "vrai" permettra de gagner en rapidité en termes d'ordre de grandeur.

#### Exigences en matière de valeur des données { #webapi_data_values_import_requirement }

L’importation de valeurs de données prend en charge un ensemble de types de valeurs. Chaque type de valeur a une exigence particulière. Le tableau suivant répertorie les cas extrêmes pour les types valeur.



Tableau : Exigences relatives au type de valeur

| Type de valeur | Exigences | Commentaire |
|---|---|---|
| BOOLÉEN | vrai &#124; C'est vrai &#124; VRAI &#124; faux &#124; Faux &#124; FAUX &#124; 1 &#124; 0 &#124; t &#124; f &#124; | Utilisé lorsque la valeur est booléenne, vraie ou fausse. Le service d'importation ne prête pas attention au fait que l'entrée commence par une lettre majuscule ou minuscule, ou qu'elle soit entièrement en lettres majuscules. |

#### Schémas d'identifiants { #webapi_data_values_identifier_schemes }

En ce qui concerne les schémas d'identifiants, les identifiants utilisés dans les messages XML utilisent par défaut les identifiants d'objets stables de DHIS2 appelés `UID`. Dans certaines situations d'interopérabilité, il se peut qu'un système externe détermine les identifiants des objets. Dans ce cas, nous pouvons utiliser la propriété `code` des unités d'organisation et d'autres objets pour définir des identifiants fixes. Lors de l'importation des valeurs de données, nous devons donc référencer la propriété "code" et non la propriété "identifiant" de ces objets de métadonnées. Les schémas d'identifiants peuvent être spécifiés dans le message XML ainsi que dans la requête en tant que paramètres de requête. Pour les spécifier dans la charge utile XML, vous pouvez procéder comme suit :

```xml
<dataValueSet xmlns="http://dhis2.org/schema/dxf/2.0"
  dataElementIdScheme="CODE" orgUnitIdScheme="UID" idScheme="CODE">
</dataValueSet>
```

Le tableau des paramètres ci-dessus explique comment les schémas d'identifiants peuvent être spécifiés comme paramètres de requête. Les règles suivantes déterminent l'ordre de priorité :

  - Les schémas d'identifiants définis dans la charge utile XML ou JSON ont priorité sur
    les schémas d'identifiants définis comme paramètres de requête URL.

  - Les schémas d'identifiants spécifiques tels que dataElementIdScheme ou
    orgUnitIdScheme ont priorité sur le idScheme général.

  - Si aucun schéma d'identifiants explicite n'est défini, le schéma d'identifiants par défaut est `code`
    pour le format ADX et `uid` pour tous les autres formats.

Les schémas d'identifiants suivants sont disponibles.

  - uid

  - code

  - nom

  - attribut (suivi de l'UID de l'attribut)

L'option d'attribut est spéciale et fait référence aux attributs de métadonnées qui ont été marqués comme *uniques*. En utilisant cette option, l'`attribut` doit être immédiatement suivi de l'identifiant de l'attribut, par exemple "attribut : DnrLSdo4hMl".

#### Importation de valeurs de données asynchrones { #webapi_data_values_async_import }

Les valeurs de données peuvent être envoyées et importées de manière asynchrone à travers un paramètre de requête `async` défini sur *vrai* :

    /api/33/dataValueSets?async=true

Cela lancera une tâche d'importation asynchrone dont vous pourrez surveiller l'état grâce à l'API de résumés des tâches. La réponse de l'API indique l'identifiant unique de la tâche, du type de tâche et de l'URL que vous pouvez utiliser pour surveiller l’état de l'importation. La réponse ressemblera à ceci :

```json
{
  "httpStatus": "OK",
  "httpStatusCode": 200,
  "status": "OK",
  "message": "Initiated dataValueImport",
  "response": {
    "name": "dataValueImport",
    "id": "YR1UxOUXmzT",
    "created": "2018-08-20T14:17:28.429",
    "jobType": "DATAVALUE_IMPORT",
    "relativeNotifierEndpoint": "/api/system/tasks/DATAVALUE_IMPORT/YR1UxOUXmzT"
  }
}
```

Veuillez lire la section sur *l'état des tâches asynchrones* pour en savoir plus.

### Format des valeurs de données CSV { #webapi_data_values_csv }

La section suivante décrit le format CSV utilisé dans DHIS2. La première ligne est supposée être une ligne d'en-tête et sera ignorée lors de l'importation.



Tableau : format CSV de DHIS2

||||
|---|---|---|
| Colonne | Obligatoire | Description |
| Élément de données | Oui | Fait référence à l'ID par défaut, peut également être un nom et un code basés sur le schéma d'identifiants sélectionné |
| Période | Oui | Au format ISO |
| Unité d'organisation | Oui | Fait référence à l'ID par défaut, peut également être un nom et un code basés sur le schéma d'identifiants sélectionné |
| Combinaison d'options de catégorie | Non | Fait référence à l'identifiant |
| Combinaison d'options d'attribut | Non | Fait référence à l'ID (à partir de la version 2.16) |
| Valeur | Non | Valeur de données |
| Stocké par | Non | Fait référence au nom d'utilisateur de l'utilisateur qui a saisi la valeur |
| Dernière mise à jour | Non | Date au format ISO |
| Commentaire | Non | Commentaire en texte libre |
| Suivi | Non | vrai ou faux |

Ci-dessous un exemple de fichier CSV pouvant être importé dans DHIS2 :

```csv
"dataelement","period","orgunit","catoptcombo","attroptcombo","value","storedby","timestamp"
"DUSpd8Jq3M7","201202","gP6hn503KUX","Prlt0C1RF0s",,"7","bombali","2010-04-17"
"DUSpd8Jq3M7","201202","gP6hn503KUX","V6L425pT3A0",,"10","bombali","2010-04-17"
"DUSpd8Jq3M7","201202","OjTS752GbZE","V6L425pT3A0",,"9","bombali","2010-04-06"
```

### Génération d'un modèle d'ensemble de valeurs de données { #webapi_data_values_template }

Pour générer un modèle d'ensemble de valeurs de données pour un ensemble de données spécifique, vous pouvez utiliser la ressource `/api/dataSets/<id>/dataValueSet`. les formats de réponse XML et JSON sont pris en charge. Exemple:

    /api/dataSets/BfMAe6Itzgt/dataValueSet.json

Ci-dessous les paramètres que vous pouvez utiliser pour ajuster davantage la sortie :



Tableau : Paramètres de requête de valeurs de données

| Paramètre de requête | Obligatoire | Description |
|---|---|---|
| période | Non | La période d'utilisation sera incluse sans aucun contrôle. |
| orgUnit (Unité d'organisation) | Non | L'unité d'organisation à utiliser ; prend en charge plusieurs unités d'organisation ; l'identifiant et le code peuvent être utilisés. |
| commentaire | Non | Sur la prise en compte des commentaires, par défaut : Oui. |
| orgUnitIdScheme (Schéma de l'identifiant de l'unité d'organisation) | Non | Schéma d'unités d'organisation à utiliser ; prend en charge l'identifiant &#124; code. |
| dataElementIdScheme (Schéma d'identifiant d'élément de données) | Non | Schéma d'élément de données à utiliser ; prend en charge l'identifiant &#124; code. |

### Lecture des valeurs de données { #webapi_reading_data_values }

This section explains how to retrieve data values from the Web API by
interacting with the *dataValueSets* resource. Data values can be
retrieved in *XML*, *JSON*, *CSV*, and *ADX* format. Since we want to read data
we will use the *GET* HTTP verb. We will also specify that we are
interested in the XML resource representation by including an `Accept`
HTTP header with our request. The following query parameters are
accepted:


Tableau : Paramètres de requête d'ensemble de valeurs de données

| Paramètre | Description |
|---|---|
| dataSet (ensemble de données) | Identifiant de l'ensemble de données. Peut être répété plusieurs fois. |
| dataElementGroup (groupe d'éléments de données) | Identifiant du groupe d'éléments de données. Peut être répété autant de fois que vous le voulez (pas pris en charge pour le format ADX). |
| période | Identifiant de période au format ISO. Peut être répété plusieurs fois. |
| date de début | Date de début pour la période des valeurs à exporter. |
| date de fin | Date de fin pour la période des valeurs à exporter. |
| orgUnit (Unité d'organisation) | Identifiant de l’unité d’organisation. Peut être répété plusieurs fois. |
| subordonnées | Permet de spécifier s'il faut inclure les unités d’organisation subordonnées dans la hiérarchie des unités d'organisation. |
| orgUnitGroup (groupe d'unités d'organisation) | Identifiant du groupe d’unités d’organisation. Peut être répété plusieurs fois. |
| attributeOptionCombo (combinaison d'options d'attribut) | Identifiant de la combinaison d’options d’attribut. Peut être répété plusieurs fois. |
| includeDeleted | Permet de spécifier s'il faut inclure les valeurs de données supprimées. |
| lastUpdated (dernière mise à jour) | Inclut uniquement les valeurs de données mises à jour depuis l'horodatage donné. |
| lastUpdatedDuration (durée de la dernière mise à jour) | Inclut uniquement les valeurs de données mises à jour pendant la durée spécifique. Le format est <value\><time-unit\>, où les unités de temps prises en charge sont "j" (jours), "h" (heures), "m" (minutes) et "s" (secondes). |
| limite | Le nombre maximum de résultats dans la réponse. |
| dataElementIdScheme (Schéma d'identifiant d'élément de données) | Propriété de l'objet d'élément de données à utiliser pour les valeurs de données dans la réponse. |
| orgUnitIdScheme (Schéma de l'identifiant de l'unité d'organisation) | Propriété de l'objet d'unité d'organisation à utiliser pour les valeurs de données dans la réponse. |
| categoryOptionComboIdScheme (Schéma de l'identifiant de la combinaison d'options de catégorie) | Propriété de la combinaison d'options de catégorie à utiliser pour les valeurs de données dans la réponse. |
| attributOptionComboIdScheme (Schéma de l'identifiant de la combinaison d'options de catégorie) | Propriété des objets de combinaison d'options d'attribut à utiliser pour les valeurs de données dans la réponse. |
| dataSetIdScheme (Schéma de l'identifiant de l'ensemble de données) | Propriété de l'objet d'ensemble de données à utiliser dans la réponse. |
| categoryIdScheme (Schéma de l'identifiant de catégorie) | Propriété de l'objet catégorie à utiliser dans la réponse (ADX uniquement). |
| categoryOptionIdScheme (Schéma de l'identifiant d'option de catégorie) | Propriété de l'objet d'options de catégorie à utiliser dans la réponse (ADX uniquement). |
| idScheme | Propriété de l'un des objets ci-dessus, s'ils ne sont pas spécifiés, à utiliser dans la réponse. S’il n’est pas spécifié, l’idScheme par défaut pour le format ADX est "code" et pour tous les autres formats, c'est "uid". |
| inputOrgUnitIdScheme | Propriété d'identification utilisée pour les valeurs du paramètre `orgUnit` fournies ; `id` ou `code` |
| inputDataSetIdScheme | Propriété d'identification utilisée pour les valeurs du paramètre `dataSet` fournies ; `id` ou `code` |
| inputDataElementGroupIdScheme | Propriété d'identification utilisée pour les valeurs du paramètre `dataElementGroup` fournies ; `id` ou `code` |
| inputIdScheme | Propriété d'identification utilisée pour l'une des valeurs des paramètres `dataSet`, `dataElementGroup`, `orgUnit`, `orgUnitGroup`, `attributeOptionCombo` fournies, à moins que l'un des trois schémas ci-dessus ne remplace explicitement cette entrée par défaut ; `id` ou `code` |

Les paramètres suivants provenant de la liste ci-dessus sont requis :
- dataSet ou dataElementGroup (pour le format ADX, cela doit être dataSet)
- period, (startDate et endDate), lastUpdated, ou lastUpdatedDuration
- orgUnit ou orgUnitGroup

Les formats de réponse suivants sont pris en charge :

  - xml (application/xml)

  - json (application/json)

  - csv (application/csv)

  - adx (application/adx+xml)

En supposant que nous avons publié les valeurs de données dans DHIS2 conformément à la section précédente intitulée *Envoi de valeurs de données*, nous pouvons maintenant constituer notre requête pour un ensemble de valeurs de données unique et l'exécuter en utilisant l'URL :

```bash
curl "https://play.dhis2.org/demo/api/33/dataValueSets?dataSet=pBOMPrpg1QX&period=201401&orgUnit=DiszpKrYNg8"
  -H "Accept:application/xml" -u admin:district
```

Nous pouvons également utiliser les paramètres de requête "date de début" et "date de fin" pour demander un plus grand nombre de valeurs de données. En d'autres termes, vous pouvez également demander des valeurs de données pour plusieurs ensembles de données, unités d'organisation et périodes afin d'exporter de plus grandes quantités de données. Notez que le paramètre de requête "période" est prioritaire sur les paramètres "date de début" et "date de fin". Voici un exemple :

```bash
curl "https://play.dhis2.org/demo/api/33/dataValueSets?dataSet=pBOMPrpg1QX&dataSet=BfMAe6Itzgt
  &startDate=2013-01-01&endDate=2013-01-31&orgUnit=YuQRtpLP10I&orgUnit=vWbkYPRmKyS&children=true"
  -H "Accept:application/xml" -u admin:district
```

Pour récupérer les valeurs de données qui ont été créées ou mises à jour au cours des 10 derniers jours, vous pouvez effectuer la requête suivante :

    /api/dataValueSets?dataSet=pBOMPrpg1QX&orgUnit=DiszpKrYNg8&lastUpdatedDuration=10d

La réponse ressemblera à ceci :

```xml
<?xml version='1.0' encoding='UTF-8'?>
<dataValueSet xmlns="http://dhis2.org/schema/dxf/2.0" dataSet="pBOMPrpg1QX"
  completeDate="2014-01-02" period="201401" orgUnit="DiszpKrYNg8">
<dataValue dataElement="eY5ehpbEsB7" period="201401" orgUnit="DiszpKrYNg8"
  categoryOptionCombo="bRowv6yZOF2" value="10003"/>
<dataValue dataElement="Ix2HsbDMLea" period="201401" orgUnit="DiszpKrYNg8"
  categoryOptionCombo="bRowv6yZOF2" value="10002"/>
<dataValue dataElement="f7n9E0hX8qk" period="201401" orgUnit="DiszpKrYNg8"
  categoryOptionCombo="bRowv6yZOF2" value="10001"/>
</dataValueSet>
```

Vous pouvez demander à ce que les données soient rendues au format JSON de la manière suivante :

    /api/dataValueSets.json?dataSet=pBOMPrpg1QX&period=201401&orgUnit=DiszpKrYNg8

La réponse ressemblera à ceci :

```json
{
  "dataSet": "pBOMPrpg1QX",
  "completeDate": "2014-02-03",
  "period": "201401",
  "orgUnit": "DiszpKrYNg8",
  "dataValues": [
    {
      "dataElement": "eY5ehpbEsB7",
      "categoryOptionCombo": "bRowv6yZOF2",
      "period": "201401",
      "orgUnit": "DiszpKrYNg8",
      "value": "10003"
    },
    {
      "dataElement": "Ix2HsbDMLea",
      "categoryOptionCombo": "bRowv6yZOF2",
      "period": "201401",
      "orgUnit": "DiszpKrYNg8",
      "value": "10002"
    },
    {
      "dataElement": "f7n9E0hX8qk",
      "categoryOptionCombo": "bRowv6yZOF2",
      "period": "201401",
      "orgUnit": "DiszpKrYNg8",
      "value": "10001"
    }
  ]
}
```

Notez que les valeurs de données sont mises en corbeille, c'est-à-dire qu'une valeur supprimée a la propriété `supprimée` définie sur "vrai" et n'est pas supprimée de façon permanente. Ceci est utile lors de l'intégration de plusieurs systèmes afin de signaler les suppressions. Vous pouvez inclure les valeurs supprimées dans la réponse comme suit :

    /api/33/dataValueSets.json?dataSet=pBOMPrpg1QX&period=201401
      &orgUnit=DiszpKrYNg8&includeDeleted=true

Vous pouvez également demander à ce que les données soient rendues au format CSV de la manière suivante :

    /api/33/dataValueSets.csv?dataSet=pBOMPrpg1QX&period=201401
      &orgUnit=DiszpKrYNg8

La réponse ressemblera à ceci :

```csv
dataelement,period,orgunit,catoptcombo,attroptcombo,value,storedby,lastupdated,comment,flwup
f7n9E0hX8qk,201401,DiszpKrYNg8,bRowv6yZOF2,bRowv6yZOF2,12,system,2015-04-05T19:58:12.000,comment1,false
Ix2HsbDMLea,201401,DiszpKrYNg8,bRowv6yZOF2,bRowv6yZOF2,14,system,2015-04-05T19:58:12.000,comment2,false
eY5ehpbEsB7,201401,DiszpKrYNg8,bRowv6yZOF2,bRowv6yZOF2,16,system,2015-04-05T19:58:12.000,comment3,false
FTRrcoaog83,201401,DiszpKrYNg8,bRowv6yZOF2,bRowv6yZOF2,12,system,2014-03-02T21:45:05.519,comment4,false
```

Les contraintes suivantes s'appliquent à la ressource Ensembles de valeurs de données :

  - Au moins un ensemble de données doit être spécifié.

  - Soit au moins une période, soit une date de début et une date de fin doivent être
    spécifiés.

  - Au moins une unité d'organisation doit être spécifiée.

  - Les unités d'organisation doivent faire partie de la hiérarchie des unités d'organisation 
    de l’utilisateur authentifié.

  - La limite ne peut pas être inférieure à zéro.

### Envoi, lecture et suppression de valeurs de données individuelles { #webapi_sending_individual_data_values }

Cet exemple montrera comment envoyer des valeurs de données individuelles à enregistrer dans une requête. Ceci peut être réalisé par l'envoi d'une requête *POST* à la ressource `dataValues` :

    /api/dataValues

Les paramètres de requête suivants sont pris en charge pour cette ressource :



Tableau : Paramètres de requête de valeurs de données

| Paramètre de requête | Obligatoire | Description |
|---|---|---|
| de | Oui | Identifiant de l'élément de données |
| pe | Oui | Identifiant de période |
| ou | Oui | Identifiant de l'unité d'organisation |
| co | Non | Identifiant de la combinaison d'options de catégorie, la valeur par défaut sera utilisée en cas d'omission |
| cc | Non (doit être combiné avec cp) | Identifiant de la combinaison de catégories d'attribut |
| cp | Non (doit être combiné avec CC) | Identifiants d'options de catégorie d'attribut, séparés par ; pour plusieurs valeurs |
| ds | Non | Ensemble de données, pour vérifier si la fonction POST or DELETE (publier ou effacer) est autorisée pour la période et l'unité d'organisation. S'il est spécifié, l'élément de données doit être affecté à cet ensemble de données. Dans le cas contraire, un ensemble de données contenant l'élément de données sera sélectionné pour vérifier si l'opération est autorisée. |
| valeur | Non | Valeur de données. Pour les valeurs booléennes, les éléments suivants seront acceptés : vrai &#124; Vrai &#124; VRAI &#124; faux &#124; Faux &#124; FAUX &#124; 1 &#124; 0 &#124; t &#124; f &#124; |
| commentaire | Non | Commentaire sur les données |
| suivi | Non | Le suivi de la valeur de données permet de faire basculer la valeur booléenne actuelle |

Si l'un des identifiants fournis n'est pas valide, si la valeur de données ou le commentaire n'est pas valide ou si les données sont verrouillées, la réponse contiendra le code d'état *409 Conflit* et un message texte descriptif. Si l'opération conduit à une valeur enregistrée ou mise à jour, *200 OK* sera renvoyé. Ci-après, un exemple de requête :

```bash
curl "https://play.dhis2.org/demo/api/33/dataValues?de=s46m5MS0hxu
  &pe=201301&ou=DiszpKrYNg8&co=Prlt0C1RF0s&value=12"
  -X POST -u admin:district
```

Cette ressource permet également une syntaxe spéciale pour associer la valeur à une combinaison d'options d'attribut. Pour ce faire, il suffit d'envoyer l'identifiant de la combinaison de catégories d'attribut, ainsi que les identifiants des options de catégories d'attribut que la valeur représente au sein de la combinaison. La combinaison de catégories est spécifiée avec le paramètre `cc`, tandis que les options de catégorie sont spécifiées sous la forme d'une chaîne de caractères séparés par des points-virgules avec le paramètre `cp`. Il faut s'assurer que les options de catégorie font toutes partie de la combinaison de catégories. Voici un exemple :

```bash
curl "https://play.dhis2.org/demo/api/33/dataValues?de=s46m5MS0hxu&ou=DiszpKrYNg8
  &pe=201308&cc=dzjKKQq0cSO&cp=wbrDrL2aYEc;btOyqprQ9e8&value=26"
  -X POST -u admin:district
```

Vous pouvez récupérer une valeur de données avec une requête en utilisant la méthode *GET* (obtenir). Les paramètres de valeur, de commentaire et de suivi ne sont pas applicables ici :

```bash
curl "https://play.dhis2.org/demo/api/33/dataValues?de=s46m5MS0hxu
  &pe=201301&ou=DiszpKrYNg8&co=Prlt0C1RF0s"
  -u admin:district
```

Vous pouvez supprimer une valeur de données avec une requête en utilisant la méthode *DELETE*.

#### Utilisation des valeurs de données de fichiers { #datavalue_file }

Lorsqu'il s'agit de valeurs de données dont l'élément de données est de type *fichier*, la méthode décrite ci-dessus ne s'applique plus. Ces valeurs de données sont spéciales dans la mesure où le contenu de la valeur est une référence UID à un objet *Ressource de fichier* et non une constante autonome. Ces valeurs de données se comportent comme les autres valeurs de données qui stockent du contenu textuel, mais elles doivent être traitées différemment afin de produire des entrées et des sorties pertinentes.

There are two methods of storing FileResource data values.

**The Easy Way:** Upload the file to the `/api/dataValues/file` endpoint as
described in the file resource section.  This works on versions 2.36 and later.

**The Hard Way:** If you are writing code that needs to be compatible
with versions of DHIS2 before 2.36, then the process is:

1.  Téléchargez le fichier sur le point de terminaison `/api/fileResources` tel que décrit
    dans la section des ressources de fichiers.

2.  Retrieve the `id` property of the returned *FileResource*.

3.  Store the retrieved id *as the value* to the data value using any
    des méthodes décrites ci-dessus.

Seules les relations un à un entre les valeurs de données et les ressources de fichiers sont autorisées. Cette règle est appliquée en interne, de sorte que l'enregistrement de l'identifiant d'une ressource de fichier dans plusieurs valeurs de données ne soit pas possible et entraîne une erreur. La suppression de la valeur de données entraîne la suppression de la ressource de fichier référencée. La suppression directe des ressources de fichiers n'est pas possible.

La valeur de données peut maintenant être récupérée normalement, mais c'est l'UID de la ressource du fichier qui sera renvoyé. Afin de récupérer le vrai contenu (c'est-à-dire le fichier stocké dans la ressource associée à la valeur de données), vous devez effectuer une requête GET à `/api/dataValues/files` en reproduisant les paramètres de la requête comme pour la valeur de données elle-même. Le point de terminaison `/api/dataValues/files` ne prend en charge que les requêtes GET.

Il convient de noter qu'en raison du fonctionnement asynchrone du mécanisme de stockage sous-jacent, le contenu du fichier peut ne pas être immédiatement téléchargeable à partir du point de terminaison `/api/dataValues/files`. Ceci est particulièrement valable pour les fichiers volumineux qui peuvent nécessiter des téléchargements en arrière-plan vers un entrepôt de fichiers externe (en fonction de la configuration du système). Récupérer les métadonnées de la ressource du fichier à partir du point de terminaison `/api/fileResources/<id>` permet de vérifier le `storageStatus` (état du stockage) du contenu avant d'essayer de le télécharger.

## Format de données ADX { #webapi_adx_data_format }

Depuis la version 2.20, nous prenons en charge une norme internationale d'échange de données agrégées appelée ADX. ADX est développé et maintenu par le comité Quality, Research and Public Health (Qualité, Recherche et Santé Publique) de l'IHE (Integrating the HealthCare Enterprise). La page wiki décrivant les activités du comité QRPH se trouve à l'adresse [wiki.ihe.net](http://wiki.ihe.net/index.php?title=Quality,_Research_and_Public_Health#Current_Domain_Activities). ADX fait toujours l'objet d'un développement actif et a maintenant été publié pour une implémentation à titre expérimental. Notez qu'actuellement, c'est la fonctionnalité de lecture et d'écriture des données formatées ADX qui est implémentée dans DHIS2, c'est-à-dire ce qui est décrit comme acteurs Consommateur de Contenu et Producteur de Contenu dans le profil ADX.

La structure d'un message de données ADX est assez similaire à celle des données DXF 2 décrites précédemment et que vous connaissez probablement. Il existe quelques différences importantes. Nous les décrirons à l'aide d'un petit exemple :

```xml
<adx xmlns="urn:ihe:qrph:adx:2015" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="urn:ihe:qrph:adx:2015 ../schema/adx_loose.xsd"
  exported="2015-02-08T19:30:00Z">
  <group orgUnit="OU_559" period="2015-06-01/P1M"
    completeDate="2015-07-01" dataSet="(TB/HIV)VCCT">
    <dataValue dataElement="VCCT_0" GENDER="FMLE" HIV_AGE="AGE0-14" value="32"/>
    <dataValue dataElement="VCCT_1" GENDER="FMLE" HIV_AGE="AGE0-14" value="20"/>
    <dataValue dataElement="VCCT_2" GENDER="FMLE" HIV_AGE="AGE0-14" value="10"/>
    <dataValue dataElement="PLHIV_TB_0" GENDER="FMLE" HIV_AGE="AGE0-14" value="10"/>
    <dataValue dataElement="PLHIV_TB_1" GENDER="FMLE" HIV_AGE="AGE0-14" value="10"/>

    <dataValue dataElement="VCCT_0" GENDER="MLE" HIV_AGE="AGE0-14" value="32"/>
    <dataValue dataElement="VCCT_1" GENDER="MLE" HIV_AGE="AGE0-14" value="20"/>
    <dataValue dataElement="VCCT_2" GENDER="MLE" HIV_AGE="AGE0-14" value="10"/>
    <dataValue dataElement="PLHIV_TB_0" GENDER="MLE" HIV_AGE="AGE0-14" value="10"/>
    <dataValue dataElement="PLHIV_TB_1" GENDER="MLE" HIV_AGE="AGE0-14" value="10"/>

    <dataValue dataElement="VCCT_0" GENDER="FMLE" HIV_AGE="AGE15-24" value="32"/>
    <dataValue dataElement="VCCT_1" GENDER="FMLE" HIV_AGE="AGE15-24" value="20"/>
    <dataValue dataElement="VCCT_2" GENDER="FMLE" HIV_AGE="AGE15-24" value="10"/>
    <dataValue dataElement="PLHIV_TB_0" GENDER="FMLE" HIV_AGE="AGE15-24" value="10"/>
    <dataValue dataElement="PLHIV_TB_1" GENDER="FMLE" HIV_AGE="AGE15-24" value="10"/>

    <dataValue dataElement="VCCT_0" GENDER="MLE" HIV_AGE="AGE15-24" value="32"/>
    <dataValue dataElement="VCCT_1" GENDER="MLE" HIV_AGE="AGE15-24" value="20"/>
    <dataValue dataElement="VCCT_2" GENDER="MLE" HIV_AGE="AGE15-24" value="10"/>
    <dataValue dataElement="PLHIV_TB_0" GENDER="MLE" HIV_AGE="AGE15-24" value="10"/>
    <dataValue dataElement="PLHIV_TB_1" GENDER="MLE" HIV_AGE="AGE15-24" value="10"/>
  </group>
</adx>
```

### L'élément racine ADX { #the-adx-root-element }

L'élément racine ADX n'a qu'un seul attribut obligatoire, qui est l'horodatage *exporté*. Comme d'autres éléments ADX, le schéma est extensible dans le sens où il ne restreint pas les attributs spécifiques d'applications supplémentaires.

### L'élément du groupe ADX { #the-adx-group-element }

Contrairement à dxf2, ADX exige que les valeurs de données soient regroupées par unité d'organisation, période et ensemble de données. L'exemple ci-dessus montre un rapport de données pour l'ensemble de données "( TB/VIH) VCCT" de la base de données de démonstration en ligne. Cet exemple utilise des codes comme identifiants et non des uids dhis2. Le code est la forme d'identifiant préférée lors de l'utilisation d'ADX.

Les attributs d'unité d'organisation, de période et d'ensemble de données sont obligatoires dans ADX. L'élément de groupe peut contenir des attributs supplémentaires. Dans notre implémentation de DHIS2, tout attribut supplémentaire est simplement transmis à l'importateur sous-jacent. Cela signifie que tous les attributs qui ont actuellement une signification dans dxf2 (comme completeDate dans l'exemple ci-dessus) peuvent continuer à être utilisés dans ADX et seront traités de la même manière.

Une différence importante entre ADX et dxf2 réside dans la manière dont les périodes sont encodées. ADX utilise strictement la norme ISO8601 et encode la période de déclaration sous la forme (date|heure) / (durée). Dans l'exemple ci-dessus, la période est donc une période d'un mois (P1M) qui commence le 01/06/2015. Il s'agit donc des données de juin 2015. La notation est un peu plus longue, mais elle est très souple et nous permet de prendre en charge tous les types de période existants dans DHIS2.

### Définitions des périodes ADX { #adx-period-definitions }

Les périodes commencent par la date à laquelle la durée commence, suivie d'un "/" et de la notation de la durée, comme indiqué dans le tableau. Le tableau suivant détaille tous les types de période dans DHIS2 et la manière dont ils sont représentés en ADX, ainsi que des exemples.

Tableau : Périodes ADX

| Type de période | Notation de durée | Exemples) | Durée(s) |
|---|---|---|---|
| Quotidien  | P1D | 2017-10-01/P1M | 01 octobre 2017 |
| Hebdomadaire | P7D | 2017-10-02/P7D | 02 oct 2017-08 oct 2017 |
| Hebdomadaire Mercredi | P7D | 04-10-2017/P7D | 04 octobre 2017-10 octobre 2017 |
| Hebdomadaire Jeudi | P7D | 05-10-2017/P7D | 05 octobre 2017-011 octobre 2017 |
| Hebdomadaire Samedi | P7D | 07-10-2017/P7D | 07 octobre 2017-13 octobre 2017 |
| Hebdomadaire Dimanche | P7D | 01-10-2017/P7D | 01 octobre 2017-07 octobre 2017 |
| Bihebdomadaire | P14D | 02-10-2017/P14D | 02 octobre 2017-15 octobre 2017 |
| Mensuel | P1M | 2017-10-01/P1M | 01 octobre 2017-31 octobre 2017 |
| Bimensuel | P2M | 01-11-2017/P2M | 01 novembre 2017-31 décembre 2017 |
| Trimestriel | P3M | 01-09-2017/P3M | 01 septembre 2017-31 décembre 2017 |
| Semestriel | P6M | 01-01-2017/P6M<br>01-07-2017/P6M | 1er janvier 2017-30 juin 2017<br>1er juillet 2017-31 décembre 2017 |
| Semestriel Avril | P6M | 01-04-2017/P6M<br>01-10-2017/P6M | 1er avril 2017-30 septembre 2017<br>1er octobre 2017-31 mars 2018 |
| Semestriel Novembre | P6M | 01-10-2017/P6M<br>01-05-2018/P6M | 1er novembre 2017-30 avril 2018<br>1er mai 2018-31 octobre 2018 |
| Annuel | P1Y | 01-01-2017/P1Y | 01 janvier 2017-31 décembre 2017 |
| Financière Avril | P1Y | 01-04-2017/P1Y | 1er avril 2017-31 mars 2018 |
| Financière Juillet | P1Y | 01-07-2017/P1Y | 1er juillet 2017-30 juin 2018 |
| Financière Octobre | P1Y | 01-10-2017/P1Y | 01 octobre 2017-30 septembre 2018 |
| Financière Novembre | P1Y | 01-11-2017/P1Y | 01 novembre 2017-31 octobre 2018 |

### Valeurs de données ADX { #adx-data-values }

L'élément "valeur de données" dans ADX est très similaire à son équivalent dans DXF. Les attributs obligatoires sont *élément de données* et *valeur*. Les attributs *unité d'organisation* et *période* n'apparaissent pas dans l'élément "valeur de données" car ils sont requis au niveau *groupe*.

La différence la plus significative est la manière dont la désagrégation est représentée. DXF utilise la combinaison d'options de catégorie pour représenter la désagrégation des données. Dans ADX, les désagrégations (par exemple GROUPE_D'ÂGE et SEXE) sont exprimées explicitement en tant qu'attributs. Si vous utilisez `code` comme schéma d'identification pour `catégorie`, vous devez attribuer un code à toutes les catégories utilisées pour les éléments de données de l'ensemble de données et, de plus, ce code doit pouvoir être utilisé en tant qu'attribut XML. La contrainte concernant un nom d'attribut XML est décrite dans la norme XML du W3C. En pratique, cela signifie qu'il n'y a pas d'espaces, pas de caractères non alphanumériques autres que "_" et que le nom ne peut pas commencer par une lettre. L'exemple ci-dessus montre des exemples de "bons" codes de catégorie ("GENRE" et "ÂGE_VIH"). Les mêmes restrictions s'appliquent si vous utilisez `nom` ou `attribut` comme schémas d'identification.

Dans ADX, seuls les identifiants de catégorie sont utilisés comme attributs XML ; les identifiants d'autres types de métadonnées ne doivent pas être utilisés comme attributs XML. Notez que cette syntaxe n'est pas appliquée par DHIS2 lorsque vous attribuez des noms, des codes ou des attributs DHIS2, mais vous obtiendrez un message d'erreur avec une explication si vous essayez d'importer des données ADX et que les identifiants de catégorie ne sont pas attribués ou ne conviennent pas.

Les principaux avantages de l’utilisation de dimensions explicites de données désagrégées sont les suivants :

  - Le système qui produit les données n'a pas besoin d'être synchronisé avec la
    combinaison d'options de catégorie dans DHIS2.

  - Le producteur et le consommateur peuvent faire correspondre leurs codes à une source tierce 
    qui fait autorité, telle qu'un service de terminologie. Notez que dans 
    l'exemple ci-dessus, les codes de genre et de groupe d'âge utilisent des listes de codes
    de l'[Observatoire mondial de la santé de l'OMS](http://apps.who.int/gho/data/node.resources.api).

Cette fonction peut être très utile, par exemple pour produire des données désagrégées à partir d'un système de DME, mais il peut arriver qu'un mapping de *combinaison d'options de catégorie* soit plus facile ou plus souhaitable. L'implémentation d'ADX dans DHIS2 permettra de vérifier l'existence d'un attribut de *combinaison d'options de catégorie* et, s'il existe, de l'utiliser au lieu des attributs de dimension éclatés. De même, un attribut de *combinaison d'options d'attributs* sur l'élément *groupe* sera traité de la même manière que les attributs existants. Sinon, la combinaison d'options d'attributs peut être utilisée comme catégories éclatées, comme pour la *valeur de données*.

Dans l'exemple simple ci-dessus, tous les éléments de données de l'ensemble de données ont la même dimensionnalité (combinaison de catégories), ce qui rend les données parfaitement rectangulaires. Les ensembles de données peuvent contenir des éléments de données ayant des combinaisons de catégories différentes, ce qui donne un message de données ADX *décalé vers la droite* (c'est-à-dire que les valeurs des différents éléments de données peuvent avoir des nombres de catégories différents).

### Importation de données ADX { #importing-adx-data }

DHIS2 expose un point de terminaison pour les données POST ADX dans `/api/dataValueSets` en utilisant *application/xml+adx* comme type de contenu. Ainsi, par exemple, la commande curl suivante peut être utilisée pour POST (publier) les exemples de données ci-dessus dans le serveur de démonstration DHIS2 :

```bash
curl -u admin:district -X POST -H "Content-Type: application/adx+xml"
  -d @data.xml "https://play.dhis2.org/demo/api/33/dataValueSets?dataElementIdScheme=code&orgUnitIdScheme=code"
```

Notez que les paramètres de requête sont les mêmes que ceux utilisés avec les données DXF. Le point de terminaison ADX doit interpréter tous les paramètres DXF existants avec la même sémantique que DXF.

### Exportation de données ADX { #exporting-adx-data }

DHIS2 expose un point de terminaison pour les ensembles de données GET ADX dans `/api/dataValueSets` en utilisant *application/xml+adx* comme type de contenu. Ainsi, par exemple, la commande curl suivante peut être utilisée pour récupérer les données ADX :

```bash
curl -u admin:district -H "Accept: application/adx+xml"
 "https://play.dhis2.org/demo/api/33/dataValueSets?dataValueSets?orgUnit=M_CLINIC&dataSet=MALARIA&period=201501"
```

Notez que les paramètres de requête sont les mêmes que ceux utilisés avec les données DXF. Une différence importante est que les identifiants d'ensemble de données et d'unité d'organisation peuvent être soit des uids, soit des codes.

## Suivi { #webapi_follow_up }

Cette section couvre les données de marquage pour le suivi.

### Suivi de la valeur de données { #data-value-follow-up }

Le point de terminaison de suivi des valeurs de données permet de marquer les valeurs de données pour le suivi.

```
PUT /api/36/dataValues/followup
```

La charge utile au format `JSON` ressemble à ceci :

```json
{
  "dataElement": "s46m5MS0hxu",
  "period": "202005",
  "orgUnit": "DiszpKrYNg8",
  "categoryOptionCombo": "psbwp3CQEhs",
  "attributeOptionCombo": "HllvX50cXC0",
  "followup": true
}
```

Les champs `combinaison d'options de catégorie` et `combinaison d'options d'attributs` sont facultatifs. Une charge utile `JSON` minimale ressemble à ceci :

```json
{
  "dataElement": "s46m5MS0hxu",
  "period": "202005",
  "orgUnit": "DiszpKrYNg8",
  "followup": false
}
```

Le champ `suivi` doit être défini sur `vrai` pour marquer une valeur de données pour le suivi, et sur `faux` pour retirer le marquage.

Le code d'état de la réponse sera `200 OK` si l'opération réussit, et `409 Conflit` en cas d'erreur avec la requête.

Pour mettre à jour plusieurs valeurs de données à la fois pour le suivi :

    PUT /api/dataValues/followups

avec la charge utile `JSON` :

```json
{
  "values": [
    {
      "dataElement": "s46m5MS0hxu",
      "period": "202005",
      "orgUnit": "DiszpKrYNg8",
      "categoryOptionCombo": "psbwp3CQEhs",
      "attributeOptionCombo": "HllvX50cXC0",
      "followup": true
    }
  ]
}
```

Chaque élément de cette mise à jour comporte les mêmes champs et exigences que le point de terminaison de la mise à jour unique.

La mise à jour groupée renvoie également `200 OK` en cas de succès ou `409 Conflit` en cas d'erreurs dans la requête.



# Validation des données { #data-validation }

## Validation { #webapi_validation }

Pour générer un résumé de validation des données, vous pouvez interagir avec la ressource de validation. La ressource "ensemble de données" est optimisée pour les clients chargés de la saisie des données et de la validation d'un ensemble de données ou d'un formulaire. Elle est accessible de la manière suivante :

    GET /api/33/validation/dataSet/QX4ZTUbOt3a.json?pe=201501&ou=DiszpKrYNg8

En plus de la validation des règles basées sur un ensemble de données, il existe deux méthodes supplémentaires de validation : validation personnalisée et validation programmée.

La première variable path (de chemin) est un identifiant qui fait référence à l'ensemble de données à valider. Les représentations XML et JSON des ressources sont prises en charge. La réponse contient les violations des règles de validation. Cette fonction sera étendue à d'autres types de validation dans les versions à venir.

Pour récupérer les règles de validation relatives à un ensemble de données spécifique, c'est-à-dire les règles de validation avec des formules où tous les éléments de données font partie de l'ensemble de données en question, vous pouvez lancer une requête GET à la ressource `validationRules` de la manière suivante :

    GET /api/validationRules?dataSet=<dataset-id>

Les règles de validation ont un côté gauche et un côté droit, dont la validité est comparée en fonction d'un opérateur. Les valeurs valides de l'opérateur sont indiquées dans le tableau ci-dessous.



Tableau : Opérateurs

| Valeur | Description |
|---|---|
| égal_à | Egale à |
| pas_égale_à | Pas égal à |
| supérieure_à | Supérieure à |
| supérieure_ou_égale_à_ | Supérieure ou égal à |
| inférieure_à | Inférieur à |
| inférieure_ou_égale_à_ | inférieur ou égal à |
| paire_obligatoire | Si l’un des côtés est présent, l’autre doit également l’être. |
| paire_exclusive | Si l’un des côtés est présent, l’autre ne doit pas être |

Les expressions du côté gauche et du côté droit sont des expressions mathématiques qui peuvent contenir des références à des éléments de données et à des combinaisons d'options de catégorie au format suivant :

    ${<dataelement-id>.<catoptcombo-id>}

Les expressions du côté gauche et du côté droit ont une *stratégie de valeur manquante*. Cette stratégie indique comment le système doit traiter les valeurs de données manquantes pour les références d'éléments de données ou de combinaisons d'options de catégorie dans la formule, en déterminant si la règle de validation doit être vérifiée ou ignorée. Les stratégies de valeurs manquantes valides sont présentées dans le tableau ci-dessous.



Tableau : Stratégies de valeur manquante

| Valeur | Description |
|---|---|
| IGNORER_SI_UNE_VALEUR_MANQUE | Ignore la règle de validation si une valeur de données est manquante |
| IGNORER_SI_TOUTES-LES_VALEURS_MANQUENT | Ignore la règle de validation si toutes les valeurs de données sont manquantes |
| NE-JAMAIS_IGNORER | N'ignore jamais la règle de validation, quelles que soient les valeurs de données manquantes |

## Résultats de la validation { #webapi_validation_results }

Les résultats de validation sont les résultats des violations constatées lors d'une analyse de validation. Si vous choisissez "conserver les résultats" lorsque vous lancez ou programmez une analyse de validation, toutes les violations constatées seront stockées dans la base de données. Lorsqu'un résultat est stocké dans la base de données, il est utilisé à trois fins :

1.  Générer des analyses basées sur les résultats stockés.

2.  Les résultats qui n'ont pas généré de notification le feront,
    une fois.

3.  Garder la trace des résultats qui ont généré ou non une
    notification.

4.  Ignorer les règles déjà vérifiées lors de
    l'analyse de validation.

Cela signifie que si vous ne conservez pas vos résultats, vous ne pourrez pas générer d'analyses pour les résultats de validation. Si cette option est sélectionnée, les résultats généreront des notifications à chaque fois qu'il y en aura et l'analyse de validation pourrait être plus lente.

### Résultats de la validation de la requête { #query-validation-results }

Les résultats de validation conservés peuvent être consultés au point d'extrémité suivant :

    GET /api/33/validationResults

Vous pouvez également inspecter un résultat individuel à l'aide de l'identifiant du résultat de validation dans ce point d'extrémité :

    GET /api/33/validationResults/<id>

Les résultats de validation peuvent également être filtrés par les propriétés suivantes :

* Unité organisationnelle : `ou=<UID>`
* Règle de validation : `vr=<UID>`
* Période : `pe=<ISO-expression>`

Chacune des propriétés de filtre ci-dessus peut apparaître plusieurs fois, par exemple :

    GET /api/36/validationResults?ou=jNb63DIHuwU&ou=RzgSFJ9E46G

Plusieurs valeurs pour le même filtre sont combinées avec OR, les résultats doivent correspondre à l'une des valeurs données.

Si plusieurs propriétés de filtre sont utilisées et qu'elles sont combinées avec AND, les résultats devront correspondre à l'une des valeurs de chacune des propriétés.

Pour le filtre de période, les résultats doivent se superposer à l'une des périodes spécifiées.

De plus, les résultats de validation peuvent également être filtrés en fonction de leur date de création :

    GET /api/36/validationResults?createdDate=<date>

Ce filtre peut être combiné avec n’importe quel autre filtre.

### Déclencher des notifications de résultats de validation { #trigger-validation-result-notifications }

Les résultats de la validation sont envoyés aux utilisateurs concernés une fois par jour. Ils peuvent également être déclenchés manuellement pour être exécutés sur demande, à l'aide du point d'extrémité de l'API suivant :

    POST /api/33/validation/sendNotifications

Seuls les résultats non envoyés sont envoyés via ce point d'extrémité.

### Supprimer les résultats de validation { #delete-validation-results }

Les résultats de validation peuvent être supprimés manuellement en utilisant l'ID,

    DELETE /api/36/validationResults/<id>

ou les filtres

    DELETE /api/36/validationResults?<filters>

Les paramètres de filtre pris en charge sont :

* `ou=<UID>` pour faire correspondre tous les résultats de validation d'une unité d'organisation. Plusieurs unités utilisent 'OU' lorsque le paramètre est fourni plus d'une fois
* `vr=<UID>` pour faire correspondre tous les résultats de validation d'une règle de validation. Plusieurs règles utilisent 'OU' lorsque le paramètre est fourni plus d'une fois
* `pe=<ISO-expression>` pour faire correspondre tous les résultats de validation liés à une période qui se superpose à la période spécifiée
* `created=<ISO-expression>` pour faire correspondre tous les résultats de validation créés au cours de la période fournie
* `notificationSent=<boolean>` pour faire correspondre uniquement les résultats de validation pour lesquels une notification a été ou n'a pas été envoyée

Si les filtres sont combinés, toutes les conditions doivent être vraies (AND logic (ET logique)).

Quelques exemples:

Pour supprimer tous les résultats de validation liés à l'unité d'organisation dont l'UID est `NqwvaQC1ni4` pour le premier trimestre (Q1) 2020, utilisez :

```
DELETE /api/36/validationResults?ou=NqwvaQC1ni4&pe=2020Q1
```

Pour supprimer tous les résultats de validation créés au cours de la semaine 1 de 2019 et pour lesquels une notification a été envoyée, utilisez :

```
DELETE /api/36/validationResults?created=2019W1&notificationSent=true
```

Toute opération de suppression nécessitera l'autorité _Effectuer des tâches de maintenance_.


## Détection des valeurs atypiques { #outlier-detection }

Le point d'extrémité de détection des valeurs atypiques permet de détecter les valeurs atypiques dans les valeurs de données agrégées.

```
GET /api/36/outlierDetection
```

Ce point d'extrémité prend en charge deux algorithmes pour détecter les valeurs atypiques :

* **Z-score :** Le z-score est défini comme l'écart absolu entre le score et la moyenne divisé par l'écart type. Un paramètre de seuil faisant référence au nombre d'écarts types par rapport à la moyenne doit être spécifié avec l'algorithme z-score pour définir les limites supérieure et inférieure de ce qui est considéré comme une valeur atypique.
* **Z-score modifié :** Identique au z-score, à la différence qu'il utilise la médiane au lieu de la moyenne comme mesure de la tendance centrale. Les paramètres sont les mêmes que pour le Z-score.
* **Min-max :** Les valeurs des éléments de données min-max (minimales et maximales) font référence aux limites personnalisées qui peuvent être insérées dans DHIS 2 en fonction de la combinaison d'éléments de données, d'unités d'organisation et d'options de catégorie.

Les valeurs atypiques seront *classées selon leur importance*, par défaut selon l'écart absolu par rapport à la moyenne, avec la valeur la plus importante en premier. Ceci permet d'identifier rapidement les valeurs atypiques qui ont le plus grand impact sur la qualité et l’analyse des données.

### Paramètres de requête{ #request-query-parameters }

Les paramètres de requête suivants sont pris en charge.

| Paramètre de requête | Description                                                  | Obligatoire | Options (par défaut en premier)                   |
| --------------- | ------------------------------------------------------------ | --------- | ----------------------------------------- |
| ds              | Ensemble de données, peut être spécifié plusieurs fois.                   | No [*]    | Identifiant de l'ensemble de données.                      |
| de              | Élément de données, peut être spécifié plusieurs fois.               | No [*]    | Identifiant de l'élément de données.                  |
| date de début       | Date en début de l'intervalle pour contrôler les valeurs atypiques.               | Oui       | Date (aaaa-MM-jj).                        |
| date de fin         | Date en fin de l'intervalle pour vérifier les valeurs aberrantes.                 | Oui       | Date (aaaa-MM-jj).                        |
| ou              | Unité d'organisation, peut être spécifiée plusieurs fois.          | Oui       | Identifiant de l’unité d’organisation.             |
| algorithme       | Algorithme à utiliser pour la détection des valeurs atypiques.                      | Non        | `Z_SCORE`, `MIN_MAX`, `MOD_Z_SCORE`       |
| seuil       | Seuil pour les valeurs atypiques. Algorithmes `Z_SCORE` et `MOD_Z_SCORE` uniquement. | Non        | Numérique, supérieur à zéro. Par défaut : 3.0. |
| Date de début des données   | Date en début de l'intervalle pour le calcul de la moyenne et de l'écart type. Algorithmes `Z_SCORE` et `MOD_Z_SCORE` uniquement. | Non        | Date (aaaa-MM-jj). |
| Date de fin des données     | Date en fin de l'intervalle pour le calcul de la moyenne et de l'écart type. Algorithmes `Z_SCORE` et `MOD_Z_SCORE` uniquement. | Non        | Date (aaaa-MM-jj).   |
| orderBy (ordonner par)         | Field to order by. `Z_SCORE` and `MOD_Z_SCORE`algorithm only.| Non        | `MEAN_ABS_DEV`, `Z_SCORE`                 |
| Résultats maximum      | Limite maximale pour la sortie.                                    | Non        | Entier, supérieur à zéro. Par défaut : 500. |

[*] Vous devez spécifier soit des ensembles de données avec le paramètre `ds`, qui inclura tous les éléments de données dans les ensembles de données, _ou_ spécifier des éléments de données avec le paramètre `de`.

Au moins un ensemble de données ou élément de données, une date de début et une date de fin, et au moins une unité d'organisation doivent être définis.

Les paramètres `Date de début` et `Date de fin` sont obligatoires et font référence à l'intervalle de temps dans lequel vous voulez détecter les valeurs atypiques. Les paramètres `Date de début des données` et `Date de fin des données` sont facultatifs et font référence à l'intervalle de temps à utiliser pour les données lors du calcul de la moyenne et de l'écart type. Ils sont utilisés pour calculer éventuellement le z-score.

### Utilisation et exemples { #usage-and-examples }

Obtenez les valeurs atypiques à l'aide de l'algorithme z-score par défaut :

```
GET /api/36/outlierDetection?ds=BfMAe6Itzgt&ds=QX4ZTUbOt3a
  &ou=O6uvpzGd5pu&ou=fdc6uOvgoji&startDate=2020-01-01&endDate=2020-12-31
```

Obtenez des valeurs atypiques à l'aide d'un algorithme et d'un seuil spécifiques :

```
GET /api/36/outlierDetection?ds=BfMAe6Itzgt&ds=QX4ZTUbOt3a
  &ou=O6uvpzGd5pu&startDate=2020-01-01&endDate=2020-12-31
  &algorithm=Z_SCORE&threshold=2.5
```

Obtenez les valeurs atypiques classées par z-score :

```
GET /api/36/outlierDetection?ds=BfMAe6Itzgt
  &ou=O6uvpzGd5pu&startDate=2020-01-01&endDate=2020-12-31
  &orderBy=Z_SCORE
```

Obtenez les 10 principales valeurs atypiques :

```
GET /api/36/outlierDetection?ds=BfMAe6Itzgt
  &ou=O6uvpzGd5pu&startDate=2020-01-01&endDate=2020-12-31
  &maxResults=10
```

Obtenez des valeurs atypiques avec un intervalle défini pour les données à utiliser lors du calcul de la moyenne et de l'écart type :

```
GET /api/36/outlierDetection?ds=BfMAe6Itzgt
  &ou=O6uvpzGd5pu&startDate=2020-01-01&endDate=2020-12-31
  &dataStartDate=2018-01-01&dataEndDate=2020-12-31
```

Obtenez les valeurs atypiques à l'aide de l'algorithme min-max :

```
GET /api/36/outlierDetection?ds=BfMAe6Itzgt&ds=QX4ZTUbOt3a
  &ou=O6uvpzGd5pu&ou=fdc6uOvgoji&startDate=2020-01-01&endDate=2020-12-31
  &algorithm=MIN_MAX
```

### Format de réponse { #response-format }

Les formats de réponse suivants sont pris en charge.

| Format | Format API                                                   |
| ------ | ------------------------------------------------------------ |
| JSON   | `/api/36/outlierDetection.json` or `Accept: application/json` (default format) |
| CSV    | `/api/36/outlierDetection.csv` or `Accept: application/csv`  |

La réponse contient les champs suivants :

| Champ      | Description                                                  |
| ---------- | ------------------------------------------------------------ |
| de         | Identifiant de l'élément de données.                                     |
| Nom de l'élément de données     | Nom de l'élément de données.                                           |
| pe         | Identifiant ISO de la période.                                       |
| ou         | Identifiant de l’unité d’organisation.                                |
| ouName     | Nom de l'unité d'organisation.                                      |
| coc        | Identifiant de la combinaison d’options de catégorie.                      |
| cocName    | Nom de la combinaison d’options de catégorie.                            |
| aoc        | Identifiant de la combinaison d’options d’attribut.                     |
| aocName    | Nom de la combinaison d’options d’attribut.                           |
| valeur      | Valeur de données.                                                  |
| moyenne       | Moyenne des valeurs de données dans la dimension de temps.                   |
| stdDev     | Écart-type.                                          |
| absDev     | Pour le z-score, il s'agit de l'écart absolu par rapport à la moyenne. Pour min-max, il s'agit de l'écart absolu par rapport à la limite min ou max. |
| zScore     | Le z-score. Algorithme du z-score uniquement.                         |
| lowerBound | La limite inférieure.                                          |
| upperBound | La limite supérieure.                                          |
| suivi   | Si la valeur de données est marquée pour le suivi.                  |

Les champs de `moyenne`, `écart type` et `z-score` ne sont présents que lorsque l'`algorithme` est `Z_SCORE`.

La réponse ressemblera à ceci. La section `métadonnées` contient des métadonnées de requête et de réponse. La section `Valeurs atypique` contient les valeurs atypiques.

```json
{
  "metadata": {
    "algorithm": "Z_SCORE",
    "threshold": 2.5,
    "orderBy": "MEAN_ABS_DEV",
    "maxResults": 10,
    "count": 10
  },
  "outlierValues": [
    {
      "de": "rbkr8PL0rwM",
      "deName": "Iron Folate given at ANC 3rd",
      "pe": "202011",
      "ou": "Pae8DR7VmcL",
      "ouName": "MCH (Kakua) Static",
      "coc": "pq2XI5kz2BY",
      "cocName": "Fixed",
      "aoc": "HllvX50cXC0",
      "aocName": "default",
      "value": 9000.0,
      "mean": 1524.5555,
      "stdDev": 2654.4661,
      "absDev": 7475.4444,
      "zScore": 2.8161,
      "lowerBound": -5111.6097,
      "upperBound": 8160.7208,
      "followUp": false
    },
    {
      "de": "rbkr8PL0rwM",
      "deName": "Iron Folate given at ANC 3rd",
      "pe": "202010",
      "ou": "vELbGdEphPd",
      "ouName": "Jimmi CHC",
      "coc": "pq2XI5kz2BY",
      "cocName": "Fixed",
      "aoc": "HllvX50cXC0",
      "aocName": "default",
      "value": 8764.0,
      "mean": 1448.0833,
      "stdDev": 2502.3031,
      "absDev": 7315.9166,
      "zScore": 2.9236,
      "lowerBound": -4807.6745,
      "upperBound": 7703.8412,
      "followUp": false
    }
  ]
}
```

### Contraintes et validation { #constraints-and-validation }

Les contraintes suivantes s'appliquent lors de la validation de la requête. Chaque erreur de validation a un code d'erreur correspondant.

| Code d'erreur | Message                                                      |
| ---------- | ------------------------------------------------------------ |
| E2200      | Au moins un élément de données doit être spécifié                  |
| E2201      | La date de début et la date de fin doivent être précisées                    |
| E2202      | La date de début doit être antérieure à la date de fin                           |
| E2203      | Au moins une unité d'organisation doit être spécifiée             |
| E2204      | Le seuil doit être un nombre positif                          |
| E2205      | Les résultats maximum doivent être exprimés en nombres positifs                        |
| E2206      | Le nombre maximum de résultats dépasse la limite autorisée : {d}               |
| E2207      | La date de début des données doit être antérieure à la date de fin des données                 |
| E2208      | Valeurs de données non numériques rencontrées lors de la détection des valeurs atypiques |

## Analyse des données { #webapi_data_analysis }

Plusieurs ressources permettant d'effectuer des analyses de données et de détecter les problèmes de qualité et de validation des données sont fournies.

**Remarque :** Ce point d'extrémité est obsolète et sera supprimé dans la version 2.38. Utilisez plutôt le point d'extrémité  `outlierAnalysis`.

### Analyse des règles de validation { #webapi_data_analysis_validation_rules } 

Pour exécuter des règles de validation et extraire les violations :

    GET /api/dataAnalysis/validationRules

Les paramètres de requête suivants sont pris en charge :



Tableau : Paramètres de requête d'analyse des règles de validation

| Paramètre de requête | Description | Option |
|---|---|---|
| vrg | Groupe de règles de validation | Identifiant |
| ou | Unité d’organisation | Identifiant |
| date de début | Date de début de la période | Date |
| date de fin | Date de fin de la période | Date |
| conserver | S'il faut conserver les violations dans le système | faux &#124; vrai |
| notification | S'il faut envoyer des notifications sur les violations | faux &#124; vrai |

Exemple de sortie :
```json
[{
    "validationRuleId": "kgh54Xb9LSE",
    "validationRuleDescription": "Malaria outbreak",
    "organisationUnitId": "DiszpKrYNg8",
    "organisationUnitDisplayName": "Ngelehun CHC",
    "organisationUnitPath": "/ImspTQPwCqd/O6uvpzGd5pu/YuQRtpLP10I/DiszpKrYNg8",
    "organisationUnitAncestorNames": "Sierra Leone / Bo / Badjia / ",
    "periodId": "201901",
    "periodDisplayName": "January 2019",
    "attributeOptionComboId": "HllvX50cXC0",
    "attributeOptionComboDisplayName": "default",
    "importance": "MEDIUM",
    "leftSideValue": 10.0,
    "operator": ">",
    "rightSideValue": 14.0
}, {
    "validationRuleId": "ZoG4yXZi3c3",
    "validationRuleDescription": "ANC 2 cannot be higher than ANC 1",
    "organisationUnitId": "DiszpKrYNg8",
    "organisationUnitDisplayName": "Ngelehun CHC",
    "organisationUnitPath": "/ImspTQPwCqd/O6uvpzGd5pu/YuQRtpLP10I/DiszpKrYNg8",
    "organisationUnitAncestorNames": "Sierra Leone / Bo / Badjia / ",
    "periodId": "201901",
    "periodDisplayName": "January 2019",
    "attributeOptionComboId": "HllvX50cXC0",
    "attributeOptionComboDisplayName": "default",
    "importance": "MEDIUM",
    "leftSideValue": 22.0,
    "operator": "<=",
    "rightSideValue": 19.0
}]
```

### Analyse des valeurs atypiques sur la base de l'écart type { #webapi_data_analysis_std_dev_outlier }

Pour identifier les valeurs atypiques parmi les données en fonction des écarts types de la valeur  moyenne :

    GET /api/dataAnalysis/stdDevOutlier

Les paramètres de requête suivants sont pris en charge :



Tableau : Paramètres de requête d'analyse des valeurs atypiques de l'écart type

| Paramètre de requête | Description | Option |
|---|---|---|
| ou | Unité d’organisation | Identifiant |
| date de début | Date de début de la période | Date |
| date de fin | Date de fin de la période | Date |
| ds | Ensembles de données, le paramètre peut être répété | Identifiant |
| écart type | Nombre d'écarts types par rapport à la moyenne | Valeur numérique |

### Analyse des valeurs aberrantes basée sur les valeurs min/max { #webapi_data_analysis_min_max_outlier }

Pour identifier les valeurs atypiques sur la base des valeurs min/max :

    GET /api/dataAnalysis/minMaxOutlier

Les paramètres de requête pris en charge équivalent à la ressource *analyse des valeurs atypiques en fonction de l'écart type* décrite ci-dessus.

### Analyse des données de suivi { #follow-up-data-analysis }

Pour identifier les données marquées pour le suivi :

    GET /api/dataAnalysis/followup

Au moins un ensemble de données ou élément de données, une date ou période de début et de fin, et au moins une unité d'organisation doivent être définis.

Les paramètres de requête suivants sont pris en charge.

| Paramètre  | Description                                                  | Obligatoire | Options (par défaut en premier)                   |
| ---------- | ------------------------------------------------------------ | --------- | ----------------------------------------- |
| ou         | Unité d'organisation, peut être spécifiée plusieurs fois.          | Oui       | Identifiant de l’unité d’organisation.             |
| ds         | Ensemble de données, peut être spécifié plusieurs fois.                   | No [*]    | Identifiant de l'ensemble de données.                      |
| de         | Élément de données, peut être spécifié plusieurs fois.               | No [*]    | Identifiant de l'élément de données.                  |
| date de début  | Date en début de l'intervalle pour contrôler les valeurs atypiques.               | No [*]    | Date (aaaa-MM-jj).                        |
| date de fin    | Date en fin de l'intervalle pour vérifier les valeurs aberrantes.                 | No [*]    | Date (aaaa-MM-jj).                        |
| pe         | ID de période ISO.                                               | No [*]    | ID ISO de la période.                        |
| peType     | Période ISO.                                                  | No [*]    | Chaîne ISO de la période.                        |
| coc        | Les combinaisons d’options de catégorie peuvent être spécifiées plusieurs fois.     | Non        | Identifiant de la combinaison d’options de catégorie.         |
| Résultats maximum | Limite maximale pour la sortie.                                    | Non        | Entier, supérieur à zéro. Par défaut : 50.  |

[*] Vous devez spécifier soit des ensembles de données avec le paramètre `ds`, qui intégrera tous les éléments de données dans les ensembles de données, _ou_ spécifier des éléments de données avec le paramètre `de`.
     De même, `Date de début` et `date de fin` _ou_ `période` doivent être spécifiés.

Les paramètres `Date de début` et `Date de fin` font référence à l'intervalle de temps au cours duquel vous voulez détecter les valeurs atypiques.
Si une période `pe` est fournie à la place, le début et la fin de l'intervalle sont également ceux de la période.

Si aucune combinaison d'options `coc` n'est fournie, tous les éléments de données de type valeur numérique seront pris en compte.


## Intégrité des données { #webapi_data_integrity } 

The data integrity capabilities of the data administration module are
available through the web API. This section describes how to run the
data integrity process as well as retrieving the result. The details of
the analysis performed are described in the user manual.

### Running data integrity { #webapi_data_integrity_run } 

The operation of measuring data integrity is a fairly resource (and
time) demanding task. It is therefore run as an asynchronous process and
only when explicitly requested. Starting the task is done by forming an
empty POST request to the *dataIntegrity* endpoint:

    POST /api/dataIntegrity

If successful the request will return HTTP 202 immediately. The location
header of the response points to the resource used to check the status
of the request. The payload also contains a json object of the job
created. Forming a GET request to the given location yields an empty
JSON response if the task has not yet completed and a JSON taskSummary
object when the task is done. Polling (conservatively) to this resource
can hence be used to wait for the task to finish.

### Fetching integrity summary { #webapi_data_integrity_fetch_results } 

Once data integrity is finished running the result can be fetched from
the `system/taskSummaries` resource like so:

    GET /api/system/taskSummaries/DATA_INTEGRITY

The returned object contains a summary for each point of analysis,
listing the names of the relevant integrity violations. As stated in the
leading paragraph for this section the details of the analysis (and the
resulting data) can be found in the user manual chapter on Data
Administration.

## Enregistrements des ensembles de données complets{ #webapi_complete_data_set_registrations }

Cette section traite de l'enregistrement d'ensembles de données complétés en tant qu'ensembles de données. Un enregistrement marque un ensemble de données comme étant complètement capturé.

### Compléter les ensembles de données { #webapi_completing_data_sets }

Cette section explique comment enregistrer des ensembles de données comme étant complets. Cela s'obtient en interagissant avec la ressource *completeDataSetRegistrations*:

    GET /api/33/completeDataSetRegistrations

Le point d'extrémité utilise la méthode *POST* pour enregistrer les ensembles de données complets. De façon pratique, ce point d'extrémité est très similaire à celui de *dataValueSets* (ensembles de valeurs de données), avec la possibilité d'importer des enregistrements complets en bloc.

L'importation de charges utiles au format *XML* et *JSON* est prise en charge. Le format de base de cette charge utile, donné en *XML* dans cet exemple, ressemble à ceci :

```xml
<completeDataSetRegistrations xmlns="http://dhis2.org/schema/dxf/2.0">
  <completeDataSetRegistration period="200810" dataSet="eZDhcZi6FLP"
    organisationUnit="qhqAxPSTUXp" attributeOptionCombo="bRowv6yZOF2" storedBy="imported"/>
  <completeDataSetRegistration period="200811" dataSet="eZDhcZi6FLP"
    organisationUnit="qhqAxPSTUXp" attributeOptionCombo="bRowv6yZOF2" storedBy="imported"/>
</completeDataSetRegistrations>
```

L'attribut *storedBy* (stocké par) est facultatif (car il peut être retiré de l'objet d'enregistrement complet). Vous pouvez également définir la propriété *date* (heure de l'enregistrement) en tant qu'attribut. Si l'heure n'est pas définie, l'heure actuelle sera utilisée.

Le processus d'importation prend en charge les paramètres de requête suivants :



Tableau : Paramètres de requête d'enregistrement d'ensembles de données complets

| Paramètre | Valeurs | Description |
|---|---|---|
| dataSetIdScheme (Schéma de l'identifiant de l'ensemble de données) | identifiant &#124; nom &#124; code &#124; attribut:ID | Propriété de l'ensemble de données permettant de mettre en correspondance les enregistrements complets. |
| orgUnitIdScheme (Schéma de l'identifiant de l'unité d'organisation) | identifiant &#124; nom &#124; code &#124; attribut:ID | Propriété de l'unité d'organisation permettant de mettre en correspondance les enregistrements complets. |
| attributOptionComboIdScheme (Schéma de l'identifiant de la combinaison d'options de catégorie) | identifiant &#124; nom &#124; code &#124; attribut:ID | Propriété de la combinaison d'options d'attribut permettant de mettre en correspondance les enregistrements complets. |
| idScheme | identifiant &#124; nom &#124; code &#124; attribut:ID | Propriété de tous les objets, y compris les ensembles de données, les unités d'organisation et les combinaisons d'options d'attribut, qui permettent de mettre en correspondance enregistrements complets. |
| preheatCache | faux &#124; vrai | Pour sauvegarder les modifications sur le serveur ou pour renvoyer le résumé de l'importation. |
| dryRun | faux &#124; vrai | Si l'enregistrement s'applique aux sous-unités |
| importStrategy (stratégie d'importation) | CRÉER &#124; METTRE À JOUR &#124; CRÉER _ET_METTRE À JOUR &#124; SUPPRIMER | Sauvegarde des objets de tous les statuts d'importation, nouveaux ou mis à jour, sur le serveur. |
| skipExistingCheck (ignorer les contrôles existants) | faux &#124; vrai | Ne contrôle pas les enregistrements complets existants. Améliore les performances. À utiliser uniquement pour les bases de données vides ou lorsque les enregistrements à importer n'existent pas encore. |
| async | faux &#124; vrai | Indique si l'importation doit être effectuée de manière asynchrone ou synchrone. La première option (asynchrone) est adapté aux importations très volumineuses car il garantit que la requête n’expire pas, bien qu’il entraîne une surcharge de performances. La deuxième (synchrone) est plus rapide mais nécessite que la connexion soit maintenue jusqu'à la fin du processus. |

Les éléments `idScheme` (schéma de l'identifiant), `dataSetIdScheme`  (schéma de l'identifiant de l'ensemble de données), `orgUnitIdScheme` (schéma de l'identifiant de l'unité d'organisation), `attributeOptionComboIdScheme` (schéma de l'identifiant de la combinaison d'options d'attribut),
`dryRun` (essai) et `strategy` (stratégie) (notez la dénomination différente du paramètre `importStrategy` (stratégie d'importation))
peuvent également être définis dans le cadre de la charge utile.
Avec XML, ce sont des attributs ; avec JSON, ce sont des éléments du nœud `completeDataSetRegistrations` (enregistrements des ensembles de données complets).

Par exemple :
```xml
<completeDataSetRegistrations xmlns="http://dhis2.org/schema/dxf/2.0"
      orgUnitIdScheme="CODE">
    <completeDataSetRegistration period="200810" dataSet="eZDhcZi6FLP"
    organisationUnit="OU_559" attributeOptionCombo="bRowv6yZOF2" storedBy="imported"/>
</completeDataSetRegistrations>
```

Si le paramètre URL et la charge utile définissent un schéma, la charge utile est prioritaire.

### Lecture des enregistrements d'ensembles de données complets { #webapi_reading_complete_data_sets }

Cette section explique comment récupérer les enregistrements d'ensembles de données complets. Nous utiliserons la ressource *completeDataSetRegistrations*. Les paramètres de requête à utiliser sont les suivants :



Tableau : Paramètres de requête d'ensemble de valeurs de données

| Paramètre | Description |
|---|---|
| dataSet (ensemble de données) | Identifiant de l'ensemble de données, plusieurs ensembles de données sont autorisés |
| période | Identifiant de la période au format ISO. Plusieurs périodes sont autorisées. |
| date de début | Date de début de la période des valeurs à exporter |
| date de fin | Date de fin de la période des valeurs à exporter |
| créé | Inclut uniquement les enregistrements créées depuis l'horodatage donné |
| Durée de la création | Inclut uniquement les enregistrements créées pendant la durée indiquée. Le format est <value\><unité-de-temps\>, où les unités de temps prises en charge sont "d", "h", "m", "s " *(jours, heures, minutes, secondes).* L'unité de temps est liée à l'heure actuelle. |
| orgUnit (Unité d'organisation) | Identifiant de l'unité d'organisation ; peut être spécifié plusieurs fois. Non applicable si un groupe d'unités d'organisation est fourni. |
| orgUnitGroup (groupe d'unités d'organisation) | Identifiant du groupe d’unités d’organisation ; peut être spécifié plusieurs fois. Non applicable si une unité d'organisation est fournie. |
| subordonnées | Permet de spécifier s'il faut inclure les unités d’organisation subordonnées dans la hiérarchie des unités d'organisation |
| limite | Le nombre maximum d'enregistrements à inclure dans la réponse. |
| idScheme | Propriété d'identifiant utilisée pour les objets de métadonnées dans la réponse. |
| dataSetIdScheme (Schéma de l'identifiant de l'ensemble de données) | Propriété d'identifiant utilisée pour les ensembles de données dans la réponse. Elle remplace le schéma de l'identifiant. |
| orgUnitIdScheme (Schéma de l'identifiant de l'unité d'organisation) | Propriété d'identifiant utilisée pour les unités d'organisation dans la réponse. Elle remplace le schéma de l'identifiant. |
| attributOptionComboIdScheme (Schéma de l'identifiant de la combinaison d'options de catégorie) | Propriété d'identifiant utilisée pour les combinaisons d'options d'attribut dans la réponse. Elle remplace le schéma de l'identifiant. |
Les paramètres `ensemble de données` et `unité d'organisation` peuvent être répétés afin d'inclure plusieurs ensembles de données et unités d'organisation.

Les paramètres `période`, `date de début`, `date de fin`, `créé` et `durée de création` fournissent plusieurs façons de définir la dimension temporelle de la requête, donc un seul peut être utilisé. Par exemple, cela n'a pas de sens de définir à la fois la date de début/fin et les périodes.

Voici donc un exemple de requête :

```bash
GET /api/33/completeDataSetRegistrations?dataSet=pBOMPrpg1QX&dataSet=pBOMPrpg1QX
  &startDate=2014-01-01&endDate=2014-01-31&orgUnit=YuQRtpLP10I
  &orgUnit=vWbkYPRmKyS&children=true
```

Vous pouvez obtenir la réponse au format *xml* et *json*. Vous pouvez indiquer le format de réponse que vous préférez via l'en-tête HTTP *Accepter* comme dans l'exemple ci-dessus. Pour xml, utilisez *application/xml* ; pour json, utilisez *application/json*.

### Annuler la finalisation des ensembles de données { #webapi_uncompleting_data_sets }

Cette section explique comment annuler l'enregistrement de la complétude d'un ensemble de données. Pour annuler la finalisation d'un ensemble de données, vous interagirez avec la ressource completeDataSetRegistrations :

    GET /api/33/completeDataSetRegistrations

Cette ressource prend en charge la fonction *DELETE* pour annuler l'inscription. Les paramètres de requête suivants sont pris en charge :



Tableau : Paramètres de requête d'enregistrement d'ensembles de données complets

| Paramètre de requête | Obligatoire | Description |
|---|---|---|
| ds | Oui | Identifiant de l'ensemble de données |
| pe | Oui | Identifiant de période |
| ou | Oui | Identifiant de l'unité d'organisation |
| cc | Non (doit combiner avec cp) | Identifiant de la combinaison d'attributs (pour la vérification du verrouillage) |
| cp | Non (doit combiner avec cp) | Identifiants d'options d'attribut, séparés par ; pour plusieurs valeurs (pour le contrôle du verrouillage) |
| multiOu (unités d'organisation multiples) | Non (faux par défaut) | Si l'enregistrement s'applique aux sous-unités |



# Approbation des données { #data-approval } 

## Approbation des données { #webapi_data_approval } 

Cette section explique comment approuver, désapprouver et vérifier le statut 
d'approbation en utilisant la ressource *dataApprovals* (Approbation des données). L'approbation se fait par flux 
de travail d'approbation des données, par période, par unité d'organisation et par combinaison d'options d'attributs.

    /api/33/dataApprovals

Un processus d'approbation des données est associé à plusieurs entités :

* Un type de période qui définit la fréquence d'approbation
* Une combinaison de catégories facultative
* Un ou plusieurs niveaux d'approbation des données qui font partie du flux de travail
* Un ou plusieurs ensembles de données utilisés pour la collecte de données

### Obtenir le statut d'approbation { #webapi_data_approval_get_status } 

Pour obtenir des informations sur l'approbation d'un ensemble de données, vous pouvez envoyer une requête GET :

    /api/dataApprovals?wf=rIUL3hYOjJc&pe=201801&ou=YuQRtpLP10I



Tableau : Paramètres de requête pour l'approbation des données

| Paramètre de requête | Obligatoire | Description |
|---|---|---|
| wf | Oui | Identifiant du workflow d'approbation des données |
| pe | Oui | Identifiant de période |
| ou | Oui | Identifiant de l'unité d'organisation |
| aoc | Non | Identifiant de combinaison d'options d'attributs |

> **Remarque**
>
> Pour des raisons de compatibilité en amont, le paramètre `ds` pour l'ensemble de données peut être donné à la place de `wf` pour le flux de travail dans cette demande d'approbation de données et dans d'autres, comme décrit ci-dessous. Si l'ensemble de données est donné, le flux de travail associé à cet ensemble de données sera utilisé.

Vous obtiendrez une réponse similaire à celle-ci :

```json
{
  "mayApprove": false,
  "mayUnapprove": false,
  "mayAccept": false,
  "mayUnaccept": false,
  "state": "UNAPPROVED_ELSEWHERE"
}
```

Les paramètres obtenus sont les suivants :



Tableau : Paramètres obtenus pour l'approbation des données

| Paramètre de retour | Description |
|---|---|
| peutApprouver | Si l'utilisateur actuel peut approuver cette sélection de données. |
| peutDésapprouver | Si l'utilisateur actuel peut désapprouver cette sélection de données. |
| peutAccepter | Si l'utilisateur actuel peut accepter cette sélection de données. |
| peutRefuser | Si l'utilisateur actuel peut refuser cette sélection de données. |
| État | L'un des états d'approbation des données est indiqué dans le tableau ci-dessous. |



Tableau : États d'approbation des données

| État | Description |
|---|---|
| NON APPROUVÉ | L'approbation des données ne s'applique pas à cette sélection. (Les données ne sont ni approuvées ni non approuvées). |
| NON APPROUVÉ_EN ATTENTE | Les données pourraient être approuvées pour cette sélection, mais elles attendent une approbation de niveau inférieur avant d'être prêtes à être approuvées. |
| NON APPROUVÉ_AUTRE PART | Les données ne sont pas approuvées et attendent d'être approuvées autre part (elles ne peuvent pas être approuvées ici). |
| NON APPROUVÉ_ PRÊT | Les données ne sont pas approuvées et sont prêtes à être approuvées pour cette sélection. |
| APPROUVÉ_ICI | Les données sont approuvées et ont été approuvées ici (elles pourraient donc être non approuvées ici). |
| APPROUVÉ_AUTRE PART | Les données sont approuvées, mais n'ont pas été approuvées ici (et ne peuvent donc pas être non approuvées ici) : <br>* Les données sont approuvées à un niveau supérieur.<br>* Les données sont approuvées pour un plus grand nombre d'options de catégories. <br>* Les données sont approuvées pour toutes les sous-périodes de la période sélectionnée. <br>Dans les deux premiers cas, il existe un seul objet d'approbation des données qui couvre la sélection. Dans le troisième cas, il n'y en a pas. |
| ACCEPTÉ_ICI | Les données sont approuvées et acceptées ici (elles pourraient donc être non approuvées ici). |
| ACCEPTÉ_AUTRE PART | Les données sont approuvées et acceptées, mais à un autre endroit. |

Notez que lorsque vous demandez l'état de l'approbation des données, vous pouvez spécifier
toute combinaison de paramètres d'interrogation. La combinaison que vous spécifiez
ne doit pas nécessairement décrire l'endroit où les données doivent être approuvées à l'un 
des niveaux d'approbation. Par exemple :

  - L'unité d'organisation peut ne pas être à un niveau d'approbation. Le
    statut d'approbation est déterminé par le fait que les données sont approuvées à un
    niveau d'approbation pour un ascendant de l'unité d'organisation.

  - Vous pouvez spécifier des options de catégories d'attributs individuelles. Le statut
    d'approbation est déterminé par le fait que les données sont approuvées pour une
    combinaison d'options de catégorie d'attributs qui comprend une ou plusieurs de ces
    options.

  - Vous pouvez spécifier une période plus longue que celle de
    l'ensemble de données, au cours de laquelle les données sont saisies et approuvées. Le statut 
    d'approbation est déterminé par l'approbation des données pour toutes les
    périodes de l'ensemble de données au cours de la période spécifiée.

Pour les ensembles de données associés à une combinaison de catégories, il est possible 
de récupérer les enregistrements d'approbation des données pour les combinaisons d'options d'attributs individuels 
à partir de la ressource suivante, au moyen d'une requête GET :

    /api/dataApprovals/categoryOptionCombos?wf=rIUL3hYOjJc&pe=201801&ou=YuQRtpLP10I

### Obtenir le statut d'approbation en bloc { #bulk-get-approval-status } 

Pour obtenir une liste de plusieurs statuts d'approbation, vous pouvez envoyer une requête GET similaire à celle-ci :

    /api/dataApprovals/approvals?wf=rIUL3hYOjJc&pe=201801,201802&ou=YuQRtpLP10I

Les paramètres `wf`, `pe`, `ou`, et `aoc` sont les mêmes que pour obtenir un statut d'approbation unique, sauf que vous pouvez fournir une liste séparée par des virgules d'une ou plusieurs valeurs pour chaque paramètre.

Vous obtiendrez une réponse contenant une liste de paramètres d'approbation et de statuts, comme suit :

```json
[
  {
    "aoc": "HllvX50cXC0",
    "pe": "201801",
    "level": "KaTJLhGmU95",
    "ou": "YuQRtpLP10I",
    "permissions": {
      "mayApprove": false,
      "mayUnapprove": true,
      "mayAccept": true,
      "mayUnaccept": false,
      "mayReadData": true
    },
    "state": "APPROVED_HERE",
    "wf": "rIUL3hYOjJc"
  },
  {
    "aoc": "HllvX50cXC0",
    "pe": "201802",
    "ou": "YuQRtpLP10I",
    "permissions": {
      "mayApprove": true,
      "mayUnapprove": false,
      "mayAccept": false,
      "mayUnaccept": false,
      "mayReadData": true
    },
    "state": "UNAPPROVED_READY",
    "wf": "rIUL3hYOjJc"
  }
]
```

Les champs obtenus sont décrits dans le tableau ci-dessous.

| Champ       | Description |
| ----------- | ----------- |
| aoc         | Identifiant de combinaison d'options d'attributs |
| pe          | Identifiant de période |
| ou          | Identifiant d'unité d'organisation |
| autorisations | The permissions: 'mayApprove', 'mayUnapprove', 'mayAccept', 'mayUnaccept', and 'mayReadData' (same definitions as for get single approval status). |
| État       | Un des états d'approbation des données (comme pour obtenir un statut d'approbation unique.) |
| wf          | Identifiant du workflow d'approbation des données |

### Approuver les données { #webapi_data_approval_approve_data } 

Pour approuver des données, vous pouvez envoyer une demande *POST* à la ressource 
*dataApprovals*. Pour annuler l'approbation des données, vous pouvez envoyer une 
demande *SUPPRIMER* à la ressource dataApprovals.

    POST DELETE /api/33/dataApprovals

Pour accepter des données déjà approuvées, vous pouvez envoyer une demande 
*POSTER* à la ressource *Acceptationdesdonnées*. Pour annuler l'acceptation de données, 
vous pouvez envoyer une demande *SUPPRIMER* à la ressource *Acceptationdesdonnées*.

    POST DELETE /api/33/dataAcceptances

Ces demandes contiennent les paramètres suivants :



Tableau : Paramètres d'action pour l'approbation des données

| Paramètres d'action | Obligatoire | Description |
|---|---|---|
| wf | Oui | Identifiant du workflow d'approbation des données |
| pe | Oui | Identifiant de période |
| ou | Oui | Identifiant de l'unité d'organisation |
| aoc | Non | Identifiant de combinaison d'options d'attributs |

Notez que, contrairement à la requête sur le statut d'approbation des données, vous devez 
spécifier des paramètres qui correspondent à une sélection de données susceptibles d'être 
approuvées. En particulier, les deux éléments suivants doivent être vrais :

  - Le niveau de l'unité d'organisation doit être spécifié par un niveau d'approbation 
    dans le flux de travail.

  - La période spécifiée doit correspondre au type de période du 
    flux de travail.

### Approuver les données en bloc { #webapi_data_approval_bulk_approve_data } 

Vous pouvez approuver un ensemble d'enregistrements de données en postant dans 
la ressource `/api/dataApprovals/approvals`.

    POST /api/33/dataApprovals/approvals

Vous pouvez approuver un bloc d'enregistrements de données en postant dans 
la ressource `/api/dataApprovals/approvals`.

    POST /api/33/dataApprovals/unapprovals

Vous pouvez accepter un grand nombre d'enregistrements en envoyant un message à la ressource
`/api/dataAcceptances/acceptances`.

    POST /api/33/dataAcceptances/acceptances

Vous pouvez refuser un bloc d'enregistrements en envoyant un message à la ressource
`/api/dataAcceptances/acceptances`.

    POST /api/33/dataAcceptances/unacceptances

La charge utile d'approbation est prise en charge en tant que JSON et ressemble à ceci :

```json
{
  "wf": [
    "pBOMPrpg1QX", "lyLU2wR22tC"
  ],
  "pe": [
    "201601", "201602"
  ],
  "approvals": [
    {
      "ou": "cDw53Ej8rju",
      "aoc": "ranftQIH5M9"
    },
    {
      "ou": "cDw53Ej8rju",
      "aoc": "fC3z1lcAW5x"
    }
  ]
}
```

### Obtenir les niveaux d'approbation des données { #get-data-approval-levels } 

Pour récupérer les flux de travail d'approbation des données et leurs niveaux d'approbation, 
vous pouvez effectuer une requête GET similaire à celle-ci :

/api/dataApprovalWorkflows ?
champs=identifiant, nom, type de période, niveau d'approbation des données [identifiant, nom, niveau, niveau de l'unité d'organisation]


### Responsables de l'approbation des données { #authorities-for-data-approval } 

- `F_FLUX DE TRAVAIL_ DE L' APPROBATION_DES DONNÉES` : permet à l'utilisateur d'ajouter/mettre à jour le flux de travail relatif à l'approbation des données.
-  `F_NIVEAU_D'APPROBATION DES_DONNÉES` : permet à l'utilisateur d'ajouter/mettre à jour le niveau d'approbation des données.


# Partage { #sharing } 

## Partage { #webapi_sharing } 

La solution de partage vous permet de partager la plupart des objets du système avec 
des groupes d'utilisateurs spécifiques et de définir si les objets doivent être accessibles 
au public ou privés. Pour obtenir et définir le statut de partage des objets, vous pouvez 
interagir avec la ressource de *partage*.

    /api/33/sharing

### Obtenir le statut de partage { #webapi_get_sharing_status } 

Pour demander le statut de partage d'un objet, faites une requête GET à :

    /api/33/sharing?type=dataElement&id=fbfJHSPpUQD

La réponse se présente comme suit.

```json
{
  "meta": {
    "autoriserl'accèspublic": vrai,
    "autoriserl'accèsexterne": faux
  },
  "objet": {
    "id": "fbfJHSPpUQD",
    "nom": "CPN 1ère visite",
    "accèspublic": "rw------",
    "accèsexterne": faux,
    "utilisateur": {},
    "accès au groupe d'utilisateurs": [
      {
        "id": "hj0nnsVsPLU",
        "accès": "rw------"
      },
      {
        "id": "qMjBflJMOfB",
        "accès": "r-------"
      }
    ]
  }
}
```

### Définir le statut de partage { #webapi_set_sharing_status } 

Vous pouvez définir le statut de partage d'un objet en utilisant la même URL avec 
une requête POST, où la charge utile au format JSON ressemble à ceci :

```json
{
  "objet": {
    "accèspublic": "rw------",
    "accèsexterne": faux,
    "utilisateur": {},
    "accès au groupe d'utilisateurs": [
      {
        "id": "hj0nnsVsPLU",
        "accès": "rw------"
      },
      {
        "id": "qMjBflJMOfB",
        "accès": "r-------"
      }
    ]
  }
}
```

Dans cet exemple, la charge utile définit l'objet comme ayant un accès public en lecture et 
en modification, aucun accès externe (sans connexion), un accès en lecture et en modification à 
un groupe d'utilisateurs et un accès en lecture uniquement à un autre groupe d'utilisateurs. Vous pouvez 
soumettre ceci à la ressource de partage en utilisant curl :

```bash
curl -d @sharing.json "localhost/api/33/sharing?type=dataElement&id=fbfJHSPpUQD"
  -H "Content-Type:application/json" -u admin:district
```
**Remarque**
> Il est possible de créer des combinaisons de partage surprenantes. Par
> exemple, si `accèsexterne` est défini à `vrai` mais que `accèspublic` est
> défini à `--------`, les utilisateurs n'auront accès à l'objet 
> que lorsqu'ils seront déconnectés.




## Nouvel objet de partage { #new-sharing-object } 
Depuis la version 2.36, une nouvelle propriété `partage` a été introduite afin de remplacer les anciennes propriétés de partage `accès utilisateur`, `accès groupe utilisateur`, `accès public`, `accès externe` dans toutes les classes de métadonnées pour lesquelles le partage est activé. Cet objet `Partage` est sauvegardé en tant que colonne JSONB dans la base de données. 
Cependant, afin de rendre le système compatible avec les anciennes versions, les anciens objets de partage continuent de fonctionner normalement, à la fois pour l'importation et l'exportation. Dans le backend, les données de partage seront sauvegardées dans la nouvelle colonne JSONb `Partage` au lieu des anciennes tables `*Accès`.

Le format est le suivant :
```json
{
  "nom": "CPN 1ère visite",
  "accès public": "rw------",
  "accès externe": faux,
  "accès aux groupes d'utilisateurs": [
      {
          "accès": "r-r-----",
          "groupe d'utilisateur Uid": "Rg8wusV7QYi",
          "nom d'affichage": "Coordinateurs du programme VIH",
          "id": "Rg8wusV7QYi"
      }
  ],
  "accès utilisateur": [],
  "utilisateur": {
      "nom d'affichage": "Tom Wakiki",
      "nom": "Tom Wakiki",
      "id": "GOLswS44mh8",
      "Nom d'utilisateur": "système"
  },
  "partage": {
      "propriétaire": "GOLswS44mh8",
      "externe": faux,
      "utilisateurs": {},
      "groupes d'utilisateurs": {
          "Rg8wusV7QYi": {
              "accès": "r-r-----",
              "id": "Rg8wusV7QYi"
          }
      },
      "public": "rw------"
  }
}
```

### Définir le statut de partage en utilisant la nouvelle Api JSON Patch { #webapi_set_sharing_status_using_json_patch_api } 
Vous pouvez utiliser [JSON Patch API](#webapi_partial_updates) pour mettre à jour le partage d'un objet en envoyant une requête `PATCH` à ce point de terminaison avec l'en-tête `Type de contenu : application/json-patch+json`
```
api/dataElements/fbfJHSPpUQD
```
Veuillez noter que cette fonction ***supporte uniquement*** le nouveau format `partage`. La charge utile au format JSON ressemble à ceci :
```json
[
  {
    "op": "remplacer",
    "chemin d'accès": "/partage/utilisateurs",
    "valeur": {
      "NOOF56dveaZ": {
        "accès": "rw------",
        "id": "NOOF56dveaZ"
      },
      "Kh68cDMwZsg": {
        "accès": "rw------",
        "id": "Kh68cDMwZsg"
      }
    }
  }
]
```
Vous pouvez ajouter des utilisateurs à la propriété `partage` d'un objet comme suit
```json
[
  {
    "op": "ajouter",
    "chemin d'accès": "/partage/utilisateurs",
    "valeur": {
      "NOOF56dveaZ": {
        "accès": "rw------",
        "id": "NOOF56dveaZ"
      },
      "Kh68cDMwZsg": {
        "accès": "rw------",
        "id": "Kh68cDMwZsg"
      }
    }
  }
]
```
Vous pouvez ajouter un utilisateur à `partage` comme ceci
```json
[
  {
    "op": "ajouter",
    "chemin d'accès": "/partage/utilisateurs/NOOF56dveaZ",
    "valeur": {
      "accès": "rw------",
      "id": "NOOF56dveaZ"
    }
  }
]
```
Vous pouvez supprimer un utilisateur de `partage` comme suit
```json
[
  { 
    "op": "remove", 
    "path": "/sharing/users/N3PZBUlN8vq"
    }
]
```

## Partage en cascade du tableau de bord { #cascade-sharing-for-dashboard } 

### Aperçu { #overview } 

- The sharing solution supports cascade sharing for Dashboard. 
- This function will copy `userAccesses` and `userGroupAccesses` of a Dashboard to all of its DashboardItem's objects including `Map`, `EventReport`, `EventChart`, `Visualization`. 
- This function will ***NOT*** copy `METADATA_WRITE` access. The copied `UserAccess` and `UserGroupAccess` will **only** have `METADATA_READ` permission. 
- The `publicAccess` setting is currently ***NOT*** handled by this function. Means the `publicAccess` of the current `Dashboard` will not be copied to its `DashboardItems`'s objects.
- If target object has `publicAccess` enabled, then it will be ignored by this function. Means that no `UserAccesses` or `UserGroupAccesses` will be copied from `Dashboard`.
- Current `User` is required to have `METADATA_READ` sharing permission to all target objects, otherwise error `E5001` will be thrown. And to update target objects, `METADATA_WRITE` is required, otherwise error `E3001` will be thrown.
- Sample use case:

    - DashboardA is shared to userA with `METADATA_READ_WRITE` permission.

    - Le tableau de bord A a une visualisation A qui a un élément de données A.

    - VisualizationA, DataElementA have `publicAccess`  *disabled* and are *not shared* to userA.

    - Après avoir exécuté le partage en cascade pour le tableau de Bord A, l'utilisateur A aura un accès `LECTURE_DE METADONNEES` à la Visualisation A et à l'Élément de Données A.

### Point de terminaison de l'API  { #api-endpoint } 

- Envoyer une requête `POST` au point de terminaison 
```
api/dashboards/cascadeSharing/{dashboardUID}
```


### Paramètres de l'API { #api-parameters } 

| Nom | Par défaut | Description |
| --- | --- | -- |
| dryRun | faux | Si ce paramètre est fixé à `vrai`, la fonction de partage en cascade sera exécutée sans mettre à jour aucun objet. </br>La réponse comprendra les erreurs éventuelles et tous les objets qui seront mis à jour. </br>Cela permet à l'utilisateur de connaître le résultat avant d'exécuter la fonction de partage en cascade.
| atomic | faux | Si ce paramètre est fixé à `vrai`, alors la fonction de partage en cascade s'arrêtera et ne mettra à jour aucun objet s'il y a une erreur. </br>Sinon, si cette valeur est ` fausse `, la fonction essaiera de procéder avec le mode du best effort (meilleur effort).

Exemple de réponse : 

```json
{
  "rapports d'erreur": [
    {
      "message": "Pas d'objet correspondant à la référence. L'identificateur était s46m5MS0hxu, et l'objet était l'élément de données .",
      "mainKlass": "org.hisp.dhis.dataelement.DataElement",
      "code d'erreur": "E5001",
      "Propriétés de l'erreur": [
        "s46m5MS0hxu",
        "élément de données "
      ]
    }
  ],
  "countUpdatedDashBoardItems": 1,
  "mettre à jour les objets": {
    "élément de données ": [
      {
        "id": "YtbsuPPo010",
        "nom": "Dose de rougeole administrée"
      },
      {
        "id": "l6byfWFUGaP",
        "nom": "Doses de fièvre jaune administrées"
      }
    ]
  }
}
```

### Propriétés de la réponse : { #response-properties } 

- `Rapports d'erreurs` : inclut toutes les erreurs survenues au cours du processus de partage en cascade.
- `countUpdatedDashBoardItems` : Nombre `d'éléments du tableau de bord` qui seront ou ont été mis à jour, en fonction du mode `dryRun`.
- `updateObjects` (Mise à jour des objets): Liste de tous les objets qui seront ou ont été mis à jour en fonction du mode `dryRun`.


# Programmation { #webapi_scheduling } 

DHIS2 permet de programmer des tâches de différents types. Chaque type de tâche possède des propriétés de configuration différentes, ce qui vous permet de contrôler plus finement la façon dont les tâches sont exécutées. En outre, vous pouvez configurer une même tâche de manière à ce qu'elle s'exécute avec différentes configurations et à différents intervalles, si nécessaire.



Tableau : Principales propriétés

| Propriété | Description | Type |
|---|---|---|
| nom | Nom de la tâche. | Chaîne |
| expression cron | L'expression cron qui définit l'intervalle d'exécution de la tâche. | Chaîne (expression Cron) |
| type de tâches | Le type de tâche représente la tâche qui est exécutée. Le tableau suivant donne un aperçu des types de tâches existants. Chaque type de tâche peut avoir un ensemble spécifique de paramètres pour la configuration de la tâche. | Chaîne (Enum) |
| paramètres de tâches | Paramètres de tâches, le cas échéant pour le type de tâche. | (Voir la liste des types de tâches) |
| activé | Une tâche peut être ajoutée au système sans être programmée en mettant `enabled` à false dans la charge utile JSON. Utilisez ceci si vous voulez arrêter temporairement la programmation d'une tâche, ou si la configuration d'une tâche n'est pas encore terminée. | Booléen |



Table: Available job types

| Job type | Paramètres | Param(Type:Default) |
|---|---|---|
| INTÉGRITÉ_DES DONNÉES | AUCUNE ||
| TABLE_ANALYTIQUE | * lastYears: Number of years back to include<br> * skipTableTypes: Skip generation of tables<br>Possible values: DATA_VALUE, COMPLETENESS, COMPLETENESS_TARGET, ORG_UNIT_TARGET, EVENT, ENROLLMENT, VALIDATION_RESULT<br> * skipResourceTables: Skip generation of resource tables | * lastYears (int:0)<br> * skipTableTypes (Array of String (Enum):None )<br> * skipResourceTables (Boolean) |
| CONTINUOUS_ANALYTICS_TABLE | * fullUpdateHourOfDay: Hour of day for full update of analytics tables (0-23)<br> * lastYears: Number of years back to include<br> * skipTableTypes: Skip generation of tables<br>Possible values: DATA_VALUE, COMPLETENESS, COMPLETENESS_TARGET, ORG_UNIT_TARGET, EVENT, ENROLLMENT, VALIDATION_RESULT<br> * skipResourceTables: Skip generation of resource tables | * lastYears (int:0)<br> * skipTableTypes (Array of String (Enum):None )<br> * skipResourceTables (Boolean) |
| DATA_SYNC | AUCUNE ||
| META_DATA_SYNC | AUCUNE ||
| SEND_SCHEDULED_MESSAGE | AUCUNE ||
| PROGRAM_NOTIFICATIONS | AUCUNE ||
| MONITORING (Validation rule analysis) | * relativeStart: A number related to date of execution which resembles the start of the period to monitor<br> * relativeEnd: A number related to date of execution which resembles the end of the period to monitor<br> * validationRuleGroups: Validation rule groups(UIDs) to include in job<br> * sendNotification: Set "true" if job should send notifications based on validation rule groups<br> * persistsResults: Set "true" if job should persist validation results | * relativeStart (int:0)<br> * relativeEnd (int:0)<br> * validationRuleGroups (Array of String (UIDs):None )<br> * sendNotification (Boolean:false)<br> * persistsResults (Boolean:false) |
| PUSH_ANALYSIS | * pushAnalysis: The uid of the push analysis you want to run | * pushAnalysis (String:None) |
| PREDICTOR | * relativeStart: A number related to date of execution which resembles the start of the period to monitor<br> * relativeEnd: A number related to date of execution which resembles the start of the period to monitor<br> * predictors: Predictors(UIDs) to include in job | * relativeStart (int:0)<br> * relativeEnd (int:0)<br> * predictors (Array of String (UIDs):None ) |

### Get available job types { #get-available-job-types } 

Pour obtenir une liste de tous les types de travaux disponibles, vous pouvez utiliser le point d'extrémité suivant :

    GET /api/jobConfigurations/jobTypes

La réponse contient des informations sur chaque type de travail, notamment le nom, le type de travail, la clé, le type de programmation et les paramètres disponibles. Le type de programmation peut être soit `CRON`, ce qui signifie que les travaux peuvent être programmés en utilisant une expression cron avec le champ `cronExpression`, soit `FIXED_DELAY`, ce qui signifie que les travaux peuvent être programmés pour s'exécuter avec un délai fixe entre les deux avec le champ `delay`. Le champ delay est donné en secondes.

Une réponse ressemblera à ceci :

```json
{
  "jobTypes": [
    {
      "name": "Data integrity",
      "jobType": "DATA_INTEGRITY",
      "key": "dataIntegrityJob",
      "schedulingType": "CRON"
    }, {
      "name": "Resource table",
      "jobType": "RESOURCE_TABLE",
      "key": "resourceTableJob",
      "schedulingType": "CRON"
    }, {
      "name": "Continuous analytics table",
      "jobType": "CONTINUOUS_ANALYTICS_TABLE",
      "key": "continuousAnalyticsTableJob",
      "schedulingType": "FIXED_DELAY"
    }
  ]
}
```

### Create job { #create-job } 

Pour configurer les tâches, vous pouvez envoyer une requête POST à la ressource suivante :

    /api/jobConfigurations

Une tâche sans paramètres au format JSON ressemble à ceci :

```json
{
  "name": "",
  "jobType": "JOBTYPE",
  "cronExpression": "0 * * ? * *",
}
```

Exemple d'un tableau d'analyse de tâches avec des paramètres au format JSON :

```json
{
  "name": "Analytics tables last two years",
  "jobType": "ANALYTICS_TABLE",
  "cronExpression": "0 * * ? * *",
  "jobParameters": {
    "lastYears": "2",
    "skipTableTypes": [],
    "skipResourceTables": false
  }
}
```

Exemple d'une tâche d'analyse push avec des paramètres au format JSON :

```json
{
   "name": "Push anlysis charts",
   "jobType": "PUSH_ANALYSIS",
   "cronExpression": "0 * * ? * *",
   "jobParameters": {
     "pushAnalysis": [
       "jtcMAKhWwnc"
     ]
    }
 }
```

Exemple de tâche avec le type de programmation `FIXED_DELAY` et un délai de 120 secondes :

```json
{
  "name": "Continuous analytics table",
  "jobType": "CONTINUOUS_ANALYTICS_TABLE",
  "delay": "120",
  "jobParameters": {
    "fullUpdateHourOfDay": 4
  }
}
```

### Get jobs { #get-jobs } 

Liste de toutes les configurations de tâches :

    GET /api/jobConfigurations

Retrouver une tâche :

    GET /api/jobConfigurations/{id}

Le contenu de la réponse se présente comme suit :

```json
{
  "lastUpdated": "2018-02-22T15:15:34.067",
  "id": "KBcP6Qw37gT",
  "href": "http://localhost:8080/api/jobConfigurations/KBcP6Qw37gT",
  "created": "2018-02-22T15:15:34.067",
  "name": "analytics last two years",
  "jobStatus": "SCHEDULED",
  "displayName": "analytics last two years",
  "enabled": true,
  "externalAccess": false,
  "jobType": "ANALYTICS_TABLE",
  "nextExecutionTime": "2018-02-26T03:00:00.000",
  "cronExpression": "0 0 3 ? * MON",
  "jobParameters": {
    "lastYears": 2,
    "skipTableTypes": [],
    "skipResourceTables": false
  },
  "favorite": false,
  "configurable": true,
  "access": {
    "read": true,
    "update": true,
    "externalize": true,
    "delete": true,
    "write": true,
    "manage": true
  },
  "lastUpdatedBy": {
    "id": "GOLswS44mh8"
  },
  "favorites": [],
  "translations": [],
  "userGroupAccesses": [],
  "attributeValues": [],
  "userAccesses": []
}
```

### Update job { #update-job } 

Mettre à jour une tâche avec des paramètres en utilisant le point d'extrémité suivant et le format de charge utile JSON :

    PUT /api/jobConfiguration/{id}

```json
{
  "name": "analytics last two years",
  "enabled": true,
  "cronExpression": "0 0 3 ? * MON",
  "jobType": "ANALYTICS_TABLE",
  "jobParameters": {
    "lastYears": "3",
    "skipTableTypes": [],
    "skipResourceTables": false
  }
}
```

### Delete job { #delete-job } 

Supprimer une tâche en utilisant :

    DELETE /api/jobConfiguration/{id}

Notez que certaines tâches avec des paramètres de configuration personnalisés peuvent ne pas être ajoutées si 
les paramètres système requis ne sont pas configurés. C'est le cas par exemple de la synchronisation des 
données, qui nécessite la configuration d'un serveur distant.

## Synchronization { #webapi_synchronization } 

This section covers pull and push of data and metadata.

### Data value push { #webapi_sync_data_push } 

To initiate a data value push to a remote server one must first configure the
URL and credentials for the relevant server from System settings >
Synchronization, then make a POST request to the following resource:

    /api/33/synchronization/dataPush

### Metadata pull { #webapi_sync_metadata_pull } 

To initiate a metadata pull from a remote JSON document you can make a
POST request with a *url* as request payload to the following resource:

    /api/33/synchronization/metadataPull

### Availability check { #webapi_sync_availability_check } 

To check the availability of the remote data server and verify user
credentials you can make a GET request to the following resource:

    /api/33/synchronization/availability


# Audit { #audit }

## Auditing { #webapi_auditing } 

DHIS2 does automatic auditing on all updates and deletions of aggregate
data values, tracked entity data values, tracked entity attribute
values, and data approvals. This section explains how to fetch this
data.

### Aggregate data value audits { #webapi_auditing_aggregate_audits } 

The endpoint for aggregate data value audits is located at
`/api/audits/dataValue`, and the available parameters are displayed in
the table below.



Tableau : Paramètres de requête des valeurs de données agrégées

| Paramètre | Option | Description |
|---|---|---|
| ds | Ensemble de données | One or more data set identifiers to get data elements from. |
| de | Élément de données | One or more data element identifiers. |
| pe | ISO Period | One or more period ISO identifiers. |
| ou | Unité d'organisation | One or more org unit identifiers. |
| auditType | UPDATE | DELETE | Filter by audit type. |
| skipPaging | faux &#124; vrai | Activer / désactiver la pagination |
| page | 1 (default) | If paging is enabled, this parameter decides which page to show |

Get all audits for data set with ID *lyLU2wR22tC*:

    /api/33/audits/dataValue?ds=lyLU2wR22tC

### Tracked entity data value audits { #webapi_tracked_entity_data_value_audits } 

The endpoint for tracked entity data value audits is located at
`/api/audits/trackedEntityDataValue`, and the available parameters are
displayed in the table below.



Tableau : Paramètres de requête pour les ensembles de données d'entités suivies

| Paramètre | Option | Description |
|---|---|---|
| de | Élément de données | One or more data element identifiers. |
| ps | Program Stage Entity | One or more program stage instance identifiers. |
| auditType | UPDATE | DELETE | Filter by audit type. |
| skipPaging | faux &#124; vrai | Activer / désactiver la pagination |
| page | 1 (default) | If paging is enabled, this parameter decides which page to show |

Get all audits which have data element ID eMyVanycQSC or qrur9Dvnyt5:

    /api/33/audits/trackedEntityDataValue?de=eMyVanycQSC&de=qrur9Dvnyt5

### Tracked entity attribute value audits { #webapi_tracked_entity_attribute_value_audits } 

The endpoint for tracked entity attribute value audits is located at
`/api/audits/trackedEntityAttributeValue`, and the available parameters
are displayed in the table below.



Tableau : Paramètres de requête pour les valeurs d'attributs d'entités suivies

| Paramètre | Option | Description |
|---|---|---|
| tea | Tracked Entity Attributes | One or more tracked entity attribute identifiers. |
| te | Tracked Entity Instances | One or more tracked entity instance identifiers. |
| auditType | UPDATE | DELETE | Filter by audit type. |
| skipPaging | faux &#124; vrai | Activer / désactiver la pagination |
| page | 1 (default) | If paging is enabled, this parameter decides which page to show |

Get all audits which have attribute with ID VqEFza8wbwA:

    /api/33/audits/trackedEntityAttributeValue?tea=VqEFza8wbwA

### Tracked entity instance audits { #webapi_tracked_entity_instance_audits } 

Once auditing is enabled for tracked entity instances (by setting
allowAuditLog of tracked entity types to true), all read and search
operations are logged. The endpoint for accessing audit logs is
api/audits/trackedEntityInstance. Below are available parameters to
interact with this endpoint.



Tableau : Paramètres de requête pour les instances d'audit d'entités suivies

| Paramètre | Option | Description |
|---|---|---|
| tei | Instance d'entité suivie | One or more tracked entity instance identifiers |
| utiisateur | Utilisateur | Un ou plusieurs identifiants d'utilisateur |
| auditType | SEARCH | READ | Audit type to filter for |
| date de début | Date de début | Start date for audit filtering in yyyy-mm-dd format. |
| date de fin | Date de fin | End date for audit filtering in yyyy-mm-dd format. |
| skipPaging | faux &#124; vrai | Activer / désactiver la pagination |
| page | 1 (default) | Specific page to ask for. |
| taille de la page | 50 (default) | Page size. |

Get all tracked entity instance audits of type READ with
startDate=2018-03-01 and endDate=2018-04-24 in a page size of 5:

    /api/33/audits/trackedEntityInstance.json?startDate=2018-03-01
      &endDate=2018-04-24&auditType=READ&pageSize=5

### Enrollment audits { #webapi_enrollment_audits } 

Once auditing is enabled for enrollments (by setting allowAuditLog of
tracker programs to true), all read operations are logged. The
endpoint for accessing audit logs is api/audits/enrollment. Below are
available parameters to interact with this endpoint.



Table: Enrollment audit query parameters

| Paramètre | Option | Description |
|---|---|---|
| en | Inscription | One or more tracked entity instance identifiers |
| utiisateur | Utilisateur | Un ou plusieurs identifiants d'utilisateur |
| date de début | Date de début | Start date for audit filtering in yyyy-mm-dd format. |
| date de fin | Date de fin | End date for audit filtering in yyyy-mm-dd format. |
| skipPaging | faux &#124; vrai | Activer / désactiver la pagination |
| page | 1 (default) | Specific page to ask for. |
| taille de la page | 50 (default) | Page size. |

Get all enrollment audits with startDate=2018-03-01 and
endDate=2018-04-24 in a page size of 5:

    /api/audits/enrollment.json?startDate=2018-03-01&endDate=2018-04-24&pageSize=5

Get all enrollment audits for user admin:

    /api/audits/enrollment.json?user=admin

### Audits d'approbation des données { #data-approval-audits } 

The endpoint for data approval audits is located at
/api/audits/dataApproval, and the available parameters are displayed in
the table below.



Tableau : Paramètres de requête pour l'approbation des données

| Paramètre | Option | Description |
|---|---|---|
| dal | Data Approval Level | One or more data approval level identifiers. |
| wf | Déroulement | One or more data approval workflow identifiers. |
| ou | Unité d'organisation | One or more organisation unit identifiers. |
| aoc | Attribute Option Combo | One or more attribute option combination identifiers. |
| date de début | Start Date | Starting Date for approvals in yyyy-mm-dd format. |
| date de fin | End Date | Ending Date for approvals in yyyy-mm-dd format. |
| skipPaging | faux &#124; vrai | Activer / désactiver la pagination |
| page | 1 (default) | If paging is enabled, this parameter decides which page to show. |

Get all audits for data approval workflow RwNpkAM7Hw7:

    /api/33/audits/dataApproval?wf=RwNpkAM7Hw7




# Messagerie { #messaging } 

## Conversations par messages { #webapi_message_conversations } 

DHIS2 dispose d'un mécanisme permettant d'envoyer des messages à des fins tels que 
le retour d'information des utilisateurs, les notifications et les informations générales à l'intention des utilisateurs. Les messages 
sont regroupés en conversations. Pour interagir avec les conversations de messages, 
vous pouvez envoyer des requêtes POST et GET à la ressource 
*messageConversations*.

    /api/33/messageConversations

Les messages sont transmis à la boîte de réception DHIS2, mais ils peuvent également être envoyés 
aux adresses électroniques et aux téléphones portables de l'utilisateur sous forme de SMS. Dans cet exemple, 
nous verrons comment utiliser l'API Web pour envoyer, lire et gérer des 
messages. Nous allons nous faire passer pour l'utilisateur *Administrateur DHIS2* et envoyer 
un message à l'utilisateur *Mobile*. Nous allons ensuite nous faire passer pour l'utilisateur 
mobile et lire notre nouveau message. Ensuite, nous allons gérer la boîte de réception de l'utilisateur 
administrateur en marquant et en supprimant des messages.

### Écrire et lire des messages { #webapi_writing_messages } 

La ressource avec laquelle nous devons interagir pour envoyer et lire des messages 
est la ressource *messageConversations*. Nous commençons par visiter le point d'entrée 
de l'API Web à l'adresse <http://play.dhis2.org/demo/api>, où nous trouvons et suivons 
le lien vers la ressource *messageConversations* à l'adresse
<http://play.dhis2.org/demo/api messageConversations>. La description 
nous indique que nous pouvons utiliser une requête POST pour créer un nouveau message 
en utilisant le format XML suivant pour l'envoyer à plusieurs utilisateurs :

```xml
<message xmlns="http://dhis2.org/schema/dxf/2.0">
  <subject>Voici le sujet</subject>
  <text>Voici le texte</text>
  <users>
    <user id="user1ID" />
    <user id="user2ID" />
    <user id="user3ID" />
  </users>
</message>
```

Pour l'envoi à tous les utilisateurs appartenant à un ou plusieurs groupes d'utilisateurs, nous pouvons
utiliser :

```xml
<message xmlns="http://dhis2.org/schema/dxf/2.0">
  <subject>Voici le sujet</subject>
  <text>Voici le texte</text>
  <userGroups>
    <userGroup id="userGroup1ID" />
    <userGroup id="userGroup2ID" />
    <userGroup id="userGroup3ID" />
  </userGroups>
</message>
```

Pour l'envoi à tous les utilisateurs connectés à une ou plusieurs unités d'organisation, nous 
pouvons utiliser :

```xml
<message xmlns="http://dhis2.org/schema/dxf/2.0">
  <subject>Voici le sujet</subject>
  <text>Voici le texte</text>
  <organisationUnits>
    <organisationUnit id="ou1ID" />
    <organisationUnit id="ou2ID" />
    <organisationUnit id="ou3ID" />
  </organisationUnits>
</message>
```

Puisque nous voulons envoyer un message à notre ami l'utilisateur mobile, nous devons 
rechercher son identifiant. Nous le faisons en allant au point d'entrée de l'API Web et 
en suivant le lien vers la ressource *utilisateurs* à `/api/users`. Nous continuons en 
suivant le lien vers l'utilisateur mobile à `/api/users/PhzytPW3g2J` où nous apprenons 
que son identifiant est *PhzytPW3g2J*. Nous sommes maintenant prêts à rassembler nos messages 
XML pour former un message dans lequel nous voulons demander à l'utilisateur mobile 
s'il a déclaré des données pour janvier 2014 :

```xml
<message xmlns="http://dhis2.org/schema/dxf/2.0">
  <subject>Rapport sur les données de mortalité</subject>
  <text>Avez-vous déclaré des données pour l'ensemble de données sur la mortalité pour janvier 2014 ?</text>
  <users>
    <user id="PhzytPW3g2J" />
  </users>
</message>
```

Pour le tester, nous enregistrons le contenu XML dans un fichier appelé *message.xml*. 
Nous utilisons cURL pour envoyer le message à l'instance de démonstration DHIS2 où nous 
indiquons que le type de contenu est XML et où nous nous authentifions en tant qu'utilisateur 
*admin* :

```bash
curl -d @message.xml "https://play.dhis2.org/demo/api/messageConversations"
  -H "Content-Type:application/xml" -u admin:district -X POST
```

La charge correspondante en JSON et la commande POST ressemblent à ceci :

```json
{
  "subject": "Hey",
  "text": "How are you?",
  "users": [
    {
      "id": "OYLGMiazHtW"
    },
    {
      "id": "N3PZBUlN8vq"
    }
  ],
  "userGroups": [
    {
      "id": "ZoHNWQajIoe"
    }
  ],
  "organisationUnits": [
    {
      "id": "DiszpKrYNg8"
    }
  ]
}
```

```bash
curl -d @message.json "https://play.dhis2.org/demo/api/33/messageConversations"
  -H "Content-Type:application/json" -u admin:district -X POST
```

Si tout se passe bien, nous recevons un code de statut HTTP *201 Créé*. Notez également 
que nous recevons un en-tête HTTP *Localisation* qui nous informe de 
l'URL de la ressource de conversation de messages nouvellement créée - celle-ci peut être 
utilisée par un utilisateur pour effectuer d'autres actions.

Nous allons maintenant nous faire passer pour l'utilisateur mobile et lire le message qui 
vient d'être envoyé en envoyant une requête GET à la ressource *messageConversations*. 
Nous fournissons un en-tête *Accepter* avec l'*application/xml* comme 
valeur pour indiquer que nous sommes intéressés par la représentation de la ressource 
XML et nous nous authentifions en tant qu'utilisateur *mobile* :

```bash
curl "https://play.dhis2.org/demo/api/33/messageConversations"
  -H "Accept:application/xml" -u mobile:district
```

En réponse, nous obtenons le fichier XML suivant :

```xml
<messageConversations xmlns="http://dhis2.org/schema/dxf/2.0"
  link="https://play.dhis2.org/demo/api/messageConversations">
  <messageConversation name="Mortality data reporting" id="ZjHHSjyyeJ2"
    link="https://play.dhis2.org/demo/api/messageConversations/ZjHHSjyyeJ2"/>
  <messageConversation name="DHIS2 version 2.7 is deployed" id="GDBqVfkmnp2"
    link="https://play.dhis2.org/demo/api/messageConversations/GDBqVfkmnp2"/>
</messageConversations>
```

Dans la réponse, nous pouvons lire l'identifiant du nouveau message envoyé, 
qui est *ZjHHSjyyeJ2*. Notez que le lien vers la ressource spécifique 
est intégré et peut être suivi pour lire le message 
complet. Une fois que nous connaissons l'URL, nous pouvons répondre directement à 
une conversation sur un message existant en incluant le texte du message dans la charge de la requête. Nous 
sommes maintenant en mesure de créer une URL pour envoyer notre réponse :

```bash
curl -d "Oui, l'ensemble des données sur la mortalité a été déclaré"
  "https://play.dhis2.org/demo/api/messageConversations/ZjHHSjyyeJ2"
  -H "Content-Type:text/plain" -u mobile:district -X POST
```

Si tout s'est déroulé comme prévu, vous recevrez un code de statut *200 OK*.

Dans la version 2.30, nous avons ajouté un paramètre de recherche d'URL :

    queryString=?&queryOperator=?

Le filtre recherche des correspondances dans l'objet, le texte et les expéditeurs pour les conversations 
de messages. L'opérateur de requête par défaut est *token* (jeton), mais d'autres opérateurs 
peuvent être définis dans la requête.

### Gérer les messages { #webapi_managing_messages } 

Au fur et à mesure que les utilisateurs reçoivent et envoient des messages, les conversations commencent à s'empiler 
dans leur boîte de réception, ce qui devient éventuellement difficile à suivre. Nous allons maintenant 
voir comment gérer la boîte de réception des messages d'un utilisateur en supprimant et en marquant 
des conversations par l'intermédiaire de la Web-API. Pour ce faire, nous allons effectuer quelques 
opérations de maintenance dans la boîte de réception de l'utilisateur « Administrateur DHIS ».

Commençons par supprimer quelques messages de la boîte de réception. Notez 
bien que toutes les opérations de suppression décrites ici ne suppriment que la 
relation entre un utilisateur et une conversation de messages. En termes pratiques, 
cela signifie que nous ne supprimons pas les messages eux-mêmes (ni aucun 
contenu d'ailleurs) mais que nous supprimons simplement le fil de messages de 
l'utilisateur de sorte qu'il ne soit plus listé dans 
la ressource `/api/messageConversations`.

Pour supprimer une conversation de messages de la boîte de réception d'un utilisateur, nous devons envoyer une 
requête *DELETE* à la ressource identifiée par l'identifiant de la conversation de 
messages et l'utilisateur participant. Par exemple, pour supprimer l'utilisateur 
avec l'identifiant `xE7jOejl9FI` de la conversation avec l'identifiant `jMe43trzrdi` :

```bash
curl "https://play.dhis2.org/demo/api/33/messageConversations/jMe43trzrdi
```

Si la demande a abouti, le serveur répondra par un *200 OK*. Le 
corps de la réponse contient un objet XML ou JSON (selon l'en-tête "accepter" 
de la demande) contenant l'identifiant de l'utilisateur supprimé.

```json
{
  "removed" : ["xE7jOejl9FI"]
}
```

En cas d'échec, l'objet renvoyé contiendra un message qui 
décrit l'erreur.

```json
{
  "message" : "No user with uid: dMV6G0tPAEa"
}
```

Le lecteur observateur aura déjà remarqué que l'objet renvoyé en cas 
de succès dans notre exemple est en fait une liste d'identifiants (contenant une seule 
entrée). Ceci est dû au fait que le endpoint prend également en charge les suppressions par lots. La 
requête est faite à la même ressource *messageConversations* mais suit 
une sémantique légèrement différente. Pour les opérations par lots, les identifiants 
de conversation sont donnés en tant que paramètres de la chaîne de requête. L'exemple suivant supprime deux 
conversations de messages distinctes pour l'utilisateur actuel :

```bash
curl "https://play.dhis2.org/demo/api/messageConversations?mc=WzMRrCosqc0&mc=lxCjiigqrJm"
  -X DELETE -u admin:district
```

Si vous disposez d'autorisations suffisantes, vous pouvez supprimer des conversations au 
nom d'un autre utilisateur en indiquant un paramètre facultatif, l'identifiant de l'utilisateur.

```bash
curl "https://play.dhis2.org/demo/api/messageConversations?mc=WzMRrCosqc0&mc=lxCjiigqrJm&user=PhzytPW3g2J"
  -X DELETE -u admin:district
```

Comme indiqué, les suppressions par lots renvoient le même format de message que pour 
les opérations individuelles. La liste des objets supprimés reflétera les suppressions 
effectuées avec succès. Les demandes partiellement erronées (c'est-à-dire les identifiants inexistants) 
n'annuleront donc pas l'ensemble de l'opération par lots.

Les messages comportent une propriété booléenne *read* (lire). Cette propriété permet de savoir si un 
utilisateur a vu (ouvert) un message ou non. Dans un scénario d'application 
typique (par exemple, le portail web DHIS2), un message est marqué comme 
lu dès que l'utilisateur l'ouvre pour la première fois. Cependant, les utilisateurs peuvent vouloir 
gérer le statut « lu » ou « non lu » de leurs messages afin de garder une 
trace de certaines conversations.

Le marquage des messages comme lus ou non lus suit une sémantique similaire à celle des suppressions 
de lots, et supporte également les opérations par lots. Pour marquer des messages comme lus, 
nous envoyons un *POST* à la ressource `messageConversations/read` avec un 
corps de requête contenant un ou plusieurs identifiants de message. Pour marquer des messages comme 
non lus, nous envoyons une requête identique à la ressource `messageConversations/unread`. 
Comme pour les suppressions, un paramètre de requête optionnel *utilisateur* peut 
être fourni.

Marquons quelques messages comme lus par l'utilisateur actuel :

```bash
curl "https://play.dhis2.org/dev/api/messageConversations/read"
  -d '["ZrKML5WiyFm","Gc03smoTm6q"]' -X POST
  -H "Content-Type: application/json" -u admin:district
```

La réponse est un *200 OK* avec le contenu JSON suivant :

```json
{
  "markedRead": ["ZrKML5WiyFm", "Gc03smoTm6q"]
}
```

Vous pouvez ajouter des destinataires à une conversation de messages existante. La ressource est située à l'adresse suivante : 

    /api/33/messageConversations/id/recipients

Les options de cette ressource sont une liste d'utilisateurs, de groupes d'utilisateurs et 
d'unités d'organisation. La requête doit ressembler à ceci :

```json
{
  "users": [
    {
      "id": "OYLGMiazHtW"
    },
    {
      "id": "N3PZBUlN8vq"
    }
  ],
  "userGroups": [
    {
      "id": "DiszpKrYNg8"
    }
  ],
  "organisationUnits": [
    {
      "id": "DiszpKrYNg8"
    }
  ]
}

```

### Pièces jointes aux messages { #webapi_message_attachments } 

La création de messages avec des pièces jointes se fait en deux étapes : le téléchargement du 
fichier dans la ressource *attachments* (pièces jointes), puis inclure un ou plusieurs
pièces jointes lors de la création d'un nouveau message.

Une requête POST à la ressource *attachments* téléchargera le fichier sur le
serveur.

```
curl -F file=@attachment.png "https://play.dhis2.org/demo/api/messageConversations/attachments"
  -u admin:district
```

La demande renvoie un objet qui représente la pièce jointe. L'identifiant de
cet objet doit être utilisé lors de la création d'un message afin de lier la 
pièce jointe au message.

```json
{
  "created": "2018-07-20T16:54:18.210",
  "lastUpdated": "2018-07-20T16:54:18.212",
  "externalAccess": false,
  "publicAccess": "--------",
  "user": {
    "name": "John Traore",
    "created": "2013-04-18T17:15:08.407",
    "lastUpdated": "2018-03-09T23:06:54.512",
    "externalAccess": false,
    "displayName": "John Traore",
    "favorite": false,
    "id": "xE7jOejl9FI"
  },
  "lastUpdatedBy": {
    "id": "xE7jOejl9FI",
    "name": "John Traore"
  },
  "favorite": false,
  "id": "fTpI4GOmujz"
}
```

Lors de la création d'un nouveau message, les identifiants peuvent être transmis dans le contenu de la requête
pour lier les fichiers téléchargés au message en cours de création.

```json
{
  "subject": "Hey",
  "text": "How are you?",
  "users": [
    {
      "id": "OYLGMiazHtW"
    },
    {
      "id": "N3PZBUlN8vq"
    }
  ],
  "userGroups": [
    {
      "id": "ZoHNWQajIoe"
    }
  ],
  "organisationUnits": [
    {
      "id": "DiszpKrYNg8"
    }
  ],
  "attachments": [
    "fTpI4GOmujz",
    "h2ZsOxMFMfq"
  ]
}
```

Lorsque vous répondez à un message, les identifiants peuvent être transmis en tant que paramètre de la 
requête.

```bash
curl -d "Oui, l'ensemble des données sur la mortalité a été déclaré"
  "https://play.dhis2.org/demo/api/33/messageConversations/ZjHHSjyyeJ2?attachments=fTpI4GOmujz,h2ZsOxMFMfq"
  -H "Content-Type:text/plain" -u mobile:district -X POST
```

Une fois qu'un message avec une pièce jointe a été créé, il est possible d'accéder à la pièce jointe 
à l'aide d'une requête GET à l'URL suivante :

    /api/messageConversations/<mcv-id>/<msg-id>/attachments/<attachment-id>

Où <mcv-id>est l'ID de la *conversation du message*, <msg-id>est l'ID du *message* qui contient la pièce jointe et <attachment-id>est l'ID de la *pièce jointe* spécifique du message.

### Notifications des tickets et des résultats de validation { #webapi_messaging_tickets } 

Vous pouvez utiliser l'outil « écrire un feedback » pour créer des tickets et des messages.
La seule différence entre un ticket et un message est que vous pouvez donner 
un statut et une priorité à un ticket. Pour définir le statut :

    POST /api/messageConversations/<uid>/status

Pour définir la priorité :

    POST /api/messageConversations/<uid>/priority

Dans la version 2.29, les messages générés par l'analyse de validation peuvent désormais être utilisés dans 
les propriétés de statut et de priorité. Par défaut, les messages générés par 
l'analyse de validation héritent de la priorité de la règle de validation en 
question, ou de la plus grande importance si le message contient plusieurs 
règles.

Dans la version 2.30, les règles de validation peuvent être affectées à n'importe quel utilisateur, alors que les tickets 
doivent toujours être affectés à un utilisateur appartenant au groupe des destinataires du retour d'information du 
système.



Tableau : Liste des valeurs de statut et de priorité valides

| Statut | Priorité |
|---|---|
| OUVRIR | BAS |
| EN ATTENTE | MOYEN |
| INVALIDE | ÉLEVÉ |
| RÉSOLU ||

Vous pouvez également ajouter un message interne à un ticket, qui ne peut être vu que 
par les utilisateurs ayant les permissions « Gérer les tickets ». Pour créer une réponse 
interne, vous devez inclure le paramètre « interne » et le définir sur:

```bash
curl -d "Ceci est un message interne"
  "https://play.dhis2.org/demo/api/33/messageConversations/ZjHHSjyyeJ2?internal=true"
  -H "Content-Type:text/plain" -u admin:district -X POST
```




# Visualisations { #visualizations } 
## Tableaux de bord { #webapi_dashboard } 

Le tableau de bord est conçu pour vous donner un aperçu de plusieurs éléments 
analytiques tels que des cartes, des graphiques, des tableaux croisés dynamiques et des rapports qui, ensemble, 
peuvent fournir un aperçu complet de vos données. Les tableaux de bord sont disponibles 
dans l'API Web via la ressource *tableaux de bord*. Un tableau de bord contient une 
liste d'*éléments* de tableau de bord. Un élément peut représenter une ressource unique, comme 
un graphique, une carte ou un tableau de rapport, ou représenter une liste de liens vers des ressources 
analytiques, comme des rapports, des ressources, des rapports tabulaires et des utilisateurs. Un 
élément de tableau de bord peut contenir jusqu'à huit liens. En règle générale, un client de 
tableau de bord peut choisir de visualiser les éléments à objet unique directement dans une 
interface utilisateur, tout en rendant les éléments à objets multiples sous forme de liens 
cliquables.

    /api/tableau de bord

### Parcourir les tableaux de bord { #webapi_browsing_dashboards } 

Pour obtenir une liste de vos tableaux de bord avec des informations de base telles que 
l'identifiant, le nom et le lien au format JSON, vous pouvez envoyer une requête *GET* à 
l'URL suivante :

    /api/dashboards.json

La ressource Tableaux de bord fournit une liste de tableaux de bord. N'oubliez pas que 
l'objet tableau de bord est partagé et que la liste sera donc affectée par 
l'utilisateur actuellement authentifié. Vous pouvez obtenir plus d'informations sur un 
tableau de bord spécifique en suivant son lien, comme suit :

    /api/dashboards/vQFhmLJU5sK.json

Un tableau de bord contient des informations telles que le nom et la date de création, ainsi 
qu'un tableau d'éléments du tableau de bord. La réponse au format JSON ressemblera 
à cette réponse (certaines informations ont été supprimées par souci de 
concision).

```json
{
  "lastUpdated" : "2013-10-15T18:17:34.084+0000",
  "id": "vQFhmLJU5sK",
  "created": "2013-09-08T20:55:58.060+0000",
  "name": "Mother and Child Health",
  "href": "https://play.dhis2.org/demo/api/dashboards/vQFhmLJU5sK",
  "publicAccess": "--------",
  "restrictFilters": false,
  "externalAccess": false,
  "itemCount": 17,
  "displayName": "Mother and Child Health",
  "access": {
    "update": true,
    "externalize": true,
    "delete": true,
    "write": true,
    "read": true,
    "manage": true
  },
  "user": {
    "id": "xE7jOejl9FI",
    "name": "John Traore",
    "created": "2013-04-18T15:15:08.407+0000",
    "lastUpdated": "2014-12-05T03:50:04.148+0000",
    "href": "https://play.dhis2.org/demo/api/users/xE7jOejl9FI"
  },
  "dashboardItems": [{
    "id": "bu1IAnPFa9H",
    "created": "2013-09-09T12:12:58.095+0000",
    "lastUpdated": "2013-09-09T12:12:58.095+0000"
    }, {
    "id": "ppFEJmWWDa1",
    "created": "2013-09-10T13:57:02.480+0000",
    "lastUpdated": "2013-09-10T13:57:02.480+0000"
  }],
  "layout": {
    "spacing": {
      "column": 5,
      "row": 5
    },
    "columns": [{
      "index": 0,
      "span": 2
    }, {
      "index": 1,
      "span": 1
    }]
  },
  "userGroupAccesses": []
}
```

Il est possible d'obtenir une réponse plus personnalisée en spécifiant des champs 
particuliers dans la demande. Un exemple est fourni ci-dessous, qui renverrait des 
informations plus détaillées sur chaque objet du tableau de bord d'un utilisateur.

    /api/dashboards/vQFhmLJU5sK/?fields=:all,dashboardItems[:all]

### Rechercher des tableaux de bord { #webapi_searching_dasboards } 

When a user is building a dashboard it is convenient
to be able to search for various analytical resources using the
*/dashboards/q* resource. This resource lets you search for matches on
the name property of the following objects: visualizations, maps,
users, reports and resources. You can do a search by making a *GET*
request on the following resource URL pattern, where my-query should be
replaced by the preferred search query:

    /api/dashboards/q/my-query.json

Par exemple, cette requête :

    /api/dashboards/q/ma?count=6&maxCount=20&max=REPORT&max=MAP

La recherche portera sur les éléments suivants :

* Le nom de l'objet analytique contient la chaîne « ma »
* Renvoi jusqu'à 6 exemplaires de chaque type
* Pour les types RAPPORT et CARTE, il est possible de renvoyer jusqu'à 20 éléments.



Table: dashboards/q query parameters

| Paramètre de requête | Description | Type | Par défaut |
|---|---|---|---|
| compter | Le nombre d'éléments de chaque type à renvoyer | Entier positif | 6 |
| Nombre max. | Le nombre d'éléments de type max à renvoyer | Entier positif | 25 |
| max | Le type pour lequel il faut renvoyer le nombre maximal  | String [MAP&#124;USER&#124;REPORT&#124;RESOURCE&#124;VISUALIZATION] | N/A |

Les formats de réponse JSON et XML sont pris en charge. La réponse au format JSON 
contiendra les références aux ressources correspondantes et le nombre de 
correspondances trouvées au total et pour chaque type de ressource. Elle 
ressemblera à ceci :

```json
{
  "visualizations": [{
    "name": "ANC: ANC 3 Visits Cumulative Numbers",
    "id": "arf9OiyV7df",
    "type": "LINE"
  }, {
    "name": "ANC: 1st and 2rd trends Monthly",
    "id": "jkf6OiyV7el",
    "type": "PIVOT_TABLE"
  }],
  "maps": [{
    "name": "ANC: 1st visit at facility (fixed) 2013",
    "id": "YOEGBvxjAY0"
  }, {
    "name": "ANC: 3rd visit coverage 2014 by district",
    "id": "ytkZY3ChM6J"
  }],
  "reports": [{
    "name": "ANC: 1st Visit Cumulative Chart",
    "id": "Kvg1AhYHM8Q"
  }, {
    "name": "ANC: Coverages This Year",
    "id": "qYVNH1wkZR0"
  }],
  "searchCount": 8,
  "visualizationCount": 3,
  "mapCount": 2,
  "reportCount": 2,
  "userCount": 0,
  "patientTabularReportCount": 0,
  "resourceCount": 0
}
```

### Créer, mettre à jour et supprimer des tableaux de bords{ #webapi_creating_updating_removing_dashboards } 

La création, la mise à jour et la suppression des tableaux de bord suivent la sémantique REST 
standard. Pour créer un nouveau tableau de bord, vous pouvez faire une requête *POST* 
à la ressource `/api/dashboards`. Du point de vue du consommateur, 
il peut être pratique de créer d'abord un tableau de bord et d'y ajouter ensuite des 
éléments. Les formats JSON et XML sont supportés pour la charge de la requête. Pour 
créer un tableau de bord avec le nom « Mon tableau de bord », vous pouvez utiliser une 
charge JSON comme celle-ci :

    {
      "nom": "Mon tableau de bord"
    }

Pour mettre à jour, par exemple renommer, un tableau de bord, vous pouvez faire une 
demande *PUT* avec une charge similaire à la même ressource api/dashboards.

To remove a dashboard, you can make a *DELETE* (supprimer) request to the specific
dashboard resource similar to this:

    /api/dashboards/vQFhmLJU5sK

### Ajouter, déplacer et supprimer des éléments et du contenu du tableau de bord { #webapi_adding_moving_removing_dashboard_items } 

Pour ajouter des éléments au tableau de bord, un utilisateur peut utiliser la ressource
`/api/dashboards/<dashboard-id>/items/content`, où
<dashboard-id\> doit être remplacé par l'identifiant du tableau de bord 
concerné.La demande doit utiliser la méthode *POST*. La syntaxe de l'URL et les paramètres
sont décrits en détail dans le tableau suivant.



Tableau : Paramètres du contenu des éléments

| Paramètre de requête | Description | Options |
|---|---|---|
| type | Type de ressource à représenter par l'élément du tableau de bord | visualization &#124; map &#124; reportTable &#124; users &#124; reports &#124; resources &#124; patientTabularReports &#124; app |
| identifiant | Identifiant de la ressource à représenter par l'élément du tableau de bord | Identifiant de ressource |

L'URL d'une requête *POST* pour ajouter une visualisation à un tableau de bord spécifique pourrait ressembler à ceci, où la dernière valeur du paramètre de l'identifiant de la requête est l'identifiant de la ressource du graphique :

    /api/dashboards/vQFhmLJU5sK/items/content?type=visualization&id=LW0O27b7TdD

Lors de l'ajout d'une ressource de type carte, visualisation et application, l'API 
crée et ajoute un nouvel élément au tableau de bord. Lors de l'ajout d'une ressource 
de type utilisateurs, rapports et ressources, l'API tente 
d'ajouter la ressource à un élément de tableau de bord existant du même type. S'il n'existe 
aucun élément du même type ou aucun élément du même type auquel moins de huit ressources 
sont associées, l'API crée un nouvel élément de tableau de bord et 
y ajoute la ressource.

Pour déplacer un élément du tableau de bord vers une nouvelle position dans la liste des 
éléments du tableau de bord, un utilisateur peut envoyer une requête *POST* à 
l'URL suivante, où `<dashboard-id>` doit être remplacé par 
l'identifiant du tableau de bord, `<item-id>` doit être remplacé par 
l'identifiant de l'élément du tableau de bord et `<index>` doit être remplacé par la 
nouvelle position de l'élément dans le tableau de bord, où l'index est 
égal à zéro :

    /api/dashboards/<dashboard-id>/items/<item-id>/position/<index>

Pour supprimer complètement un élément d'un tableau de bord spécifique, un 
utilisateur peut envoyer une requête *DELETE* à l'URL de la ressource ci-dessous, où 
`<dashboard-id>` doit être remplacé par l'identifiant du tableau de bord 
et `<item-id>` par l'identifiant de l'élément du tableau de 
bord. Les identifiants des éléments du tableau de bord peuvent être récupérés par le biais 
d'une requête GET à l'URL de la ressource tableau de bord.

    /api/dashboards/<dashboard-id>/items/<item-id>

Pour supprimer une ressource de contenu spécifique dans un élément de tableau de bord, un utilisateur 
peut envoyer une requête *DELETE* à l'URL de ressource ci-dessous, où 
`<content-resource-id>` doit être remplacé par l'identifiant d'une 
ressource associée à l'élément de tableau de bord, par exemple l'identifiant 
d'un rapport ou d'un utilisateur. Par exemple, cela peut être utilisé pour supprimer un seul 
rapport d'un élément de tableau de bord de type rapports, plutôt que de supprimer 
complètement l'élément du tableau de bord :

    /api/dashboards/<dashboard-id>/items/<item-id>/content/<content-resource-id>

### Définir la présentation d'un tableau de bord { #webapi_dasboard_layout } 

Vous pouvez définir et enregistrer une présentation pour chaque tableau de bord. L'objet suivant est chargé de gérer ce paramètre.

    {
      "layout": {
        "spacing": {
          "column": 5,
          "row": 5
        },
        "columns": [{
          "index": 0,
          "span": 2
        }, {
          "index": 1,
          "span": 1
        }]
      }
    }

La définition de la présentation sera appliquée à tous les éléments du tableau de bord liés au tableau de bord donné, en respectant les attributs de présentation tels que l'espacement, les colonnes, la portée, etc. Vous trouverez ci-dessous une brève description de chaque attribut.

Tableau : Attributs de la présentation

| Attribut | Description | Type |
|---|---|---|
| présentation | Ceci est l'objet racine | Objet |
| l'espacement | Il définit l'espacement de certains composants de la présentation. Pour l'instant, il prend en charge les colonnes et les lignes. | Objet |
| colonnes | Il stocke des paramètres spécifiques liés aux colonnes ( pour l'instant, l'index et la portée) | Tableau d'objets |

## Visualisation { #webapi_visualization } 

L'API de visualisation est conçue pour aider les clients à interagir avec les graphiques et les tableaux croisés dynamiques/rapports. Les endpoints de cette API sont utilisés par l'application de visualisation des données qui permet la création, la configuration et la gestion des graphiques et des tableaux croisés dynamiques sur la base des définitions du client. L'idée principale est de permettre aux clients et aux utilisateurs de disposer d'une API unique et centralisée fournissant tous les types de graphiques et de tableaux croisés dynamiques ainsi que des paramètres et une configuration spécifiques pour chaque type de visualisation.

Cette API a été introduite pour unifier les API `charts` (graphiques) et `reportTables` (tableaux de rapports) et les remplacer entièrement par l'API `visualizations` (visualisations).

Un objet de visualisation est composé de nombreux attributs (certains sont liés aux graphiques et d'autres aux tableaux croisés dynamiques), mais les plus importants d'entre eux, qui reflètent les informations essentielles de l'objet, sont les suivants :*  "id" (identifiant) , "name" (nom) , "type" (type) , "dataDimensionItems" (éléments de données de dimensions) , "columns" (colonnes) , "rows" (lignes) et "filters" (filtres) .*

Le endpoint racine de l'API est `/api/visualizations`, et la liste des attributs et éléments actuels est décrite dans le tableau ci-dessous.



Tableau : Attributs de visualisation

| Champ | Description |
|---|---|
| identifiant | L'identifiant unique. |
| code | Un code personnalisé pour identifier la visualisation. |
| nom | Le nom de la visualisation |
| type | Le type de visualisation. Les types valides sont les suivants COLONNE, COLONNE_EMPILÉE, BARRE, BARRE_EMPILÉE, LIGNE, ZONE, CIRCULAIRE, RADAR, JAUGE, LIGNE_ANNÉE_SUR_ANNÉE, COLONNE_ANNÉE_SUR_ANNÉE, VALEUR_UNIQUE, TABLEAU_CROISÉ DYNAMIQUE. |
| titre | Un titre personnalisé. |
| sous-titre | Un sous-titre personnalisé. |
| Description | Définit une description personnalisée pour la visualisation. |
| créé | La date/heure de création de la visualisation. |
| date de début | La date de début utilisée lors du filtrage. |
| date de fin | La date de fin utilisée lors du filtrage. |
| sortOrder (ordre de tri) | L'ordre de tri de cette visualisation. Valeur entière. |
| utiisateur | Un objet représentant le créateur de la visualisation. |
| accès public | Définit les autorisations pour l'accès public. |
| displayDensity (afficher la densité) | La densité du texte affiché. |
| fontSize (taille de la police) | La taille de la police du texte. |
| fontStyle (style de police) | Styles de police personnalisés pour : visualizationTitle (titre de la visualisation), visualizationSubtitle (sous-titre de la visualisation), horizontalAxisTitle (titre de l'axe horizontal), verticalAxisTitle (titre de l'axe vertical), targetLineLabel (étiquette de la ligne cible), baseLineLabel (étiquette de la ligne de base), seriesAxisLabel (étiquette de l'axe de la série), categoryAxisLabel (étiquette de l'axe de la catégorie), légende. |
| périodes relatives | Un objet représentant les périodes relatives utilisées dans la requête analytique. |
| legendSet (ensemble de légende) | Un objet représentant les définitions de la légende. |
| legendDisplayStyle (style d'affichage de légende) | Le style d'affichage de la légende. Il peut être : FILL ( remplit) ou TEXT ( texte). |
| legendDisplayStrategy (stratégie d'affichage de la légende) | Le style d'affichage de la légende. Il peut être : FIXE ou BY_DATA_ITEM (par élément de données). |
| Type d'agrégation | Détermine la manière dont les valeurs du tableau croisé dynamique sont agrégées. Options valides : SUM (somme), AVERAGE (moyenne), AVERAGE_SUM_ORG_UNIT ( somme moyenne des unités d'organisation), LAST (dernier), LAST_AVERAGE_ORG_UNIT (dernière moyenne des unités d'organisation), FIRST (premier), FIRST_AVERAGE_ORG_UNIT (première moyenne des unités d'organisation), COUNT (nombre), STDDEV (écart type), VARIANCE (écart), MIN (minimum), MAX (maximum), NONE (aucun), CUSTOM (personnalisé) ou DEFAULT (par défaut). |
| regressionType (type de régression) | Un type de régression valide : NONE (aucun), LINEAR (linéaire), POLYNOMIAL (polynomial) ou LOESS. |
| targetLineValue (valeur de la ligne cible) | La ligne cible du graphique. Accepte un type Double. |
| targetLineLabel (étiquette de la ligne cible) | L'étiquette de la ligne cible du graphique. |
| rangeAxisLabel (Étiquette de l'axe de la plage ) | L'étiquette/titre de l'axe vertical (y) du graphique. |
| domainAxisLabel (étiquette de l'axe du domaine) | L'étiquette/titre de l'axe horizontal (x) du graphique. |
| rangeAxisMaxValue (Plage de l'axe de la valeur maximale) | La valeur maximale de l'axe du graphique. Les valeurs en dehors de la plage ne seront pas affichées. |
| rangeAxisMinValue (Plage de l'axe de la Valeur minimale) | La valeur minimale de l'axe du graphique. Les valeurs en dehors de la plage ne seront pas affichées. |
| rangeAxisSteps (Étapes de l'axe de la plage) | Le nombre de pas d'axe entre les valeurs minimale et maximale. |
| rangeAxisDecimals (Décimales de l'axe de la plage) | Le nombre de décimales pour les valeurs des axes. |
| baseLineValue (Valeur de la ligne de base) | Une valeur de référence du graphique. |
| baseLineLabel (étiquette de la ligne de base) | Une étiquette de ligne de base du graphique. |
| digitGroupSeparator (Séparateur de groupes de chiffres) | Séparateur de groupes de chiffres. Valeurs valides : VIRGULE, ESPACE ou AUCUN. |
| topLimit (Limite maximale) | La limite maximale fixée pour le tableau croisé dynamique. |
| Critères de mesure | Décrit les critères appliqués à cette mesure. |
| percentStackedValues (Pourcentage des valeurs empilées) | Utilise ou non des valeurs empilées. Plus susceptible d'être utilisé pour les graphiques. Valeur booléenne. |
| noSpaceBetweenColumns (Aucun espace entre les colonnes) | Afficher/masquer l'espace entre les colonnes. Valeur booléenne. |
| régression | Indique si la visualisation contient des colonnes de régression. Plus susceptible de s'appliquer aux rapports/croisés dynamiques. Valeur booléenne. |
| externalAccess (accès externe) | Indique si la visualisation est disponible en lecture seule externe. Ne s'applique que si aucun utilisateur n'est connecté. Valeur booléenne. |
| userOrganisationUnit (Unité d'organisation de l'utilisateur) | Indique si l'utilisateur dispose d'une unité d'organisation. Valeur booléenne. |
| userOrganisationUnitChildren (Unité d'organisation subordonnées de l'utilisateur ) | Indique si l'utilisateur a des unités d'organisation subordonnées. Valeur booléenne. |
| userOrganisationUnitGrandChildren (Unité d'organisation subordonnées de l'utilisateur ) | Indique si l'utilisateur a une unité d'organisation subordonnées. Valeur booléenne. |
| reportingParams (Paramètres de déclaration) | Objet utilisé pour définir des attributs booléens liés à la déclaration. |
| rowTotals (totaux des lignes) | Affiche (ou non) les totaux des lignes. Valeur booléenne. |
| colTotals (totaux des colonnes) | Affiche (ou non) les totaux des colonnes. Valeur booléenne. |
| rowSubTotals (Sous-totaux des lignes) | Affiche (ou non) les sous-totaux des lignes. Valeur booléenne. |
| colSubTotals (Sous-totaux des colonnes) | Affiche (ou non) les sous-totaux des colonnes. Valeur booléenne. |
| cumulativeValues (Valeurs cumulées) | Indique si la visualisation utilise des valeurs cumulées. Valeur booléenne. |
| hideEmptyColumns (cacher les colonnes vides) | Indique s'il faut masquer les colonnes sans données. Valeur booléenne. |
| hideEmptyRows (cacher les lignes vides) | Indique s'il faut masquer les lignes qui ne contiennent pas de données. Valeur booléenne.
 |
| fixColumnHeaders (fixer les en-têtes de colonne) | Maintient les en-têtes des colonnes fixes (ou non) dans un tableau croisé dynamique. Valeur booléenne. |
| fixRowHeaders (En-tête de ligne fixe) | Conserve les en-têtes des lignes fixes (ou non) dans un tableau croisé dynamique. Valeur booléenne. |
| completedOnly (Terminé uniquement) | Indique s'il faut masquer les colonnes sans données. Valeur booléenne. |
| skipRounding (ignorer l'arrondissement des valeurs) | Appliquer ou non l'arrondi. Valeur booléenne. |
| showDimensionLabels (afficher les étiquettes de dimension) | Affiche ou non les étiquettes des dimensions. Valeur booléenne. |
| hideTitle (masquer le titre) | Masque ou non le titre. Valeur booléenne. |
| hideSubtitle (masquer le sous-titre) | Masque ou non les sous-titres. Valeur booléenne. |
| hideLegend (masquer la légende) | Affiche/masque la légende. Très probablement utilisé pour les graphiques. Valeur booléenne. |
| showHierarchy (afficher la hiérarchie) | Affiche (ou non) les noms de la hiérarchie des unités d'organisation. Valeur booléenne. |
| showData (afficher les données) | Utilisé par les graphiques pour masquer ou non les données/valeurs dans le modèle présenté. Valeur booléenne. |
| lastUpdatedBy (Dernière mise à jour par) | L'objet qui représente l'utilisateur qui a appliqué les dernières modifications à la visualisation. |
| lastUpdated (dernière mise à jour) | Date/heure de la dernière modification de la visualisation. |
| favoris | Liste des utilisateurs qui ont marqué cet objet comme favori. |
| abonnés | Liste des utilisateurs ayant souscrit à cette visualisation. |
| traductions | Ensemble des traductions d'objets disponibles, normalement filtrées par le paramètre locale. |
| outlierAnalysis (Analyse des valeurs atypiques) | Objet chargé de conserver les paramètres relatifs à l'analyse des valeurs atypiques. L'attribut interne 'outlierMethod' (méthode des valeurs atypiques) prend en charge : IQR, STANDARD_Z_SCORE (SCORE Z STANDARD), MODIFIED_Z_SCORE (SCORE Z MODIFIÉ). L'attribut 'normalizationMethod' (méthode de normalisation) n'accepte pour l'instant que Y_RESIDUALS_LINEAR (RESIDUS LINEAIRE Y). |
| seriesKey (Clé de série) | Options de style pour l'affichage ou non de la clé de série. |
| légende | Options permettant d'appliquer ou non des couleurs de légende à la série de graphiques.
 |

### Récupération des visualisations { #webapi_visualization_retrieving_visualizations } 

Pour récupérer une liste de toutes les visualisations existantes, au format JSON, avec quelques informations de base (y compris l'identifiant, le nom et la pagination), vous pouvez faire une requête `GET` à l'URL ci-dessous. Vous devriez voir une liste de toutes les visualisations publiques/partagées ainsi que vos visualisations privées.

    GET /api/visualizations.json

Si vous souhaitez extraire la définition JSON d'une visualisation spécifique, vous pouvez ajouter son identifiant respectif à l'URL :

    GET /api/visualizations/hQxZGXqnLS9.json

La représentation suivante est un exemple de réponse au format JSON (par souci de concision, certaines informations ont été supprimées). Pour obtenir le schéma complet, veuillez utiliser `GET /api/schemas/visualization`.

```json
{
  "lastUpdated": "2020-02-06T11:57:09.678",
  "href": "http://my-domain/dhis/api/visualizations/hQxZGXqnLS9",
  "id": "hQxZGXqnLS9",
  "created": "2017-05-19T17:22:00.785",
  "name": "ANC: ANC 1st visits last 12 months cumulative values",
  "publicAccess": "rw------",
  "userOrganisationUnitChildren": false,
  "type": "LINE",
  "access": {},
  "reportingParams": {
    "parentOrganisationUnit": false,
    "reportingPeriod": false,
    "organisationUnit": false,
    "grandParentOrganisationUnit": false
  },
  "dataElementGroupSetDimensions": [],
  "attributeDimensions": [],
  "yearlySeries": [],
  "axes": [
    {
      "index": 0,
      "type": "RANGE",
      "title": {
        "textMode": "CUSTOM",
        "text": "Any Title"
      }
    }
  ],
  "filterDimensions": [
    "dx"
  ],
  "columns": [
    {
      "id": "ou"
    }
  ],
  "dataElementDimensions": [],
  "categoryDimensions": [],
  "rowDimensions": [
    "pe"
  ],
  "columnDimensions": [
    "ou"
  ],
  "dataDimensionItems": [
    {
      "dataDimensionItemType": "DATA_ELEMENT",
      "dataElement": {
        "id": "fbfJHSPpUQD"
      }
    }
  ],
  "filters": [
    {
      "id": "dx"
    }
  ],
  "rows": [
    {
      "id": "pe"
    }
  ]
}
```
Une réponse plus personnalisée peut être obtenue en spécifiant, dans l'URL, les champs que vous souhaitez extraire. Par exemple:

    GET /api/visualizations/hQxZGXqnLS9.json?fields=interpretations

renvoie

```json
{
  "interpretations": [
    {
      "id": "Lfr8I2RPU0C"
    },
    {
      "id": "JuwgdJlJPGb"
    },
    {
      "id": "WAoU2rSpyZp"
    }
  ]
}
```

Comme on peut le voir, le `GET` ci-dessus ne renverra que les interprétations liées à l'identifiant donné (dans ce cas `hQxZGXqnLS9`).

### Créer, mettre à jour et supprimer des visualisations { #webapi_visualization_add_update_remove_visualizations } 

Ces opérations suivent la sémantique standard *REST*. Une nouvelle visualisation peut être créée par une requête `POST` à la ressource `/api/visualisations` avec une charge JSON valide. Un exemple de charge pourrait être :

```json
{
  "columns": [
    {
      "dimension": "J5jldMd8OHv",
      "items": [
        {
          "name": "CHP",
          "id": "uYxK4wmcPqA",
          "displayName": "CHP",
          "displayShortName": "CHP",
          "dimensionItemType": "ORGANISATION_UNIT_GROUP"
        },
        {
          "name": "Hospital",
          "id": "tDZVQ1WtwpA",
          "displayName": "Hospital",
          "displayShortName": "Hospital",
          "dimensionItemType": "ORGANISATION_UNIT_GROUP"
        }
      ]
    }
  ],
  "rows": [
    {
      "dimension": "SooXFOUnciJ",
      "items": [
        {
          "name": "DOD",
          "id": "B0bjKC0szQX",
          "displayName": "DOD",
          "displayShortName": "DOD",
          "dimensionItemType": "CATEGORY_OPTION_GROUP"
        },
        {
          "name": "CDC",
          "id": "OK2Nr4wdfrZ",
          "displayName": "CDC",
          "displayShortName": "CDC",
          "dimensionItemType": "CATEGORY_OPTION_GROUP"
        }
      ]
    }
  ],
  "filters": [
    {
      "dimension": "ou",
      "items": [
        {
          "name": "Sierra Leone",
          "id": "ImspTQPwCqd",
          "displayName": "Sierra Leone",
          "displayShortName": "Sierra Leone",
          "dimensionItemType": "ORGANISATION_UNIT"
        },
        {
          "name": "LEVEL-1",
          "id": "LEVEL-H1KlN4QIauv",
          "displayName": "LEVEL-1"
        }
      ]
    }
  ],
  "name": "HIV Cases Monthly",
  "description": "Cases of HIV across the months",
  "category": "XY1vwCQskjX",
  "showDimensionLabels": true,
  "hideEmptyRows": true,
  "hideEmptyColumns": true,
  "skipRounding": true,
  "aggregationType": "SUM",
  "regressionType": "LINEAR",
  "type": "PIVOT_TABLE",
  "numberType": "VALUE",
  "measureCriteria": "Some criteria",
  "showHierarchy": true,
  "completedOnly": true,
  "displayDensity": "NORMAL",
  "fontSize": "NORMAL",
  "digitGroupSeparator": "SPACE",
  "legendDisplayStyle": "FILL",
  "legendDisplayStrategy": "FIXED",
  "hideEmptyRowItems": "BEFORE_FIRST_AFTER_LAST",
  "fixColumnHeaders": true,
  "fixRowHeaders": false,
  "regression": false,
  "cumulative": true,
  "sortOrder": 1,
  "topLimit": 2,
  "rowTotals": true,
  "colTotals": true,
  "hideTitle": true,
  "hideSubtitle": true,
  "hideLegend": true,
  "showData": true,
  "percentStackedValues": true,
  "noSpaceBetweenColumns": true,
  "rowSubTotals": true,
  "colSubTotals": true,
  "userOrgUnitType": "TEI_SEARCH",
  "externalAccess": false,
  "publicAccess": "--------",
  "reportingParams": {
    "reportingPeriod": true,
    "organisationUnit": true,
    "parentOrganisationUnit": true,
    "grandParentOrganisationUnit": true
  },
  "parentGraphMap": {
    "ImspTQPwCqd": ""
  },
  "access": {
    "read": true,
    "update": true,
    "externalize": true,
    "delete": false,
    "write": true,
    "manage": false
  },
  "optionalAxes": [
    {
      "dimensionalItem": "fbfJHSPpUQD",
      "axis": 1
    },
    {
      "dimensionalItem": "cYeuwXTCPkU",
      "axis": 2
    }
  ],
  "relativePeriods": {
    "thisYear": false,
    "quartersLastYear": true,
    "last52Weeks": false,
    "thisWeek": false,
    "lastMonth": false,
    "last14Days": false,
    "biMonthsThisYear": false,
    "monthsThisYear": false,
    "last2SixMonths": false,
    "yesterday": false,
    "thisQuarter": false,
    "last12Months": false,
    "last5FinancialYears": false,
    "thisSixMonth": false,
    "lastQuarter": false,
    "thisFinancialYear": false,
    "last4Weeks": false,
    "last3Months": false,
    "thisDay": false,
    "thisMonth": false,
    "last5Years": false,
    "last6BiMonths": false,
    "last4BiWeeks": false,
    "lastFinancialYear": false,
    "lastBiWeek": false,
    "weeksThisYear": false,
    "last6Months": false,
    "last3Days": false,
    "quartersThisYear": false,
    "monthsLastYear": false,
    "lastWeek": false,
    "last7Days": false,
    "thisBimonth": false,
    "lastBimonth": false,
    "lastSixMonth": false,
    "thisBiWeek": false,
    "lastYear": false,
    "last12Weeks": false,
    "last4Quarters": false
  },
  "user": {},
  "yearlySeries": [
    "THIS_YEAR"
  ],
  "userGroupAccesses": [
    {
      "access": "rwx-----",
      "userGroupUid": "ZoHNWQajIoe",
      "displayName": "Bo District M&E officers",
      "id": "ZoHNWQajIoe"
    }
  ],
  "userAccesses": [
    {
      "access": "--------",
      "displayName": "John Barnes",
      "id": "DXyJmlo9rge",
      "userUid": "DXyJmlo9rge"
    }
  ],
  "legendSet": {
    "name": "Death rate up",
    "id": "ham2eIDJ9k6",
    "legends": [
      {
        "startValue": 1,
        "endValue": 2,
        "color": "red",
        "image": "some-image"
      },
      {
        "startValue": 2,
        "endValue": 3,
        "color": "blue",
        "image": "other-image"
      }
    ]
  },
  "outlierAnalysis": {
    "enabled": true,
    "outlierMethod": "IQR",
    "thresholdFactor": 1.5,
    "normalizationMethod": "Y_RESIDUALS_LINEAR",
    "extremeLines": {
      "enabled": true,
      "value": 3.5
    }
  },
  "legend": {
    "strategy": "FIXED",
    "style": "FILL",
    "set": {
      "id": "fqs276KXCXi",
      "displayName": "ANC Coverage"
    },
    "showKey": false
  },
  "seriesKey": {
    "hidden": true,
    "label": {
      "fontStyle": {
        "textColor": "#cccddd"
      }
    }
  },
  "axes": [
    {
      "index": 0,
      "type": "RANGE",
      "label": {
        "fontStyle": {
          "textColor": "#cccddd"
        }
      },
      "title": {
        "text": "Range axis title",
        "textMode": "CUSTOM",
        "fontStyle": {
          "textColor": "#000000"
        }
      },
      "decimals": 1,
      "maxValue": 100,
      "minValue": 20,
      "steps": 5,
      "baseLine": {
        "value": 50,
        "title": {
          "text": "My baseline",
          "fontStyle": {
            "textColor": "#000000"
          }
        }
      },
      "targetLine": {
        "value": 80,
        "title": {
          "text": "My targetline",
          "fontStyle": {
            "textColor": "#cccddd"
          }
        }
      }
    },
    {
      "index": 1,
      "type": "DOMAIN",
      "label": {
        "fontStyle": {
          "textColor": "#000000"
        }
      },
      "title": {
        "text": "Domain axis title",
        "textMode": "CUSTOM",
        "fontStyle": {
          "textColor": "#cccddd"
        }
      }
    }
  ],
  "axes": [
    {
      "index": 0,
      "type": "RANGE",
      "label": {
        "fontStyle": {
          "textColor": "#cccddd"
        }
      },
      "title": {
        "text": "Range axis title",
        "fontStyle": {
          "textColor": "#000000"
        }
      },
      "decimals": 1,
      "maxValue": 100,
      "minValue": 20,
      "steps": 5,
      "baseLine": {
        "value": 50,
        "title": {
          "text": "My baseline",
          "fontStyle": {
            "textColor": "#000000"
          }
        }
      },
      "targetLine": {
        "value": 80,
        "title": {
          "text": "My targetline",
          "fontStyle": {
            "textColor": "#cccddd"
          }
        }
      }
    },
    {
      "index": 1,
      "type": "DOMAIN",
      "label": {
        "fontStyle": {
          "textColor": "#000000"
        }
      },
      "title": {
        "text": "Domain axis title",
        "fontStyle": {
          "textColor": "#cccddd"
        }
      }
    }
  ]
}
```

Pour mettre à jour une visualisation spécifique, vous pouvez envoyer une requête `PUT` à la même ressource `/api/visualisations` avec une charge similaire `PLUS` l'identifiant de la visualisation respective, par exemple :

    PUT /api/visualizations/hQxZGXqnLS9

Enfin, pour supprimer une visualisation existante, vous pouvez faire une requête `DELETE` en spécifiant l'identifiant de la visualisation à supprimer, comme indiqué :

    DELETE /api/visualizations/hQxZGXqnLS9

## Interprétations { #webapi_interpretations } 

For resources related to data analysis in DHIS2, such as visualizations, maps, event reports and event charts, you can write and share data interpretations. An interpretation can be a comment, question, observation or interpretation about a data report or visualization.

    /api/interpretations

### Lire les interprétations { #webapi_reading_interpretations } 

Pour lire les interprétations, nous allons interagir avec la ressource
`/api/interpretations`. Une requête GET typique utilisant le filtrage des champs
peut ressembler à ceci :

    GET /api/interpretations?fields=*,comments[id,text,user,mentions]

La réponse au format JSON pourrait ressembler à ce qui suit (les champs supplémentaires 
ont été omis par souci de concision) :

```json
{
  "interpretations": [
    {
      "id": "XSHiFlHAhhh",
      "created": "2013-05-30T10:24:06.181+0000",
      "text": "Data looks suspicious, could be a data entry mistake.",
      "type": "MAP",
      "likes": 2,
      "user": {
        "id": "uk7diLujYif"
      },
      "reportTable": {
        "id": "LcSxnfeBxyi"
      },
      "visualization": {
        "id": "LcSxnfeBxyi"
      }
    }, {
      "id": "kr4AnZmYL43",
      "created": "2013-05-29T14:47:13.081+0000",
      "text": "Delivery rates in Bo looks high.",
      "type": "VISUALIZATION",
      "likes": 3,
      "user": {
        "id": "uk7diLujYif"
      },
      "visualization": {
        "id": "HDEDqV3yv3H"
      },
      "mentions": [
        {
          "created": "2018-06-25T10:25:54.498",
          "username": "boateng"
        }
      ],
      "comments": [
        {
          "id": "iB4Etq8yTE6",
          "text": "This report indicates a surge.",
          "user": {
            "id": "B4XIfwOcGyI"
          }
        },
        {
          "id": "iB4Etq8yTE6",
          "text": "Likely caused by heavy rainfall.",
          "user": {
            "id": "B4XIfwOcGyI"
          }
        },
        {
          "id": "SIjkdENan8p",
          "text": "Have a look at this @boateng.",
          "user": {
            "id": "xE7jOejl9FI"
          },
          "mentions": [
            {
              "created": "2018-06-25T10:03:52.316",
              "username": "boateng"
            }
          ]
        }
      ]
    }
  ]
}
```



Tableau : Champs d'interprétation

| Champ | Description |
|---|---|
| identifiant | L'identifiant de l'interprétation. |
| créé | L'heure de création de l'interprétation. |
| type | The type of analytical object being interpreted. Valid options: VISUALIZATION, MAP, EVENT_REPORT, EVENT_CHART, DATASET_REPORT. |
| utiisateur | Associer à l'utilisateur qui a créé l'interprétation. |
| visualisation | Associer à la visualisation si le type est VISUALISATION |
| carte | Associer à la carte si le type est CARTE. |
| eventReport (rapport d'événement) | Associer au rapport d'événement le type RAPPORT_D'ÉVÉNEMENT. |
| graphique d'événements | Associer au graphique de l'événement si le type est GRAPHIQUE_D'ÉVÉNEMENT. |
| dataSet (ensemble de données) | Associer à l'ensemble de données si le type est RAPPORT_D'ENSEMBLE DE DONNÉES. |
| commentaires | Tableau de commentaires pour l'interprétation. Le champ texte contient le commentaire proprement dit. |
| mentions | Tableau des mentions pour l'interprétation. Une liste d'identifiants d'utilisateurs. |

Pour tous les objets analytiques, vous pouvez ajouter */ données* à l'URL pour récupérer 
les données associées à la ressource (par opposition aux métadonnées). Par 
exemple, en suivant le lien de la carte et en ajoutant / données, on peut 
récupérer une représentation PNG (image) de la carte thématique par l'intermédiaire de 
l'URL suivante :

    https://play.dhis2.org/demo/api/maps/bhmHJ4ZCdCd/data

Pour tous les objets analytiques, vous pouvez filtrer par *mentions*. Pour récupérer toutes 
les interprétations/commentaires où un utilisateur a été mentionné, vous avez 
trois options. Vous pouvez filtrer par les mentions d'interprétation (mentions 
dans la description de 
l'interprétation) :

    GET /api/interpretations?fields=*,comments[*]&filter=mentions.username:in:[boateng]

Vous pouvez filtrer les commentaires d'interprétation en fonction des mentions (mentions dans n'importe quel 
commentaire) :

    GET /api/interpretations?fields=*,comments[*]
      &filter=comments.mentions.username:in:[boateng]

Vous pouvez filtrer les interprétations qui contiennent les mentions soit
dans l'interprétation ou dans un commentaire ( OU jonction) :

    GET /api/interpretations?fields=*,comments[*]&filter=mentions:in:[boateng]

### Écrire les interprétations { #webapi_writing_interpretations } 

Lorsque vous écrivez des interprétations, vous fournissez le texte de l'interprétation dans 
le corps de la requête en utilisant une requête POST avec un contenu de type « text/plain ». 
Le modèle d'URL ressemble à ce qui suit, où {object-type} fait référence au 
type de l'objet interprété et {object-id} fait référence à 
l'identifiant de l'objet interprété.

    /api/interpretations/{object-type}/{object-id}

Valid options for object type are *visualization*, *map*,
*eventReport*, *eventChart* and *dataSetReport*.

Quelques exemples pertinents d'interprétations sont énumérés ci-dessous.

    /api/interpretations/visualization/hQxZGXqnLS9
    /api/interpretations/map/FwLHSMCejFu
    /api/interpretations/eventReport/xJmPLGP3Cde
    /api/interpretations/eventChart/nEzXB2M9YBz
    /api/interpretations/dataSetReport/tL7eCjmDIgM

A titre d'exemple, nous commencerons par écrire une interprétation pour la visualisation avec l'identifiant *EbRN2VIbPdV*. Pour écrire des interprétations de visualisation, nous allons interagir avec la ressource `/api/interpretations/visualization/{visualizationId}`.
L'interprétation sera le corps de la requête. Sur cette base, nous pouvons formuler 
la requête suivante en utilisant cURL :

```bash
curl -d "Cette visualisation montre un abandon important de la CPN 1-3" -X POST
  "https://play.dhis2.org/demo/api/interpretations/visualization/EbRN2VIbPdV" -H "Content-Type:text/plain" -u admin:district
```

Notez que la réponse fournit un en-tête de Localisation avec une valeur
indiquant l'emplacement de l'interprétation créée. Ceci est utile
du point de vue du client lorsque vous souhaitez ajouter un commentaire à
interprétation.

### Mise à jour et suppression d'interprétations { #webapi_updating_removing_interpretations } 

Pour mettre à jour une interprétation existante, vous pouvez utiliser une requête PUT dont le texte de l'interprétation est le corps de la requête, qui utilise le modèle d'URL suivant, dans lequel {id} fait référence à l'identifiant de l'interprétation :

    /api/interpretations/{id}

Sur cette base, nous pouvons utiliser curl pour mettre à jour l'interprétation :

```bash
curl -d "Cette visualisation montre un taux d'abandon élevé" -X PUT
  "https://play.dhis2.org/demo/api/interpretations/visualization/EV08iI1cJRA" -H "Content-Type:text/plain" -u admin:district
```

Vous pouvez utiliser le même modèle d'URL que ci-dessus en utilisant une requête DELETE pour
supprimer l'interprétation.

### Création des commentaires d'interprétation { #webapi_creating_interpretation_comments } 

Lorsque vous écrivez des commentaires sur les interprétations, vous fournissez le texte du commentaire
dans le corps de la requête en utilisant une requête POST avec le type de contenu
« text/plain ». Le modèle d'URL ressemble à ce qui suit, où
{interpretation-id} fait référence à l'identifiant de l'interprétation.

    /api/interpretations/{interpretation-id}/comments

Deuxièmement, nous allons rédiger un commentaire à l'interprétation que nous avons écrite dans 
l'exemple ci-dessus. En regardant la réponse de l'interprétation, vous verrez 
qu'un en-tête *Localisation* est renvoyé. Cet en-tête nous indique l'URL de 
l'interprétation nouvellement créée et, à partir de là, nous pouvons lire son 
identifiant. Cet identifiant est généré de manière aléatoire, vous devrez donc 
remplacer celui de la commande ci-dessous par le vôtre. Pour écrire un commentaire, 
nous pouvons interagir avec la ressource `/api/interpretations/{id}/comments` 
comme ceci :

```bash
curl -d "Une intervention est nécessaire" -X POST
  "https://play.dhis2.org/demo/api/interpretations/j8sjHLkK8uY/comments"
  -H "Content-Type:text/plain" -u admin:district
```

### Mise à jour et suppression des commentaires d'interprétation { #webapi_updating_removing_interpretation_comments } 

Pour mettre à jour un commentaire d'interprétation, vous pouvez utiliser une requête PUT où
le texte du commentaire est le corps de la requête en utilisant le modèle d'URL suivant :

    /api/interpretations/{interpretation-id}/comments/{comment-id}

Sur cette base, nous pouvons utiliser curl pour mettre à jour le commentaire :

```bash
curl "https://play.dhis2.org/demo/api/interpretations/j8sjHLkK8uY/comments/idAzzhVWvh2"
  -d "Je suis d'accord." -X PUT -H "Content-Type:text/plain" -u admin:district
```

Vous pouvez utiliser le même modèle d'URL que ci-dessus en utilisant une requête DELETE pour
supprimer le commentaire d'interprétation.

### Comment aimer les interprétations { #webapi_liking_interpretations } 

Pour aimer une interprétation, vous pouvez utiliser une requête POST vide vers la ressource
*like* :

    POST /api/interpretations/{id}/like

Un like sera ajouté pour l'utilisateur actuellement authentifié. Un utilisateur ne peut
aimer une interprétation qu'une seule fois.

Pour supprimer un « like » pour une interprétation, vous pouvez utiliser une requête DELETE à 
la même ressource que pour l'opération « like ».

Le statut d'une interprétation peut être visualisé en regardant la 
représentation ordinaire de l'API Web :

    GET /api/interpretations/{id}

Les informations relatives aux appréciations se trouvent dans le champ *likes* (aimé), qui représente le 
nombre d'appréciations, et dans le tableau *likedBy* (aimé par), qui énumère les utilisateurs qui 
ont aimé l'interprétation.

```json
{
  "id": "XSHiFlHAhhh",
  "text": "Data looks suspicious, could be a data entry mistake.",
  "type": "VISUALIZATION",
  "likes": 2,
  "likedBy": [
    {
      "id": "k7Hg12fJ2f1"
    },
    {
      "id": "gYhf26fFkjFS"
    }
  ]
}
```
## Les vues SQL { #webapi_sql_views } 

La ressource des vues SQL vous permet de créer et d'extraire l'ensemble des résultats
de vues SQL. Les vues SQL peuvent être exécutées directement dans la base de données
et restituer l'ensemble des résultats par l'intermédiaire de la ressource Web API.

    /api/sqlViews

Les vues SQL sont utiles dans la création de vues de données qui peuvent être plus facilement 
construites avec SQL qu'en combinant les multiples objets de l'API 
Web. Par exemple, supposons qu'il nous a été demandé de fournir une vue de 
toutes les unités d'organisation avec leur noms, les noms des parents, le niveau et le nom de l'unité 
d'organisation, ainsi que les coordonnées répertoriées dans la base de données. La vue 
pourrait ressembler à ceci :

```sql
SELECT ou.name as orgunit, par.name as parent, ou.coordinates, ous.level, oul.name from organisationunit ou
INNER JOIN _orgunitstructure ous ON ou.organisationunitid = ous.organisationunitid
INNER JOIN organisationunit par ON ou.parentid = par.organisationunitid
INNER JOIN orgunitlevel oul ON ous.level = oul.level
WHERE ou.coordinates is not null
ORDER BY oul.level, par.name, ou.name
```

Nous allons utiliser *curl* pour exécuter d'abord la vue sur le serveur de DHIS2. Il s'agit 
essentiellement d'un processus de matérialisation, qui garantit que les données les plus 
récentes sont disponibles dans la vue SQL lorsqu'elles sont récupérées 
sur le serveur. Vous pouvez d'abord rechercher la vue SQL dans la 
ressource api/sqlViews, puis faire un POST à l'aide de la commande suivante :

```bash
curl "https://play.dhis2.org/demo/api/sqlViews/dI68mLkP1wN/execute" -X POST -u admin:district
```

The next step in the process is the retrieval of the data.The basic
structure of the URL is as follows

    http://{server}/api/sqlViews/{id}/data(.csv)

The `{server}` parameter should be replaced with your own server. The
next part of the URL `/api/sqlViews/` should be appended with the
specific SQL view identifier. Append either `data` for XML data or
`data.csv` for comma delimited values. Support response formats are
json, xml, csv, xls, html and html+css. As an example, the following
command would retrieve XML data for the SQL view defined above.

```bash
curl "https://play.dhis2.org/demo/api/sqlViews/dI68mLkP1wN/data.csv" -u admin:district
```

Il existe trois types de vues SQL :

  - *Vues SQL:* Vues SQL standard.

  - *Vue SQL matérialisée:* Les vues SQL matérialisées, c'est-à-dire 
    écrites sur le disque, doivent être mises à jour pour refléter les modifications apportées aux 
    tables sous-jacentes. Elles prennent en charge les critères permettant de filtrer l'ensemble des résultats.

  - *Requêtes SQL:* Les requêtes SQL simples. Elles prennent en charge les variables en ligne pour 
    les requêtes personnalisées.

### Critère { #webapi_sql_view_criteria } 

Vous pouvez effectuer un filtrage simple sur les colonnes de l'ensemble de résultats en
ajoutant des paramètres de requête *critère* à l'URL, en utilisant les noms de colonnes
et les valeurs de filtrage séparées par les colonnes en tant que valeurs de paramètre, au 
format suivant :

    /api/sqlViews/{id}/data?criteria=col1:value1&criteria=col2:value2

As an example, to filter the SQL view result set above to only return
organisation units at level 4 you can use the following
    URL:

    https://play.dhis2.org/demo/api/sqlViews/dI68mLkP1wN/data.csv?criteria=level:4

### Les variables { #webapi_sql_view_variables } 

Les vues SQL supportent la substitution de variables. La substitution de variables n'est 
disponible que pour les vues SQL de type *requête*, c'est-à-dire les vues SQL qui ne sont pas 
créées dans la base de données mais simplement exécutées comme des requêtes SQL normales. 
Les variables peuvent être insérées directement dans la requête SQL et doivent être dans 
ce format :

    ${variable-key}

Par exemple, une requête SQL qui récupère tous les éléments de données d'un 
type de valeur donné, où le type de valeur est défini par une variable, peut ressembler 
à ceci :

    select * from dataelement where valuetype = '${valueType}';

Ces variables peuvent ensuite être fournies dans le cadre de l'URL lorsqu'elles sont demandées par l'intermédiaire de la ressource API Web *sqlViews*. Les variables peuvent être fournies dans le format suivant :

    /api/sqlViews/{id}/data?var=key1:value1&var=key2:value2

Un exemple de requête correspondant à l'exemple ci-dessus peut se présenter comme suit :

    /api/sqlViews/dI68mLkP1wN/data.json?var=valueType:int

La variable *valueType* sera remplacée par la valeur *int* et 
la requête renverra des éléments de données de type int.

Le paramètre variable ne doit contenir que des caractères alphanumériques. Les 
variables doivent contenir uniquement des caractères alphanumériques, des tirets, des traits 
de soulignement et des espaces.

Les vues SQL de type *query* prennent également en charge deux variables définies par le système qui permettent à la requête d'accéder à des informations sur l'utilisateur qui exécute la vue :

| variable | signifie |
| -------- | ----- |
| ${_current_user_id} | l'identifiant de l'utilisateur dans la base de données |
| ${_current_username} | le nom d'utilisateur de l'utilisateur |

Les valeurs de ces variables ne peuvent pas être fournies dans le cadre de l'URL. Elles sont toujours remplies d'informations sur l'utilisateur.

Par exemple, la vue SQL suivante de type *requête* affiche toutes les unités d'organisation affectées à l'utilisateur :

```sql
    select ou.path, ou.name
    from organisationunit ou_user
    join organisationunit ou on ou.path like ou_user.path || '%'
    join usermembership um on um.organisationunitid = ou_user.organisationunitid
    where um.userinfoid = ${_current_user_id}
    order by ou.path
```

### Filtrage { #webapi_sql_view_filtering } 

The SQL view api supports data filtering, equal to the [metadata object
filter](#webapi_metadata_object_filter). For a complete list of filter
operators you can look at the documentation for [metadata object
filter](#webapi_metadata_object_filter).

To use filters, simply add them as parameters at the end of the request
url for your SQL view like
    this:

    /api/sqlViews/w3UxFykyHFy/data.json?filter=orgunit_level:eq:2&filter=orgunit_name:ilike:bo

This request will return a result including org units with "bo" in the
name and which has org unit level 2.

The following example will return all org units with `orgunit_level` 2 or
4:

    /api/sqlViews/w3UxFykyHFy/data.json?filter=orgunit_level:in:[2,4]

And last, an example to return all org units that does not start with
"Bo"

    /api/sqlViews/w3UxFykyHFy/data.json?filter=orgunit_name:!like:Bo


## Éléments de données { #webapi_data_items } 

Ce endpoint permet à l'utilisateur d'interroger les données relatives à quelques éléments dimensionnels différents. Ces éléments sont les suivants : `INDICATEUR`, `ÉLÉMENT DE_DONNÉES`, `ENSEMBLE DE_DONNÉES`, `INDICATEUR DE_PROGRAMME`, `ÉLÉMENT DE_DONNÉES_DE PROGRAMME`, `ATTRIBUT DE_PROGRAMME`. Le endpoint ne supporte que les requêtes `GET` et, comme les autres endpoints, peut renvoyer des réponses au format JSON ou XML.

L'URL est `/api/dataItems` et comme vous pouvez l'imaginer, il est possible de récupérer différents objets à travers le même endpoint dans la même requête `GET`. Pour cette raison, certains attributs disponibles pour les requêtes seront différents en fonction de l'élément dimensionnel interrogé.

Pour comprendre la déclaration ci-dessus, examinons les exemples de requête suivants :

1) `GET /api/dataItems?filter=dimensionItemType:eq:DATA_ELEMENT&filter=valueType:eq:TEXT`
Dans cet exemple, le type d'élément `ELEMENT_DE DONNÉES` possède un attribut `Type de valeur` qui peut être utilisé dans la requête.

2) `GET /api/dataItems?pageSize=50&order=displayName:asc&filter=dimensionItemType:eq:PROGRAM_INDICATOR&filter=displayName:ilike:someName&filter=programId:eq:WSGAb5XwJ3Y`

Ici, le `L'INDICATEUR DE_PROGRAMME` permet de filtrer par `identifiant de programme`.

Ainsi, en se basant sur les exemples `1)` et `2)`, si vous essayez de filtrer un `ELEMENT DE_DONNEES` par `identifiant de programme` ou de filtrer un `INDICATEUR_DE PROGRAMME` par `type de valeur`, vous n'obtiendrez aucun résultat.
En d'autres termes, le filtre ne sera appliqué que si l'attribut existe réellement pour l'élément de données concerné.

Un autre aspect important à souligner est que ce endpoint ne suit PAS les mêmes normes de requête que d'autres endpoints existants, comme [ Filtre d'objet de métadonnées ](#webapi_metadata_object_filter) par exemple. En conséquence, il supporte un ensemble plus restreint de fonctionnalités et de requêtes.
La raison principale en est la nécessité d'interroger plusieurs éléments différents ayant des relations différentes, ce qui n'est pas possible en utilisant les composants de filtrage existants (utilisés par les autres endpoints).

### Possible endpoint responses { #webapi_data_items_possible_responses } 

Base on the `GET` request/query, a few different responses are possible. Below we are summarizing each possibility.

#### Results found (HTTP status code 200) { #results-found-http-status-code-200 } 

```
{
  "pager": {
    "page": 1,
    "pageCount": 27,
    "total": 1339,
    "pageSize": 50,
    "nextPage": "https://play.dhis2.org/dev/api/36/dataItems?page=2&filter=displayName:ilike:a&filter=id:eq:nomatch&rootJunction=OR&displayName:asc=&paging=true"
  },
  "dataItems": [
    {
      "simplifiedValueType": "TEXT",
      "displayName": "TB program Gender",
      "displayShortName": "TB prog. Gen.",
      "valueType": "TEXT",
      "name": "TB program Gender",
      "shortName": ""TB prog. Gen.",
      "id": "ur1Edk5Oe2n.cejWyOfXge6",
      "programId": "ur1Edk5Oe2n",
      "dimensionItemType": "PROGRAM_ATTRIBUTE"
    },
    ...
  ]
}
```

#### Results not found (HTTP status code 200) { #results-not-found-http-status-code-200 } 

```
{
  "pager": {
    "page": 1,
    "pageCount": 1,
    "total": 0,
    "pageSize": 50
  },
  "dataItems": []
}
```

#### Invalid query (HTTP status code 409) { #invalid-query-http-status-code-409 } 

```
{
  "httpStatus": "Conflict",
  "httpStatusCode": 409,
  "status": "ERROR",
  "message": "Unable to parse element `INVALID_TYPE` on filter `dimensionItemType`. The values available are: [INDICATOR, DATA_ELEMENT, DATA_ELEMENT_OPERAND, DATA_SET, PROGRAM_INDICATOR, PROGRAM_DATA_ELEMENT, PROGRAM_ATTRIBUTE]",
  "errorCode": "E2016"
}
```

#### Unhandled error (HTTP status code 500) { #unhandled-error-http-status-code-500 } 

```
{
  "httpStatus": "Internal Server Error",
  "httpStatusCode": 500,
  "status": "ERROR"
}
```

### Pagination { #webapi_data_items_pagination } 

This endpoint also supports pagination as a default option. If needed, you can disable pagination by adding `paging=false` to the `GET` request.
ie.: `/api/dataItems?filter=dimensionItemType:in:[INDICATOR]&paging=false`.

Voici un exemple de charge lorsque la pagination est activée. N'oubliez pas que la pagination est l'option par défaut et qu'il n'est pas nécessaire de la définir explicitement.

```
{
  "pager": {
    "page": 1,
    "pageCount": 20,
    "total": 969,
    "pageSize": 50,
    "nextPage": "https://play.dhis2.org/dev/api/dataItems?page=2&filter=dimensionItemType:in:[INDICATOR]"
  },
  "dataItems": [...]
}
```

> **Remarque**
>
> Pour les éléments auxquels un programme est associé, le nom du programme doit également être renvoyé en tant que partie du nom de l'élément (en tant que préfixe). La seule exception concerne les `Indicateurs de programme`. Nous ne préfixerons pas le nom de l'élément dans ce cas, afin de conserver le même comportement que les endpoints existants.
>
> Le endpoint /dataItems n'apportera que des éléments de données qui sont définis comme étant de type agrégable. La liste actuelle des types agrégeables valides est la suivante :
`TEXTE, TEXTE_LONG`, `LETTRE`, `BOLÉEN`, `VRAI_UNIQUEMENT`, `NOMBRE`, `INTERVALLE_UNITAIRE`, `POURCENTAGE`, `ENTIER`, `ENTIER_POSITIF`, `ENTIER_NÉGATIF`, `ENTIER_ZÉRO_OU_POSITIF`, `COORDONNÉE`.
>
> Même si la réponse renvoie plusieurs attributs différents, le filtrage ne peut être appliqué qu'à certains d'entre eux : `afficher le nom`, `le nom`, `le type de valeur`, `l'id`, `le type d'élément de dimension`, `l'id de programme`.
>
> L' `ordre` sera considéré comme invalide s'il est placé au-dessus de `nom` (ie. : ordre=*nom:asc*) et qu'un `filtre` est placé sur `afficher le nom` (ie. : filter=*afficher le nom:ilike:aNom*), et vice-versa.

### Attributs de la réponse { #webapi_data_items_response_attributes } 

Maintenant que nous avons une bonne idée des principales caractéristiques et de l'utilisation de ce endpoint , examinons la liste des attributs renvoyés dans la réponse.



Tableau : Attributs des éléments de données

| Champ | Description |
|---|---|
| identifiant | L'identifiant unique. |
| code | Un code personnalisé pour identifier l'élément dimensionnel. |
| nom | Le nom donné à l'élément. |
| Nom d'affichage | Le nom d'affichage défini. |
| nomAbrégé | Le nom court donné à l'élément. |
| displayShortName (afficher le Nom Court) | Le nom court d'affichage défini. |
| dimensionItemType (type de dimension de l'élément) | Type de dimension. Les types possibles sont les suivants : INDICATEUR, ÉLÉMENT DE_DONNÉES, TAUX DE_DÉCLARATION, INDICATEUR DE_PROGRAMME, ÉLÉMENT DE_DONNÉES_DU PROGRAMME, ATTRIBUT DE_PROGRAMME. |
| Type de valeur | Le type de valeur de l'élément (définition plus précise). Types possibles : TEXTE, TEXTE_LONG, LETTRE, BOOLÉEN, VRAI_UNIQUEMENT, UNITÉ_INTERVALLE, POURCENTAGE, ENTIER, ENTIER_POSITIF, ENTIER_NÉGATIF, ENTIER_ZÉRO_OU_POSITIF, COORDONNÉES. |
| simplifiedValueType (type de valeur simplifiée) | Représentation générique d'un type de valeur. Valeurs valides : NOMBRE, BOOLÉEN, DATE, RESSOURCE DE_FICHIER, COORDONNÉES, TEXTE |
| programId (Id du programme) | L'identifiant de programme associé. |

## Visualisation des représentations des ressources analytiques { #webapi_viewing_analytical_resource_representations } 

DHIS2 has several resources for data analysis. These resources include
*maps*, *visualizations*, *reports* and *documents*. By visiting these resources you will retrieve information about the resource. For instance, by navigating to `/api/visualizations/R0DVGvXDUNP` the response will contain the name, last date of modification and so on for the chart. To retrieve the analytical representation, for instance, a PNG representation of the visualization, you can append */data* to all these resources. For instance, by visiting `/api/visualizations/R0DVGvXDUNP/data` the system will return a PNG image of the visualization.



Tableau : Ressources analytiques

| Ressource | Description | URL des données | Représentations des ressources |
|---|---|---|---|
| graphiques d'événements | Graphiques d'évènements | /api/eventCharts/<identifier\>/data | png |
| cartes | Cartes | /api/maps/<identifier\>/data | png |
| visualisation | Tableaux croisés dynamiques et graphiques | /api/visualizations/<identifier\>/data | json &#124; jsonp &#124; html &#124; xml &#124; pdf &#124; xls &#124; csv | png |
| rapports | **SIG:**Le SIG intégré à DHIS 2 permet de présenter et d'analyser vos
données à l'aide de cartes géographiques à thèmes. Vous pouvez y
visualiser aussi bien les éléments de données que les indicateurs ; et
en supposant que vous disposiez des coordonnées de toutes vos unités
d’organisation, vous pouvez parcourir votre hiérarchie
organisationnelle et faire apparaitre des cartes pour tous les niveaux à
l’aide de polygones ou de points. Toutes les informations affichées sur
les cartes sont générées par DHIS 2 ; tout ce que vous devez faire est
de procéder à l’enregistrement des coordonnées de vos unités
d'organisation pour que les cartes deviennent disponibles. Voir le
chapitre spécifique qui traite du SIG pour obtenir plus de détails. | /api/reports/<identifier\>/data | pdf &#124; xls &#124; html |
| documents | Ressources | /api/documents/<identifier\>/data | <follows document\> |

Le contenu des données des représentations analytiques peut être modifié en
fournissant un paramètre de requête *date*. Pour cela, il faut que la ressource analytique
soit configurée en périodes relatives pour la dimension période.



Tableau : Paramètres de requête de données

| Paramètre de requête | Valeur | Description |
|---|---|---|
| date | Les dates doivent être au format aaaa-MM-jj | Base pour les périodes relatives dans le rapport (exige des périodes relatives) |



Tableau : Paramètres de requête pour les pngs / types d'images (visualisations, cartes)

| Paramètre de requête | Description |
|---|---|
| largeur | Largeur de l'image en pixels |
| taille | Taille de l'image en pixels |

Quelques exemples d'URL valides pour la récupération de diverses représentations analytiques
sont énumérés ci-dessous.

    /api/visualization/R0DVGvXDUNP/data
    /api/visualization/R0DVGvXDUNP/data?date=2013-06-01

    /api/visualization/jIISuEWxmoI/data.html
    /api/visualization/jIISuEWxmoI/data.html?date=2013-01-01
    /api/visualization/FPmvWs7bn2P/data.xls
    /api/visualization/FPmvWs7bn2P/data.pdf

    /api/maps/DHE98Gsynpr/data
    /api/maps/DHE98Gsynpr/data?date=2013-07-01

    /api/reports/OeJsA6K1Otx/data.pdf
    /api/reports/OeJsA6K1Otx/data.pdf?date=2014-01-01

## Plugins { #webapi_plugins } 

DHIS2 comes with plugins which enable you to embed live data directly in
your web portal or web site. Currently, plugins exist for charts, maps
and pivot tables.

Please be aware that all of the code examples in this section are for
demonstration purposes only. They should not be used as is in
production systems. To make things simple, the credentials
(admin/district) have been embedded into the scripts. In a real scenario,
you should never expose credentials in javascript as it opens a
vulnerability to the application. In addition, you would create a user
with more minimal privileges rather than make use of a superuser to
fetch resources for your portal.

It is possible to workaround exposing the credentials by using a reverse
proxy such as nginx or apache2. The proxy can be configured to inject
the required Authorization header for only the endpoints that you wish
to make public. There is some documentation to get you started in the
section of the implementers manual which describes [reverse
proxy](https://docs.dhis2.org/master/en/implementer/html/install_reverse_proxy_configuration.html#install_making_resources_available_with_nginx)
configuration.

### Embedding pivot tables with the Pivot Table plug-in { #webapi_pivot_table_plugin } 

In this example, we will see how we can embed good-looking, light-weight
html pivot tables with data served from a DHIS2 back-end into a Web
page. To accomplish this we will use the Pivot table plug-in. The
plug-in is written in Javascript and depends on the jQuery library only.
A complete working example can be found at
<http://play.dhis2.org/portal/table.html>. Open the page in a web
browser and view the source to see how it is set up.

We start by having a look at what the complete html file could look
like. This setup puts two tables in our web page. The first one is
referring to an existing table. The second is configured inline.

```html
<!DOCTYPE html>
<html>
<head>
  <script src="https://dhis2-cdn.org/v227/plugin/jquery-2.2.4.min.js"></script>
  <script src="https://dhis2-cdn.org/v227/plugin/reporttable.js"></script>

  <script>
    reportTablePlugin.url = "https://play.dhis2.org/demo";
    reportTablePlugin.username = "admin";
    reportTablePlugin.password = "district";
    reportTablePlugin.loadingIndicator = true;

    // Referring to an existing table through the id parameter, render to "report1" div

    var r1 = { el: "report1", id: "R0DVGvXDUNP" };

    // Table configuration, render to "report2" div

    var r2 = {
      el: "report2",
      columns: [
        {dimension: "dx", items: [{id: "YtbsuPPo010"}, {id: "l6byfWFUGaP"}]}
      ],
      rows: [
        {dimension: "pe", items: [{id: "LAST_12_MONTHS"}]}
      ],
      filters: [
        {dimension: "ou", items: [{id: "USER_ORGUNIT"}]}
      ],

      // All following properties are optional
      title: "My custom title",
      showColTotals: false,
      showRowTotals: false,
      showColSubTotals: false,
      showRowSubTotals: false,
      showDimensionLabels: false,
      hideEmptyRows: true,
      skipRounding: true,
      aggregationType: "AVERAGE",
      showHierarchy: true,
      completedOnly: true,
      displayDensity: "COMFORTABLE",
      fontSize: "SMALL",
      digitGroupSeparator: "COMMA",
      legendSet: {id: "fqs276KXCXi"}
    };

    reportTablePlugin.load([r1, r2]);
  </script>
</head>

<body>
  <div id="report1"></div>
  <div id="report2"></div>
</body>
</html>
```

Two files are included in the header section of the HTML document. The
first file is the jQuery JavaScript library (we use the DHIS2 content
delivery network in this case). The second file is the Pivot table
plug-in. Make sure the path is pointing to your DHIS2 server
installation.

Now let us have a look at the various options for the Pivot tables. One
property is required: *el* (please refer to the table below). Now, if
you want to refer to pre-defined tables already made inside DHIS2 it is
sufficient to provide the additional *id* parameter. If you instead want
to configure a pivot table dynamically you should omit the id parameter
and provide data dimensions inside a *columns* array, a *rows* array and
optionally a *filters* array instead.

A data dimension is defined as an object with a text property called
*dimension*. This property accepts the following values: *dx*
(indicator, data element, data element operand, data set, event data
item and program indicator), *pe* (period), *ou* (organisation unit) or
the id of any organisation unit group set or data element group set (can
be found in the web api). The data dimension also has an array property
called *items* which accepts objects with an *id* property.

To sum up, if you want to have e.g. "ANC 1 Coverage", "ANC 2 Coverage"
and "ANC 3 Coverage" on the columns in your table you can make the
following *columns* config:

```json
columns: [{
  dimension: "dx",
  items: [
    {id: "Uvn6LCg7dVU"}, // the id of ANC 1 Coverage
    {id: "OdiHJayrsKo"}, // the id of ANC 2 Coverage
    {id: "sB79w2hiLp8"}  // the id of ANC 3 Coverage
  ]
}]
```



Table: Pivot table plug-in configuration

| Param | Type | Obligatoire | Options (par défaut en premier) | Description |
|---|---|---|---|---|
| url | chaîne | Oui || Base URL of the DHIS2 server |
| Nom d'utilisateur | chaîne | Yes (if cross-domain) || Used for authentication if the server is running on a different domain |
| password | chaîne | Yes (if cross-domain) || Used for authentication if the server is running on a different domain |
| loadingIndicator | booléen | Non || Whether to show a loading indicator before the table appears |



Table: Pivot table configuration

| Param | Type | Obligatoire | Options (par défaut en premier) | Description |
|---|---|---|---|---|
| el | chaîne | Oui || Identifier of the HTML element to render the table in your web page |
| identifiant | chaîne | Non || Identifier of a pre-defined table (favorite) in DHIS2 |
| colonnes | array | Yes (if no id provided) || Data dimensions to include in table as columns |
| lignes | array | Yes (if no id provided) || Data dimensions to include in table as rows |
| filtre | array | Non || Data dimensions to include in table as filters |
| titre | chaîne | Non || Show a custom title above the table |
| showColTotals | booléen | Non | vrai &#124; faux | Whether to display totals for columns |
| showRowTotals | booléen | Non | vrai &#124; faux | Whether to display totals for rows |
| showColSubTotals | booléen | Non | vrai &#124; faux | Whether to display sub-totals for columns |
| showRowSubTotals | booléen | Non | vrai &#124; faux | Whether to display sub-totals for rows |
| showDimensionLabels (afficher les étiquettes de dimension) | booléen | Non | vrai &#124; faux | Whether to display the name of the dimension top-left in the table |
| hideEmptyRows (cacher les lignes vides) | booléen | Non | faux &#124; vrai | Whether to hide rows with no data |
| skipRounding (ignorer l'arrondissement des valeurs) | booléen | Non | faux &#124; vrai | Whether to skip rounding of data values |
| completedOnly (Terminé uniquement) | booléen | Non | faux &#124; vrai | Whether to only show completed events |
| showHierarchy (afficher la hiérarchie) | booléen | Non | faux &#124; vrai | Whether to extend orgunit names with the name of all anchestors |
| Type d'agrégation | chaîne | Non | "SUM" &#124;"AVERAGE" &#124; "AVERAGE_SUM_ORG_UNIT"&#124;"LAST"&#124;"LAST_AVERAGE_ORG_UNIT"&#124; "COUNT" &#124; "STDDEV" &#124; "VARIANCE" &#124; "MIN" &#124; "MAX" | Override the data element's default aggregation type |
| displayDensity (afficher la densité) | chaîne | Non | "NORMAL" &#124; "COMFORTABLE" &#124; "COMPACT" | The amount of space inside table cells |
| fontSize (taille de la police) | chaîne | Non | "NORMAL" &#124; "LARGE" &#124; "SMALL" | Table font size |
| digitGroupSeparator (Séparateur de groupes de chiffres) | chaîne | Non | "SPACE" &#124; "COMMA" &#124; "NONE" | How values are formatted: 1 000 &#124; 1,000 &#124; 1000 |
| legendSet (ensemble de légende) | object | Non || Color the values in the table according to the legend set |
| userOrgUnit (unité d'organisation d'utilisateur) | string / array | Non || Organisation unit identifiers, overrides organisation units associated with curretn user, single or array |
| relativePeriodDate (Date de la période relative) | chaîne | Non || Identifiant de date, par exemple : "2016-01-01". Il remplace la date de début de la période relative |

### Embedding charts with the Visualizer chart plug-in { #webapi_chart_plugin } 

In this example, we will see how we can embed good-looking Highcharts
charts (<http://www.highcharts.com>) with data served from a DHIS2
back-end into a Web page. To accomplish this we will use the DHIS2
Visualizer plug-in. The plug-in is written in JavaScript and depends on
the jQuery library. A complete working example can be found at
<http://play.dhis2.org/portal/chart.html>. Open the page in a web
browser and view the source to see how it is set up.

We start by having a look at what the complete html file could look
like. This setup puts two charts on our web page. The first one is
referring to an existing chart. The second is configured inline.

```html
<!DOCTYPE html>
<html>
<head>
  <script src="https://dhis2-cdn.org/v227/plugin/jquery-2.2.4.min.js"></script>
  <script src="https://dhis2-cdn.org/v227/plugin/chart.js"></script>

  <script>
    chartPlugin.url = "https://play.dhis2.org/demo";
    chartPlugin.username = "admin";
    chartPlugin.password = "district";
    chartPlugin.loadingIndicator = true;

    // Referring to an existing chart through the id parameter, render to "report1" div

    var r1 = { el: "report1", id: "R0DVGvXDUNP" };

    // Chart configuration, render to "report2" div

    var r2 = {
      el: "report2",
      columns: [
        {dimension: "dx", items: [{id: "YtbsuPPo010"}, {id: "l6byfWFUGaP"}]}
      ],
      rows: [
        {dimension: "pe", items: [{id: "LAST_12_MONTHS"}]}
      ],
      filters: [
        {dimension: "ou", items: [{id: "USER_ORGUNIT"}]}
      ],

      // All following properties are optional
      title: "Custom title",
      type: "line",
      showValues: false,
      hideEmptyRows: true,
      regressionType: "LINEAR",
      completedOnly: true,
      targetLineValue: 100,
      targetLineTitle: "My target line title",
      baseLineValue: 20,
      baseLineTitle: "My base line title",
      aggregationType: "AVERAGE",
      rangeAxisMaxValue: 100,
      rangeAxisMinValue: 20,
      rangeAxisSteps: 5,
      rangeAxisDecimals: 2,
      rangeAxisTitle: "My range axis title",
      domainAxisTitle: "My domain axis title",
      hideLegend: true
    };

    // Render the charts

    chartPlugin.load(r1, r2);
  </script>
</head>

<body>
  <div id="report1"></div>
  <div id="report2"></div>
</body>
</html>
```

Two files are included in the header section of the HTML document. The
first file is the jQuery JavaScript library (we use the DHIS2 content
delivery network in this case). The second file is the Visualizer chart
plug-in. Make sure the path is pointing to your DHIS2 server
installation.

Now let us have a look at the various options for the charts. One
property is required: *el* (please refer to the table below). Now, if
you want to refer to pre-defined charts already made inside DHIS2 it is
sufficient to provide the additional *id* parameter. If you instead want
to configure a chart dynamically you should omit the id parameter and
provide data dimensions inside a *columns* array, a *rows* array and
optionally a *filters* array instead.

A data dimension is defined as an object with a text property called
*dimension*. This property accepts the following values: *dx*
(indicator, data element, data element operand, data set, event data
item and program indicator), *pe* (period), *ou* (organisation unit) or
the id of any organisation unit group set or data element group set (can
be found in the web api). The data dimension also has an array property
called *items* which accepts objects with an *id* property.

To sum up, if you want to have e.g. "ANC 1 Coverage", "ANC 2 Coverage"
and "ANC 3 Coverage" on the columns in your chart you can make the
following *columns* config:

```json
columns: [{
  dimension: "dx",
  items: [
    {id: "Uvn6LCg7dVU"}, // the id of ANC 1 Coverage
    {id: "OdiHJayrsKo"}, // the id of ANC 2 Coverage
    {id: "sB79w2hiLp8"}  // the id of ANC 3 Coverage
  ]
}]
```



Table: Chart plug-in configuration

| Param | Type | Obligatoire | Options (par défaut en premier) | Description |
|---|---|---|---|---|
| url | chaîne | Oui || Base URL of the DHIS2 server |
| Nom d'utilisateur | chaîne | Yes (if cross-domain) || Used for authentication if the server is running on a different domain |
| password | chaîne | Yes (if cross-domain) || Used for authentication if the server is running on a different domain |
| loadingIndicator | booléen | Non || Whether to show a loading indicator before the chart appears |



Table: Chart configuration

| Param | Type | Obligatoire | Options (par défaut en premier) | Description |
|---|---|---|---|---|
| el | chaîne | Oui || Identifier of the HTML element to render the chart in your web page |
| identifiant | chaîne | Non || Identifier of a pre-defined chart (favorite) in DHIS |
| type | chaîne | Non | column &#124; stackedcolumn &#124; bar &#124; stackedbar &#124; line &#124; area &#124; pie &#124; radar &#124; gauge | Chart type |
| colonnes | array | Yes (if no id provided) || Data dimensions to include in chart as series |
| lignes | array | Yes (if no id provided) || Data dimensions to include in chart as category |
| filtre | array | Non || Data dimensions to include in chart as filters |
| titre | chaîne | Non || Show a custom title above the chart |
| showValues | booléen | Non | faux &#124; vrai | Whether to display data values on the chart |
| hideEmptyRows (cacher les lignes vides) | booléen | Non | faux &#124; vrai | Whether to hide empty categories |
| completedOnly (Terminé uniquement) | booléen | Non | faux &#124; vrai | Whether to only show completed events |
| regressionType (type de régression) | chaîne | Non | "NONE" &#124; "LINEAR" | Show trend lines |
| targetLineValue (valeur de la ligne cible) | nombre | Non || Display a target line with this value |
| targetLineTitle | chaîne | Non || Display a title on the target line (does not apply without a target line value) |
| baseLineValue (Valeur de la ligne de base) | nombre | Non || Display a base line with this value |
| baseLineTitle | chaîne | Non || Display a title on the base line (does not apply without a base line value) |
| rangeAxisTitle | nombre | Non || Title to be displayed along the range axis |
| rangeAxisMaxValue (Plage de l'axe de la valeur maximale) | nombre | Non || Max value for the range axis to display |
| rangeAxisMinValue (Plage de l'axe de la Valeur minimale) | nombre | Non || Min value for the range axis to display |
| rangeAxisSteps (Étapes de l'axe de la plage) | nombre | Non || Number of steps for the range axis to display |
| rangeAxisDecimals (Décimales de l'axe de la plage) | nombre | Non || Bumber of decimals for the range axis to display |
| domainAxisTitle | nombre | Non || Title to be displayed along the domain axis |
| Type d'agrégation | chaîne | Non | "SUM" &#124;"AVERAGE" &#124; "AVERAGE_SUM_ORG_UNIT"&#124;"LAST"&#124;"LAST_AVERAGE_ORG_UNIT"&#124; "COUNT" &#124; "STDDEV" &#124; "VARIANCE" &#124; "MIN" &#124; "MAX" | Override the data element's default aggregation type |
| hideLegend (masquer la légende) | booléen | Non | faux &#124; vrai | Whether to hide the series legend |
| hideTitle (masquer le titre) | booléen | Non | faux &#124; vrai | Whether to hide the chart title |
| userOrgUnit (unité d'organisation d'utilisateur) | string / array | Non || Organisation unit identifiers, overrides organisation units associated with curretn user, single or array |
| relativePeriodDate (Date de la période relative) | chaîne | Non || Identifiant de date, par exemple : "2016-01-01". Il remplace la date de début de la période relative |

### Embedding maps with the GIS map plug-in { #webapi_map_plugin } 

In this example we will see how we can embed maps with data served from
a DHIS2 back-end into a Web page. To accomplish this we will use the GIS
map plug-in. The plug-in is written in JavaScript and depends on the Ext
JS library only. A complete working example can be found at
<http://play.dhis2.org/portal/map.html>. Open the page in a web browser
and view the source to see how it is set up.

We start by having a look at what the complete html file could look
like. This setup puts two maps on our web page. The first one is
referring to an existing map. The second is configured inline.

```html
<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" type="text/css" href="http://dhis2-cdn.org/v215/ext/resources/css/ext-plugin-gray.css" />
  <script src="http://dhis2-cdn.org/v215/ext/ext-all.js"></script>
  <script src="https://maps.google.com/maps/api/js?sensor=false"></script>
  <script src="http://dhis2-cdn.org/v215/openlayers/OpenLayers.js"></script>
  <script src="http://dhis2-cdn.org/v215/plugin/map.js"></script>

  <script>
    var base = "https://play.dhis2.org/demo";

    // Login - if OK, call the setLinks function

    Ext.onReady( function() {
      Ext.Ajax.request({
        url: base + "dhis-web-commons-security/login.action",
        method: "POST",
        params: { j_username: "portal", j_password: "Portal123" },
        success: setLinks
      });
    });

    function setLinks() {
      DHIS.getMap({ url: base, el: "map1", id: "ytkZY3ChM6J" });

      DHIS.getMap({
        url: base,
        el: "map2",
        mapViews: [{
          columns: [{dimension: "in", items: [{id: "Uvn6LCg7dVU"}]}], // data
          rows: [{dimension: "ou", items: [{id: "LEVEL-3"}, {id: "ImspTQPwCqd"}]}], // organisation units,
          filters: [{dimension: "pe", items: [{id: "LAST_3_MONTHS"}]}], // period
          // All following options are optional
          classes: 7,
          colorLow: "02079c",
          colorHigh: "e5ecff",
          opacity: 0.9,
          legendSet: {id: "fqs276KXCXi"}
        }]
      });
    }
  </script>
</head>

<body>
  <div id="map1"></div>
  <div id="map2"></div>
</body>
</html>
```

Four files and Google Maps are included in the header section of the
HTML document. The first two files are the Ext JS JavaScript library (we
use the DHIS2 content delivery network in this case) and its stylesheet.
The third file is the OpenLayers JavaScript mapping framework
(<http://openlayers.org>) and finally we include the GIS map plug-in.
Make sure the path is pointing to your DHIS2 server
    installation.

    <link rel="stylesheet" type="text/css" href="http://dhis2-cdn.org/v215/ext/resources/css/ext-plugin-gray.css" />
    <script src="http://dhis2-cdn.org/v215/ext/ext-all.js"></script>
    <script src="https://maps.google.com/maps/api/js?sensor=false"></script>
    <script src="http://dhis2-cdn.org/v215/openlayers/OpenLayers.js"></script>
    <script src="http://dhis2-cdn.org/v215/plugin/map.js"></script>

To authenticate with the DHIS2 server we use the same approach as in the
previous section. In the header of the HTML document we include the
following Javascript inside a script element. The *setLinks* method will
be implemented later. Make sure the *base* variable is pointing to your
DHIS2 installation.

    Ext.onReady( function() {
      Ext.Ajax.request({
        url: base + "dhis-web-commons-security/login.action",
        method: "POST",
        params: { j_username: "portal", j_password: "Portal123" },
        success: setLinks
      });
    });

Now let us have a look at the various options for the GIS plug-in. Two
properties are required: *el* and *url* (please refer to the table
below). Now, if you want to refer to pre-defined maps already made in
the DHIS2 GIS it is sufficient to provide the additional *id* parameter.
If you instead want to configure a map dynamically you should omit the id
parameter and provide *mapViews* (layers) instead. They should be
configured with data dimensions inside a *columns* array, a *rows* array
and optionally a *filters* array instead.

A data dimension is defined as an object with a text property called
*dimension*. This property accepts the following values: *in*
(indicator), *de* (data element), *ds* (data set), *dc* (data element
operand), *pe* (period), *ou* (organisation unit) or the id of any
organisation unit group set or data element group set (can be found in
the web api). The data dimension also has an array property called
*items* which accepts objects with an *id* property.

To sum up, if you want to have a layer with e.g. "ANC 1 Coverage" in
your map you can make the following *columns* config:

```json
columns: [{
  dimension: "in", // could be "in", "de", "ds", "dc", "pe", "ou" or any dimension id
  items: [{id: "Uvn6LCg7dVU"}], // the id of ANC 1 Coverage
}]
```



Table: GIS map plug-in configuration

| Param | Type | Obligatoire | Options (par défaut en premier) | Description |
|---|---|---|---|---|
| el | chaîne | Oui || Identifier of the HTML element to render the map in your web page |
| url | chaîne | Oui || Base URL of the DHIS2 server |
| identifiant | chaîne | Non || Identifier of a pre-defined map (favorite) in DHIS |
| baseLayer | string/boolean | Non | 'gs', 'googlestreets' &#124; 'gh', 'googlehybrid' &#124; 'osm', 'openstreetmap' &#124; false, null, 'none', 'off' | Show background map |
| hideLegend (masquer la légende) | booléen | Non | faux &#124; vrai | Hide legend panel |
| mapViews | array | Yes (if no id provided) || Array of layers |

If no id is provided you must add map view objects with the following
config options:



Table: Map plug-in configuration

||||||
|---|---|---|---|---|
| layer | chaîne | Non | "thematic1" &#124; "thematic2" &#124; "thematic3" &#124; "thematic4" &#124; "boundary" &#124; "facility" &#124; | The layer to which the map view content should be added |
| colonnes | array | Oui || Indicator, data element, data operand or data set (only one will be used) |
| lignes | array | Oui || Organisation units (multiple allowed) |
| filtre | array | Oui || Period (only one will be used) |
| classes | entier | Non | 5 &#124; 1-7 | The number of automatic legend classes |
| method | entier | Non | 2 &#124; 3 | Legend calculation method where 2 = equal intervals and 3 = equal counts |
| colorLow | chaîne | Non | "ff0000" (red) &#124; Any hex color | The color representing the first automatic legend class |
| colorHigh | chaîne | Non | "00ff00" (green) &#124; Any hex color | The color representing the last automatic legend class |
| radiusLow | entier | Non | 5 &#124; Any integer | Only applies for facilities (points) - radius of the point with lowest value |
| radiusHigh | entier | Non | 15 &#124; Any integer | Only applies for facilities (points) - radius of the point with highest value |
| opacity | double | Non | 0.8 &#124; 0 - 1 | Opacity/transparency of the layer content |
| legendSet (ensemble de légende) | object | Non || Pre-defined legend set. Will override the automatic legend set. |
| labels | boolean/object | Non | false &#124; true &#124; object properties: fontSize (integer), color (hex string), strong (boolean), italic (boolean) | Show labels on the map |
| largeur | entier | Non || Width of map |
| taille | entier | Non || Height of map |
| userOrgUnit (unité d'organisation d'utilisateur) | string / array | Non || Organisation unit identifiers, overrides organisation units associated with current user, single or array |

We continue by adding one pre-defined and one dynamically configured map
to our HTML document. You can browse the list of available maps using
the Web API here: <http://play.dhis2.org/demo/api/33/maps>.

```javascript
function setLinks() {
  DHIS.getMap({ url: base, el: "map1", id: "ytkZY3ChM6J" });

  DHIS.getMap({
 url: base,
 el: "map2",
 mapViews: [
   columns: [ // Chart series
  columns: [{dimension: "in", items: [{id: "Uvn6LCg7dVU"}]}], // data
   ],
   rows: [ // Chart categories
  rows: [{dimension: "ou", items: [{id: "LEVEL-3"}, {id: "ImspTQPwCqd"}]}], // organisation units
   ],
   filters: [
  filters: [{dimension: "pe", items: [{id: "LAST_3_MONTHS"}]}], // period
   ],
   // All following options are optional
   classes: 7,
   colorLow: "02079c",
   colorHigh: "e5ecff",
   opacity: 0.9,
   legendSet: {id: "fqs276KXCXi"}
 ]
  });
}
```

Finally we include some *div* elements in the body section of the HTML
document with the identifiers referred to in the plug-in JavaScript.

```html
<div id="map1"></div>
<div id="map2"></div>
```

To see a complete working example please visit
<http://play.dhis2.org/portal/map.html>.



# Analyse  { #analytics } 

## Analyses { #webapi_analytics }

Pour accéder aux données analytiques et agrégées dans DHIS2, vous pouvez utiliser la ressource *analyse*. L'importance de la ressource "analyse" réside dans le fait qu'elle vous permet d'interroger et d'extraire des données agrégées pour toutes les dimensions de données disponibles. Par exemple, vous pouvez demander à la ressource "analyse" de vous fournir des valeurs agrégées pour un ensemble d'éléments de données, de périodes et d'unités d'organisation. Vous pouvez également récupérer les données agrégées d'une combinaison de dimensions en vous basant sur des éléments de données et des groupes d'unités d'organisation.

    /api/33/analytics

### Paramètres de requête { #webapi_analytics_query_parameters }

La ressource "analyse" vous permet de définir un ensemble de paramètres de requête :



Tableau : Paramètres de requête

| Paramètre de requête | Obligatoire | Description | Options (par défaut en premier) |
|---|---|---|---|
| dimension | Oui | Dimensions et éléments de dimension à extraire. Ils sont répétés pour chaque paramètre. | N'importe quelle dimension |
| filtre | Non | Filtres et éléments de filtre à appliquer à la requête. Ils sont répétés pour chaque paramètre. | N'importe quelle dimension |
| Type d'agrégation | Non | Type d'agrégation à utiliser dans le processus d'agrégation. | SUM &#124; AVERAGE &#124; AVERAGE_SUM_ORG_UNIT &#124; LAST &#124; LAST_AVERAGE_ORG_UNIT &#124; COUNT &#124; STDDEV &#124; VARIANCE &#124; MIN &#124; MAX |
| Critères de mesure | Non | Filtres pour les données/mesures. | EQ &#124; GT &#124; GE &#124; LT &#124; LE |
| preAggregationMeasureCriteria | Non | Filtres pour les données/mesures, appliqués avant l'agrégation. | EQ &#124; GT &#124; GE &#124; LT &#124; LE |
| date de début | Non | Date de début d’une plage de dates. Elle sera appliquée comme filtre, mais ne peut pas être utilisée avec une dimension ou un filtre de période. | Date |
| date de fin | Non | Date de fin d’une plage de dates. Elle sera appliquée comme filtre, mais ne peut pas être utilisée avec une dimension ou un filtre de période. | Date |
| skipMeta (ignorer les métadonnées) | Non | Exclut la partie métadonnées de la réponse (améliore les performances) | faux &#124; vrai |
| skipData (ignorer les données) | Non | Excluez la partie données de la réponse. | faux &#124; vrai |
| skipRounding (ignorer l'arrondissement des valeurs) | Non | Évite l'arrondissement des valeurs de données, c'est-à-dire que les valeurs fournies sont très précise. | faux &#124; vrai |
| hierarchyMeta (métadonnées de la hiérarchie) | Non | Inclut les noms des unités d'organisation racines et le parcours hiérarchique des unités d'organisation dans les métadonnées. | faux &#124; vrai |
| ignoreLimit (Ignorer la limite) | Non | Ignore la limite de 50 000 enregistrements maximum dans la réponse - à utiliser avec précaution. | faux &#124; vrai |
| tableLayout (présentation du tableau) | Non | Utilise une source de données simples ou une présentation de tableau pour générer la réponse. | faux &#124; vrai |
| hideEmptyRows (cacher les lignes vides) | Non | Masque les lignes vides dans la réponse ; applicable lorsque la présentation du tableau est définie sur "vrai". | faux &#124; vrai |
| hideEmptyColumns (cacher les colonnes vides) | Non | Masque les colonnes vides dans la réponse ; applicable lorsque la présentation du tableau est définie sur "vrai". | faux &#124; vrai |
| showHierarchy (afficher la hiérarchie) | Non | Affiche le parcours hiérarchique complet de l'unité d'organisation ainsi que le nom de l'unité d'organisation. | faux &#124; vrai |
| includeNumDen (inclure le numérateur et le dénominateur) | Non | Inclut dans la réponse, le numérateur et le dénominateur utilisés pour calculer la valeur. | faux &#124; vrai |
| includeMetadataDetails (inclure les détails des métadonnées) | Non | Inclut les détails des métadonnées dans la réponse générée pour les données brutes. | faux &#124; vrai |
| displayProperty (afficher la propriété) | Non | Affiche la propriété des métadonnées. | NAME &#124; SHORTNAME |
| outputIdScheme (schéma d'identification de la sortie) | Non | Schéma d'identification utilisé pour les éléments de métadonnées dans la réponse à la requête. Il accepte des identifiants, des codes ou des attributs. | UID &#124; UUID &#124; CODE &#124; NAME &#124; ATTRIBUTE:<ID\> |
| outputOrgUnitIdScheme (schéma d'identification de l'unité d'organisation de sortie)  | Non | Schéma d'identification utilisé pour les éléments de métadonnées dans la réponse à la requête. Ce paramètre remplace le "outputIdScheme" spécialement pour les unités d'organisation. Il accepte des identifiants, des codes ou des attributs. | UUID &#124; CODE &#124; NAME &#124; ATTRIBUTE:<ID\> |
| outputDataElementIdScheme (schéma d'identification de l'élément de données de sortie) | Non | Schéma d'identification utilisé pour les éléments de métadonnées dans la réponse à la requête. Ce paramètre remplace le "outputIdScheme" spécialement pour les éléments de données. Il accepte des identifiants, des codes ou des attributs. | UUID &#124; CODE &#124; NAME &#124; ATTRIBUTE:<ID\> |
| inputIdScheme | Non | Schéma d'identification à utiliser pour les éléments de métadonnées dans la requête. Il peut être un identifiant, un code ou constitué d'attributs. | UID &#124; CODE &#124; ATTRIBUTE:<ID\> |
| approvalLevel (niveau d'a | Non | Inclut les données qui ont été approuvées au moins jusqu'au niveau d'approbation spécifié. Il fait référence à l'identifiant du niveau d'approbation. | Identifiant du niveau d'approbation |
| relativePeriodDate (Date de la période relative) | Non | Date utilisée comme base pour les périodes relatives. | Date. |
| userOrgUnit (unité d'organisation d'utilisateur) | Non | Définit explicitement les unités d'organisation d'utilisateur à utiliser. Elle remplace les unités d'organisation associées à l'utilisateur actuel. Plusieurs identifiants peuvent être séparés par un point-virgule. | Identifiants d’unité d’organisation. |
| colonnes | Non | Dimensions à utiliser comme colonnes pour la présentation du tableau. | N'importe quelle dimension (doit être une dimension de requête) |
| lignes | Non | Dimensions à utiliser comme lignes pour la présentation du tableau. | N'importe quelle dimension (doit être une dimension de requête) |
| Ordre | Non | Spécifie l'ordre des lignes en fonction de la valeur. | ASC &#124; DESC |
| timeField (champ du temps) | Non | Le champ de temps sur lequel baser l'agrégation des événements. Ceci s'applique uniquement aux éléments de données d'événements. Il peut s'agir d'une option prédéfinie ou de l'ID d'un attribut ou d'un élément de données ayant une valeur temporelle. | EVENT_DATE &#124; ENROLLMENT_DATE &#124; INCIDENT_DATE &#124; DUE_DATE &#124; COMPLETED_DATE &#124; CREATED &#124; LAST_UPDATED &#124; <Attribute ID\> &#124; <Data element ID\> |
| orgUnitField (champ d'unité d'organisation) | Non | The organisation unit field to base event aggregation on. Applies to event data items only. Can be the ID of an attribute or data element with the Organisation unit value type. The default option is specified as omitting the query parameter. <Attribute ID\> &#124; <Data element ID\> | <Attribute ID\> &#124; <Data element ID\> |

Le paramètre de requête *dimension* définit les dimensions à inclure dans la requête d'analyse. Un nombre quelconque de dimensions peut être spécifié. Le paramètre "dimension" doit être répété pour chaque dimension à inclure dans la réponse à la requête. La réponse à la requête peut éventuellement contenir des valeurs agrégées pour toutes les combinaisons des éléments de dimension spécifiés.

Le paramètre *filtre* définit les dimensions à utiliser comme filtres pour les données extraites de la requête d'analyse. Un nombre quelconque de filtres peut être spécifié. Le paramètre "filtre" doit être répété pour chaque filtre à utiliser dans la requête. La différence entre un filtre et une dimension réside dans le fait que les dimensions du filtre ne font pas partie du contenu de la réponse à la requête et que les valeurs agrégées dans la réponse sont regroupées en fonction des dimensions du filtre. En d'autres termes, les données de la réponse seront agrégées selon les dimensions du filtre, mais les filtres ne seront pas inclus en tant que dimensions dans la réponse proprement dite. Par exemple, pour lancer une requête pour certains éléments de données filtrés par les périodes et les unités d'organisation, vous pouvez utiliser l'URL suivante :

    /api/33/analytics?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU&filter=pe:2014Q1;2014Q2
      &filter=ou:O6uvpzGd5pu;lc3eMKXaEfw

Le paramètre de requête *aggregationType* (type d'agrégation) vous permet de définir l'opérateur d'agrégation à utiliser pour la requête. Par défaut, l'opérateur d'agrégation défini pour les éléments de données inclus dans la requête sera utilisé. Si votre requête ne contient aucun élément de données mais des groupes d'éléments de données, l'opérateur d'agrégation du premier élément de données du premier groupe sera utilisé. L'ordre des groupes et des éléments de données n'est pas défini. Ce paramètre de requête vous permet de remplacer l'opérateur d'agrégation par défaut et de définir un opérateur spécifique. Par exemple, vous pouvez le définir sur "count" (compter) avec l'URL suivante :

    /api/33/analytics?dimension=dx:fbfJHSPpUQD&dimension=pe:2014Q1&dimension=ou:O6uvpzGd5pu
      &aggregationType=COUNT

Le paramètre de requête *measureCriteria* (critères de mesure) vous permet de filtrer les plages d'enregistrements de données à renvoyer. Vous pouvez demander au système de ne renvoyer que les enregistrements dont les valeurs agrégées sont égales, supérieures, supérieures ou égales, inférieures ou inférieures ou égales à certaines valeurs. Vous pouvez spécifier un nombre quelconque de critères dans le format suivant, où *criteria* et *value* doivent être remplacés par des valeurs réelles :

    /api/33/analytics?measureCriteria=criteria:value;criteria:value

À titre d'exemple, la requête suivante renverra uniquement les enregistrements pour lesquels la valeur est supérieure ou égale à 6 500 et inférieure à 33 000 :

    /api/33/analytics?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU&dimension=pe:2014
      &dimension=ou:O6uvpzGd5pu;lc3eMKXaEfw&measureCriteria=GE:6500;LT:33000

Comme pour *measureCriteria*, le paramètre de requête *preAggregationMeasureCriteria* vous permet de filtrer les données avant que l'agrégation ne soit effectuée. Par exemple, la requête suivante n'agrège que les données dont la valeur initiale correspond aux critères définis :

    /api/33/analytics?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU&dimension=pe:2014
      &dimension=ou:O6uvpzGd5pu;lc3eMKXaEfw&preAggregationMeasureCriteria=GE:10;LT:100

Les paramètres *startDate* (date de début) et *endDate* (date de fin) peuvent être utilisés pour définir une plage de dates personnalisée pour l'agrégation. Lorsque vous définissez une plage de dates, vous ne pouvez pas définir de périodes relatives ou fixes en tant que dimension ou filtre. La plage de dates va filtrer la réponse de l'outil d'analyse. Vous pouvez l'utiliser comme ceci :

    /api/33/analytics.json?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU
      &dimension=ou:ImspTQPwCqd&startDate=2018-01-01&endDate=2018-06-01

Pour que la ressource analytique génère les données sous forme d'un tableau tout fait, vous pouvez définir le paramètre *tableLayout* (présentation du tableau) en lui attribuant la valeur "true" (vrai). Au lieu de générer une source de données normalisée, la ressource analytique va maintenant générer les données dans un tableau. Vous pouvez utiliser les paramètres *columns* (colonnes) et *rows* (lignes) avec des identifiants de dimension séparés par des points-virgules en guise de valeurs pour indiquer ceux qui doivent apparaître dans les colonnes et ceux qui doivent apparaître dans les lignes du tableau. Les dimensions des colonnes et des lignes doivent être utilisées comme dimension de données dans la requête (et non comme filtre). Une telle requête peut ressembler à ceci :

    /api/33/analytics.html?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU&dimension=pe:2014Q1;2014Q2
      &dimension=ou:O6uvpzGd5pu&tableLayout=true&columns=dx;ou&rows=pe

Le paramètre *order* peut être utilisé pour les ressources analytiques afin de générer des données ordonnées. Les données seront classées dans l'ordre croissant (ou décroissant) des valeurs. Voici un exemple de requête permettant de classer les valeurs par ordre décroissant :

    /api/33/analytics?dimension=dx:fbfJHSPpUQD&dimension=pe:LAST_12_MONTHS
      &dimension=ou:O6uvpzGd5pu&order=DESC

### Dimensions et éléments { #webapi_analytics_dimensions_and_items }

DHIS2 dispose d'un modèle de données multidimensionnel avec plusieurs dimensions de données fixes et dynamiques. Les dimensions fixes sont l'élément de données, la période (temps) et l'unité d'organisation. Vous pouvez ajouter des dimensions de manière dynamique par le biais de catégories, de groupes d'éléments de données et de groupes d'unités d'organisation. Le tableau ci-dessous présente les dimensions de données disponibles dans DHIS2. Chaque dimension de données a un *identifiant de dimension* et chaque dimension peut avoir un ensemble d'*éléments de dimension*:



Tableau : Dimensions et éléments de dimension

| Dimension | Identifiant de la dimension | Éléments de dimension |
|---|---|---|
| Éléments de données, indicateurs, mesures du taux de déclaration des ensembles de données, opérandes d'éléments de données, indicateurs de programme, éléments de données de programme, attributs de programme, règles de validation | dx | Élément de données, indicateur, mesures du taux de déclaration de l'ensemble de données, opérande d'élément de données, indicateur de programme, identifiants d'attribut de programme, mot clé DE_GROUP-<group-id\>, IN_GROUP-<group-id\> , utilisez <dataelement-id\>.<optioncombo-id\> pour les opérandes d'éléments de données, <program-id\>.<dataelement-id\> pour les éléments de données du programme, <program-id\>.<attribute-id\> pour les attributs du programme, <validationrule-id\> pour les résultats de validation. |
| Périodes (temps) | pe | Périodes ISO et périodes relatives, voir "format de date et de période" |
| Hiérarchie d'unités d'organisation | ou | Identifiants d'unité d'organisation et mots-clés USER_ORGUNIT, USER_ORGUNIT_CHILDREN, USER_ORGUNIT_GRANDCHILDREN, LEVEL-<level\> et OU_GROUP-<group-id\> |
| Combinaisons d'options de catégories | co | Identifiants des combinaisons d'options de catégorie (omettre pour obtenir tous les éléments) |
| Combinaisons d'options d'attribut | ao | Identifiants des combinaisons d'options de catégorie (omettre pour obtenir tous les éléments) |
| Catégories | <category id\> | Identifiants des options de catégorie (omettre pour obtenir tous les éléments) |
| Des ensembles de groupes d'éléments de données | <group set id\> | Identifiants des groupes d'éléments de données (omettre pour obtenir tous les éléments) |
| Ensembles de groupes d'unités d'organisation | <group set id\> | Identifiants des groupes d'unités d'organisation (omettre pour obtenir tous les éléments) |
| Ensembles de groupes d'options de catégorie | <group set id\> | Identifiants des combinaisons d'options de catégorie (ignorer pour obtenir tous les éléments) |

Il n'est pas nécessaire de savoir quels objets sont utilisés pour les 
différentes dimensions dynamiques lors de la conception des requêtes analytiques. Vous pouvez obtenir 
une liste complète des dimensions dynamiques en visitant cette URL dans l'API Web :

    /api/33/dimensions

If you want to retrieve only the dimensional items for a given dynamic dimension you can
use the exemple below. The pagination is disabled by default. It can be enabled by adding
the pagination parameter `paging=true` to the URL.

    /api/33/dimensions/J5jldMd8OHv/items?paging=true

L'URL de base de la ressource analytique est `/api/analytics`. Pour demander des dimensions et des éléments de dimension spécifiques, vous pouvez utiliser une chaîne de requête au format suivant, où `dim-id` (identifiant de la dimension) et `dim-item` (élément de dimension) doivent être remplacés par des valeurs réelles :

    /api/33/analytics?dimension=dim-id:dim-item;dim-item&dimension=dim-id:dim-item;dim-item

Comme illustré ci-dessus, l'identifiant de la dimension est suivi de deux points, tandis que les éléments de la dimension sont séparés par des points-virgules. Par exemple, une requête portant sur deux éléments de données, deux périodes et deux unités d'organisation peut être effectuée à l'aide de l'URL suivante :

    /api/33/analytics?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU
      &dimension=pe:2016Q1;2016Q2&dimension=ou:O6uvpzGd5pu;lc3eMKXaEfw

Pour obtenir des données ventilées par combinaisons d'options de catégorie au lieu des totaux des éléments de données, vous pouvez inclure la dimension de catégorie dans la chaîne de requête. Voici une exemple :

    /api/33/analytics?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU
      &dimension=co&dimension=pe:201601&dimension=ou:O6uvpzGd5pu;lc3eMKXaEfw

When selecting data elements you can also select all data elements in a
group as items by using the DE_GROUP-<id> syntax:

    /api/33/analytics?dimension=dx:DE_GROUP-h9cuJOkOwY2
      &dimension=pe:201601&dimension=ou:O6uvpzGd5pu

Au moment de sélectionner les taux de déclaration des ensembles de données, la syntaxe contient un identifiant d'ensemble de données suivi d'une mesure de taux de déclaration :

    /api/33/analytics?dimension=dx:BfMAe6Itzgt.REPORTING_RATE;BfMAe6Itzgt.ACTUAL_REPORTS
      &dimension=pe:201601&dimension=ou:O6uvpzGd5pu

To query for program data elements (of tracker domain type) you can get
those by specifying the program for each data element using the
<program-id>.<dataelement-id> syntax:

    /api/33/analytics.json?dimension=dx:eBAyeGv0exc.qrur9Dvnyt5;eBAyeGv0exc.GieVkTxp4HH
      &dimension=pe:LAST_12_MONTHS&filter=ou:ImspTQPwCqd

To query for program attributes (tracked entity attributes) you can get
those by specifying the program for each attribute using the
<program.id>.<attribute-id> syntax:

    /api/33/analytics.json?dimension=dx:IpHINAT79UW.a3kGcGDCuk6;IpHINAT79UW.UXz7xuGCEhU
      &dimension=pe:LAST_4_QUARTERS&dimension=ou:ImspTQPwCqd

Pour obtenir des ensembles de groupes d'unités d'organisation et des éléments de données, vous pouvez utiliser l'URL ci-dessous. Remarquez que l'identifiant de l'ensemble de groupes est utilisé comme identifiant de dimension et les groupes comme éléments de dimension :

    /api/33/analytics?dimension=Bpx0589u8y0:oRVt7g429ZO;MAs88nJc9nL
      &dimension=pe:2016&dimension=ou:ImspTQPwCqd

Pour obtenir des éléments de données et des catégories, vous pouvez utiliser l'URL suivante. Utilisez l'identifiant de la catégorie comme identifiant de dimension et les options de la catégorie comme éléments de dimension :

    /api/33/analytics?dimension=dx:s46m5MS0hxu;fClA2Erf6IO&dimension=pe:2016
      &dimension=YNZyaJHiHYq:btOyqprQ9e8;GEqzEKCHoGA&filter=ou:ImspTQPwCqd

Pour effectuer une requête en utilisant des périodes relatives et des unités d'organisation associées à l'utilisateur actuellement connecté, vous pouvez utiliser l'URL suivante :

    /api/33/analytics?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU
      &dimension=pe:LAST_12_MONTHS&dimension=ou:USER_ORGUNIT

Lorsque vous sélectionnez des unités d'organisation pour une dimension, vous pouvez utiliser la syntaxe `LEVEL-<level>` pour sélectionner un niveau entier, éventuellement limité par un nombre quelconque d'unités d'organisation limites. La limite renvoie à un nœud supérieur dans une sous-hiérarchie, ce qui signifie que toutes les unités d'organisation au niveau indiqué sous l'unité d'organisation limite indiquée dans la hiérarchie seront incluses dans la réponse et sont fournies en tant qu'éléments de dimension d'unité d'organisation ordinaires. La valeur du niveau peut être un niveau numérique ou faire référence à l'identifiant de l'entité du niveau de l'unité d'organisation. Voici une requête simple pour toutes les unités d'organisation de niveau trois :

    /api/33/analytics?dimension=dx:fbfJHSPpUQD&dimension=pe:2016&dimension=ou:LEVEL-3

Une requête pour les niveaux trois et quatre avec deux unités d'organisation limites peut se présenté comme suit :

    /api/33/analytics?dimension=dx:fbfJHSPpUQD&dimension=pe:2016
      &dimension=ou:LEVEL-3;LEVEL-4;O6uvpzGd5pu;lc3eMKXaEf

When selecting organisation units you can also select all organisation
units in an organisation unit group to be included as dimension items
using the OU_GROUP-<id> syntax. The organisation units in the groups
can optionally be constrained by any number of boundary organisation
units. Both the level and the group items can be repeated any number of
times:

    /api/33/analytics?dimension=dx:fbfJHSPpUQD&dimension=pe:2016
      &dimension=ou:OU_GROUP-w0gFTTmsUcF;OU_GROUP-EYbopBOJWsW;O6uvpzGd5pu;lc3eMKXaEf

Vous pouvez utiliser des schémas d'identification pour la partie métadonnées de la réponse analytique avec la propriété outputIdScheme. Vous pouvez utiliser l'identifiant, le code ou les attributs comme schéma d'identification. Voici un exemple :

    /api/33/analytics?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU
      &dimension=pe:2017Q1;2017Q2&dimension=ou:O6uvpzGd5pu&outputIdScheme=CODE

Quelques éléments à prendre en compte lors de l'utilisation de la ressource analytique sont répertoriés ci-dessous.

  - Éléments de données, indicateur, taux de déclaration des ensembles de données, données de programme
    et les indicateurs de programme font partie d’une dimension de données commune,
    identifié comme "dx". Cela signifie que vous pouvez utiliser n'importe quelle élément de données, 
    indicateur et identifiant d'ensemble de données avec l'identifiant 
    de dimension "dx" dans la requête.

  - Pour les dimensions "catégorie", "ensemble de groupes d'éléments de données" et "ensemble de groupes d'unités d'organisation", 
    tous les éléments de dimension seront utilisés dans la requête si
    éléments de dimension ne sont pas spécifiés.

  - Pour la dimension de période, les éléments de dimension sont des identifiants de période ISO
    et/ou des périodes relatives. Consultez la section 
    "Format de date et de période" plus haut, pour mieux comprendre le format des périodes et
    les périodes relatives disponibles.

  - Pour la dimension d'unité d'organisation, vous pouvez spécifier des éléments qui seront 
    l'unité d'organisation ou les sous-unités de l'unité d'organisation
    associée à l'utilisateur actuellement authentifié pour la requête.
    Vous pouvez le faire en utilisant respectivement les clés `USER_ORGUNIT` ou `USER_ORGUNIT_CHILDREN` comme éléments.
    Vous pouvez également spécifier des identifiants d'unité d'organisation
    ou une combinaison des deux possibilités.

  - Pour la dimension d'unité d'organisation, vous pouvez spécifier le niveau hiérarchique 
    et l'unité d'organisation limite à utiliser pour la requête en utilisant le 
    format `LEVEL-<level>-<boundary-id>` ; par exemple
    `LEVEL-3-ImspTQPwCqd` prend en compte toutes les unités d'organisation inférieures à 
    l'unité d'organisation limite au niveau 3 de la hiérarchie.

  - Pour la dimension d'unité d'organisation, les éléments de dimension sont les
    unités d'organisation et leur sous-hiérarchie - les données seront agrégées
    pour toutes les unités d'organisation situées en dessous de l'unité d'organisation spécifiée dans la 
    hiérarchie.

  - Vous ne pouvez pas spécifier d'éléments de dimension pour la dimension de combinaison 
    d'options de catégorie. En lieu et place de cela, la réponse contiendra les éléments
    associés aux valeurs de données.

### La dimension dx { #webapi_analytics_dx_dimension }

La dimension `dx` est une dimension spéciale qui peut contenir tous les types de données suivants.



Tableau : Types de dimensions de données dx

| Type | Syntaxe | Description | Source des données |
|---|---|---|---|
| Indicateur | <indicator-id\> | Identifiant de l'indicateur. | Données agrégées |
| Groupe indicateur | IN_GROUP-<indicatorgroup-id\> | Mot clé suivi d'un identifiant de groupe d'indicateurs. Inclura tous les indicateurs du groupe dans la réponse. | Données agrégées |
| Élément de données | <dataelement-id\> | Identifiant de l'élément de données. | Données agrégées |
| Groupe d'éléments de données | DE_GROUP-<dataelementgroup-id\> | Mot clé suivi d'un identifiant de groupe d'éléments de données. Inclura tous les éléments de données du groupe dans la réponse. | Données agrégées |
| Opérande de l'élément de données | <dataelement-id\>.<categoryoptcombo-id\>.<attributeoptcombo-id\> | Identifiant de l'élément de données suivi d'une combinaison d'options de catégorie et d'un identifiant de combinaison d'options d'attributs, ou des deux. Le symbole joker « \* » peut être utilisé pour indiquer n'importe quelle valeur de combinaison d'options. L'identifiant de la combinaison d'options d'attributs peut être ignoré complètement. | Données agrégées |
| Ensemble de données | <dataset-id\>.<reporting-rate-metric\> | Identifiant de l’ensemble de données suivi de la mesure du taux de déclaration. Peut être REPORTING_RATE &#124; REPORTING_RATE_ON_TIME &#124; ACTUAL_REPORTS &#124; ACTUAL_REPORTS_ON_TIME &#124; EXPECTED_REPORTS. | Enregistrements de la complétude des ensembles de données |
| Élément de données de programme | <program-id\>.<dataelement-id\> | Identifiant du programme suivi de l'identifiant de l'élément de données. Lit les événements du programme spécifié. | Événements du programme en question |
| Indicateur de programme | <programindicator-id\> | Identifiant de l’indicateur du programme. Lit les événements du programme associés à l'identifiant du programme. | Événements du programme de l'indicateur de programme |
| Résultat de validation | <validationrule-id\> | Identifiant de la règle de validation. Inclura les violations à la règle de validation et requiert que les résultats de la validation soient générés et conservés. | Résultats de validation |

Les éléments de tous les différents types `dx` peuvent être combinés dans une requête d'analyse. Voici un exemple :

    /api/33/analytics.json
      ?dimension=dx:Uvn6LCg7dVU;BfMAe6Itzgt.REPORTING_RATE;IpHINAT79UW.a3kGcGDCuk6
      &dimension=pe:LAST_12_MONTHS&filter=ou:ImspTQPwCqd

La syntaxe de groupe peut également être utilisée avec n’importe quel autre élément. Voici un exemple :

    /api/33/analytics.json
      ?dimension=dx:DE_GROUP-qfxEYY9xAl6;IN_GROUP-oehv9EO3vP7;BfMAe6Itzgt.REPORTING_RATE
      &dimension=pe:LAST_12_MONTHS&filter=ou:ImspTQPwCqd

Les opérandes d'élément de données peuvent éventuellement spécifier des combinaisons d'options d'attribut et utiliser des caractères génériques, par exemple pour spécifier toutes les valeurs des combinaisons d'options de catégorie :

    /api/33/analytics.json
      ?dimension=dx:Uvn6LCg7dVU.*.j8vBiBqGf6O;Uvn6LCg7dVU.Z4oQs46iTeR
      &dimension=pe:LAST_12_MONTHS&filter=ou:ImspTQPwCqd

> **Tip**
>
> A great way to learn how to use the analytics API is to use the DHIS2
> *pivot table* app. You can play around with pivot tables using the
> various dimensions and items and click Download > Plain data source > JSON
> to see the resulting analytics API calls in the address bar of
> your Web browser.

### Formats de réponse { #webapi_analytics_response_formats }

La réponse analytique contenant les données agrégées peut être renvoyée sous différents formats. Comme toujours, vous pouvez définir un format spécifique en ajoutant une extension de fichier à l'URL, via l'en-tête HTTP `Accept` ou via le paramètre de requête `format`. Le format par défaut est JSON. Les formats et types de contenu disponibles sont listés ci-dessous.

  - json (application/json)

  - jsonp (application/javascript)

  - xml (application/xml)

  - csv (application/csv)

  - html (texte/html)

  - html+css (texte/html)

  - xls (application/vnd.ms-excel)

À titre d'exemple, vous pouvez demander une réponse analytique au format XML, en utilisant l'URL suivante :

    /api/33/analytics.xml?dimension=dx:fbfJHSPpUQD
      &dimension=pe:2016&dimension=ou:O6uvpzGd5pu;lc3eMKXaEfw

The analytics responses must be retrieved using the HTTP *GET* method.
This allows for direct linking to analytics responses from Web pages as
well as other HTTP-enabled clients. To do functional testing we can use
the cURL library. By executing this command against the demo database
you will get an analytics response in JSON format:

```bash
curl "play.dhis2.org/demo/api/analytics.json?dimension=dx:eTDtyyaSA7f;FbKK4ofIv5R
  &dimension=pe:2016Q1;2016Q2&filter=ou:ImspTQPwCqd" -u admin:district
```

La réponse JSON ressemblera à ceci :

```json
{
  "headers": [
    {
      "name": "dx",
      "column": "Data",
      "meta": true,
      "type": "java.lang.String"
    },
    {
      "name": "pe",
      "column": "Period",
      "meta": true,
      "type": "java.lang.String"
    },
    {
      "name": "value",
      "column": "Value",
      "meta": false,
      "type": "java.lang.Double"
    }
  ],
  "height": 4,
  "metaData": {
    "pe": [
      "2016Q1",
      "2016Q2"
    ],
    "ou": [
      "ImspTQPwCqd"
    ],
    "names": {
      "2016Q1": "Jan to Mar 2016",
      "2016Q2": "Apr to Jun 2016",
      "FbKK4ofIv5R": "Measles Coverage <1 y",
      "ImspTQPwCqd": "Sierra Leone",
      "eTDtyyaSA7f": "Fully Immunized Coverage"
    }
  },
  "rows": [
    [
      "eTDtyyaSA7f",
      "2016Q2",
      "81.1"
    ],
    [
      "eTDtyyaSA7f",
      "2016Q1",
      "74.7"
    ],
    [
      "FbKK4ofIv5R",
      "2016Q2",
      "88.9"
    ],
    [
      "FbKK4ofIv5R",
      "2016Q1",
      "84.0"
    ]
  ],
  "width": 3
}
```

La réponse représente un tableau de données dimensionnelles. L'*en-tête* donne un aperçu des colonnes du tableau et de leur contenu. La propriété *colonne* indique l'identifiant de la dimension de la colonne ou, si la colonne contient des mesures, le mot "Value". La propriété *métadonnées* est définie sur *vrai* si la colonne contient des éléments de dimension ou *faux* si la colonne contient une mesure (valeurs de données agrégées). La propriété *nom* est similaire à la propriété "colonne", à la différence qu'elle affiche "valeur" lorsque la colonne contient une mesure. La propriété *type* indique le type de classe Java des valeurs de la colonne.

Les propriétés *hauteur* et *largeur* indiquent respectivement le nombre de colonnes et de lignes de données contenues dans la réponse.

La propriété *périodes de métadonnées* contient un tableau unique et ordonné des périodes contenues dans la réponse. La propriété *unité d'organisation de métadonnées* contient un tableau d'identifiants d'unités d'organisation contenues dans la réponse. La propriété *noms de métadonnées* permet d'obtenir une correspondance entre les identifiants utilisés dans la réponse et les noms des objets qu'ils représentent. Les clients peuvent utiliser cette propriété pour remplacer les identifiants de la réponse par des noms afin d'obtenir une représentation plus claire du tableau de données.

La rubrique *lignes* contient le tableau des données dimensionnelles. Ce dernier est fait de colonnes dans lesquelles figurent des éléments de dimension (identifiants d'objets ou de périodes) et une colonne dans laquelle figurent des valeurs de données agrégées. L'exemple de réponse ci-dessus comporte une colonne pour les données et les indicateurs, une colonne pour les périodes et une colonne pour les valeurs. La première colonne contient les identifiants d'indicateur, la deuxième contient les identifiants de période ISO et la troisième contient les valeurs de données agrégées.

### Contraintes et validation { #webapi_analytics_constraints }

Les paramètres d'entrée que vous pouvez fournir à la ressource analytique sont soumis à plusieurs contraintes. Si l'une de ces contraintes n'est pas respectée, l'API renvoie une réponse *409 Conflict* avec un message semblable à celui-ci :

```json
{
  "httpStatus": "Conflict",
  "httpStatusCode": 409,
  "status": "ERROR",
  "message": "Only a single indicator can be specified as filter",
  "errorCode": "E7108"
}
```

Les champs `httpStatus` et `httpStatusCode` indiquent le statut HTTP et le code de statut conformément à la spécification HTTP. Le champ `message` fournit une description de l'erreur de validation lisible par l'homme. Le champ `errorCode` fournit un code lisible par une machine que les clients peuvent utiliser pour gérer les erreurs de validation. Les erreurs de validation potentielles pour l'API d'analyse des données agrégées sont décrites dans le tableau ci-dessous.

| Code d'erreur | Message |
| ---------- | ------- |
| E7100      | Les paramètres de requête ne peuvent pas être nuls |
| E7101      | Au moins une dimension doit être spécifiée |
| E7102      | Au moins un élément de dimension de données ou un élément de dimension d'ensemble de groupes d'éléments de données doit être spécifié. |
| E7103      | Les dimensions ne peuvent pas être spécifiées à la fois comme dimension et comme filtre |
| E7104      | Au moins une période doit être spécifiée comme dimension ou filtre, ou dates de début et de fin  |
| E7105      | Les périodes et les dates de début et de fin ne peuvent pas être spécifiées simultanément |
| E7106      | La date de début ne peut pas être postérieure à la date de fin |
| E7107      | Des dates de début et de fin ne peuvent pas être spécifiées pour les taux de déclaration |
| E7108      | Un seul indicateur peut être spécifié comme filtre |
| E7109      | Un seul taux de déclaration peut être spécifié comme filtre |
| E7110      | Les combinaisons d'options de catégorie ne peuvent pas être spécifiées comme filtre |
| E7111      | Les dimensions ne peuvent pas être spécifiées plus d'une fois |
| E7112      | Les taux de déclaration ne peuvent être spécifiés qu'avec les dimensions de type |
| E7113      | Les catégories attribuées ne peuvent pas être spécifiées si les éléments de données ne sont pas spécifiés |
| E7114      | Les catégories attribuées ne peuvent être spécifiées qu'avec des éléments de données, et non avec des indicateurs ou des taux de déclaration. |
| E7115      | Les éléments de données doivent être d'un type de valeur et d'agrégation qui permette l'agrégation |
| E7116      | Les expressions d'indicateur ne peuvent pas contenir de références cycliques |
| E7117      | Une dimension de données 'dx' doit être spécifiée lorsque le format de sortie est DATA_VALUE_SET (ensemble de v. |
| E7118      | Une dimension de période 'pe' doit être spécifiée lorsque le format de sortie est DATA_VALUE_SET. |
| E7119      | Une dimension d'unité d'organisation 'ou' doit être spécifiée lorsque le format de sortie est DATA_VALUE_SET. |
| E7120      | L'utilisateur n'est pas autorisé à visualiser l'unité d'organisation |
| E7121      | L'utilisateur n'est pas autorisé à lire les données de l'objet |
| E7122      | Le niveau d'approbation des données n'existe pas |
| E7123      | L'utilisateur actuel est limité par une dimension mais n'a accès à aucun élément de dimension |
| E7124      | La dimension est présente dans la requête sans aucune option de dimension valide |
| E7125      | L'identifiant de dimension ne fait référence à aucune dimension |
| E7126      | La colonne doit être présente en tant que dimension dans la requête |
| E7127      | La ligne doit être présente dans la requête en tant que dimension |
| E7128      | Les résultats de la requête ont dépassé la limite maximale |
| E7129      | Le programme est spécifié mais n'existe pas |
| E7130      | L'étape de programme est spécifiée mais n'existe pas |
| E7131      | La requête a échoué, probablement parce que la requête a expiré |

### Format de l'ensemble de valeurs de données { #webapi_analytics_data_value_set_format }

La ressource analytique *dataValueSet* permet de renvoyer des données agrégées dans le format "ensemble de valeurs de données". Ce format représente des valeurs de données brutes, par opposition aux données qui ont été agrégées en fonction des différentes dimensions. L'exportation de données agrégées sous la forme de valeurs de données régulières permet d'échanger des données entre systèmes lorsque le système cible contient des données d'une granularité plus fine que celles stockées par le système de destination.

Par exemple, il est possible de spécifier un indicateur dans le système cible qui va récapituler les données de plusieurs éléments de données, et d'importer ces données pour le compte d'un seul élément de données dans le système de destination. Autre exemple, l'on peut agréger les données collectées au niveau 4 de l'unité d'organisation dans le système cible au niveau 2 et importer ces données dans le système de destination.

Vous pouvez récupérer des données au format d'ensemble de valeurs de données brutes à partir de la ressource dataValueSet :

    /api/33/analytics/dataValueSet

Les représentations de ressources suivantes sont prises en charge :

  - json (application/json)

  - xml (application/xml)

Lorsque vous utilisez le format d'ensemble de valeurs de données, exactement trois dimensions doivent être spécifiées en tant que dimensions analytiques avec au moins un élément de dimension pour chacune d'entre elles :

  - Données (dx)

  - Période (pe)

  - Unité d'organisation (ou)

Toute autre dimension sera ignorée. Les filtres seront appliqués de la même manière que pour les demandes d'analyse ordinaires. Notez que tout type de dimension de données peut être spécifié, notamment les indicateurs, les éléments de données, les opérandes d'éléments de données, les ensembles de données et les indicateurs de programme.

Voici un exemple de requête qui agrège des données pour des indicateurs, des périodes et des unités d'organisation spécifiques et les renvoie sous forme de valeurs de données régulières au format XML :

    api/analytics/dataValueSet.xml?dimension=dx:Uvn6LCg7dVU;OdiHJayrsKo
      &dimension=pe:LAST_4_QUARTERS&dimension=ou:lc3eMKXaEfw;PMa2VCrupOd

Trouvez ci-dessous un exemple de requête qui agrège des données pour des opérandes d'éléments de données et qui utilise CODE comme schéma d'identification de sortie. Lorsque vous définissez un schéma d'identification de sortie, tous les objets de métadonnées qui font partie de la réponse sont affectés :

    api/analytics/dataValueSet.json?dimension=dx:fbfJHSPpUQD.pq2XI5kz2BY;fbfJHSPpUQD.PT59n8BQbqM
      &dimension=pe:LAST_12_MONTHS&dimension=ou:ImspTQPwCqd&outputIdScheme=CODE

Lorsque vous utilisez des schémas d'identification basés sur des attributs pour effectuer des exportations, des valeurs peuvent être dupliquées. Le paramètre de requête booléen duplicatesOnly peut être utilisé à des fins de débogage pour ne renvoyer que les valeurs de données dupliquées. Cette réponse peut être utilisée pour nettoyer les doublons :

    api/analytics/dataValueSet.xml?dimension=dx:Uvn6LCg7dVU;OdiHJayrsKo
      &dimension=pe:LAST_4_QUARTERS&dimension=ou:lc3eMKXaEfw&duplicatesOnly=true

### Format de données brutes { #webapi_analytics_raw_data }

La ressource analytique *rawData* permet de renvoyer les données stockées dans les tableaux de données analytiques sans qu'aucune agrégation ne soit effectuée. Cette ressource permet aux clients qui le souhaitent d'effectuer eux-mêmes des agrégations et des filtrages sans avoir à dénormaliser eux-mêmes les données existant dans les dimensions disponibles.

    /api/analytics/rawData

Les représentations de ressources suivantes sont prises en charge :

  - json (application/json)

  - csv (application/csv)

Cette ressource respecte la syntaxe d'une ressource analytique ordinaire. Seul un sous-ensemble de paramètres de requête est pris en charge. En outre, les paramètres *startDate* et *endDate* sont disponibles. Les paramètres pris en charge sont énumérés dans le tableau ci-dessous.



Tableau : Paramètres de requête

| Paramètre de requête | Obligatoire / Remarques |
|---|---|
| dimension | Oui |
| date de début | No / aaaa-MM-jj |
| date de fin | No / aaaa-MM-jj |
| skipMeta (ignorer les métadonnées) | Non |
| skipData (ignorer les données) | Non |
| hierarchyMeta (métadonnées de la hiérarchie) | Non |
| showHierarchy (afficher la hiérarchie) | Non |
| displayProperty (afficher la propriété) | Non |
| outputIdScheme (schéma d'identification de la sortie) | Non |
| outputOrgUnitIdScheme (schéma d'identification de l'unité d'organisation de sortie)  | Non |
| outputDataElementIdScheme (schéma d'identification de l'élément de données de sortie) | Non |
| inputIdScheme | Non |
| userOrgUnit (unité d'organisation d'utilisateur) | Non |

Le paramètre de requête *dimension* définit les dimensions (colonnes du tableau) à inclure dans la réponse. Il peut éventuellement être limité par des éléments. Le paramètre de requête *filter* (filtre) définit les éléments et les dimensions (colonnes du tableau) qui doivent être utilisés comme filtre pour la réponse.

Pour la dimension "unité d'organisation", la réponse contiendra les données associées à l'unité d'organisation et à toutes les unités d'organisation qui lui sont inférieures dans la hiérarchie (c'est-à-dire ses subordonnées). Ceci est différent de la ressource analytique ordinaire, où seules les unités d'organisation explicitement sélectionnées sont incluses dans la réponse.

Pour obtenir une réponse contenant des éléments de données, périodes et unités d'organisation spécifiques, ainsi que toutes les données relatives à deux dimensions personnalisées, vous pouvez lancer une requête de ce type :

    /api/analytics/rawData.json?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU;Jtf34kNZhzP
      &dimension=J5jldMd8OHv&dimension=Bpx0589u8y0
      &dimension=pe:LAST_12_MONTHS
      &dimension=ou:O6uvpzGd5pu;fdc6uOvgoji

Les paramètres *startDate* et *endDate* permettent de récupérer des données associées à toute période comprise entre ces dates. Avec cette méthode, nul besoin de définir explicitement toutes les périodes dans la requête :

    /api/analytics/rawData.json?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU;Jtf34kNZhzP
      &dimension=J5jldMd8OHv&dimension=Bpx0589u8y0
      &startDate=2015-01-01&endDate=2015-12-31
      &dimension=ou:O6uvpzGd5pu;fdc6uOvgoji

Le paramètre *filter* peut être utilisé pour filtrer une réponse sans inclure cette dimension dans la réponse, cette fois au format CSV :

    /api/analytics/rawData.csv?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU;Jtf34kNZhzP
      &filter=J5jldMd8OHv:uYxK4wmcPqA;tDZVQ1WtwpA
      &startDate=2015-01-01&endDate=2015-12-31
      &dimension=ou:O6uvpzGd5pu

Vous pouvez utiliser le paramètre *outputIdScheme* (schéma d'identification de la sortie) pour obtenir des données lisibles par l'homme, car il peut être défini sur *NOM* comme dans l'exemple suivant :

    /api/analytics/rawData.csv?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU
      &filter=J5jldMd8OHv:uYxK4wmcPqA;tDZVQ1WtwpA
      &startDate=2017-01-01&endDate=2017-12-31
      &dimension=ou:O6uvpzGd5pu
      &outputIdScheme=NAME

La réponse de la ressource *rawData* est identique à celle de la ressource analytique ordinaire, à la différence qu'elle contient des données brutes et non agrégées qui peuvent être agrégées ultérieurement par des systèmes tiers.

### Débogage { #webapi_analytics_debugging }

Lors du débogage des requêtes analytiques, il peut être utile d'examiner la source des valeurs de données de la réponse analytique agrégée. La ressource *analytics/debug/sql* fournira une instruction SQL qui renvoie le contenu recherché du tableau des valeurs de données. Vous pouvez produire cette instruction SQL en effectuant une requête GET avec le type de contenu "text/html" ou "text/plain" comme ci-dessous. La syntaxe des dimensions et des filtres est identique à celle des requêtes analytiques ordinaires :

    /api/analytics/debug/sql?dimension=dx:fbfJHSPpUQD;cYeuwXTCPkU
      &filter=pe:2016Q1;2016Q2&filter=ou:O6uvpzGd5pu

## Analyse d'événements { #webapi_event_analytics }

L'API d'analyse d'événements vous permet d'accéder à des données d'événements agrégées et d'interroger des *événements* capturés dans DHIS2. Cette ressource vous permet d'extraire des événements à partir d'un programme et éventuellement d'une étape de programme. Elle vous permet également d'extraire et de filtrer des événements en fonction des différentes dimensions d'événements.

    /api/33/analytics/events

### Dimensions et éléments { #webapi_event_analytics_dimensions_items }

Les dimensions d'événements comprennent les éléments de données, les attributs, les unités d'organisation et les périodes. La ressource analytique des événements agrégés renvoie des informations agrégées telles que des chiffres issus de comptages ou des moyennes. La ressource analytique de requête renvoie simplement les événements correspondant à un ensemble de critères et n'effectue aucune agrégation. Vous pouvez spécifier des éléments de dimension sous la forme d'options à partir d'ensembles d'options et de légendes à partir d'ensembles de légendes, pour les éléments de données et les attributs qui y sont associés. Les dimensions des événements sont répertoriées dans le tableau ci-dessous.



Tableau : Dimensions de l'événement

| Dimension | Identifiant de la dimension | Description |
|---|---|---|
| Des éléments de données | <id\> | Identifiants de l'élément de données. |
| Attributs | <id\> | Identifiants d'attribut |
| Périodes | pe | Périodes ISO et périodes relatives, voir "format de date et de période" |
| Unités d’organisation | ou | Identifiants d'unité d'organisation et mots-clés USER_ORGUNIT, USER_ORGUNIT_CHILDREN, USER_ORGUNIT_GRANDCHILDREN, LEVEL-<level\> et OU_GROUP-<group-id\> |
| Ensembles de groupes d'unités d'organisation | <org unit group set id\> | Identifiants d'ensemble de groupes d'unités d'organisation |
| Catégories | <category id\> | Identifiants de catégorie (catégories d'attributs de programme uniquement) |

### Paramètres de requête{ #webapi_event_analytics_request_query_parameters }

L'API d'événement analytique vous permet de définir un ensemble de paramètres de requête.



Tableau : Paramètres de requête pour la requête d'événement et l'analyse agrégée

| Paramètre de requête | Obligatoire | Description | Options (par défaut en premier) |
|---|---|---|---|
| de paludisme) ». | Oui | Identifiant du programme. | Tout identifiant de programme |
| étape | Non | Identifiant de l'étape de programme. | Tout identifiant d'étape de programme |
| date de début | Oui | Date de début des événements. | Les dates doivent être au format aaaa-MM-jj |
| date de fin | Oui | Date de fin des événements. | Les dates doivent être au format aaaa-MM-jj |
| dimension | Oui | L'identifiant de dimension comprend les éléments de données, les attributs, les indicateurs de programme, les périodes, les unités d'organisation et les ensembles de groupes d'unités d'organisation. Le paramètre peut être répété autant de fois que nécessaire. Des filtres d'éléments peuvent être appliqués à une dimension selon le format <item-id\>:<operator\>:<filter\>. Les valeurs des filtres ne sont pas sensibles à la casse. | Les opérateurs peuvent être EQ &#124; GT&#124; GE&#124; LT&#124; LE&#124; NE &#124; COMME &#124; DANS |
| filtre | Non | L'identifiant de dimension comprend les éléments de données, les attributs, les périodes, les unités d'organisation et les ensembles de groupes d'unités d'organisation. Le paramètre peut être répété autant de fois que nécessaire. Des filtres d'éléments peuvent être appliqués à une dimension selon le format <item-id\>:<operator\>:<filter\>. Les valeurs des filtres ne sont pas sensibles à la casse. ||
| hierarchyMeta (métadonnées de la hiérarchie) | Non | Inclut les noms des unités d'organisation racines et le parcours hiérarchique des unités d'organisation dans les métadonnées. | faux &#124; vrai |
| eventStatus (statut d'événement) | Non | Spécifie le statut des événements à inclure. | ACTIVE &#124; COMPLETED &#124; SCHEDULE &#124; OVERDUE &#124; SKIPPED |
| programStatus (statut de programme) | Non | Spécifie le statut d’inscription des événements à inclure. | ACTIF &#124; TERMINÉ &#124; ANNULÉ |
| relativePeriodDate (Date de la période relative) | chaîne | Non | Identifiant de date, par exemple : "2016-01-01". Il remplace la date de début de la période relative |
| colonnes | Non | Dimensions à utiliser comme colonnes pour la présentation du tableau. | N'importe quelle dimension (doit être une dimension de requête) |
| lignes | Non | Dimensions à utiliser comme lignes pour la présentation du tableau. | N'importe quelle dimension (doit être une dimension de requête) |



Tableau : Paramètres de requête pour l'analyse des requêtes d'événement uniquement

| Paramètre de requête | Obligatoire | Description | Options |
|---|---|---|---|
| ou Mode | Non | The mode of selecting organisation units. Default is DESCENDANTS, meaning all sub units in the hierarchy. CHILDREN refers to immediate children in the hierarchy; SELECTED refers to the selected organisation units only. | DESCENDANTS, CHILDREN, SELECTED |
| asc | Non | Permet de trier les dimensions par ordre croissant; peut concerner la date de l'événement, le nom et le code de l'unité d'organisation et tout identifiant d'élément. | EVENTDATE &#124; OUNAME &#124; OUCODE &#124; item identifier |
| desc | Non | Permet de trier les dimensions par ordre décroissant ; peut concerner la date de l'événement, le nom et le code de l'unité d'organisation et tout identifiant d'élément. | EVENTDATE &#124; OUNAME &#124; OUCODE &#124; item identifier |
| coordinatesOnly (coordonnées uniquement) | Non | Indique s'il faut uniquement renvoyer les événements qui ont des coordonnées. | faux &#124; vrai |
| coordinateOuFallback (Coordonner le repli de l'uo) | Non | La géométrie de l'instance de programme est appliquée chaque fois que la géométrie de l'unité d'organisation est manquante. | faux &#124; vrai |
| dataIdScheme (schéma d'identification des données) | Non | Schéma d'identification à utiliser pour les données, plus spécifiquement pour les éléments de données et les attributs qui disposent d'un ensemble d'options ou de légendes. Ceci permet par exemple de renvoyer le nom de l'option au lieu du code, ou le nom de la légende au lieu de son ID, dans la réponse de données. | NAME &#124; CODE &#124; UID |
| page | Non | Le numéro de page. La page par défaut est 1. | Valeur numérique positive |
| taille de la page | Non | La taille de la page. La taille par défaut est de 50 éléments par page. | Zéro ou valeur positive |



Tableau : Paramètres de requête pour l'analyse agrégée des événements uniquement

| Paramètre de requête | Obligatoire | Description | Options |
|---|---|---|---|
| valeur | Non | Il s'agit de l'identifiant de la dimension de la valeur ; peut être un élément de données ou un attribut qui doit être de type numérique. | Identifiant d’élément de données ou d’attribut |
| Type d'agrégation | Non | Type d'agrégation pour la dimension de valeur. Par défaut, il est définit sur AVERAGE (moyenne). | SUM &#124; AVERAGE &#124; AVERAGE_SUM_ORG_UNIT &#124; LAST &#124; LAST_AVERAGE_ORG_UNIT &#124; COUNT &#124; STDDEV &#124; VARIANCE &#124; MIN &#124; MAX |
| showHierarchy (afficher la hiérarchie) | Non | Affiche le parcours hiérarchique complet de l'unité d'organisation ainsi que le nom de l'unité d'organisation. | faux &#124; vrai |
| displayProperty (afficher la propriété) | Non | Affiche la propriété des métadonnées. | NAME &#124; SHORTNAME |
| sortOrder (ordre de tri) | Non | Trie les enregistrements de la colonne de valeurs par ordre croissant ou décroissant. | ASC &#124; DESC |
| limite | Non | Le nombre maximum d'enregistrements à renvoyer. Ne peut pas dépasser 10 000. | Valeur numérique positive |
| outputType (type de sortie) | Non | Spécifie le type de sortie pour les données d'analyse. Il peut s'agir d'événements, d'inscriptions ou d'instances d'entité suivie. Les deux dernières options s'appliquent aux programmes avec inscription uniquement. | EVENT &#124; ENROLLMENT &#124; TRACKED_ENTITY_INSTANCE |
| collapseDataDimensions (Dimensions des données regroupées) | Non | Réduit toutes les dimensions de données (éléments de données et attributs) en une seule dimension dans la réponse. | faux &#124; vrai |
| skipMeta (ignorer les métadonnées) | Non | Exclut la partie métadonnées de la réponse (améliore les performances). | faux &#124; vrai |
| skipData (ignorer les données) | Non | Excluez la partie données de la réponse. | faux &#124; vrai |
| skipRounding (ignorer l'arrondissement des valeurs) | Non | Évite d'arrondir les valeurs de données agrégées. | faux &#124; vrai |
| aggregateData (données agrégées) | Non | Produit des valeurs agrégées pour les dimensions de données (par opposition aux éléments de dimension). | faux &#124; vrai |
| timeField (champ du temps) | Non | The time field to base event aggregation on. Applies to event data items only. Can be a predefined option or the ID of an attribute or data element having a time-based value type. | EVENT_DATE &#124; ENROLLMENT_DATE &#124; INCIDENT_DATE &#124; DUE_DATE &#124; COMPLETED_DATE &#124; <Attribute ID\> &#124; <Data element ID\> |
| orgUnitField (champ d'unité d'organisation) | Non | The organisation unit field to base event aggregation on. Applies to event data items only. Can be the ID of an attribute or data element with the Organisation unit value type. The default option is specified as omitting the query parameter. <Attribute ID\> &#124; <Data element ID\> | <Attribute ID\> &#124; <Data element ID\> |



Tableau : Paramètres de requête pour les analyses d'événements en grappes uniquement

| Paramètre de requête | Obligatoire | Description | Options |
|---|---|---|---|
| clusterSize (taille des grappes) | Oui | Taille des grappes en mètres. | Valeur numérique positive |
| coordinateField (champs de coordonnées) | Non | Champ à partir duquel les analyses d'événements géospatiaux sont effectuées. La valeur par défaut est " événement ". Il peut être défini comme identifiant d'attributs et d'éléments de données de type coordonnées. | EVENT &#124; <attribute-id\> &#124; <dataelement-id\> |
| bbox | Oui | Zone de délimitation des événements à inclure dans la réponse au format "longitude minimale, latitude minimale, longitude maximale, latitude maximale". | Chaîne |
| includeClusterPoints (Inclure les points d'assemblage) | Non | Inclut des informations sur les points sous-jacents pour chaque grappe. Faites attention si la grappe représente un très grand nombre de points. | faux &#124; vrai |

### Analyse des requêtes d'événements { #webapi_event_query_analytics } 

La ressource *analytics/events/query* vous permet d'effectuer des requêtes sur des événements capturés. Cette ressource ne fait pas d'agrégation, elle vous permet plutôt de lancer des requêtes et de filtrer des informations sur les événements.

    /api/33/analytics/events/query

Vous pouvez spécifier un nombre quelconque de dimensions et de filtres dans une requête. Les identifiants d'éléments de dimension peuvent faire référence à des éléments de données, des attributs de personnes, des identifiants de personnes, des périodes fixes et relatives et des unités d'organisation. Les dimensions peuvent éventuellement être accompagnées d'un opérateur de requête et d'un filtre. Les requêtes d'événements doivent respecter le format décrit ci-dessous.

    /api/33/analytics/events/query/<program-id>?startDate=yyyy-MM-dd&endDate=yyyy-MM-dd
      &dimension=ou:<ou-id>;<ou-id>&dimension=<item-id>&dimension=<item-id>:<operator>:<filter>

Par exemple, pour extraire des événements du programme "Morbidité et mortalité chez les patients hospitalisés" entre janvier et octobre 2016, où les éléments de données "Sexe" et "Âge" sont inclus et où la dimension "Âge" est filtrée sur "18 ans", vous pouvez utiliser la requête suivante :

    /api/33/analytics/events/query/eBAyeGv0exc?startDate=2016-01-01&endDate=2016-10-31
      &dimension=ou:O6uvpzGd5pu;fdc6uOvgoji&dimension=oZg33kd9taw&dimension=qrur9Dvnyt5:EQ:18

Pour extraire les événements de l'étape "Naissance" du "Programme pour les enfants" entre mars et décembre 2016, où l'élément de données "Poids" est filtré pour les valeurs supérieures à 2000, vous pouvez utiliser ce qui suit :

    /api/33/analytics/events/query/IpHINAT79UW?stage=A03MvHHogjR&startDate=2016-03-01
      &endDate=2016-12-31&dimension=ou:O6uvpzGd5pu&dimension=UXz7xuGCEhU:GT:2000

Le tri peut être appliqué à la requête pour la date de l'événement et toutes les dimensions. Pour effectuer un tri par ordre décroissant sur la date de l'événement et par ordre croissant sur la dimension de l'élément de données "Âge", vous pouvez utiliser ceci :

    /api/33/analytics/events/query/eBAyeGv0exc?startDate=2016-01-01&endDate=2016-10-31
      &dimension=ou:O6uvpzGd5pu&dimension=qrur9Dvnyt5&desc=EVENTDATE&asc=qrur9Dvnyt5

Vous pouvez appliquer la pagination à la requête à travers les paramètres de numéro de page et de taille de page. Si le numéro de page est spécifié mais que la taille de la page ne l'est pas, la taille de page "50" sera utilisée. Si la taille de la page est spécifiée mais que le numéro de page ne l'est pas, le numéro de page "1" sera utilisé. Pour obtenir la troisième page de la réponse avec une taille de page de 20, vous pouvez utiliser la requête suivante :

    /api/33/analytics/events/query/eBAyeGv0exc?startDate=2016-01-01&endDate=2016-10-31
      &dimension=ou:O6uvpzGd5pu&dimension=qrur9Dvnyt5&page=3&pageSize=20

#### Filtrage { #filtering } 

Des filtres peuvent être appliqués aux éléments de données, aux attributs de personnes et aux identifiants de personnes. Le filtrage est effectué par le biais de la valeur du paramètre de la requête dans le format suivant :

    &dimension=<item-id>:<operator>:<filter-value>

À titre d'exemple, vous pouvez filtrer l'élément de données "Poids" pour les valeurs supérieures à 2000 et inférieures à 4000 comme suit :

    &dimension=UXz7xuGCEhU:GT:2000&dimension=UXz7xuGCEhU:LT:4000

Vous pouvez filtrer l'élément de données "Âge" pour plusieurs âges spécifiques à l'aide de l'opérateur IN comme dans l'exemple suivant :

    &dimension=qrur9Dvnyt5:IN:18;19;20

Vous pouvez spécifier plusieurs filtres pour un élément donné en répétant les composants de l'opérateur et du filtre, tous séparés par des points-virgules :

    &dimension=qrur9Dvnyt5:GT:5:LT:15

Les opérateurs disponibles sont répertoriés ci-dessous.



Tableau : Opérateurs de filtre

| Opérateur | Description |
|---|---|
| EQ | Egale à |
| GT | Supérieure à |
| GE | Supérieure ou égal à |
| LT | Inférieur à |
| LE | inférieur ou égal à |
| NE | Pas égal à |
| LIKE | Pareil (correspondance textuelle) |
| IN | Égal à l'une des multiples valeurs séparées par ";" |

#### Formats de réponse { #response-formats } 

Le format de représentation de la réponse par défaut est JSON. Les requêtes doivent utiliser la méthode HTTP *GET*. Les formats de réponse suivants sont pris en charge.

  - json (application/json)

  - jsonp (application/javascript)

  - xls (application/vnd.ms-excel)

À titre d'exemple, pour obtenir une réponse au format Excel vous pouvez utiliser une extension de fichier dans l'URL de la requête comme ceci :

    /api/33/analytics/events/query/eBAyeGv0exc.xls?startDate=2016-01-01&endDate=2016-10-31
      &dimension=ou:O6uvpzGd5pu&dimension=oZg33kd9taw&dimension=qrur9Dvnyt5

Vous pouvez définir le paramètre de requête hierarchyMeta (hiérarchie de métadonnées) sur "true" pour inclure les noms de toutes les unités d'organisation ascendantes dans la section métadonnées de la réponse :

    /api/33/analytics/events/query/eBAyeGv0exc?startDate=2016-01-01&endDate=2016-10-31
      &dimension=ou:YuQRtpLP10I&dimension=qrur9Dvnyt5:EQ:50&hierarchyMeta=true

Le format JSON de réponse par défaut ressemblera à ceci :

```json
{
  "headers": [
    {
      "name": "psi",
      "column": "Event",
      "type": "java.lang.String",
      "hidden": false,
      "meta": false
    },
    {
      "name": "ps",
      "column": "Program stage",
      "type": "java.lang.String",
      "hidden": false,
      "meta": false
    },
    {
      "name": "eventdate",
      "column": "Event date",
      "type": "java.lang.String",
      "hidden": false,
      "meta": false
    },
    {
      "name": "coordinates",
      "column": "Coordinates",
      "type": "java.lang.String",
      "hidden": false,
      "meta": false
    },
    {
      "name": "ouname",
      "column": "Organisation unit name",
      "type": "java.lang.String",
      "hidden": false,
      "meta": false
    },
    {
      "name": "oucode",
      "column": "Organisation unit code",
      "type": "java.lang.String",
      "hidden": false,
      "meta": false
    },
    {
      "name": "ou",
      "column": "Organisation unit",
      "type": "java.lang.String",
      "hidden": false,
      "meta": false
    },
    {
      "name": "oZg33kd9taw",
      "column": "Gender",
      "type": "java.lang.String",
      "hidden": false,
      "meta": false
    },
    {
      "name": "qrur9Dvnyt5",
      "column": "Age",
      "type": "java.lang.String",
      "hidden": false,
      "meta": false
    }
  ],
  "metaData": {
    "names": {
      "qrur9Dvnyt5": "Age",
      "eBAyeGv0exc": "Inpatient morbidity and mortality",
      "ImspTQPwCqd": "Sierra Leone",
      "O6uvpzGd5pu": "Bo",
      "YuQRtpLP10I": "Badjia",
      "oZg33kd9taw": "Gender"
    },
    "ouHierarchy": {
      "YuQRtpLP10I": "/ImspTQPwCqd/O6uvpzGd5pu"
    }
  },
  "width": 8,
  "height": 4,
  "rows": [
    [
      "yx9IDINf82o",
      "Zj7UnCAulEk",
      "2016-08-05",
      "[5.12, 1.23]",
      "Ngelehun",
      "OU_559",
      "YuQRtpLP10I",
      "Female",
      "50"
    ],
    [
      "IPNa7AsCyFt",
      "Zj7UnCAulEk",
      "2016-06-12",
      "[5.22, 1.43]",
      "Ngelehun",
      "OU_559",
      "YuQRtpLP10I",
      "Female",
      "50"
    ],
    [
      "ZY9JL9dkhD2",
      "Zj7UnCAulEk",
      "2016-06-15",
      "[5.42, 1.33]",
      "Ngelehun",
      "OU_559",
      "YuQRtpLP10I",
      "Female",
      "50"
    ],
    [
      "MYvh4WAUdWt",
      "Zj7UnCAulEk",
      "2016-06-16",
      "[5.32, 1.53]",
      "Ngelehun",
      "OU_559",
      "YuQRtpLP10I",
      "Female",
      "50"
    ]
  ]
}
```

La section *en-têtes* de la réponse décrit le contenu du résultat de la requête. L'identifiant unique de l'événement, l'identifiant de l'étape de programme, la date de l'événement, le nom de l'unité d'organisation, le code de l'unité d'organisation et l'identifiant de l'unité d'organisation apparaissent en tant que six premières dimensions dans la réponse et seront toujours présents. Viennent ensuite les éléments de données, les attributs et identifiants de personnes qui ont été définis comme dimensions dans la demande ; il s'agit dans ce cas précis des dimensions d'éléments de données "Sexe" et "Âge". L'identifiant de l'élément de dimension se trouve dans la propriété "nom" et une description lisible de la dimension dans la propriété "colonne" de la section en-têtes.

La section *metaData*, objet *ou* (unité d'organisation), contient les identifiants de toutes les unités d'organisation présentes dans la réponse, mis en correspondance avec une chaîne qui représente la hiérarchie. Cette chaîne hiérarchique énumère les identifiants des ascendants de l'unité d'organisation en commençant par la racine. L'objet *noms* contient les identifiants de tous les éléments de la réponse mis en correspondance avec leurs noms.

La section *lignes* contient les événements produits par la requête. Chaque ligne représente exactement un événement.

Pour que la ressource analytique des événements génère les données dans un tableau tout fait, vous pouvez renseigner les paramètres *lignes* et *colonnes* avec les identifiants des dimensions requises. Ces identifiants doivent être séparés par des points-virgules ; elles serviront de valeurs pour indiquer quelles dimensions doivent être utilisées comme colonnes ou lignes du tableau. Au lieu de générer une source de données simples et normalisées, la ressource analytique d'événements va maintenant générer les données dans un tableau. Dans la requête, les dimensions des colonnes et des lignes doivent figurer en tant que dimensions de données (et non en tant que filtre). Une telle requête peut ressembler à ceci :

    /api/33/analytics.html+css?dimension=dx:cYeuwXTCPkU;fbfJHSPpUQD&dimension=pe:WEEKS_THIS_YEAR
      &filter=ou:ImspTQPwCqd&displayProperty=SHORTNAME&columns=dx&rows=pe

### Analyse agrégée des événements { #webapi_event_aggregate_analytics } 

La ressource `/analytics/events/aggregate` vous permet d'extraire des *nombres agrégés* d'événements capturés dans DHIS2. Cette ressource vous permet d'extraire des données agrégées liés à un programme spécifique ou éventuellement à une étape de programme. Elle vous permet également d'effectuer des filtrages en fonction d'une dimension d'événement quelconque.

    /api/33/analytics/events/aggregate

La ressource d'agrégation des événements ne renvoie pas les informations relatives à l'événement lui-même, mais plutôt les nombres agrégés d'événements correspondant à la requête. Les dimensions d'événements comprennent les éléments de données, les attributs de personnes, les identifiants de personnes, les périodes et les unités d'organisation. Les requêtes d'agrégation des événements doivent respecter le format décrit ci-dessous.

    /api/33/analytics/events/aggregate/<program-id>?startDate=yyyy-MM-dd&endDate=yyyy-MM-dd
      &dimension=ou:<ou-id>;<ou-id>&dimension=<item-id>&dimension=<item-id>:<operator>:<filter>

Par exemple, pour extraire des nombres agrégés des événements du programme "Morbidité et mortalité chez les patients hospitalisés" entre janvier et octobre 2016, où les éléments de données "Sexe" et "Âge" sont inclus, avec l'élément de dimension "Âge" filtré sur "18 ans" et l'élément de dimension "Sexe"  filtré sur "Femme", vous pouvez utiliser la requête suivante :

    /api/33/analytics/events/aggregate/eBAyeGv0exc?startDate=2016-01-01&endDate=2016-10-31
      &dimension=ou:O6uvpzGd5pu&dimension=oZg33kd9taw:EQ:Female&dimension=qrur9Dvnyt5:GT:50

Pour extraire des données relatives à des périodes fixes et relatives au lieu des dates de début et de fin, dans ce cas, mai 2016 et les 12 derniers mois, et l'unité d'organisation associée à l'utilisateur actuel, vous pouvez utiliser la requête suivante :

    /api/33/analytics/events/aggregate/eBAyeGv0exc?dimension=pe:201605;LAST_12_MONTHS
      &dimension=ou:USER_ORGUNIT;fdc6uOvgo7ji&dimension=oZg33kd9taw

Afin de spécifier "Femme" comme filtre pour le "Sexe" dans la réponse, ce qui signifie que "Sexe" ne fera pas partie de la réponse mais filtrera les nombres agrégés qu'il contient, vous pouvez utiliser la syntaxe suivante :

    /api/33/analytics/events/aggregate/eBAyeGv0exc?dimension=pe:2016;
      &dimension=ou:O6uvpzGd5pu&filter=oZg33kd9taw:EQ:Female

Pour spécifier l'unité d'organisation "Bo" et la période "2016" comme filtres, et le "Mode de sortie" et le "Sexe" comme dimensions, où le "Sexe" est filtré en fonction de l'élément "Masculin", vous pouvez utiliser une requête comme celle-ci :

    /api/33/analytics/events/aggregate/eBAyeGv0exc?filter=pe:2016&filter=ou:O6uvpzGd5pu
      &dimension=fWIAEtYVEGk&dimension=oZg33kd9taw:EQ:Male

Pour créer un "rapport de Top 3" pour le _Mode de sortie_, vous pouvez utiliser les paramètres de requête "limit" (limite) et sortOrder (ordre de tri) de la manière suivante :

    /api/33/analytics/events/aggregate/eBAyeGv0exc?filter=pe:2016&filter=ou:O6uvpzGd5pu
      &dimension=fWIAEtYVEGk&limit=3&sortOrder=DESC

Pour spécifier une dimension de valeur avec un type d'agrégation correspondant, vous pouvez utiliser les paramètres de requête "value" (valeur) et "aggregationType" (type d'aggrégation). En spécifiant une dimension de valeur, le moteur d'analyse renverra des valeurs agrégées pour les valeurs de cette dimension dans la réponse, plutôt que des nombres d'événements.

    /api/33/analytics/events/aggregate/eBAyeGv0exc.json?stage=Zj7UnCAulEk
      &dimension=ou:ImspTQPwCqd&dimension=pe:LAST_12_MONTHS&dimension=fWIAEtYVEGk
      &value=qrur9Dvnyt5&aggregationType=AVERAGE

Pour que l'agrégation des analyses d'événements se fasse en fonction d'un élément de données ou d'un attribut spécifique de type 'date' ou 'date et heure', vous pouvez utiliser le paramètre `timeField` (champ de temps) :

    /api/33/analytics/events/aggregate/IpHINAT79UW.json?dimension=ou:ImspTQPwCqd
      &dimension=pe:LAST_12_MONTHS&dimension=cejWyOfXge6&stage=A03MvHHogjR
      &timeField=ENROLLMENT_DATE

Pour que l'agrégation des analyses d'événements se fasse en fonction d'un élément de données ou d'un attribut spécifique de type 'unité d'organisation', vous pouvez utiliser le paramètre `orgUnitField` (champ d'unité d'organisation) :

    /api/33/analytics/events/aggregate/eBAyeGv0exc.json?dimension=ou:ImspTQPwCqd
      &dimension=pe:THIS_YEAR&dimension=oZg33kd9taw&stage=Zj7UnCAulEk
      &orgUnitField=S33cRBsnXPo

#### Plages / jeux de légendes { #ranges-legend-sets } 

Pour les requêtes d'agrégation, vous pouvez spécifier une plage ou un ensemble de légendes pour les éléments de données numériques et les dimensions d'attributs. L'objectif est de regrouper les valeurs numériques dans des plages. Par exemple, au lieu de générer des données pour un élément de données "Âge" pour des années différentes, vous pouvez regrouper les informations par tranche d'âge. Pour ce faire, l'élément de données ou l'attribut doit être associé à l'ensemble de légendes. Le format est décrit ci-dessous :

    ?dimension=<item-id>-<legend-set-id>

Voici donc un exemple :

    /api/33/analytics/events/aggregate/eBAyeGv0exc.json?stage=Zj7UnCAulEk
      &dimension=qrur9Dvnyt5-Yf6UHoPkdS6&dimension=ou:ImspTQPwCqd&dimension=pe:LAST_MONTH

#### Formats de réponse { #response-formats } 

Le format de représentation de réponse par défaut est JSON. Les requêtes doivent utiliser la méthode HTTP *GET*. La réponse va ressembler à ceci :

```json
{
  "headers": [
    {
      "name": "oZg33kd9taw",
      "column": "Gender",
      "type": "java.lang.String",
      "meta": false
    },
    {
      "name": "qrur9Dvnyt5",
      "column": "Age",
      "type": "java.lang.String",
      "meta": false
    },
    {
      "name": "pe",
      "column": "Period",
      "type": "java.lang.String",
      "meta": false
    },
    {
      "name": "ou",
      "column": "Organisation unit",
      "type": "java.lang.String",
      "meta": false
    },
    {
      "name": "value",
      "column": "Value",
      "type": "java.lang.String",
      "meta": false
    }
  ],
  "metaData": {
    "names": {
      "eBAyeGv0exc": "Inpatient morbidity and mortality"
    }
  },
  "width": 5,
  "height": 39,
  "rows": [
    [
      "Female",
      "95",
      "201605",
      "O6uvpzGd5pu",
      "2"
    ],
    [
      "Female",
      "63",
      "201605",
      "O6uvpzGd5pu",
      "2"
    ],
    [
      "Female",
      "67",
      "201605",
      "O6uvpzGd5pu",
      "1"
    ],
    [
      "Female",
      "71",
      "201605",
      "O6uvpzGd5pu",
      "1"
    ],
    [
      "Female",
      "75",
      "201605",
      "O6uvpzGd5pu",
      "14"
    ],
    [
      "Female",
      "73",
      "201605",
      "O6uvpzGd5pu",
      "5"
    ]
  ]
}
```

La limite maximale de lignes que peut comporter une réponse est de 10 000.
Si la requête produit plus que la limite maximale, un code de statut *409 Conflict* sera renvoyé.

### Analyse des événements en grappes{ #webapi_event_clustering_analytics } 

La ressource *analytics/events/cluster* fournit des données géospatiales en grappe. Une requête se présente comme suit :

    /api/33/analytics/events/cluster/eBAyeGv0exc?startDate=2016-01-01&endDate=2016-10-31
      &dimension=ou:LEVEL-2&clusterSize=100000
      &bbox=-13.2682125,7.3721619,-10.4261178,9.904012&includeClusterPoints=false

La réponse fournit le nombre de points sous-jacents, le point central et l'étendue de chaque grappe. Si le paramètre de requête `includeClusterPoints` (inclure des points en grappe) est défini sur 'true' (vrai), une chaîne contenant les identifiants des événements sous-jacents, séparés par des virgules, sera incluse dans la réponse. Voici un exemple de réponse :

```json
{
  "headers": [
    {
      "name": "count",
      "column": "Count",
      "type": "java.lang.Long",
      "meta": false
    },
    {
      "name": "center",
      "column": "Center",
      "type": "java.lang.String",
      "meta": false
    },
    {
      "name": "extent",
      "column": "Extent",
      "type": "java.lang.String",
      "meta": false
    },
    {
      "name": "points",
      "column": "Points",
      "type": "java.lang.String",
      "meta": false
    }
  ],
  "width": 3,
  "height": 4,
  "rows": [
    [
      "3",
      "POINT(-13.15818 8.47567)",
      "BOX(-13.26821 8.4St7215,-13.08711 8.47807)",
      ""
    ],
    [
      "9",
      "POINT(-13.11184 8.66424)",
      "BOX(-13.24982 8.51961,-13.05816 8.87696)",
      ""
    ],
    [
      "1",
      "POINT(-12.46144 7.50597)",
      "BOX(-12.46144 7.50597,-12.46144 7.50597)",
      ""
    ],
    [
      "7",
      "POINT(-12.47964 8.21533)",
      "BOX(-12.91769 7.66775,-12.21011 8.49713)",
      ""
    ]
  ]
}
```

### Analyse du nombre d'événements et de la portée { #webapi_event_count_extent_analytics } 

The *analytics/events/count* resource is suitable for geometry-related
requests for retrieving the count and extent (bounding box) of events
for a specific query. The query syntax is equal to the *events/query*
resource. A request looks like
    this:

    /api/33/analytics/events/count/eBAyeGv0exc?startDate=2016-01-01
      &endDate=2016-10-31&dimension=ou:O6uvpzGd5pu

La réponse va fournir le nombre et l'étendue dans le format JSON :

```json
{
  extent: "BOX(-13.2682125910096 7.38679562779441,-10.4261178860988 9.90401290212795)",
  count: 59
}
```

### Contraintes et validation { #webapi_event_analytics_constraints } 

Les paramètres d'entrée que vous pouvez fournir à la ressource d'analyse des événements sont soumis à plusieurs contraintes. Si l'une de ces contraintes n'est pas respectée, l'API renvoie une réponse *409 Conflict* avec un message semblable à celui-ci :

```json
{
  "httpStatus": "Conflict",
  "httpStatusCode": 409,
  "status": "ERROR",
  "message": "At least one organisation unit must be specified",
  "errorCode": "E7200"
}
```

Les erreurs de validation possibles pour l'API d'analyse d'événements sont décrites dans le tableau ci-dessous.

| Code d'erreur | Message |
| ---------- | ------- |
| E7200      | Au moins une unité d'organisation doit être spécifiée |
| E7201      | Les dimensions ne peuvent pas être spécifiées plus d'une fois |
| E7202      | Les éléments de la requête ne peuvent pas être spécifiés plus d'une fois |
| E7203      | Une dimension de valeur ne peut pas être spécifiée en tant qu'élément ou filtre d'élément. |
| E7204      | La dimension de valeur ou les données agrégées doivent être spécifiées lorsque le type d'agrégation est spécifié. |
| E7205      | Les dates de début et de fin ou au moins une période doivent être spécifiées. |
| E7206      | La date de début est postérieure à la date de fin |
| E7207      | Le numéro de page doit être un nombre positif |
| E7208      | La taille de la page doit être zéro ou nombre positif |
| E7209      | La limite est supérieure à la limite maximale |
| E7210      | Le champ de l'heure n'est pas valide |
| E7211      | Le champ de l'unité d'organisation n'est pas valide |
| E7212      | La taille de la grappe doit être un nombre positif |
| E7213      | La zone de délimitation n'est pas valide ; elle doit être au format : 'min-lng,min-lat,max-lng,max-lat' |
| E7214      | Le champ de la grappe doit être renseigné lorsque la zone de délimitation ou la taille de la grappe sont spécifiées. |
| E7215      | L'élément de requête ne peut pas spécifier à la fois un ensemble de légendes et un ensemble d'options. |
| E7216      | L'élément de requête doit pouvoir être agrégé lorsqu'il est utilisé dans une requête agrégée. |
| E7217      | L'utilisateur n'est pas autorisé à consulter les données d'analyse des événements |
| E7218      | La prise en charge des bases de données spatiales n'est pas activée |
| E7219      | L'élément de données doit être de type "coordonnée" pour pouvoir être utilisé comme champ de coordonnées. |
| E7220      | L'attribut doit être de type "coordonnée" pour pouvoir être utilisé comme champ de coordonnées. |
| E7221      | Le champ de coordonnées n'est pas valide |
| E7222      | L'élément de requête ou le filtre n'est pas valide |
| E7223      | La valeur ne fait pas référence à un élément de données ou à un attribut qui sont numériques et font partie du programme. |
| E7224      | L'identifiant d'élément ne fait référence à aucun élément de données, attribut ou indicateur qui fait partie du programme. |
| E7225      | L'étape de programme est obligatoire pour les dimensions de l'élément de données dans les requêtes d'analyse d'inscriptions. |
| E7226      | La dimension n'est pas un élément de requête valide |
| E7227      | Le type d'entité 'relation' n'est pas pris en charge |

## Analyse des inscriptions { #webapi_enrollment_analytics } 

L'API d'analyse des inscriptions vous permet d'accéder aux données agrégées des événements et d'interroger les *inscriptions avec leurs données d'événements* capturées dans DHIS2. Cette ressource vous permet d'extraire des données d'un programme à partir des étapes du programme et des éléments de données, en plus des attributs d'entités suivies. Lorsque vous effectuez une requête sur des données d'événements pour des étapes spécifiques d'un programme au sein de chaque inscription, les valeurs des éléments de données pour chaque étape du programme seront renvoyées dans une même ligne dans la réponse de l'API. Si vous effectuez une requête sur un élément de données dans une étape répétable du programme, la valeur la plus récente de l'élément de données sera utilisée pour cet élément de données dans la réponse de l'API.

### Dimensions et éléments { #webapi_enrollment_analytics_dimensions } 

Les dimensions d'inscription comprennent les éléments de données, les attributs, les unités d'organisation et les périodes. La ressource d'analyse des requêtes renvoie simplement les inscriptions correspondant à un ensemble de critères et n'effectue aucune agrégation.



Tableau : Dimensions dl'inscription

| Dimension | Identifiant de la dimension | Description |
|---|---|---|
| Éléments de données dans les étapes du programme | <program stage id\>.<data element id\> | Les identifiants des éléments de données doivent inclure l'étape de programme lors de la requête de données pour les inscriptions. 
dimension=edqlbukwRfQ.vANAXwtLwcT |
| Attributs | <id\> | Identifiants d'attribut |
| Périodes | pe | Périodes ISO et périodes relatives, voir "format de date et de période" |
| Unités d’organisation | ou | Identifiants d'unité d'organisation et mots-clés USER_ORGUNIT, USER_ORGUNIT_CHILDREN, USER_ORGUNIT_GRANDCHILDREN, LEVEL-<level\> et OU_GROUP-<group-id\> |

### Analyse des requêtes d'inscription { #webapi_enrollment_query_analytics } 

The *analytics/enrollments/query* resource lets you query for captured enrollments. This resource does not perform any aggregation, rather it lets you query and filter for information about enrollments.

    /api/33/analytics/enrollments/query

Vous pouvez spécifier un nombre quelconque de dimensions et de filtres dans une requête. Les identifiants d'éléments de dimension peuvent faire référence à tout élément de données dans des étapes de programme, des attributs de personnes, des périodes fixes et relatives et des unités d'organisation. Les dimensions peuvent éventuellement être accompagnées d'un opérateur de requête et d'un filtre. Les requêtes d'inscription doivent respecter le format décrit ci-dessous.

    /api/33/analytics/enrollments/query/<program-id>?startDate=yyyy-MM-dd&endDate=yyyy-MM-dd
      &dimension=ou:<ou-id>;<ou-id>&dimension=<item-id>&dimension=<item-id>:<operator>:<filter>

Par exemple, pour extraire des inscriptions au programme "Soins prénatals" à partir de janvier 2019, où le "Prénom" est tiré des attributs, les éléments de données "Maladies chroniques" et "Tabagisme" sont inclus à partir de la première étape du programme, la "Valeur de l'hémoglobine" à partir de l'étape suivante du programme, et où seules les femmes atteintes de "Maladies chroniques" sont incluses, vous pouvez utiliser la requête suivante :

    /api/33/analytics/enrollments/query/WSGAb5XwJ3Y.json?dimension=ou:ImspTQPwCqd
      &dimension=w75KJ2mc4zz&dimension=WZbXY0S00lP.de0FEHSIoxh:eq:1&dimension=w75KJ2mc4zz
      &dimension=WZbXY0S00lP.sWoqcoByYmD&dimension=edqlbukwRfQ.vANAXwtLwcT
      &startDate=2019-01-01&endDate=2019-01-31

Pour extraire des inscriptions au programme "Soins prénatals" à partir du mois dernier (par rapport au moment où la requête est effectuée), où les éléments de données "Maladies chroniques" et "Tabagisme" sont inclus à partir de la première étape du programme, et "Valeur de l'hémoglobine" à partir de l'étape de suivi du programme, et où seules les femmes fumeuses avec un taux d'hémoglobine inférieur à 20 sont prises en compte :

    /api/33/analytics/enrollments/query/WSGAb5XwJ3Y.json?dimension=ou:ImspTQPwCqd
      &dimension=WZbXY0S00lP.de0FEHSIoxh&dimension=w75KJ2mc4zz
      &dimension=WZbXY0S00lP.sWoqcoByYmD:eq:1&dimension=edqlbukwRfQ.vANAXwtLwcT:lt:20
      &dimension=pe:LAST_MONTH

Un tri peut être appliqué à la requête pour les dates d'inscription et d'incident :

    /api/33/analytics/enrollments/query/WSGAb5XwJ3Y.xls?dimension=ou:ImspTQPwCqd
      &columns=w75KJ2mc4zz&dimension=WZbXY0S00lP.sWoqcoByYmD&dimension=pe:LAST_MONTH
      &stage=WZbXY0S00lP&pageSize=10&page=1&asc=ENROLLMENTDATE&ouMode=DESCENDANTS

Vous pouvez appliquer la pagination à la requête à travers les paramètres de numéro de page et de taille de page. Si le numéro de page est spécifié mais que la taille de la page ne l'est pas, la taille de page "50" sera utilisée. Si la taille de la page est spécifiée mais que le numéro de page ne l'est pas, le numéro de page "1" sera utilisé. Pour obtenir la deuxième page de la réponse avec une taille de page de 10, vous pouvez utiliser la requête suivante :

    /api/33/analytics/enrollments/query/WSGAb5XwJ3Y.json?dimension=ou:ImspTQPwCqd
      &dimension=WZbXY0S00lP.de0FEHSIoxh&dimension=w75KJ2mc4zz&dimension=pe:LAST_MONTH
      &dimension=WZbXY0S00lP.sWoqcoByYmD&pageSize=10&page=2

#### Filtrage { #filtering } 

Des filtres peuvent être appliqués aux éléments de données, aux attributs de personnes et aux identifiants de personnes. Le filtrage est effectué par le biais de la valeur du paramètre de la requête dans le format suivant :

    &dimension=<item-id>:<operator>:<filter-value>

À titre d'exemple, vous pouvez filtrer l'élément de données "Poids" pour les valeurs supérieures à 2000 et inférieures à 4000 comme suit :

    &dimension=WZbXY0S00lP.UXz7xuGCEhU:GT:2000&dimension=WZbXY0S00lP.UXz7xuGCEhU:LT:4000

Vous pouvez filtrer l'attribut "Âge" pour plusieurs âges spécifiques à l'aide de l'opérateur IN comme dans l'exemple suivant :

    &dimension=qrur9Dvnyt5:IN:18;19;20

Vous pouvez spécifier plusieurs filtres pour un élément donné en répétant les composants de l'opérateur et du filtre, tous séparés par des points-virgules :

    &dimension=qrur9Dvnyt5:GT:5:LT:15

##### Mot-clé NV { #nv-keyword } 
Un mot-clé spécial `NV` peut être utilisé pour filtrer les valeurs `null` (nulles).

Filtrer par ÂGE est nul

    &dimension=qrur9Dvnyt5:EQ:NV

Filtrer par ÂGE est non nul

    &dimension=qrur9Dvnyt5:NE:NV

Le filtrage par l'ÂGE est 18, 19 ou est nul

    &dimension=qrur9Dvnyt5:IN:18;19;NV

`NV` peut être utilisé avec les opérateurs `EQ`, `NE` et `IN`.

##### Opérateurs { #operators } 

Les opérateurs disponibles sont répertoriés ci-dessous.

Tableau : Opérateurs de filtre

| Opérateur | Description |
|---|---|
| EQ | Egale à |
| GT | Supérieure à |
| GE | Supérieure ou égal à |
| LT | Inférieur à |
| LE | inférieur ou égal à |
| NE | Pas égal à |
| LIKE | Pareil (correspondance textuelle) |
| IN | Égal à l'une des multiples valeurs séparées par ";" |

### Paramètres de requête { #webapi_enrollment_analytics_query_parameters } 

L'API de requête d'inscription analytique vous permet de spécifier un ensemble de paramètres de requête.



Tableau : Paramètres de requête pour le point d'extrémité de la requête d'inscription

| Paramètre de requête | Obligatoire | Description | Options (par défaut en premier) |
|---|---|---|---|
| de paludisme) ». | Oui | Identifiant du programme. | Tout identifiant de programme |
| date de début | Non | Date de début des inscriptions. | Les dates doivent être au format aaaa-MM-jj |
| date de fin | Non | Date de fin des inscriptions. | Les dates doivent être au format aaaa-MM-jj |
| dimension | Oui | L'identifiant de dimension comprend les éléments de données, les attributs, les indicateurs de programme, les périodes, les unités d'organisation et les ensembles de groupes d'unités d'organisation. Le paramètre peut être répété autant de fois que nécessaire. Des filtres d'éléments peuvent être appliqués à une dimension selon le format <item-id\>:<operator\>:<filter\>. Les valeurs des filtres ne sont pas sensibles à la casse. | Les opérateurs peuvent être EQ &#124; GT&#124; GE&#124; LT&#124; LE&#124; NE &#124; COMME &#124; DANS |
| filtre | Non | L'identifiant de dimension comprend les éléments de données, les attributs, les périodes, les unités d'organisation et les ensembles de groupes d'unités d'organisation. Le paramètre peut être répété autant de fois que nécessaire. Des filtres d'éléments peuvent être appliqués à une dimension selon le format <item-id\>:<operator\>:<filter\>. Les valeurs des filtres ne sont pas sensibles à la casse. ||
| programStatus (statut de programme) | Non | Spécifie le statut d’inscription des inscriptions à inclure. | ACTIF &#124; TERMINÉ &#124; ANNULÉ |
| relativePeriodDate (Date de la période relative) | chaîne | Non | Identifiant de date, par exemple : "2016-01-01". Il remplace la date de début de la période relative |
| ou Mode | Non | The mode of selecting organisation units. Default is DESCENDANTS, meaning all sub units in the hierarchy. CHILDREN refers to immediate children in the hierarchy; SELECTED refers to the selected organisation units only. | DESCENDANTS, CHILDREN, SELECTED |
| asc | Non | Permet de trier les dimensions par ordre croissant ; peut concerner la date d'inscription, la date d'incident, le nom et le code de l'unité d'organisation. | ENROLLMENTDATE &#124; INCIDENTDATE&#124; OUNAME &#124; OUCODE |
| desc | Non | Permet de trier les dimensions dans l'ordre décroissant ; peut concerner la date d'inscription, la date d'incident, le nom et le code de l'unité d'organisation. | ENROLLMENTDATE &#124; INCIDENTDATE&#124; OUNAME &#124; OUCODE |
| coordinatesOnly (coordonnées uniquement) | Non | Indique s'il faut uniquement renvoyer les inscriptions qui ont des coordonnées. | faux &#124; vrai |
| page | Non | Le numéro de page. La page par défaut est 1. | Valeur numérique positive |
| taille de la page | Non | La taille de la page. La taille par défaut est de 50 éléments par page. | Zéro ou valeur positive |

#### Formats de réponse { #response-formats } 

Le format de représentation de réponse par défaut est JSON. Les requêtes doivent utiliser la méthode HTTP *GET*. Les formats de réponse suivants sont pris en charge.

  - json (application/json)
  - xml (application/xml)
  - xls (application/vnd.ms-excel)
  - csv (application/csv)
  - html (texte/html)
  - html+css (texte/html)

À titre d'exemple, pour obtenir une réponse au format Excel, vous pouvez utiliser une extension de fichier dans l'URL de la requête comme ceci :

    /api/33/analytics/enrollments/query/WSGAb5XwJ3Y.xls?dimension=ou:ImspTQPwCqd
      &dimension=WZbXY0S00lP.de0FEHSIoxh&columns=w75KJ2mc4zz
      &dimension=WZbXY0S00lP.sWoqcoByYmD&dimension=pe:LAST_MONTH&stage=WZbXY0S00lP
      &pageSize=10&page=1&asc=ENROLLMENTDATE&ouMode=DESCENDANTS

Le format JSON de réponse par défaut ressemblera à ceci :

```json
{
  "headers": [
    {
      "name": "pi",
      "column": "Enrollment",
      "valueType": "TEXT",
      "type": "java.lang.String",
      "hidden": false,
      "meta": true
    },
    {
      "name": "tei",
      "column": "Tracked entity instance",
      "valueType": "TEXT",
      "type": "java.lang.String",
      "hidden": false,
      "meta": true
    },
    {
      "name": "enrollmentdate",
      "column": "Enrollment date",
      "valueType": "DATE",
      "type": "java.util.Date",
      "hidden": false,
      "meta": true
    },
    {
      "name": "incidentdate",
      "column": "Incident date",
      "valueType": "DATE",
      "type": "java.util.Date",
      "hidden": false,
      "meta": true
    },
    {
      "name": "geometry",
      "column": "Geometry",
      "valueType": "TEXT",
      "type": "java.lang.String",
      "hidden": false,
      "meta": true
    },
    {
      "name": "longitude",
      "column": "Longitude",
      "valueType": "NUMBER",
      "type": "java.lang.Double",
      "hidden": false,
      "meta": true
    },
    {
      "name": "latitude",
      "column": "Latitude",
      "valueType": "NUMBER",
      "type": "java.lang.Double",
      "hidden": false,
      "meta": true
    },
    {
      "name": "ouname",
      "column": "Organisation unit name",
      "valueType": "TEXT",
      "type": "java.lang.String",
      "hidden": false,
      "meta": true
    },
    {
      "name": "oucode",
      "column": "Organisation unit code",
      "valueType": "TEXT",
      "type": "java.lang.String",
      "hidden": false,
      "meta": true
    },
    {
      "name": "ou",
      "column": "Organisation unit",
      "valueType": "TEXT",
      "type": "java.lang.String",
      "hidden": false,
      "meta": true
    },
    {
      "name": "de0FEHSIoxh",
      "column": "WHOMCH Chronic conditions",
      "valueType": "BOOLEAN",
      "type": "java.lang.Boolean",
      "hidden": false,
      "meta": true
    },
    {
      "name": "sWoqcoByYmD",
      "column": "WHOMCH Smoking",
      "valueType": "BOOLEAN",
      "type": "java.lang.Boolean",
      "hidden": false,
      "meta": true
    }
  ],
  "metaData": {
    "pager": {
      "page": 2,
      "total": 163,
      "pageSize": 4,
      "pageCount": 41
    },
    "items": {
      "ImspTQPwCqd": {
        "name": "Sierra Leone"
      },
      "PFDfvmGpsR3": {
        "name": "Care at birth"
      },
      "bbKtnxRZKEP": {
        "name": "Postpartum care visit"
      },
      "ou": {
        "name": "Organisation unit"
      },
      "PUZaKR0Jh2k": {
        "name": "Previous deliveries"
      },
      "edqlbukwRfQ": {
        "name": "Antenatal care visit"
      },
      "WZbXY0S00lP": {
        "name": "First antenatal care visit"
      },
      "sWoqcoByYmD": {
        "name": "WHOMCH Smoking"
      },
      "WSGAb5XwJ3Y": {
        "name": "WHO RMNCH Tracker"
      },
      "de0FEHSIoxh": {
        "name": "WHOMCH Chronic conditions"
      }
    },
    "dimensions": {
      "pe": [],
      "ou": [
        "ImspTQPwCqd"
      ],
      "sWoqcoByYmD": [],
      "de0FEHSIoxh": []
    }
  },
  "width": 12,
  "rows": [
    [
      "A0cP533hIQv",
      "to8G9jAprnx",
      "2019-02-02 12:05:00.0",
      "2019-02-02 12:05:00.0",
      "",
      "0.0",
      "0.0",
      "Tonkomba MCHP",
      "OU_193264",
      "xIMxph4NMP1",
      "0",
      "1"
    ],
    [
      "ZqiUn2uXmBi",
      "SJtv0WzoYki",
      "2019-02-02 12:05:00.0",
      "2019-02-02 12:05:00.0",
      "",
      "0.0",
      "0.0",
      "Mawoma MCHP",
      "OU_254973",
      "Srnpwq8jKbp",
      "0",
      "0"
    ],
    [
      "lE747mUAtbz",
      "PGzTv2A1xzn",
      "2019-02-02 12:05:00.0",
      "2019-02-02 12:05:00.0",
      "",
      "0.0",
      "0.0",
      "Kunsho CHP",
      "OU_193254",
      "tdhB1JXYBx2",
      "",
      "0"
    ],
    [
      "nmcqu9QF8ow",
      "pav3tGLjYuq",
      "2019-02-03 12:05:00.0",
      "2019-02-03 12:05:00.0",
      "",
      "0.0",
      "0.0",
      "Korbu MCHP",
      "OU_678893",
      "m73lWmo5BDG",
      "",
      "1"
    ]
  ],
  "height": 4
}
```

La section *en-têtes* de la réponse décrit le contenu du résultat de la requête. L'identifiant unique de l'inscription, l'identifiant de l'instance d'entité suivie, la date de l'inscription, le nom de l'incident, la géométrie, la latitude, la longitude, le nom et le code de l'unité d'organisation apparaissent en tant que premières dimensions dans la réponse et seront toujours présents. Viennent ensuite les éléments de données, les attributs d'entité suivie qui ont été définis comme dimensions dans la demande ; il s'agit dans ce cas précis des dimensions d'éléments de données "WHOMCH maladies chroniques" et "WHOMCH fumeurs". L'identifiant de l'élément de dimension se trouve dans la propriété "nom" et une description lisible de la dimension dans la propriété "colonne" de la section en-têtes.

La section *metaData*, objet *ou* (unité d'organisation), contient les identifiants de toutes les unités d'organisation présentes dans la réponse, mis en correspondance avec une chaîne qui représente la hiérarchie. Cette chaîne hiérarchique énumère les identifiants des ascendants de l'unité d'organisation en commençant par la racine. L'objet *noms* contient les identifiants de tous les éléments de la réponse mis en correspondance avec leurs noms.

La section *lignes* contient les inscriptions produites par la requête. Chaque ligne représente exactement un inscription.

### Analyse des relations entre les TEI et les indicateurs de programme { #analytics-across-tei-relationships-with-program-indicators } 

L'API d'analyse des inscriptions sans agrégation permet également de relier les indicateurs de programme aux types de relations, afin d'afficher le résultat du calcul d'un indicateur de programme spécifique, appliqué aux entités liées à l'instance d'entité suivie répertoriée.

![](resources/images/enrollments/enrollments-pi-relationship.jpg)

For the Program Indicator/Relationship Type link to work, the `/api/33/analytics/enrollments/query` API requires an additional dimension which must include the chosen Relationship Type UID and the chosen Program Indicator UID:

    /api/33/analytics/enrollments/query/<program-id>
      ?dimension=<relationshiptype-id>.<programindicator-id>

Par exemple, pour extraire une liste d'inscriptions du programme "WHO RMNCH Tracker" pour janvier 2019 et afficher le nombre de cas de paludisme liés à cette inscription par le type de relation "Cas de paludisme lié à une personne", vous pouvez utiliser la requête suivante :

    /api/33/analytics/enrollments/query/WSGAb5XwJ3Y.json?dimension=mxZDvSZYxlw.nFICjJluo74
      &startDate=2019-01-01&endDate=2019-01-31    

L'API permet d'utiliser des indicateurs de programme qui ne sont pas associés au programme "principal" (c'est-à-dire le programme dont l'ID est spécifié après `/query/`).

## Analyse des unités d'organisation { #webapi_org_unit_analytics } 

L'API d'analyse des unités d'organisation fournit des statistiques sur les unités d'organisation classées par ensembles de groupes d'unités d'organisation, c'est-à-dire le nombre d'unités d'organisation dans chaque groupe au sein des ensembles de groupes d'unités d'organisation.

    GET /api/orgUnitAnalytics?ou=<org-unit-id>&ougs=<org-unit-group-set-id>

L'API requiert au moins une unité d'organisation et au moins un ensemble de groupes d'unités d'organisation. Plusieurs unités d'organisation et ensembles de groupes peuvent être fournis, séparés par un point-virgule.

### Paramètres de requête{ #request-query-parameters }

La ressource analytique des unités d'organisation vous permet de spécifier un ensemble de paramètres d'interrogation :



Tableau : Paramètres de requête analytique pour les unités d'organisation

| Propriété | Description | Obligatoire |
|---|---|---|
| ou | Identifiants d'unités d'organisation, éventuellement séparés par un point-virgule. | Oui |
| ougs | Identifiants des ensembles de groupes d'unités d'organisation, éventuellement séparés par un point-virgule. | Oui |
| colonnes | Identifiants des ensembles de groupes d'unités d'organisation, éventuellement séparés par un point-virgule. Ils déterminent les ensembles de groupes qui apparaissent sous forme de colonnes dans un tableau. | Non |

La réponse contiendra une colonne pour l'unité d'organisation mère, des colonnes pour chaque groupe d'unités d'organisation faisant partie de la requête et une colonne pour le nombre d'unités d'organisation. Les statistiques comprennent le nombre d'unités d'organisation qui se trouvent en dessous des unités d'organisation spécifiées dans la requête. La réponse contient une section 'métadonnées' qui spécifie le nom de chaque unité d'organisation et de chaque groupe d'unités d'organisation qui font partie de la réponse. Elles sont référencées par leurs identifiants.

La réponse par défaut comporte une seule colonne `count`. Elle peut être présentée dans un tableau dans lequel au moins un groupe d'unités d'organisation est spécifié à l'aide du paramètre de requête `columns`.

### Formats de réponse { #response-formats } 

Le point d'extrémité analytique des unités d'organisation rend en charge les formats de représentation suivants :

- json (application/json)
- csv (application/csv)
- xls (application/vnd.ms-excel)
- pdf (candidature/pdf)

### Exemples { #examples }

Pour obtenir des analyses d'unité d'organisation pour une unité d'organisation et un ensemble de groupes d'unités d'organisation :

    GET /api/orgUnitAnalytics?ou=lc3eMKXaEfw&ougs=J5jldMd8OHv

Pour obtenir des  données analytiques d'unité d'organisation pour deux unités d'organisation et deux ensembles de groupes d'unités d'organisation, utilisez ce qui suit :

    GET /api/orgUnitAnalytics?ou=lc3eMKXaEfw;PMa2VCrupOd&ougs=J5jldMd8OHv;Bpx0589u8y0

Pour obtenir des données analytiques d'unité d'organisation dans un tableau avec un ensemble de groupes présenté dans des colonnes, utilisez ceci :

    GET /api/orgUnitAnalytics?ou=fdc6uOvgoji;jUb8gELQApl;lc3eMKXaEfw;PMa2VCrupOd
      &ougs=J5jldMd8OHv&columns=J5jldMd8OHv

### Contraintes et validation { #constraints-and-validation }

Les éventuelles erreurs de validation spécifiques à l'API d'analyse des unités d'organisation sont décrites dans le tableau ci-dessous. Certaines erreurs spécifiées pour l'API d'analyse agrégée sont également concernées.

| Code d'erreur | Message |
| ---------- | ------- |
| E7300      | Au moins une unité d'organisation doit être spécifiée |
| E7301      | Au moins un ensemble de groupes d'unités d'organisation doit être spécifié. |

## Rapport sur l'ensemble de données { #webapi_data_set_report } 

Les rapports sur les ensembles de données peuvent être générés avec l'API Web, à l'aide de la ressource `/dataSetReport`. Cette ressource génère des rapports sur les ensembles de données et renvoie le résultat dans un un tableau HTML.

    /api/33/dataSetReport

### Paramètres de requête{ #request-query-parameters }

La requête prend en charge les paramètres suivants :



Tableau : Paramètres de requête du rapport sur l'ensemble de données

| Paramètre | Description | Type | Obligatoire |
|---|---|---|---|
| ds | L'ensemble de données à partir duquel le rapport est créé. | UID de l'ensemble de données | Oui |
| pe | La ou les période(s) à partir de laquelle/desquelles le rapport doit être créé. Il peut s'agir d'une liste dont les éléments sont séparés par des virgules. | Chaîne ISO | Oui |
| ou | L'unité d'organisation à partir de laquelle le rapport doit être créé. | L'UID de l'unité d'organisation | Oui |
| filtre | Les filtres à utiliser pour le rapport ; ils peuvent être répétés autant de fois que nécessaire. Ils viennent juste après la syntaxe de l'API analytique. | Un ou plusieurs UID | Non |
| selectedUnitOnly (unité sélectionnée uniquement) | Détermine s'il faut utiliser les données saisies uniquement ou les données agrégées. | Booléen | Non |

La ressource du rapport sur les ensembles de données accepte uniquement les requêtes `GET`. Le contenu de la réponse est de type `application/json` et les données sont renvoyées dans une grille. Ce point d'extrémité fonctionne pour tous les types d'ensemble de données, notamment les formulaires par défaut, les formulaires à sections et les formulaires personnalisés.

Voici un exemple de requête d'extraction d'un rapport pour un ensemble de données mensuel et une unité d'organisation pour le mois d'octobre 2018 :

    GET /api/33/dataSetReport?ds=BfMAe6Itzgt&pe=201810&ou=ImspTQPwCqd&selectedUnitOnly=false

Voici un exemple de requête d'extraction d'un rapport pour un ensemble de données mensuel et une unité d'organisation pour octobre, novembre et décembre 2018 :

    GET /api/33/dataSetReport?ds=BfMAe6Itzgt&pe=201810,201811,201812&ou=ImspTQPwCqd&selectedUnitOnly=false

Pour obtenir un rapport sur un ensemble de données avec un filtre, vous pouvez utiliser le paramètre `filter`. Dans ce cas, le filtre se base sur un ensemble de groupes d'unités d'organisation et deux groupes d'unités d'organisation :

    GET /api/33/dataSetReport?ds=BfMAe6Itzgt&pe=201810&ou=ImspTQPwCqd
      &filter=J5jldMd8OHv:RXL3lPSK8oG;tDZVQ1WtwpA

### Formats de réponse { #response-formats } 

Le point d'extrémité du rapport sur l'ensemble de données prend en charge les formats de sortie suivants. Vous pouvez récupérer un point d'extrémité spécifique en utilisant l'extension du fichier ou l'en-tête HTTP `Accept`.

- json (application/json)
- pdf (candidature/pdf)
- xls (application/vnd.ms-excel)

### Formulaires personnalisés { #custom-forms } 

Un point d'extrémité spécifique est disponible pour les ensembles de données avec des formulaires HTML personnalisés. Ce point d'extrémité renvoie le contenu du formulaire HTML au format `text/html` avec les données qui y sont insérées. Vous pouvez également utiliser le point d'extrémité du rapport général sur les ensembles de données pour les ensembles de données avec des formulaires personnalisés. Cependant, ce point d'extrémité renverra le rapport au format JSON dans une grille. Ce point d'extrémité ne fonctionne que pour les ensembles de données avec des formulaires HTML personnalisés.

    GET /api/33/dataSetReport/custom

La syntaxe de ce point d'extrémité est par ailleurs la même que celle du point d'extrémité du rapport général sur les ensembles de données. Pour récupérer un rapport HTML personnalisé sur un ensemble de données, vous pouvez effectuer la requête suivant :

    GET /api/33/dataSetReport/custom?ds=lyLU2wR22tC&pe=201810&ou=ImspTQPwCqd


## Analyse push { #webapi_push_analysis } 

L'API d'analyse push comprend des points d'extrémité qui permettent la prévisualisation d'un rapport d'analyse push par l'utilisateur connecté et le déclenchement manuel de la génération et de l'envoi de rapports d'analyse push par le système, en plus des opérations CRUD normales. Lorsque vous utilisez les points d'extrémité de création et de mise à jour pour l'analyse push, celle-ci est programmée pour s'exécuter selon les propriétés de l'analyse push. De même, lorsque vous supprimez ou mettez à jour une analyse push pour la désactiver, la tâche ne pourra plus être exécutée à l'avenir.

Pour obtenir l'aperçu d'une analyse push existante en HTML, vous pouvez effectuer une requête GET au point d'extrémité suivant :

    /api/33/pushAnalysis/<id>/render

Pour déclencher manuellement une tâche d'analyse push, vous pouvez envoyer une requête POST au point d'extrémité suivant :

    /api/33/pushAnalysis/<id>/run

Une analyse push comprend les propriétés suivantes, dont certaines sont nécessaires pour l'exécution automatique des tâches d'analyse push :



Tableau : Propriétés de l'analyse push

| Propriété | Description | Type | Obligatoire |
|---|---|---|---|
| tableau de bord | Tableau de bord sur lequel repose les rapports | UID du tableau de bord | Oui |
| message | Apparaît après le titre dans les rapports | Chaîne | Non |
| recipientUserGroups (groupes d'utilisateurs destinataires) | Un ensemble de groupes d'utilisateurs qui doivent recevoir les rapports | Un ou plusieurs UID de groupes d'utilisateurs | Non. Les tâches programmées sans destinataire seront ignorés. |
| activé | Indique si cette analyse push doit être planifiée ou non. La valeur par défaut est 'Faux'. | Booléen | Oui. Doit être défini sur "true" pour être planifié. |
| schedulingFrequency (fréquence de planification) | La fréquence à laquelle les rapports doivent être planifiés. | "QUOTIDIEN", "HEBDOMADAIRE", "MENSUEL" | Non. Les analyses push sans fréquence ne seront pas planifiés. |
| schedulingDayOfFrequency (Programmation du jour de la fréquence) | Le jour dans la fréquence où la tâche doit être planifiée. | Entier. Toute valeur est valide lorsque la fréquence est "QUOTIDIENNE". 0-7 lorsque la fréquence est "HEBDOMADAIRE". 1-31 lorsque la fréquence est "MENSUELLE" | Non. Les analyses push qui n'ont pas de jour de fréquence valide pour l'ensemble de fréquences ne seront pas planifiées. |

## Analyse de l'utilisation des données { #webapi_usage_analytics } 

L'API d'analyse de l'utilisation vous permet d'accéder à des informations sur la manière dont les gens utilisent DHIS2 sur la base d'une analyse de données. Lorsque les utilisateurs accèdent aux favoris, un événement est enregistré. L'événement se compose du nom de l'utilisateur, de l'UID du favori, de la date de l'événement et du type d'événement. Les différents types d'événements sont répertoriés dans le tableau.

    /api/33/dataStatistics

L'API d'analyse de l'utilisation vous permet de récupérer des instantanés agrégés sur l'analyse de l'utilisation, en fonction d'intervalles de temps donnés. L'API capture les vues des utilisateurs (par exemple le nombre de fois qu'un graphique ou un tableau croisé dynamique a été visualisé par un utilisateur) et les favoris d'analyse enregistrés (par exemple les graphiques et les tableaux croisés dynamiques favoris). DHIS2 capture des instantanés nocturnes qui sont ensuite agrégés à la demande.

### Paramètres de requête{ #webapi_usage_analytics_request_query_parameters } 

L'API d'analyse de l'utilisation (statistiques de données) prend en charge deux opérations :

  - *POST:* crée un événement de vue

  - *GET:* récupère les statistiques agrégées

### Création des événements de visualisation (POST) { #webapi_usage_analytics_create_view_events } 

L'API d'analyse de l'utilisation vous permet de créer des visualisations d'événement. Le paramètre dataStatisticsEventType (type d'événement des statistiques de données) décrit le type de l'élément visualisé. Le paramètre de favori indique l'identifiant du favori concerné.

URL that creates a new event view of
    charts:

    POST /api/33/dataStatistics?eventType=CHART_VIEW&favorite=LW0O27b7TdD

Une opération de sauvegarde réussie renvoie un code de statut HTTP "201". Le tableau ci-dessous présente les types d'événement pris en charge.



Tableau : Types d'événements pris en charge

| Clé | Description |
|---|---|
| REPORT_TABLE_VIEW | Report table (pivot table) view |
| CHART_VIEW | Chart view |
| MAP_VIEW | Aperçu de la carte (GIS) |
| EVENT_REPORT_VIEW | Aperçu du rapport d'événement |
| EVENT_CHART_VIEW | Aperçu du graphique d'événement |
| DASHBOARD_VIEW | Aperçu du tableau de bord |
| PASSIVE_DASHBOARD_VIEW | Aperçu du tableau de bord (lorsque le tableau de bord n'est pas explicitement sélectionné)
 |
| DATA_SET_REPORT_VIEW | Aperçu du rapport sur l'ensemble des données |

### Récupération des rapports agrégés d'analyse de l'utilisation (GET) { #webapi_aggregated_usage_analytics } 

L'API d'analyse de l'utilisation (statistiques de données) vous permet de spécifier certains paramètres de requête lorsque vous demandez un rapport agrégé.



Tableau : Paramètres de requête pour l'analyse agrégée de l'utilisation (statistiques de données)

| Paramètre de requête | Obligatoire | Description | Options |
|---|---|---|---|
| date de début | Oui | Date de début de la période | Les dates doivent être au format aaaa-MM-jj |
| date de fin | Oui | Date de fin de la période | Les dates doivent être au format aaaa-MM-jj |
| intervalle | Oui | Type d'intervalle à agréger | JOUR, SEMAINE, MOIS, ANNÉE |

Les paramètres 'date de début' et 'date de fin' spécifient la période pour laquelle les instantanés doivent être utilisés dans l'agrégation. Vous devez mettre les dates au format indiqué ci-dessus. Si aucun instantané n'est sauvegardé au cours de la période spécifiée, une liste vide est renvoyée. Le paramètre appelé 'intervalle' spécifie le type d'agrégation qui sera effectué.

Requête API qui crée une agrégation mensuelle :

    GET /api/33/dataStatistics?startDate=2014-01-02&endDate=2016-01-01&interval=MONTH

### Récupération des favoris { #webapi_usage_analytics_top_favorites } 

L'API d'analyse de l'utilisation vous permet de récupérer les principaux favoris utilisés dans DHIS2, et par utilisateur.



Tableau : Paramètres requête pour les principaux favoris

| Paramètre de requête | Obligatoire | Description | Options |
|---|---|---|---|
| eventType (type d'événement) | Oui | Le type d'événement des statistiques de données | Voir le tableau ci-dessus |
| taille de la page | Non | Taille de la liste renvoyée | Par exemple 5, 10, 25. La valeur par défaut est 25 |
| sortOrder (ordre de tri) | Non | Décroissant ou croissant | ASC ou DESC. La valeur par défaut est DESC. |
| Nom d'utilisateur | Non | Si ce paramètre est spécifié, la réponse ne contiendra que les favoris de cet utilisateur. | Par exemple, "admin". |

La requête API peut être utilisée sans nom d'utilisateur. Dans ce cas, elle trouvera les principaux favoris de tout le système.

    /api/33/dataStatistics/favorites?eventType=CHART_VIEW&pageSize=25&sortOrder=ASC

Si le nom d'utilisateur est spécifié, la réponse ne contiendra que les favoris de cet utilisateur.

    /api/33/dataStatistics/favorites?eventType=CHART_VIEW&pageSize=25
      &sortOrder=ASC&username=admin

### Format de la réponse { #webapi_usage_analytics_response_format } 

Vous pouvez renvoyer les données agrégées dans une réponse d'analyse d'utilisation dans différents formats de représentation. Le format par défaut est JSON. Les formats et types de contenu disponibles sont les suivants :

  - json (application/json)

  - xml (application/xml)

  - html (texte/html)

API query that requests a usage analytics response in XML
    format:

    /api/33/dataStatistics.xml?startDate=2014-01-01&endDate=2016-01-01&interval=WEEK

You must retrieve the aggregated usage analytics response with the HTTP
GET method. This allows you to link directly from Web pages and other
HTTP-enabled clients to usage analytics responses. To do functional
testing use the cURL library.

Pour obtenir une réponse d'analyse d'utilisation au format JSON :

    /api/33/dataStatistics?startDate=2016-02-01&endDate=2016-02-14&interval=WEEK

La réponse JSON ressemble à ceci :

```json
[
  {
    "year": 2016,
    "week": 5,
    "mapViews": 2181,
    "chartViews": 2227,
    "reportTableViews": 5633,
    "eventReportViews": 6757,
    "eventChartViews": 9860,
    "dashboardViews": 10082,
    "passiveDashboardViews": 0,
    "totalViews": 46346,
    "averageViews": 468,
    "averageMapViews": 22,
    "averageChartViews": 22,
    "averageReportTableViews": 56,
    "averageEventReportViews": 68,
    "averageEventChartViews": 99,
    "averageDashboardViews": 101,
    "averagePassiveDashboardViews": 0,
    "savedMaps": 1805,
    "savedCharts": 2205,
    "savedReportTables": 1995,
    "savedEventReports": 1679,
    "savedEventCharts": 1613,
    "savedDashboards": 0,
    "savedIndicators": 1831,
    "activeUsers": 99,
    "users": 969
  },
  {
    "year": 2016,
    "week": 6,
    "mapViews": 2018,
    "chartViews": 2267,
    "reportTableViews": 4714,
    "eventReportViews": 6697,
    "eventChartViews": 9511,
    "dashboardViews": 12181,
    "passiveDashboardViews": 0,
    "totalViews": 47746,
    "averageViews": 497,
    "averageMapViews": 21,
    "averageChartViews": 23,
    "averageReportTableViews": 49,
    "averageEventReportViews": 69,
    "averageEventChartViews": 99,
    "averageDashboardViews": 126,
    "averagePassiveDashboardViews": 0,
    "savedMaps": 1643,
    "savedCharts": 1935,
    "savedReportTables": 1867,
    "savedEventReports": 1977,
    "savedEventCharts": 1714,
    "savedDashboards": 0,
    "savedIndicators": 1646,
    "activeUsers": 96,
    "users": 953
  }
]
```

### Récupération des statistiques pour un favori { #webapi_usage_analytics_retrieve_favorite_statistics } 

Vous pouvez obtenir le nombre de visualisations pour un favori spécifique en utilisant la ressource *favoris*, où *{favorite-id}* (Id du favori) doit être remplacé par l'identifiant du favori en question :

    /api/33/dataStatistics/favorites/{favorite-id}.json

La réponse contiendra le nombre de visualisations pour le favori en question et ressemblera à ceci :

```json
{
  "views": 3
}
```

## Fonctionnalités géospatiales { #webapi_geospatial_features } 

La ressource *geoFeatures* vous permet d'extraire des informations géospatiales de DHIS2. Les fonctionnalités géospatiales sont stockées avec les unités d'organisation. La syntaxe utilisée pour extraire ces fonctionnalités est identique à la celle utilisée pour la dimension d'unité d'organisation de la ressource analytique. Nous vous recommandons de vous renseigner sur la ressource de l'API analytique avant de poursuivre la lecture de cette section. Vous devez utiliser le type de requête GET et seul le format de réponse JSON est pris en charge.

Par exemple, pour récupérer les éléments géospatiaux de toutes les unités d'organisation situées au niveau 3 de la hiérarchie des unités d'organisation, vous pouvez utiliser une requête GET avec l'URL suivante :

    /api/33/geoFeatures.json?ou=ou:LEVEL-3

Pour récupérer les éléments géospatiaux des unités d'organisation à un niveau situé à l'intérieur d'une unité d'organisation (par exemple au niveau 2), vous pouvez utiliser l'URL suivante :

    /api/33/geoFeatures.json?ou=ou:LEVEL-4;O6uvpzGd5pu

La sémantique des propriétés de la réponse est décrite dans le tableau suivant :



Tableau : Réponse pour les éléments géospatiaux

| Propriété | Description |
|---|---|
| identifiant | Unité d'organisation / identifiant de l'élément géospatiale |
| na | Unité d'organisation / nom de l'élément géospatiale |
| hcd | Les coordonnées se trouvent vers le bas ; elles indiquent s'il existe une ou plusieurs unités d'organisation subordonnées avec des coordonnées (c'est-à-dire à un niveau inférieur dans la hiérarchie). |
| hcu | Les coordonnées se trouvent vers le haut ; elles indiquent si l'unité d'organisation mère a des coordonnées (c'est-à-dire à un niveau supérieur dans la hiérarchie). |
| le | Niveau de cette unité d'organisation / élément géospatial |
| pg | Graphique mère : il s'agit du graphique contenant les identifiants des unités d'organisation mères jusqu'à la racine de la hiérarchie. |
| pi | Identifiant mère : il s'agit de l'identifiant de l'ascendant direct de cette unité d'organisation |
| pn | Nom de l'ascendant direct : il s'agit du nom de l'ascendant direct de cette unité d'organisation |
| ty | Type d'élément géospatial, 1 = point et 2 = polygone ou multi-polygone |
| co | Coordonnées de cet élément géospatial |

### GeoJSON { #geojson } 

Pour exporter du GeoJSON, vous pouvez simplement ajouter *.geosjon* en tant qu'extension au point d'extrémité */api/organisationUnits*, ou vous pouvez utiliser l'en-tête *Accept* avec *application/json+geojson*.

Deux paramètres sont pris en charge : `level` (1 par défaut) et `parent` (unités d'organisation racine par défaut). Les deux paramètres peuvent être ajoutés à plusieurs reprise. Quelques exemples :

Obtenir tous les éléments aux niveaux 2 et 4 :

    /api/organisationUnits.geojson?level=2&level=4

Pour obtenir tous les éléments du niveau 3 avec une unité d'organisation limite :

    /api/organisationUnits.geojson?parent=fdc6uOvgoji&level=3

## Crochets pour table analytiques { #webapi_analytics_table_hooks }

Les crochets de tableaux analytiques fournissent un mécanisme permettant d'appeler des scripts SQL au cours des différentes phases du processus de génération des tableaux analytiques. Ceci permet de personnaliser les données dans les tableaux de ressources et d'analyse, par exemple pour obtenir une logique spécifique pour les calculs et l'agrégation. Vous pouvez manipuler les crochets de tables analytiques à l'aide du point d'extrémité d'API suivant :

    /api/analyticsTableHooks

L'API des crochets de tableaux analytiques prend en charge les opérations CRUD HTTP standard pour créer (POST), mettre à jour (PUT), récupérer (GET) et supprimer (DELETE) des entités.

### Champs de crochets { #webapi_analytics_table_hook_fields } 

Les crochets de tableaux analytiques comportent les champs suivants :



Tableau : Champs des crochets de tableaux analytiques

| Champ | Options | Description |
|---|---|---|
| nom | Texte | Nom du crochet. |
| phase | RESOURCE_TABLE_POPULATED, ANALYTICS_TABLE_POPULATED (tableau de ressources et tableau analytique renseignés) | Phase au cours de laquelle le script SQL doit être appelé. |
| resourceTableType (type de tableau de ressources) | Voir la colonne "Type de tableau" dans le tableau "Phases, types de tableaux et tableaux temporaires" ci-dessous. | Le type de tableau de ressources pour lequel le script SQL doit être appelé. Ceci ne s'applique qu'aux crochets définis avec la phase RESOURCE_TABLE_POPULATED. |
| analyticsTableType (type de tableau analytique) | Voir la colonne "Type de tableau" dans le tableau "Phases, types de tableaux et tableaux temporaires" ci-dessous. | Le type de tableau analytique pour lequel le script SQL doit être appelé. Ceci ne s'applique qu'aux crochets définis avec la phase ANALYTICS_TABLE_POPULATED. |
| sql | Texte | Le script SQL à appeler. |

The *ANALYTICS_TABLE_POPULATED* phase takes place after the analytics
table has been populated, but before indexes have been created and the
temp table has been swapped with the main table. As a result, the SQL
script should refer to the analytics temp table, e.g. *analytics_temp*,
*analytics_completeness_temp*.

Ceci s'applique également à la phase *RESOURCE_TABLE_POPULATED*, qui a lieu après le remplissage de la table de ressources, mais avant la création des index et le remplacement du tableau temporaire par le tableau principal. Le script SQL va désormais faire référence au tableau de ressources temporaire, par exemple *_orgunitstructure_temp*, *_categorystructure_temp*.

Vous ne devez définir qu'un seul champ entre *resourceTableType* et *analyticsTableType*. Vous le ferez en fonction de la *phase* définie.

Vous pouvez faire référence au tableau temporaire de la base de données qui correspond uniquement au type du tableau de crochets spécifié (les autres tableaux temporaires ne seront pas disponibles). Par exemple, si vous spécifiez *ORG_UNIT_STRUCTURE* comme type de tableau de ressources, vous ne pourrez faire référence qu'au tableau temporaire de la base de données *_orgunitstructure_temp*.

Le tableau suivant présente les combinaisons valables de phases, de types de tableaux et de tableaux temporaire.



Tableau : Phases, types de tableaux et tableaux temporaires

| Phase | Type de tableau | Table temporaire |
|---|---|---|
| RESOURCE_TABLE_POPULATED | ORG_UNIT_STRUCTURE (structure de l'unité d'organisation) | _orgunitstructure_temp |
|| DATA_SET_ORG_UNIT_CATEGORY | _datasetorgunitcategory_temp |
|| CATEGORY_OPTION_COMBO_NAME | _categoryoptioncomboname_temp |
|| DATA_ELEMENT_GROUP_SET_STRUCTURE (structure de l'ensemble de groupes d'éléments de données) | _dataelementgroupsetstructure_temp |
|| INDICATOR_GROUP_SET_STRUCTURE | _indicatorgroupsetstructure_temp |
|| ORG_UNIT_GROUP_SET_STRUCTURE (structure de l'ensemble de groupes d'unités d'organisation) | _organisationunitgroupsetstructure_temp |
|| CATEGORY_STRUCTURE (structure de la catégorie) | _categorystructure_temp |
|| DATA_ELEMENT_STRUCTURE (structure de l'élément de données) | _dataelementstructure_temp |
|| PERIOD_STRUCTURE (structure de la période) | _periodstructure_temp |
|| DATE_PERIOD_STRUCTURE (structure de la période + la date) | _dateperiodstructure_temp |
|| DATA_ELEMENT_CATEGORY_OPTION_COMBO (combinaison d'option de catégorie de l'élément de donnée) | _dataelementcategoryoptioncombo_temp |
|| DATA_APPROVAL_MIN_LEVEL (niveau minimal d'approbation des données) | _dataapprovalminlevel_temp |
| ANALYTICS_TABLE_POPULATED | DATA_VALUE | analytics_temp |
|| COMPLETENESS (complétude) | analytics_completeness_temp |
|| COMPLETENESS_TARGET (cible de complétude) | analytics_completenesstarget_temp |
|| ORG_UNIT_TARGET (cible de l'unité d'organisation) | analytics_orgunittarget_temp |
|| ÉVÉNEMENT | analytics_event_temp_<program-uid\> |
|| INSCRIPTION | analytics_enrollment_temp_<program-uid\> |
|| VALIDATION_RESULT (résultat de validation) | analytics_validationresult_temp |

### Création de crochets { #webapi_create_analytics_table_hook } 

To create a hook which should run after the resource tables have been
populated you can do a *POST* request like this using *JSON* format:

```bash
curl -d @hooks.json "localhost/api/analyticsTableHooks" -H "Content-Type:application/json" -u admin:district
```

```json
{
  "name": "Update 'Area' in org unit group set resource table",
  "phase": "RESOURCE_TABLE_POPULATED",
  "resourceTableType": "ORG_UNIT_GROUP_SET_STRUCTURE",
  "sql": "update _organisationunitgroupsetstructure_temp set \"uIuxlbV1vRT\" = 'b0EsAxm8Nge'"
}
```

To create a hook which should run after the data value analytics table
has been populated you can do a *POST* request like this using *JSON*
format:

```json
{
  "name": "Update 'Currently on treatment' data in analytics table",
  "phase": "ANALYTICS_TABLE_POPULATED",
  "analyticsTableType": "DATA_VALUE",
  "sql": "update analytics_temp set monthly = '200212' where \"monthly\" in ('200210', '200211')"
}
```

## Conversion SVG { #webapi_svg_conversion } 

L'API Web fournit une ressource qui peut être utilisée pour convertir le contenu SVG dans des formats plus utilisés tels que PNG et PDF. Idéalement, cette conversion devrait avoir lieu côté client, mais toutes les technologies côté client ne sont pas en mesure d'effectuer cette tâche. Actuellement, les formats de sortie PNG et PDF sont pris en charge. Le contenu SVG lui-même doit être transmis avec un paramètre de requête *svg*, et un paramètre de requête facultatif *filename* peut être utilisé pour spécifier le nom de fichier de la pièce jointe à la réponse. Notez que l'extension du fichier doit être omise. Pour obtenir une réponse dans le format PNG, vous pouvez envoyer une requête *POST* à l'URL suivante avec pour type de contenu `application/x-www-form-urlencoded`. Ce processus est identique à la soumission d'un formulaire HTML classique.

    api/svg.png

Pour obtenir la réponse dans le format PDF, vous pouvez envoyer une requête *POST* à l'URL suivante avec pour type de contenu `application/x-www-form-urlencoded`.

    api/svg.pdf



Tableau : Paramètres de requête

| Paramètre de requête | Obligatoire | Description |
|---|---|---|
| svg | Oui | Le contenu SVG |
| nom de fichier | Non | Le nom de fichier de la pièce jointe renvoyée sans extension de fichier |



# Maintenance { #maintenance } 

## Tableaux de ressources et d'analyse { #webapi_generating_resource_analytics_tables } 

DHIS2 comporte un ensemble de tableaux de base de données générés qui sont utilisés comme 
base pour diverses fonctionnalités du système. Ces tableaux peuvent être exécutés 
immédiatement ou programmés à intervalles réguliers via 
l'interface utilisateur. Ils peuvent également être générés via l'API Web, comme 
expliqué dans cette section. Cette tâche incombe généralement à un administrateur 
système et non aux clients consommateurs.

Les tables de ressources sont utilisées en interne par l'application DHIS2 pour
diverses fonctions d'analyse. Ces tables sont également utiles aux utilisateurs
qui rédigent des rapports SQL avancés. Elles peuvent être générées par une requête POST ou PUT
à l'URL suivante :

    /api/33/resourceTables

Les tableaux analytiques sont optimisés pour l'agrégation des données et sont actuellement 
utilisés dans DHIS2 pour le module de tableau croisé dynamique. Les tableaux d'analyse peuvent 
être générés à l'aide d'une requête POST ou PUT à :

    /api/33/resourceTables/analytics



Tableau : Paramètres de requête facultatifs des tableaux d'analyse

| Paramètre de requête | Options | Description |
|---|---|---|
| Ignorer les tableaux de ressources | faux &#124; vrai | Ignorer la génération des tableaux de ressources |
| Ignorer l'agrégat | faux &#124; vrai | Ignorer la génération de données agrégées et de données exhaustives |
| Ignorer les événements | faux &#124; vrai | Ignorer la génération de données d'événement |
| Ignorer les événements | faux &#124; vrai | Ignorer la génération des données d'inscription |
| années précédentes | entier | Nombre de dernières années de données à inclure |

Les tâches « Qualité des données “ et ” Surveillance des données » peuvent être exécutées 
via la tâche de surveillance, déclenchée avec le endpoint 

    /api/33/resourceTables/monitoring

Cette tâche analyse vos règles de validation, détecte les violations et 
les conserve en tant que résultats de validation.

Ces demandes sont renvoyées immédiatement et déclenchent un processus 
côté serveur.

## Maintenance { #webapi_maintenance } 

Pour effectuer la maintenance, vous pouvez interagir avec la ressource *maintenance*. Vous devez utiliser *POST* ou *PUT* comme méthode pour les requêtes. Les méthodes suivantes sont disponibles.

La suppression des tables d'analyse entraîne la disparition de toutes les tables d'analyse.

    POST PUT /api/maintenance/analyticsTablesClear

L'analyse des tables d'analyse permet de collecter des statistiques sur le contenu des tables d'analyse de la base de données.

    POST PUT /api/maintenance/analyticsTablesAnalyze

La suppression des invitations expirées permet de supprimer toutes les invitations de comptes d'utilisateurs qui 
ont expiré.

    POST PUT /api/maintenance/expiredInvitationsClear

L'élagage des périodes permet de supprimer les périodes qui ne sont liées à aucune valeur de 
données.

    POST PUT /api/maintenance/periodPruning

La suppression des valeurs de données nulles permet de supprimer les valeurs de données nulles liées à des 
éléments de données où les données nulles sont définies comme non significatives :

    POST PUT /api/maintenance/zeroDataValueRemoval

La suppression des valeurs de données supprimées de façon réversible supprime définitivement les valeurs de données supprimées de façon réversible.

    POST PUT /api/maintenance/softDeletedDataValueRemoval

La suppression de l'instance de l'étape du programme supprimé de façon réversible supprime de façon permanente les événements supprimés de façon réversible.

    POST PUT /api/maintenance/softDeletedProgramStageInstanceRemoval

La suppression de l'instance de programme supprimée de façon réversible supprime définitivement les inscriptions supprimées de façon réversible.

    POST PUT /api/maintenance/softDeletedProgramInstanceRemoval

La suppression des instances d'entités suivies supprimées de façon réversible supprime définitivement les instances d'entités suivies supprimées de façon réversible.

    POST PUT /api/maintenance/softDeletedTrackedEntityInstanceRemoval

Supprimer les vues SQL supprime toutes les vues SQL de la base de données. Notez qu'il ne supprime pas les entités de la vue SQL de DHIS2.

    POST PUT /api/maintenance/sqlViewsDrop

Créer des vues SQL va recréer toutes les vues SQL dans la base de données.

    POST PUT /api/maintenance/sqlViewsCreate

La mise à jour des combinaisons d'options de catégories supprimera les combinaisons d'options de catégories obsolètes et générera les combinaisons d'options de catégories manquantes pour toutes les combinaisons de catégories.

    POST PUT /api/maintenance/categoryOptionComboUpdate

Il est également possible de mettre à jour les combinaisons d'options de catégorie pour une seule combinaison de catégorie en utilisant le point d'extrémité suivant.

    POST PUT /api/maintenance/categoryOptionComboUpdate/categoryCombo/<category-combo-uid>

Le nettoyage du cache efface le cache d'hibernation de l'application et les caches de la partition analytique.

    POST PUT /api/maintenance/cacheClear

La mise à jour des chemins des unités d'organisation va regénérer la propriété du chemin de l'unité d'organisation. Cela peut être utile, par exemple, si vous avez importé des unités d'organisation avec SQL.

    POST PUT /api/maintenance/ouPathsUpdate

L'élagage des données permet de supprimer des enregistrements complets d'ensembles de données, des approbations de données, des audits de valeurs de données et des valeurs de données, dans ce cas pour une unité d'organisation.

    POST PUT /api/maintenance/dataPruning/organisationUnits/<org-unit-id>

L'élagage des données pour les éléments de données, qui supprime les audits de valeurs de données et les valeurs de données.

    POST PUT /api/maintenance/dataPruning/dataElement/<data-element-uid>

La validation des métadonnées appliquera toutes les règles de validation des métadonnées et renverra le résultat de l'opération.

    POST PUT /api/metadataValidation

Le rechargement d'applications actualise le cache des applications installées géré par DHIS2 en lisant le système de fichiers.

    POST PUT /api/appReload

Les opérations de maintenance sont prises en charge par lots au moyen d'une requête POST à la ressource api/maintenance, où les opérations sont fournies en tant que paramètres de requête :

    POST PUT /api/maintenance?analyticsTablesClear=true&expiredInvitationsClear=true
      &periodPruning=true&zeroDataValueRemoval=true&sqlViewsDrop=true&sqlViewsCreate=true
      &categoryOptionComboUpdate=true&cacheClear=true&ouPathsUpdate=true

## Informations sur le système { #webapi_system_resource } 

La ressource système vous fournit des informations et des fonctions 
pratiques. La ressource système se trouve à l'adresse */api/system*.

### Générer des identifiants { #webapi_system_resource_generate_identifiers } 

Pour générer des identifiants DHIS2 valides et aléatoires, vous pouvez effectuer une requête GET à 
cette ressource :

    /api/33/system/id?limit=3

Le paramètre de requête *limit* est facultatif et indique le nombre 
d'identifiants à renvoyer avec la réponse. La valeur par défaut est
de renvoyer un seul identifiant. La réponse contiendra un objet JSON avec un 
tableau nommé codes, similaire à ceci :

```json
{
  "codes": [
    "Y0moqFplrX4",
    "WI0VHXuWQuV",
    "BRJNBBpu4ki"
  ]
}
```

Le format DHIS2 UID répond à ces critères :

  - Long de 11 caractères.

  - Caractères alphanumériques uniquement, c'est-à-dire caractères alphabétiques ou numériques
    (A-Za-z0-9).

  - Commencez par un caractère alphabétique (A-Za-z).

### Visualiser les informations du système { #webapi_system_resource_view_system_information } 

Pour obtenir des informations sur le système actuel, vous pouvez envoyer une requête GET à 
cette URL :

    /api/33/system/info

Les formats de réponse JSON et JSONP sont pris en charge. La réponse info système
comprend actuellement les propriétés suivantes.

```json
{
  "contextPath": "http://yourdomain.com",
  "userAgent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 Chrome/29.0.1547.62",
  "calendar": "iso8601",
  "dateFormat": "yyyy-mm-dd",
  "serverDate": "2021-01-05T09:16:03.548",
  "serverTimeZoneId": "Etc/UTC",
  "serverTimeZoneDisplayName": "Coordinated Universal Time",
  "version": "2.13-SNAPSHOT",
  "revision": "11852",
  "buildTime": "2013-09-01T21:36:21.000+0000",
  "serverDate": "2013-09-02T12:35:54.311+0000",
  "environmentVariable": "DHIS2_HOME",
  "javaVersion": "1.7.0_06",
  "javaVendor": "Oracle Corporation",
  "javaIoTmpDir": "/tmp",
  "javaOpts": "-Xms600m -Xmx1500m -XX:PermSize=400m -XX:MaxPermSize=500m",
  "osName": "Linux",
  "osArchitecture": "amd64",
  "osVersion": "3.2.0-52-generic",
  "externalDirectory": "/home/dhis/config/dhis2",
  "databaseInfo": {
    "type": "PostgreSQL",
    "name": "dhis2",
    "user": "dhis",
    "spatialSupport": false
  },
  "memoryInfo": "Mem Total in JVM: 848 Free in JVM: 581 Max Limit: 1333",
  "cpuCores": 8
}
```

> **Remarque**
>
> Si l'utilisateur qui demande cette ressource n'a pas toute l'autorité nécessaire, seules les propriétés qui ne sont pas considérées comme sensibles seront incluses.

Pour obtenir des informations sur le contexte du système uniquement, c'est-à-dire `contextPath` et
`userAgent`, vous pouvez faire une requête GET à l'URL ci-dessous. Les formats de réponse JSON et
JSONP sont supportés :

    /api/33/system/context

### Vérifier si la combinaison du nom d'utilisateur et du mot de passe est correcte { #webapi_system_resource_check_username_password } 

Pour vérifier si les informations d'identification d'un utilisateur (combinaison d'un nom d'utilisateur et d'un mot de passe)
est correcte, vous pouvez envoyer une requête *GET* à la ressource suivante en utilisant l'option
*authentification de base* :

    /api/33/system/ping

Vous pouvez détecter le résultat de l'authentification en inspectant le *code du statut HTTP*
de l'en-tête de la réponse. La signification des codes de statut possibles
sont énumérés ci-dessous. Notez que cela s'applique aux demandes d'API Web en
général.



Tableau : Codes de statut HTTP

| Code de statut HTTP | Description | Résultat |
|---|---|---|
| 200 | OK | L'authentification a réussi |
| 302 | Trouvé | Aucune information d'identification n'a été fournie avec la requête - aucune authentification n'a eu lieu. |
| 401 | Non autorisé | La combinaison du nom d'utilisateur et du mot de passe est incorrecte - l'authentification a échoué. |

### Consulter le statut d'une tâche asynchrone { #webapi_system_resource_view_async_task_status } 

Les tâches qui prennent souvent beaucoup de temps peuvent être exécutées 
de manière asynchrone. Après avoir initié une tâche asynchrone, vous pouvez interroger son statut 
via la ressource `system/tasks` en fournissant la catégorie de tâche et 
l'identifiant de la tâche qui vous intéresse.

Lorsque vous demandez le statut d'une tâche, vous devez vous authentifier en tant 
qu'utilisateur ayant initié la tâche. Les catégories de tâches suivantes sont 
prises en charge :



Tableau : Catégories de tâches

| Identificateur | Description |
|---|---|
| TABLE_ANALYTIQUE | Génération des tableaux analytiques. |
| TABLE_DE RESSOURCES | Génération des tableaux de ressources. |
| SURVEILLANCE | Traitement des règles de validation des données de surveillance/contrôle. |
| IMPORTATION_DE DONNÉES | Importation de données. |
| IMPORTATION_D'ÉVÉNEMENTS | Importation d'événements. |
| IMPORTATION_D'INSCRIPTION | Importation des inscriptions. |
| IMPORTATION_D'IES | Importation d'instances d'entités suivies. |
| IMPORTATION_DE MÉTADONNÉES | Importation de métadonnées. |
| INTÉGRITÉ_DES DONNÉES | Traitement des contrôles d'intégrité des données. |

Chaque tâche asynchrone se voit automatiquement attribuer un identifiant qui peut 
être utilisé pour contrôler le statut de la tâche. Cet identifiant de tâche est
renvoyé par l'API lorsque vous lancez une tâche asynchrone via les différents
endpoints activés asynchrones.


#### Surveillance d'une tâche { #monitoring-a-task } 

Vous pouvez consulter l'état des tâches par le biais d'une requête GET à la ressource des tâches 
du système, comme suit :

    /api/33/system/tasks/{task-category-id}/{task-id}

Un exemple de requête peut ressembler à ceci :

    /api/33/system/tasks/DATAVALUE_IMPORT/j8Ki6TgreFw

La réponse fournira des informations sur le statut, telles que le niveau de 
notification, la catégorie, l'heure et le statut. La propriété *terminé* indique 
si le processus est considéré comme terminé.

```json
[{
  "uid": "hpiaeMy7wFX",
  "level": "INFO",
  "category": "DATAVALUE_IMPORT",
  "time": "2015-09-02T07:43:14.595+0000",
  "message": "Import done",
  "completed": true
}]
```

#### Suivre toutes les tâches d'une catégorie { #monitoring-all-tasks-for-a-category } 

Vous pouvez consulter toutes les tâches d'une catégorie spécifique par le biais d'une requête GET vers
la ressource des tâches du système :

    /api/33/system/tasks/{task-category-id}

Un exemple de requête pour consulter le statut des tâches d'importation de données
ressemble à ceci :

    /api/33/system/tasks/DATAVALUE_IMPORT

#### Suivre toutes les tâches { #monitor-all-tasks } 

Vous pouvez demander une liste de toutes les tâches en cours d'exécution dans le système avec 
une requête GET à la ressource tâches du système :

    /api/33/system/tasks

La réponse ressemblera à ceci :

```json
[{
  "EVENT_IMPORT": {},
  "DATA_STATISTICS": {},
  "RESOURCE_TABLE": {},
  "FILE_RESOURCE_CLEANUP": {},
  "METADATA_IMPORT": {},
  "CREDENTIALS_EXPIRY_ALERT": {},
  "SMS_SEND": {},
  "MOCK": {},
  "ANALYTICSTABLE_UPDATE": {},
  "COMPLETE_DATA_SET_REGISTRATION_IMPORT": {},
  "DATAVALUE_IMPORT": {},
  "DATA_SET_NOTIFICATION": {},
  "DATA_INTEGRITY": {
    "OB1qGRlCzap": [{
      "uid": "LdHQK0PXZyF",
      "level": "INFO",
      "category": "DATA_INTEGRITY",
      "time": "2018-03-26T15:02:32.171",
      "message": "Data integrity checks completed in 38.31 seconds.",
      "completed": true
    }]
  },
  "PUSH_ANALYSIS": {},
  "MONITORING": {},
  "VALIDATION_RESULTS_NOTIFICATION": {},
  "REMOVE_EXPIRED_RESERVED_VALUES": {},
  "DATA_SYNC": {},
  "SEND_SCHEDULED_MESSAGE": {},
  "DATAVALUE_IMPORT_INTERNAL": {},
  "PROGRAM_NOTIFICATIONS": {},
  "META_DATA_SYNC": {},
  "ANALYTICS_TABLE": {},
  "PREDICTOR": {}
}]
```

### Visualiser les résumés des tâches asynchrones { #view-asynchronous-task-summaries } 

La ressource résumés de tâches vous permet de récupérer un résumé d'une invocation 
d'une tâche asynchrone. Vous devez spécifier la catégorie et, 
éventuellement l'identifiant de la tâche. L'identifiant de la tâche peut être
récupéré à partir de la réponse de la requête API qui a initié la 
tâche asynchrone.

Pour récupérer le résumé d'une tâche spécifique, vous pouvez envoyer une requête à :

    /api/33/system/taskSummaries/{task-category-id}/{task-id}

Un exemple de requête pourrait ressembler à ceci :

    /api/33/system/taskSummaries/DATAVALUE_IMPORT/k72jHfF13J1

La réponse ressemblera à ceci :

```json
{
  "responseType": "ImportSummary",
  "status": "SUCCESS",
  "importOptions": {
    "idSchemes": {},
    "dryRun": false,
    "async": true,
    "importStrategy": "CREATE_AND_UPDATE",
    "mergeMode": "REPLACE",
    "reportMode": "FULL",
    "skipExistingCheck": false,
    "sharing": false,
    "skipNotifications": false,
    "datasetAllowsPeriods": false,
    "strictPeriods": false,
    "strictCategoryOptionCombos": false,
    "strictAttributeOptionCombos": false,
    "strictOrganisationUnits": false,
    "requireCategoryOptionCombo": false,
    "requireAttributeOptionCombo": false,
    "skipPatternValidation": false
  },
  "description": "Import process completed successfully",
  "importCount": {
    "imported": 0,
    "updated": 431,
    "ignored": 0,
    "deleted": 0
  },
  "dataSetComplete": "false"
}
```

Vous pouvez également récupérer des résumés d'importation pour plusieurs tâches d'une
catégorie spécifique avec une requête comme
celle-ci :

    /api/33/system/taskSummaries/{task-category-id}

### Obtenir des informations sur la présentation { #webapi_system_resource_get_appearance_information } 

Vous pouvez récupérer les icônes de drapeaux disponibles au format JSON à l'aide d'une 
requête GET :

    /api/33/system/flags

Vous pouvez récupérer les styles d'interface utilisateur disponibles au format JSON à l'aide 
d'une requête GET :

    /api/33/system/styles

## Informations sur le cluster { #cluster-info } 

Lorsque DHIS 2 est configuré en cluster, il est utile de savoir quel nœud du cluster agit en tant que principal nœud du cluster. L'API suivante peut être utilisée pour obtenir les détails de l'instance du nœud principal. L'API prend en charge les formats JSON et XML.

```
GET /api/36/cluster/leader
```

Un exemple de réponse JSON ressemble à ceci :

```json
{
  "leaderNodeId": "play-dhis2-org-dev",
  "leaderNodeUuid": "d386e46b-26d4-4937-915c-025eb99c8cad",
  "currentNodeId": "play-dhis2-org-dev",
  "currentNodeUuid": "d386e46b-26d4-4937-915c-025eb99c8cad",
  "leader": true
}
```

## Éléments de données min-max { #webapi_min_max_data_elements } 

La ressource éléments de données min-max vous permet de définir des plages de valeurs minimales et maximales 
pour les éléments de données. Elle est unique en raison de la combinaison de 
l'unité d'organisation, de l'élément de données et de l'option de catégorie.

    /api/minMaxDataElements



Tableau : Structure des données de l'élément Min-max

| Élément | Description | Type de données |
|---|---|---|
| source | Identifiant de l'unité d'organisation | Chaîne |
| élément de données | Identifiant de l'élément de données | Chaîne |
| Combinaison d'options | Identifiant de la combinaison d'options de catégorie de l'élément de données | Chaîne |
| min | Valeur minimale | Entier |
| max | Valeur maximum | Entier |
| généré | Indique si cet objet est généré par le système (et non défini manuellement). | Booléen |

Vous pouvez obtenir une liste de tous les éléments de données min-max à partir de la 
ressource suivante :

    GET /api/minMaxDataElements.json

Vous pouvez filtrer la réponse comme suit :

    GET /api/minMaxDataElements.json?filter=dataElement.id:eq:UOlfIjgN8X6

    GET /api/minMaxDataElements.json?filter=dataElement.id:in:[UOlfIjgN8X6,xc8gmAKfO95]

Le paramètre de filtrage des éléments de données min-max prend en charge deux opérateurs :
eq et in. Vous pouvez également utiliser le paramètre de requête `fields`.

    GET /api/minMaxDataElements.json?fields=:all,dataElement[id,name]

### Ajouter/mettre à jour l'élément de données min-max { #webapi_add_update_min_max_data_element } 

Pour ajouter un nouvel élément de données min-max, utilisez la requête POST à :

    POST /api/minMaxDataElements.json

Le format de contenu JSON se présente comme suit :

```json
{
  "min": 1,
  "generated": false,
  "max": 100,
  "dataElement": {
    "id": "UOlfIjgN8X6"
   },
  "source": {
    "id": "DiszpKrYNg8"
  },
  "optionCombo": {
    "id": "psbwp3CQEhs"
  }
}
```

Si la combinaison de l'élément de données, de l'unité d'organisation et de la catégorie
existe, la valeur min-max sera mise à jour.

### Supprimer l'élément de données min-max { #webapi_delete_min_max_data_element } 

Pour supprimer un élément de données min-max, envoyez une requête avec la méthode DELETE :

    DELETE /api/minMaxDataElements.json

Le contenu JSON est dans le même format que ci-dessus :

```json
{
  "min": 1,
  "generated": false,
  "max": 100,
  "dataElement": {
    "id": "UOlfIjgN8X6"
   },
  "source": {
    "id": "DiszpKrYNg8"
  },
  "optionCombo": {
    "id": "psbwp3CQEhs"
  }
}
```

## Exceptions de verrouillage { #webapi_lock_exceptions } 

La ressource exceptions de blocage vous permet d'ouvrir des ensembles de données verrouillés 
pour la saisie de données pour un ensemble de données, une période et une unité d'organisation 
spécifiques. Vous pouvez lire les exceptions de verrouillage à partir de la ressource suivante :

    /api/lockExceptions

Pour créer une nouvelle exception de verrouillage, vous pouvez utiliser une requête POST et spécifier
l'ensemble de données, la période et l'unité d'organisation :

    POST /api/lockExceptions?ds=BfMAe6Itzgt&pe=201709&ou=DiszpKrYNg8

Pour supprimer une exception de verrouillage, vous pouvez utiliser une syntaxe de demande similaire avec une
 requête DELETE :

    DELETE /api/lockExceptions?ds=BfMAe6Itzgt&pe=201709&ou=DiszpKrYNg8




# I18n { #i18n } 

## Locales { #webapi_locales } 

DHIS2 supports translations both for the user interface and for database
content.

### UI locales { #ui-locales } 

You can retrieve the available locales for the user interface through
the following resource with a GET request. XML and JSON resource
representations are supported.

    /api/33/locales/ui

### Database content locales { #database-content-locales } 

You can retrieve and create locales for the database content with GET and
POST requests through the following resource. XML and JSON resource
representations are supported.

    /api/33/locales/db

## Les traductions { #webapi_translations } 

DHIS2 allows for translations of database content. 
If a metadata is translatable, then it will have a `translations` property.

That means you can retrieve and update translations using metadata class resources such as `api/dataElements`, `api/organisationUnits`, `api/dataSets`, etc.

### Get translations { #get-translations } 

You can get translations for a metadata object such as DataElement by sending a GET request to `api/dataElements/{dataElementUID}`

The response contains full details of the DataElement which also includes the `translations` property as below

```json
{
  "id": "fbfJHSPpUQD",
  "href": "https://play.dhis2.org/dev/api/29/dataElements/fbfJHSPpUQD",
  "created": "2010-02-05T10:58:43.646",
  "name": "ANC 1st visit",
  "shortName": "ANC 1st visit",
  "translations": 
  [
    {
      "property": "SHORT_NAME",
      "locale": "en_GB",
      "value": "ANC 1st visit"
    },
    {
      "property": "NAME",
      "locale": "fr",
      "value": "Soin prénatal 1"
    },
    {
      "property": "NAME",
      "locale": "en_GB",
      "value": "ANC 1st visit"
    }
  ]
}
```
You can also get only the `translations` property of an object by sending a GET request to 
`api/dataElements/{dataElementUID}/translations`

```json
{
  "translations": 
  [
    {
      "property": "SHORT_NAME",
      "locale": "en_GB",
      "value": "ANC 1st visit"
    },
    {
      "property": "NAME",
      "locale": "fr",
      "value": "Soin prénatal 1"
    },
    {
      "property": "NAME",
      "locale": "en_GB",
      "value": "ANC 1st visit"
    }
  ]
}
```

### Create a translations { #create-a-translations } 

You can create a translation by sending a PUT request with same JSON format to `api/dataElements/{dataElementUID}/translations`

```json
{
  "translations": 
  [
    {
      "property": "SHORT_NAME",
      "locale": "en_GB",
      "value": "ANC 1st visit"
    },
    {
      "property": "NAME",
      "locale": "fr",
      "value": "Soin prénatal 1"
    },
    {
      "property": "DESCRIPTION",
      "locale": "fr",
      "value": "description in french"
    },
    {
      "property": "FORM_NAME",
      "locale": "fr",
      "value": "name in french"
    }
  ]
}
```

Alternatively, you can also just update the object with payload including the `translations` property.

Send PUT request to `api/dataElements/{dataElementUID}` with full object payload as below:

```json
{
  "id": "fbfJHSPpUQD",
  "created": "2010-02-05T10:58:43.646",
  "name": "ANC 1st visit",
  "shortName": "ANC 1st visit",
  "translations": 
  [
    {
      "property": "SHORT_NAME",
      "locale": "en_GB",
      "value": "ANC 1st visit"
    },
    {
      "property": "NAME",
      "locale": "fr",
      "value": "Soin prénatal 1"
    },
    {
      "property": "NAME",
      "locale": "en_GB",
      "value": "ANC 1st visit"
    }
  ]
}
```

The common properties which support translations are listed in the table below.

Table: Property names

| Property name | Description |
|---|---|
| nom | Object name |
| nomAbrégé | Object short name |
| Description | Object description |

The classes which support translations are listed in the table below.

Table: Class names

| Class name | Description | Other translatable Properties |
|---|---|---|
| DataElementCategoryOption | Option de catégorie | |
| DataElementCategory | Catégorie | |
| DataElementCategoryCombo | La combinaison de catégories | |
| Élément de données | Élément de données | |
| DataElementGroup | Groupe d'éléments de données | |
| DataElementGroupSet | Ensemble de groupes d'éléments de donnée | |
| Indicateur | Indicateur | numeratorDescription, denominatorDescription |
| IndicatorType | Type d'indicateur | |
| IndicatorGroup | Groupe d’indicateurs | |
| IndicatorGroupSet | Ensemble de groupes d'indicateurs | |
| OrganisationUnit | Unité d’organisation | |
| OrganisationUnitGroup | Groupe d'unités d'organisation | |
| OrganisationUnitGroupSet | Ensemble de groupes d'unités d'organisation | |
| Ensemble de données | Ensemble de données | |
| Section | Data set section | |
| ValidationRule | Règle de validation | instruction |
| ValidationRuleGroup | Groupe de règles de validation | |
| Programme | Programme | enrollmentDateLabel, incidentDateLabel |
| Étape du programme | Étape du programme | executionDateLabel, dueDateLabel |
| TrackedEntityAttribute | Attribut d’entité suivie | |
| TrackedEntity | Tracked entity | |
| Type de relation | Relationship type for tracked entity instances | fromToName, toFromName |
| Ensemble d'options | Ensemble d'options | |
| Attribut | Attribute for metadata | |
| ProgramNotificationTemplate | Program Notification template | subjectTemplate, messageTemplate |
| ValidationNotificationTemplate | Validation Notification template | subjectTemplate, messageTemplate |
| DataSetNotificationTemplate | DataSet Notification template | subjectTemplate, messageTemplate |
| Visualisation | Visualisation | title, subtitle, rangeAxisLabel, baseLineLabel, targetLineLabel, domainAxisLabel |
| ProgramRuleAction | Program Rule Actions | contenu |

## Internationalization { #webapi_i18n } 

In order to retrieve key-value pairs for translated strings you can use
the *i18n* resource.

    /api/33/i18n

The endpoint is located at */api/i18n* and the request format is a simple
array of the key-value pairs:

```json
[
  "access_denied",
  "uploading_data_notification"
]
```

The request must be of type *POST* and use *application/json* as
content-type. An example using curl, assuming the request data is saved
as a file `keys.json`:

```bash
curl -d @keys.json "play.dhis2.org/demo/api/33/i18n" -X POST
  -H "Content-Type: application/json" -u admin:district
```

The result will look like this:

```json
{
  "access_denied":"Access denied",
  "uploading_data_notification":"Uploading locally stored data to the server"
}
```





# SMS { #sms } 

## Service de messages courts (SMS) { #webapi_sms } 

Cette section porte sur l'API Web SMS, qui permet d'envoyer et de recevoir des messages 
texte courts.

### Service de SMS sortant { #outbound-sms-service } 

L'API Web prend en charge l'envoi de SMS sortants à l'aide de la méthode POST. Les SMS peuvent 
être envoyés à un ou plusieurs destinataires. Une ou plusieurs passerelles doivent 
être configurées avant d'utiliser le service. Un SMS ne sera pas envoyé si 
aucune passerelle n'est configurée. Il nécessite un ensemble de destinataires et 
un texte de message au format JSON, comme indiqué ci-dessous.

    /api/sms/sortant

```json
{
  "message":"Texte du Sms",
  "destinataires": [
    "004712341234",
    "004712341235"
  ]
}
```

> **Remarque**
>
> La liste des destinataires sera divisée si la taille dépasse la limite `DESTINATAIRES_MAXIMUM_AUTORISÉS` de 200.

L'API Web prend également en charge une version de paramètre de requête, mais 
l'API paramétrée ne peut être utilisée que pour envoyer des SMS à un seul 
destinataire.

    /api/sms/outbound?message=text&recipient=004712341234

Les messages sortants peuvent être récupérés à l'aide de la ressource GET.

    GET /api/sms/outbound
    GET /api/sms/outbound?filter=status:eq:SENT
    GET /api/sms/outbound?filter=status:eq:SENT&fields=*

Les messages sortants peuvent être supprimés à l'aide de la ressource SUPPRIMER.

    SUPPRIMER/api/sms/outbound/{uid}
    SUPPRIMER /api/sms/outbound?ids=uid1,uid2

#### Codes de réponse de la passerelle { #gateway-response-codes } 

La passerelle peut répondre avec les codes de réponse suivants.



Tableau : Codes de réponse de la passerelle

| Code de la réponse | Message de réponse | Description détaillée |
|---|---|---|
| CODE DU_RÉSULTAT_0 | succès | Le message a été envoyé avec succès |
| CODE DU_RÉSULTAT_1 | programmé | Le message a été programmé avec succès |
| CODE DU_RÉSULTAT_22 | erreur fatale interne | erreur fatale interne |
| CODE DU_RÉSULTAT_23 | échec de l'authentification | Les données de l'authentification sont incorrectes |
| CODE DU_RÉSULTAT_24 | échec de la validation des données | Les paramètres fournis dans la demande sont incorrects |
| CODE DU_RÉSULTAT_25 | crédits insuffisants | Le crédit est insuffisant pour envoyer un message |
| CODE DU_RÉSULTAT_26 | montant du crédit non disponible | Montant du crédit non disponible |
| CODE DU_RÉSULTAT_27 | vous avez dépassé votre quota journalier | vous avez dépassé votre quota journalier |
| CODE DU_RÉSULTAT_40 | temporairement indisponible | Le service est temporairement interrompu |
| CODE DU_RÉSULTAT_201 | taille maximale du lot dépassée | Taille maximale du lot dépassée |
| CODE DU_RÉSULTAT_200 | succès | La demande a été traitée avec succès |
| CODE DU_RÉSULTAT_202 | accepté | Le(s) message(s) sera(ont) traité(s) |
| CODE DU_RÉSULTAT_207 | multi-statut | Plus d'un message a été soumis à l'API ; cependant, tous les messages n'ont pas le même statut. |
| CODE DU_RÉSULTAT_400 | mauvaise requête | Échec de validation (paramètres ou en-têtes manquants/invalides) |
| CODE DU_RÉSULTAT_401 | Non-autorisé | Échec de l'authentification. Ce problème peut également être causé par des paramètres de verrouillage de l'IP. |
| CODE DU_RÉSULTAT_402 | paiement requis | Crédit insuffisant pour envoyer un message |
| CODE DU_RÉSULTAT_404 | pas trouvé | La ressource n'existe pas |
| CODE DU_RÉSULTAT_405 | méthode non autorisée | La méthode Http n'est pas supportée par la ressource |
| CODE DU_RÉSULTAT_410 | parti | Le numéro du téléphone portable est bloqué |
| CODE DU_RÉSULTAT_429 | trop de requêtes | Erreur générique de limitation du taux |
| CODE DU_RÉSULTAT_503 | Service indisponible | Une erreur temporaire s'est produite sur notre plateforme - veuillez réessayer |

### Service de SMS entrants { #inbound-sms-service } 

L'API Web prend en charge la collecte des messages SMS entrants à l'aide de la méthode 
POST. Les messages entrants acheminés vers l'API Web DHIS2 peuvent être 
reçus à l'aide de cette API. L'API collecte les messages SMS entrants et 
les fournit aux auditeurs pour qu'ils les analysent, en fonction du contenu du SMS (commande SMS). Un exemple de charge utile au format JSON est donné ci-dessous. Le 
texte, l'expéditeur, la date de réception et la date d'envoi sont des paramètres obligatoires. 
Les autres sont facultatifs, mais le système utilisera la valeur par défaut pour ces 
paramètres.

    /api/sms/entrant

```json
{
  "texte" : "texte de l'échantillon",
  "auteur": "004712341234",
  "iddelapasserelle " : " inconnu",
  "date de réception": "2016-05-01",
  "date d'envoi":"2016-05-01",
  "codage sms": "1",
  "statut sms":"1"
}
```

Les messages entrants peuvent être récupérés à l'aide de la ressource GET.

    GET /api/sms/inbound
    GET /api/sms/inbound?fields=*&filter=smsstatus=INCOMING

Les messages entrants peuvent être supprimés à l'aide de la ressource SUPPRIMER.

    SUPPRIMER /api/sms/inbound/{uid}
    SUPPRIMER /api/sms/inbound?ids=uid1,uid2

Pour importer tous les messages non traités

    POST /api/sms/entrant/importer



Tableau : Paramètres de requête de l'utilisateur

| Paramètre | Type | Description |
|---|---|---|
| message | Chaîne | Il s'agit d'un paramètre obligatoire qui contient le message textuel proprement dit. |
| auteur | Chaîne | Il s'agit d'un paramètre obligatoire qui indique de qui provient le message. |
| passerelle | Chaîne | Il s'agit d'un paramètre facultatif qui indique l'identifiant de la passerelle. S'il n'est pas présent, le texte par défaut " INCONNU " sera stocké |
| heure de réception | Date | Ce paramètre est facultatif. Il indique l'heure à laquelle le message a été reçu par la passerelle. |

### Administration du service de la passerelle { #gateway-service-administration } 

L'API Web expose des ressources qui permettent de configurer et 
de mettre à jour les configurations de la passerelle SMS.

La liste des différentes passerelles configurées peut être obtenue à l'aide de la méthode 
GET

    GET /api/33/gateways

Les configurations peuvent également être récupérées pour un type de passerelle spécifique à l'aide de la
méthode GET.

    GET /api/33/gateways/{uid}

De nouvelles configurations de passerelles peuvent être ajoutées à l'aide de POST. L'api POST nécessite un paramètre de requête de type et actuellement sa valeur peut être *http,bulksms,clickatell,smpp*. La première passerelle ajoutée sera définie par défaut. Une seule passerelle peut être définie par défaut à la fois. La passerelle par défaut ne peut être modifiée que par l'intermédiaire de son interface utilisateur. Si la passerelle par défaut est supprimée, la suivante dans la liste deviendra automatiquement la passerelle par défaut.

    POST /api/33/gateways

La configuration peut être mise à jour en fournissant l'uid et la configuration de la passerelle comme indiqué ci-dessous

    PUT /api/33/gateways/{uids}

Les configurations peuvent être supprimées pour un type de passerelle spécifique à l'aide de la méthode 
SUPPRIMER

    DELETE /api/33/gateways/{uid}

La passerelle par défaut peut être récupérée et mise à jour.

    GET /api/33/gateways/default

Default gateway can be set using the PUT method.

    PUT /api/33/gateways/default/{uid}

### Configuration de la passerelle { #gateway-configuration } 

L'API Web vous permet de créer et de mettre à jour les configurations de la passerelle. Pour chaque
type de passerelle, les paramètres de la charge utile JSON sont différents.
Des exemples de charges utiles JSON pour chaque passerelle sont donnés ci-dessous. POST est utilisé pour
créer et PUT pour mettre à jour les configurations. Le paramètre En-tête peut être utilisé dans
le cas de "GenericHttpGateway" pour envoyer un ou plusieurs paramètres en tant qu'en-tête http.

#### Clickatell { #clickatell } 

```json
{
  "type" : "clickatell",
  "nom" : "clickatell",
  "nom d'utilisateur": "utilisateur de clickatell",
  "authToken": "XXXXXXXXXXXXXXXXXXXX",
  "modèle d'url": "https://platform.clickatell.com/messages"
}
```

#### Bulksms { #bulksms } 

```json
{
  "type": "bulksms",
  "nom": "bulkSMS",
  "nom d'utilisateur": "utilisateur bulk",
  "mot de passe": "abc123"
}
```

#### Passerelle SMPP { #smpp-gateway } 

```json
{
  "type": "smpp",
  "nom": "smpp gateway2",
  "systemId": "smppclient1",
  "hôte" : " hôte local",
  "type de système": "cp",
  "Indicateur de plan de numérotation": "INCONNU",
  "typeDeNombre": "INCONNU",
  "type de lien": "BIND_TX",
  "port": 2775,
  "mot de passe" : "mot de passe",
  "compressé" : faux
}
```

#### Générique HTTP { #generic-http } 

```json
{
  "type": "http",
  "nom": "Générique",
  "modèle de configuration": "nom d'utilisateur=${nom d'utilisateur}&mot de passe=${mot de passe}&to=${destinataires}&code pays=880&message=${text$}&identifiant du message=0",
  "useGet": faux,
  "paramètres d'envoi d'URL":faux,
  "type de contenu": "APPLICATION_JSON",
  "modèle d'url":"https://samplegateway.com/messages",
  "paramètres": [
    {
      "en-tête": vrai,
      "code": faux,
      "clé": "nom d'utilisateur",
      "valeur": "utilisateur_uio",
      "confidentiel": vrai
    },
    {
      "en-tête": vrai,
      "code": faux,
      "clé": "mot de passe",
      "valeur": "123abcxyz",
      "confidentiel": vrai
    },
    {
      "en-tête": faux,
      "code": faux,
      "clé": "rapport de diffusion",
      "valeur": "oui",
      "confidentiel": faux
    }
  ],
  "estParDéfaut": faux
}
```

Dans une passerelle générique http, il est possible d'ajouter un nombre illimité de paramètres.



Tableau : Paramètres génériques de la passerelle SMS

| Paramètre | Type | Description |
|---|---|---|
| nom | Chaîne | nom de la passerelle |
| modèle de configuration | Chaîne | Le modèle de configuration qui est rempli avec les valeurs des paramètres. Par exemple, le modèle de configuration donné ci-dessus sera rempli comme suit : { "to" : "+27001234567", "body" : "Hello World !"} |
| useGet | Booléen | La méthode Http POST est utilisée par défaut. Pour la remplacer par Http GET, l'utilisateur peut attribuer la valeur "true" au paramètre "useGet". |
| type de contenu | Chaîne | Le type de contenu spécifie le type de données envoyées. Les types pris en charge sont l'APPLICATION_JSON, l'APPLICATION_XML, le FORMULAIRE_URL_CODE, TEXTE_CLAIR |
| modèle d'url | Chaîne | modèle d'url |
| En-tête | Booléen | Si le paramètre doit être envoyé dans les en-têtes Http |
| coder | Booléen | Si le paramètre doit être codé |
| clé | Chaîne | clé de paramètre |
| valeur | Chaîne | valeur du paramètre |
| confidentiel | Booléen | Si le paramètre est confidentiel. Ce paramètre ne sera pas exposé à travers l'API |
| Paramètres d'envoi d'Url | Booléen | Si cette option est cochée, le modèle d'url peut être ajouté aux paramètres de la requête. Ceci est utile si l'API de la passerelle ne prend en charge que le HTTP GET. Un exemple de modèle d'url ressemble à ceci `"urlTemplate" : "https://samplegateway.com/messages?apiKey={apiKey}&to={recipients},content={text},deliveryreport={dp}"`. |

HTTP.OK sera renvoyé si les configurations sont sauvegardées avec succès, sinon *Erreur*

## Les commandes SMS { #webapi_sms_commands } 

Les commandes SMS sont utilisées pour collecter des données par SMS. Ces commandes 
appartiennent à un type d'analyseur spécifique. Chaque analyseur a des fonctionnalités différentes.

La liste des commandes peut être récupérée à l'aide de la fonction GET.

    GET /api/smsCommands

Une commande particulière peut être récupérée à l'aide de GET.

    GET /api/smsCommands/uid

Une commande particulière peut être mise à jour à l'aide de PUT.

    PUT /api/smsCommands/uid

La commande peut être créée en utilisant POST.

    POST /api/smsCommands

Une commande particulière peut être supprimée à l'aide de la commande SUPPRIMER.

    DELETE /api/smsCommands/uid

#### Types de commande SMS { #sms-command-types } 

| Type | Utilisation |
|---|---|
|ANALYSEUR_CLÉ_DE VALEUR | Pour la collecte de données agrégées.|
|ANALYSEUR_D'ALERTES | Pour envoyer des messages d'alerte.|
|ANALYSEUR_NON ENREGISTRÉ | Pour la surveillance des maladies et la notification des cas.|
|ANALYSEUR_D'ENREGISTREMENT_D'ENTITÉS_SUIVIES | Pour l'enregistrement de l'entité du tracker.|
|ANALYSEUR_DE SAISIE DE DONNÉES_DE L'ÉTAPE_DU PROGRAMME | Collecte de données pour l'étape du programme. ( L'IES est identifié sur la base du numéro de téléphone )|
|ANALYSEUR_D'ENREGISTREMENT_D'ÉVÉNEMENTS | Enregistrement d'un événement unique. Elle est utilisée pour les programmes d'événements.|

#### Types de commandes SMS pour Android { #sms-command-types-for-android } 

Ces types de commandes peuvent être utilisés par l'application Android pour l'envoi de données par SMS lorsque la connexion internet n'est pas disponible. Le SMS est composé par l'application Android.

| Type | Utilisation |
|---|---|
|ENSEMBLE DE DONNÉES_AGRÉGÉ | Pour la collecte de données agrégées.|
|INSCRIPTION | Pour l'enregistrement de l'entité du tracker.|
|ÉVÉNEMENT_TRACKER | Inscription à un événement pour les programmes tracker.|
|ÉVÉNEMENT_SIMPLE | Inscription aux programmes d'événements.|
|RELATION | Pour créer des relations.|
|SUPPRIMER | Supprimer un événement.|



# Utilisateurs { #users } 

## Utilisateurs { #webapi_users } 

Cette section couvre les méthodes de ressources de l'utilisateur.

    /api/33/users

### Requête de l'utilisateur { #webapi_users_query } 

La ressource *utilisateurs* offre des paramètres de requête supplémentaires en plus des
paramètres standard (par exemple, la pagination). Pour rechercher des utilisateurs 
dans la ressource vous pouvez utiliser les paramètres suivants.

Tableau : Paramètres de requête de l'utilisateur

| Paramètre | Type | Description |
|---|---|---|
| requête | Texte | Valeur de la requête pour le prénom, le nom de famille, le nom d'utilisateur et l'adresse électronique, sensible à la casse. |
| Numéro de Téléphone | Texte | Requête pour un numéro de téléphone. |
| peutGérer | faux &#124; vrai | Filtre permettant de déterminer si l'utilisateur actuel peut gérer les utilisateurs renvoyés à travers les relations de groupe d'utilisateurs gérés. |
| authSubset | faux &#124; vrai | Filtre permettant de déterminer si les utilisateurs renvoyés ont un sous-ensemble des autorisations de l'utilisateur actuel. |
| dernière connexion | Date | Filtre les utilisateurs qui se sont connectés après la date indiquée. |
| mois inactifs | Nombre | Filtre les utilisateurs qui ne se sont pas connectés pendant le nombre de mois indiqué. |
| inactif Depuis | Date | Filtre les utilisateurs qui ne se sont pas connectés après la date indiquée. |
| auto-inscrit | faux &#124; vrai | Filtre les utilisateurs qui se sont auto-inscrits sur leur compte d'utilisateur. |
| statut de l'invitation | aucun &#124; all &#124; expiré | Filtre les invitations des utilisateurs, notamment toutes les invitations ou les invitations expirées. |
| ou | Identificateur | Filtre les utilisateurs associés à l'unité d'organisation dont l'identifiant est indiqué. |
| unités d'organisation des utilisateurs | faux &#124; vrai | Filtre les utilisateurs qui sont associés aux unités d'organisation liées à l'utilisateur actuellement connecté. |
| Inclut les enfants | faux &#124; vrai | Inclut les utilisateurs de toutes les unités d'organisation subordonnées du paramètre de l'uo. |
| page | Nombre | Le nombre de la page. |
| taille de la page | Nombre | La taille de la page |

Une requête pour un maximum de 10 utilisateurs avec "konan" comme prénom ou nom de famille (sensible 
à la casse) qui ont un sous-ensemble d'autorisations par rapport à l'utilisateur 
actuel :

    /api/33/users?query=konan&authSubset=true&pageSize=10

### Recherche d'utilisateurs { #user-lookup } 

L'API de recherche d'utilisateurs propose un système de récupération des utilisateurs lorsque la 
réponse comporte un minimum d'informations. Aucune autorité spécifique 
n'est requise et elle permet aux clients de rechercher des informations 
telles que le prénom et le nom de famille de l'utilisateur, sans pour autant révéler des informations 
potentiellement sensibles.

```
/api/userLookup
```

Le système de recherche de l'utilisateur comporte deux méthodes.

#### Recherche des utilisateurs par identifiant { #user-lookup-by-identifier } 

Vous pouvez effectuer une recherche d'utilisateur par identifiant en utilisant la requête API suivante :

```
GET /api/userLookup/{id}
```

L'`ID` de l'utilisateur sera recherché par rapport aux propriétés d'utilisateur 
suivantes dans l'ordre indiqué :

- UID
- UUID
- Nom d'utilisateur

Voici donc un exemple de requête :

```
/api/userLookup/QqvaU7JjkUV
```

La réponse comportera un minimum d'informations relatives à l'utilisateur.

```json
{
  "id": "QqvaU7JjkUV",
  "nom d'utilisateur": "nkono",
  "prénom": "Thomas",
  "nom de famille": "Nkono",
  "nom affiché": "Thomas Nkono"
}
```

#### Requête de recherche d'utilisateurs { #user-lookup-query } 

Vous pouvez réaliser une requête des utilisateurs à partir de la requête API suivante :

```
GET /api/userLookup?query={string}
```

Le paramètre de requête `query` est obligatoire. La chaîne de requête `query` sera comparée 
aux propriétés utilisateur suivantes :

- Prénom
- Nom
- Adresses électronique
- Nom d'utilisateur

Voici donc un exemple de requête :

```
/api/userLookup?query=John
```

La réponse comportera des informations relatives aux utilisateurs et correspondants à la requête.

```json
{
  "utilisateurs": [
    {
      "id": "DXyJmlo9rge",
      "nom d'utilisateur": "jbarnes",
      "prénom": "John",
      "nom de famille": "Barnes",
      "nom affiché": "John Barnes"
    },
    {
      "id": "N3PZBUlN8vq",
      "nom d'utilisateur": "jkamara",
      "prénom": "John",
      "nom de famille": "Kamara",
      "nom affiché": "John Kamara"
    }
  ]
}
```

### Créer et mettre à jour un compte utilisateur { #webapi_users_create_update } 

La création et la mise à jour des utilisateurs sont prises en charge par l'API. Une charge utile
de base pour créer un utilisateur ressemble à l'exemple ci-dessous. Notez que le mot de passe
sera envoyé en texte clair, n'oubliez donc pas d'activer SSL/HTTPS pour le transport réseau.

```json
{
  "identifiant": "Mj8balLULKp",
  "Prénom": "John",
  "nom ": "Doe",
  "email": "johndoe@mail.com",
  "informations d'identification de l'utilisateur": {
    "identifiant": "lWCkJ4etppc",
    "infoUtilisateur": {
    "identifiant": "Mj8balLULKp"
  },
  "nom d'utilisateur": "johndoe123",
  "mot de passe": "Your-password-123",
  "skype": "john.doe",
  "telegram": "joh.doe",
  "whatsApp": "+1-541-754-3010",
  "facebookMessenger": "john.doe",
  "avatar": {
    "identifiant": "<fileResource id>"
  },
  "rôles d'utilisateur": [
    {
      "identifiant": "Ufph3mGRmMo"
    }
  ]
  },
  "unités d'organisation": [
    {
      "identifiant": "Rp268JB6Ne4"
    }
  ],
  "groupes d'utilisateurs": [
    {
      "identifiant": "wl5cDMuUhmF"
    }
  ]
}
```

```bash
curl -X POST -d @u.json "http://server/api/33/users" -u user:pass
  -H "Content-Type: application/json"
```

Dans la charge utile de création d'utilisateurs, les groupes d'utilisateurs ne sont pris en charge que lors de l'importation 
ou du *POSTing* d'un seul utilisateur à la fois. Si vous tentez de créer plus d'un 
utilisateur tout en spécifiant des groupes d'utilisateurs, vous ne recevrez pas d'erreur et les 
utilisateurs seront créés, mais aucun groupe d'utilisateurs ne sera affecté. Ceci est prévu et 
limité en raison de la relation de plusieurs à plusieurs entre les utilisateurs et les 
groupes d'utilisateurs, les groupes d'utilisateurs étant propriétaires de la relation. Pour mettre à jour 
ou créer plusieurs utilisateurs et leurs groupes d'utilisateurs, envisagez un programme pour *POSTER* 
un à la fois, ou *POSTER* tous les utilisateurs suivi d'une autre action pour mettre à jour 
leurs groupes d'utilisateurs tout en spécifiant les identifiants du nouvel utilisateur.

Après la création de l'utilisateur, une entête *Location* est renvoyée avec l'identifiant 
nouvellement généré (vous pouvez également fournir le vôtre en utilisant le point d'extrémité 
`/api/system/id`). La même charge utile peut alors être utilisée pour faire des mises à jour, mais n'oubliez pas 
d'utiliser *PUT* au lieu de *POST* et le point d'extrémité est désormais `/api/users/ID`.

```bash
curl -X PUT -d @u.json "http://server/api/33/users/ID" -u user:pass
  -H "Content-Type: application/json"
```

Pour plus d'informations sur l'ensemble des données disponibles, voir `/api/schemas/user`.

Pour plus d'informations sur le téléchargement et la récupération des avatars des utilisateurs, veuillez consulter le 
point d'extrémité `/fileResources`.

### Invitations pour les comptes d'utilisateurs { #webapi_user_invitations } 

L'API Web permet d'inviter des personnes à créer des comptes d'utilisateur par le biais de la ressource
`invite`. Pour créer une invitation, vous devez POSTER un utilisateur au format XML
ou JSON à la ressource "invite". Un nom d'utilisateur spécifique peut être imposé
en définissant le nom d'utilisateur dans l'entité postée. En omettant le nom d'utilisateur,
la personne pourra le spécifier elle-même. Le système enverra
une invitation par courrier électronique. Il faut pour cela que les paramètres de messagerie soient
correctement configurés.

La ressource "invite" est utile pour permettre en toute sécurité
à des personnes de créer des comptes sans que personne d'autre ne connaisse le mot de passe
ou en transférant le mot de passe en texte clair. La charge utile à utiliser pour
l'invitation est la même que pour la création d'utilisateurs. Un exemple de charge utile en JSON
ressemble à ceci :

```json
{
  "prénom": "John",
  "nom": "Doe",
  "email": "johndoe@mail.com",
  "informations d'identification de l'utilisateur": {
    "nom d'utilisateur": "johndoe",
    "roles d'utilisateur": [{
      "id": "Euq3XfEIEbx"
    }]
  },
  "unités d'organisation": [ {
    "id": "ImspTQPwCqd"
  } ],
  "groupes d'utilisateurs": [ {
    "id": "vAvEltyXGbD"
  }]
}
```

L'entité d'invitation de l'utilisateur peut être affichée comme suit :

```bash
curl -d @invite.json "localhost/api/33/users/invite" -u admin:district
  -H "Content-Type:application/json"
```

Pour envoyer des invitations à plusieurs utilisateurs en même temps, vous devez utiliser un 
format légèrement différent. Pour JSON :

```json
{
  "utilisateurs": [ {
    "prénom": "John",
    "nom": "Doe",
    "email": "johndoe@mail.com",
    "informations d'identification de l'utilisateur": {
      "nom d'utilisateur": "johndoe",
      "rôles d'utilisateur": [ {
        "id": "Euq3XfEIEbx"
      } ]
    },
    "unités d'organisation": [ {
      "id": "ImspTQPwCqd"
      } ]
    }, {
    "prénom": "Tom",
    "nom": "Johnson",
    "email": "tomj@mail.com",
    "informations d'identification de l'utilisateur": {
      "rôles d'utilisateur": [ {
        "id": "Euq3XfEIEbx"
      } ]
    },
    "unités d'organisation": [ {
      "id": "ImspTQPwCqd"
      } ]
    }
  ]
}
```

Pour créer plusieurs invitations, vous pouvez envoyer la charge utile à la ressource
api/users/invites comme ceci :

```bash
curl -d @invites.json "localhost/api/33/users/invites" -u admin:district
  -H "Content-Type:application/json"
```

Certaines conditions doivent être remplies pour que les invitations à ouvrir un compte d'utilisateur soient 
envoyées :

  - Le serveur SMTP doit être configuré correctement sur le serveur.

  - L'utilisateur à inviter doit avoir indiqué un e-mail valide.

  - Si le nom d'utilisateur est spécifié, il ne doit pas être déjà pris par un autre
    utilisateur existant.

Si l'une de ces conditions n'est pas remplie, la ressource invitée renvoie 
un code d'état *409 Conflict* accompagné d'un message descriptif.

### Réplication de l'utilisateur { #webapi_user_replication } 

Pour répliquer un utilisateur, vous pouvez utiliser la ressource *replica*. Répliquer un
utilisateur peut être utile pour déboguer ou reproduire des problèmes signalés par un
particulier. Vous devez fournir un nouveau nom d'utilisateur et un nouveau mot de passe à l'utilisateur 
répliqué, que vous allez utiliser pour vous authentifier ultérieurement. Notez que vous
avez besoin de l'autorisation ALL pour effectuer cette action. Pour répliquer un utilisateur, vous
vous pouvez envoyer une charge utile JSON comme ci-dessous :

```json
{
  "nom d'utilisateur" : " utilisateur_replica",
  "mot de passe" : " Motdepassesecret "
}
```

Cette charge utile peut être envoyée à la ressource réplique, où vous fournissez
l'identifiant de l'utilisateur à répliquer dans l'URL :

    /api/33/users/<uid>/replica

Voici un exemple de reproduction d'un utilisateur à l'aide de curl :

```bash
curl -d @replica.json "localhost/api/33/users/N3PZBUlN8vq/replica"
  -H "Content-Type:application/json" -u admin:district
```

### Réinitialiser le mot de passe de l'utilisateur { #webapi_user_reset }

Les administrateurs utilisateurs (disposant des droits appropriés) peuvent réinitialiser le compte 
d'un autre utilisateur en déclenchant la récupération du mot de passe. Une fois l'opération déclenchée, un e-mail contenant un lien de récupération 
est envoyé à l'utilisateur. Les utilisateurs qui suivent le lien accèdent à un formulaire qui leur 
permet de définir un nouveau mot de passe.

Pour déclencher ce flux de travail pour l'utilisateur `tH7WIiIJ0O3`, utilisez :

    POST /api/37/users/tH7WIiIJ0O3/reset

### Désactiver et activer des comptes d'utilisateurs { #webapi_user_disable } 

Les comptes d'utilisateurs peuvent être marqués comme désactivés.
Un utilisateur désactivé ne peut plus se connecter.

Pour marquer un utilisateur avec l'UID `tH7WIiIJ0O3` comme désactivé (nécessite un utilisateur avec les droits appropriés) :

    POST /api/36/users/tH7WIiIJ0O3/disabled

Pour permettre à un utilisateur désactivé d'utiliser à nouveau l'outil en question (l'utilisateur doit disposer des droits appropriés) :

    POST /api/36/users/tH7WIiIJ0O3/enabled

### Expiration de l'utilisateur { #webapi_user_expiration } 

Une date d'expiration peut être définie pour un compte d'utilisateur.
Elle marque le moment à partir duquel le compte d'utilisateur a expiré 
et ne peut plus être utilisé. L'utilisateur dont le compte a expiré ne peut plus se connecter.

Pour mettre à jour la date d'expiration de l'utilisateur avec l'UID `tH7WIiIJ0O3` 
et la mettre à la date `2021-01-01` (nécessite un utilisateur avec les droits appropriés) :

    POST /api/36/users/tH7WIiIJ0O3/expired?date=2021-01-01

Pour désactiver la date d'expiration afin que le compte n'expire jamais 
utiliser en conséquence (nécessite un utilisateur disposant des droits appropriés) :

    POST /api/36/users/tH7WIiIJ0O3/unexpired

### Flux de travail pour l'approbation des données des utilisateurs { #user-data-approval-workflows } 

Pour connaître les flux de travail et les niveaux d'approbation des données auxquels un utilisateur peut accéder, 
vous pouvez utiliser la ressource *dataApprovalWorkflows* comme suit :

```
GET /api/users/{id}/dataApprovalWorkflows
```

## Informations sur l'utilisateur actuel { #webapi_current_user_information } 

Pour obtenir des informations sur l'utilisateur actuellement authentifié et ses associations 
avec d'autres ressources, vous pouvez utiliser la ressource *me* 
(vous pouvez également l'appeler par son ancien nom *currentUser*). Les 
ressources liées à l'utilisateur actuel fournissent des informations utiles lors 
de la création de clients, par exemple pour la saisie de données et la gestion des utilisateurs. Les 
paragraphes suivants décrivent ces ressources et leur objectif.

Fournit des informations de base sur l'utilisateur sous lequel vous êtes actuellement connecté.
en tant qu'utilisateur, y compris le nom d'utilisateur, les informations d'identification de l'utilisateur, les unités d'organisation 
affectées:

    /api/me

Donne des informations sur les messages non lus et les interprétations :

    /api/me/tableau de bord

Pour modifier le mot de passe, ce point d'extrémité peut être utilisé pour valider le mot de passe nouvellement saisi.
le nouveau mot de passe. La validation du mot de passe sera effectuée sur la base des
PasswordValidationRules configurées dans le système. Ce point d'extrémité prend en charge
POST et la chaîne du mot de passe doit être envoyée dans le corps de POST.

    /api/me/valider le mot de passe

Lors d'un changement de mot de passe, ce point final (support POST) peut être utilisé pour
vérifier l'ancien mot de passe. La chaîne du mot de passe doit être envoyée dans le corps du POST.

    /api/me/verifier le mot de passe

Renvoie l'ensemble des autorisations accordées à l'utilisateur actuel :

    /api/me/authorisation

Renvoie vrai ou faux, indiquant si l'utilisateur actuel a 
reçu l'autorisation `<auth>` donnée:

    /api/me/authorisation/<auth>

Indique les niveaux d'approbation des données correspondant à l'utilisateur actuel :

    /api/me/Niveaux d'approbation des données

Indique les flux de travail d'approbation des données accessibles à l'utilisateur actuel.
Pour chaque flux de travail, indique les niveaux d'approbation des données que l'utilisateur peut voir, et
les autorisations dont il dispose à chaque niveau :

    /api/me/dataApprovalWorkflows



# Paramètres et configuration { #settings-and-configuration } 

## Paramètres du système { #webapi_system_settings } 

Vous pouvez manipuler les paramètres du système en interagissant avec la ressource
*systemSettings*. Un paramètre système est une simple paire clé-valeur,
où la clé et la valeur sont des chaînes de texte en clair. Pour enregistrer ou
mettre à jour un paramètre système, vous pouvez envoyer une requête *POST* à l'URL suivante :

    /api/33/systemSettings/my-key?value=my-val

Vous pouvez également soumettre la valeur du paramètre dans le corps de la requête,
où le type de contenu est défini sur "texte/clair". Par exemple, vous pouvez utiliser
curl comme suit :

```bash
curl "play.dhis2.org/demo/api/33/systemSettings/my-key" -d "My long value"
  -H "Content-Type: text/plain" -u admin:district
```

Pour définir les paramètres du système en bloc, vous pouvez envoyer un objet JSON avec une 
propriété et une valeur pour chaque paire clé-valeur de paramètre du système à l'aide d'une requête POST :

```json
{
  "notification de l'application clé" : "Bienvenue",
  "intro de l'application clé": "DHIS2",
  "pied de page de l'application clé" : "En savoir plus sur dhis2.org"
}
```

Les traductions pour les clés de paramétrage traduisibles peuvent être définies en spécifiant  le paramètre local  comme 
paramètre de requête et la valeur traduite qui peut être spécifiée 
soit comme paramètre de requête, soit dans la charge utile du corps. Voir un exemple d'URL :

    /api/33/systemSettings/<my-key>?locale=<my-locale>&value=<my-translated-value>

Vous devez remplacer my-key par votre clé réelle et my-val par votre valeur 
réelle. Pour récupérer la valeur d'une clé donnée (en JSON ou en texte brut)
vous pouvez envoyer une requête *GET* à l'URL suivante :

    /api/33/systemSettings/my-key

Alternativement, vous pouvez spécifier la clé en tant que paramètre de requête :

    /api/33/systemSettings?key=my-key

Vous pouvez récupérer des paramètres système spécifiques sous forme de JSON en répétant la clé
paramètre de la requête :

```bash
curl "play.dhis2.org/demo/api/33/systemSettings?key=keyApplicationNotification&key=keyApplicationIntro"
  -u admin:district
```

Vous pouvez récupérer tous les paramètres du système à l'aide d'une requête GET :

    /api/33/systemSettings

Pour récupérer une traduction spécifique pour une clé traduisible donnée, vous pouvez spécifier
un paramètre local comme paramètre de requête :

    /api/33/systemSettings/<my-key>?locale=<my-locale>

Si elle est présente, la traduction pour le paramètre local donné est renvoyée. Sinon, une valeur
est renvoyée. Si aucun paramètre local n'est spécifié pour la clé traduisible, le paramètre local par défaut de 
l'interface utilisateur est utilisé pour obtenir la traduction correcte. Si la traduction donnée n'est pas
présente, la valeur par défaut est renvoyée.

La priorité pour les clés traduisibles est la suivante :

 locale spécifiée > UI local par défaut de l'utilisateur > valeur par défaut

Pour supprimer un paramètre du système, vous pouvez envoyer une requête *DELETE* à l'URL
similaire à celle utilisée ci-dessus pour la récupération. Si une clé traduisible est
utilisée, toutes les traductions présentes seront également supprimées.

Pour supprimer uniquement une traduction spécifique d'une clé traduisible, il convient d'utiliser la même URL
que pour l'ajout d'une traduction et la valeur vide doit être
fournie :

    /api/33/systemSettings/<my-key>?locale=<my-locale>&value=

Les paramètres système disponibles sont énumérés ci-dessous.



Tableau : Paramètres du système

| Clé | Description | Traduisible |
|---|---|---|
| cléUiLocale | Paramètre local pour l'interface utilisateur | Non |
| cléDbLocale | Paramètre local de la base de données | Non |
| Propriété d'affichage de l'analyse clé | La propriété à afficher dans l'analyse. Par défaut : " nom " | Non |
| Séparateur de groupes de chiffres de l'analyse clé | Le séparateur utilisé pour séparer les groupes de chiffres | Non |
| type clé du domaine actuel | Pas encore en service | Non |
| présentation du tableau de bord clé du tracker | Utilisé par la saisie tracker | Non |
| titre de l'application | Titre de l'application. Par défaut : « DHIS2 » | Oui |
| clé Introduction de l'application | La présentation de l'application | Oui |
| Notification clé de l'application | Notification de l'application | Oui |
| clé Pied de page de l'application | Pied de page gauche de l'application | Oui |
| clé pied de page droit de l'application | pied de page droit de l'application | Oui |
| clé Drapeau | Drapeau de l'application | Non |
| clé Image du drapeau | Drapeau utilisé dans le menu tableau de bord | Non |
| module démarrer | La page de démarrage de l'application. Par défaut :  " Intégration du-tableau de bord-de dhis-web  " | Non |
| facteur Écart  | Facteur d'écart-type de l'analyse des données. Par défaut :"2d" | Non |
| clé Nom de l'hôte de l'email | Nom d'hôte du serveur e-mail | Non |
| clé Port Email | Port du serveur email | Non |
| clé Tls de l'email | Utiliser TLS. Par défaut : « vrai » | Non |
| clé Expéditeur de l'e-mail | Expéditeur de l'e-mail | Non |
| clé Nom d'utilisateur de l'e-mail  | Nom d'utilisateur du serveur de l'email | Non |
| clé Mot de passe de l'e-mail  | Mot de passe du serveur de l'email | Non |
| Longueur minimale du mot de passe | Longueur minimale du mot de passe | Non |
| Longueur maximale du mot de passe | Longueur maximale du mot de passe | Non |
| clé Paramètre des Sms | Configuration de SMS | Non |
| clé Stratégie de mise en cache | Stratégie de mise en cache. Par défaut : " MIS EN CACHE_6H_DEMAIN " | Non |
| clé Mise en cache | PUBLIC ou PRIVÉ. Détermine si les serveurs proxy sont autorisés à mettre des données en cache ou non. | Non |
| Code régional du numéro de téléphone | Code régional du numéro de téléphone | Non |
| Formulaires des unités d'organisation multiples | Permet d'activer les formulaires d'unités multi-organisations. Par défaut :  " faux  " | Non |
| clé Configuration || Non |
| Clé Récupération de compte | Active la récupération des comptes d'utilisateurs. Par défaut : " faux " | Non |
| Clé Verrouillage des touches en cas d'échecs multiples de connexion | Active le verrouillage de l'accès après plusieurs échecs de connexion | Non |
| Analyse de Google UA | Clé d'analyse Google UA pour le suivi de l'utilisation du site | Non |
| Informations d'identification Expirés | Demande de modification du mot de passe du compte utilisateur. Par défaut : « 0 » (jamais) | Non |
| Alerte d'expiration des informations d'identification | Activer l'alerte lorsque les informations d'identification sont proches de la date d'expiration | Non |
| alerte d'expiration du compte | Envoi un e-mail d'alerte aux utilisateurs dont le compte est sur le point d'expirer en raison d'une date d'expiration définie. Par défaut : " faux " | Non |
| expiration du compte en jours | Nombre de jours pendant lesquels l'alerte d'expiration du compte doit être envoyée avant l'expiration réelle. Par défaut : 7 | Non |
| clé Auto inscription, pas de recaptcha | Ne pas exiger de recaptcha pour l'auto-inscription. Par défaut : " faux " | Non |
| secret de recaptcha | Secret de recaptcha de l'API Google. Par défaut : l'API secret de l'instance de jeu dhis2, mais cela ne fonctionnera que sur votre instance locale et pas en production. | Non |
| site de recaptcha | Site de recaptcha de l'API Google. Par défaut : l'API du site de l'instance de jeu dhis2, mais cela ne fonctionnera que sur votre instance locale et pas en production. | Non |
| clé Peut accorder des groupes d'autorisation à ses propres utilisateurs | Permet aux utilisateurs d'attribuer leurs propres rôles. Par défaut : " faux " | Non |
| clé limite maximale de vue Sql | Limite maximale pour la vue SQL | Non |
| clé Respecter les dates de début et de fin des métadonnées dans l'exportation des tableaux analytiques | Lorsque cette option est " vraie ", l'outil d'analyse ignore les données qui ne sont pas comprises dans les dates de début et de fin de l'option de catégorie. Par défaut : " faux " | Non |
| clé Sauter la validation du type de données dans l'exportation de tableaux analytiques | Ne pas valider le type de données dans l'exportation de tableaux analytiques | Non |
| clé Logo personnalisé de la page de connexion | Logo pour la page de connexion personnalisée | Non |
| clé Logo du menu supérieur personnalisé | Logo pour le menu supérieur personnalisé | Non |
| clé Seuil de l'année des données du Cache analytique | Les données analytiques plus anciennes que cette valeur (en années) seront toujours mises en cache. La valeur « 0 » désactive ce paramètre. Par défaut : 0 | Non |
| clé Seuil de l'année des données du Cache analytique | Les données analytiques plus anciennes que cette valeur (en années) seront toujours mises en cache. La valeur « 0 » désactive ce paramètre. Par défaut : 0 | Non |
| Analyse du début de l'exercice financier | Définir le début de l'exercice financier. Par défaut : octobre | Non |
| clé Ignorer le seuil de l'année d'approbation de l'analyse | « 0 » vérifie l'approbation de toutes les données. « -1 » désactive le contrôle de l'approbation. « 1 » ou plus vérifie l'approbation de toutes les données qui sont plus récentes que « 1 » année. | Non |
| clé Limite Maximale Analytique | Maximum number of analytics recors. Default: "50000" | Non |
| keyAnalyticsMaintenanceMode | Put analytics in maintenance mode. Default: "false" | Non |
| clé Unités centrales du serveur de la base de données | Nombre d'unités centrales du serveur de base de données. Par défaut : « 0 » (Automatique) | Non |
| clé Dernière exécution réussie des tableaux d'analyse | Conserve l'horodatage de la dernière exécution réussie des tables d'analyse. | Non |
| keyLastSuccessfulLatestAnalyticsPartitionRuntime (clé Temps d'exécution de la dernière analyse de la dernière Partition) | Conserve l'horodatage de la dernière exécution réussie de la partition analytique | Non |
| clé Dernière Exécution de la Surveillance | Conserve l'horodatage de la dernière exécution de la surveillance | Non |
| clé Dernière Syncronisation de Données Réussie | Conserve l'horodatage de la dernière synchronisation réussie des valeurs de données | Non |
| clé Dernière synchronisation réussie d'événements de données | Conserve l'horodatage de la dernière synchronisation réussie des données des programmes d'événements. | Non |
| keyLastCompleteDataSetRegistrationSyncSuccess (clé Succès de la synchronisation de l'enregistrement du dernier ensemble de données complet ) | Conserve l'horodatage de la dernière synchronisation réussie de l'exhaustivité | Non |
| sync Sauter la synchronisation pour les données modifiées avant | Spécifie l'horodatage utilisé pour ignorer la synchronisation de toutes les données modifiées avant ce point dans le temps | Non |
| Dernière mise à jour réussie des tableaux d'analyse | Conserve l'horodatage de la dernière mise à jour réussie des tableaux d'analyse | Non |
| clé Dernière mise à jour réussie de la partition analytique | Conserve l'horodatage de la dernière mise à jour réussie de la partition analytique | Non |
| clé  Dernière mise à jour réussie des tableaux de ressources | Conserve l'horodatage de la dernière mise à jour réussie des tableaux de ressources | Non |
| keyLastSuccessfulSystemMonitoringPush (Clé Dernier push réussi de la surveillance du système ) | Conserve l'horodatage de du dernier push réussi de la surveillance du système | Non |
| keyLastSuccessfulMonitoring (clé Dernière surveillance réussie) | Conserve l'horodatage de la dernière surveillance réussie | Non |
| keyNextAnalyticsTableUpdate (clé Mise à jour du tableau analytique suivant) | Conserve l'horodatage de la prochaine mise à jour du tableau d'analyse | Non |
| Lien de la page d'aide | Lien vers la page d'aide. Par défaut : "[https://dhis2.github.io/dhis2-docs/master/en/user/html/dhis2_user_manual_en.html](http://dhis2.github.io/dhis2-docs/master/en/user/html/dhis2_user_manual_en.html) | Non |
| keyAcceptanceRequiredForApproval (clé Acceptation requise pour l'approbation) | L'acceptation est requise avant la validation. Par défaut "faux" | Non |
| clé Notifications Email du Système | Où envoyer les notifications du système par e-mail | Non |
| clé Analyse de la Période Relative | Période relative par défaut pour l'analyse. Par défaut : « 12_DERNIERS_MOIS ». | Non |
| keyRequireAddToView (clé Nécessite Ajouter à l'affichage) | Autorisation requise pour l'ajout de listes d'objets à visualiser. Par défaut : « faux » | Non |
| keyAllowObjectAssignment (clé Autoriser l'affectation d'objets) | Autoriser l'affectation d'un objet à des objets apparentés lors d'un ajout ou d'une mise à jour. Par défaut "faux" | Non |
| keyUseCustomLogoFront (Clé Utilisation du logo personnalisé sur la face avant) | Permet l'utilisation d'un logo personnalisé sur la page d'accueil. Par défaut : « faux » | Non |
| keyUseCustomLogoBanner (clé Utiliser une bannière du logo personnalisé) | Permet l'utilisation d'une bannière personnalisée sur le site web. Par défaut : « faux » | Non |
| keyDataImportStrictPeriods (clé Importation de données de Périodes strictes) || Non |
| keyDataImportStrictPeriods (clé Importation de données de Périodes strictes) | Exige que les périodes correspondent au type de période de l'ensemble de données. Par défaut : « faux » | Non |
| keyDataImportStrictDataElements (Clé Importation de données Éléments de données stricts) | Exiger que les éléments de données fassent partie de l'ensemble de données. Par défaut : « faux » | Non |
| keyDataImportStrictCategoryOptionCombos (clé Importation de données Strict Combinaisons d'options de catégories) | Nécessite que les combinaisons d'options de catégorie correspondent à la combinaison de catégories de l'élément de données. Par défaut : « faux » | Non |
| keyDataImportStrictOrganisationUnits (clé Importation de données Unités d'organisation strictes) | Nécessite que les unités d'organisation correspondent à l'affectation de l'ensemble de données. Valeur par défaut : « faux » | Non |
| keyDataImportStrictAttributeOptionsCombos | Nécessite que l'option d'attribut combis corresponde à la catégorie combo de l'ensemble de données. Valeur par défaut : « faux » | Non |
| keyDataImportRequireCategoryOptionCombo | Exige que la combinaison d'options de catégorie soit spécifiée. Valeur par défaut : « faux » | Non |
| keyDataImportRequireAttributeOptionCombo | Exige que la combinaison d'options d'attributs soit spécifiée. Par défaut : « faux » | Non |
| keyCustomJs | JavaScript personnalisé à utiliser sur le site web | Non |
| keyCustomCss | CSS personnalisé à utiliser sur le site web | Non |
| clé calendrier | Le type de calendrier. Par défaut : « iso8601 ». | Non |
| keyDateFormat | Format dans lequel les dates doivent être affichées. Valeur par défaut : « aaaa-MM-jj ». | Non |
| cléStyle | Style utilisé sur les pages web de DHIS2. Valeur par défaut : « light_blue/light_blue.css ». | Non |
| keyRemoteInstanceUrl | Url utilisée pour se connecter à l'instance distante | Non |
| keyRemoteInstanceUsername | Nom d'utilisateur utilisé pour se connecter à l'instance DHIS2 distante | Non |
| keyRemoteInstancePassword | Mot de passe utilisé pour se connecter à l'instance DHIS2 distante | Non |
| keyGoogleMapsApiKey | Google Maps API key | Non |
| keyGoogleCloudApiKey | Clé de l'API Google Cloud | Non |
| keyLastMetaDataSyncSuccess | Conserve l'horodatage de la dernière synchronisation réussie des métadonnées. | Non |
| keyVersionEnabled | Permet le versionnage des métadonnées | Non |
| keyMetadataFailedVersion | Conserve les détails de l'échec de la version de synchronisation des métadonnées | Non |
| keyMetadataLastFailedTime | Conserve l'horodatage du dernier échec de synchronisation des métadonnées | Non |
| keyLastSuccessfulScheduledProgramNotifications || Non |
| keyLastSuccessfulScheduledDataSetNotifications || Non |
| keyRemoteMetadataVersion | Détails sur la version des métadonnées de l'instance distante | Non |
| keySystemMetadataVersion | Détails sur la version des métadonnées du système | Non |
| keyStopMetadataSync | Drapeau pour arrêter la synchronisation des métadonnées | Non |
| keyFileResourceRetentionStrategy | Détermine la durée de conservation des ressources du fichier associées aux valeurs supprimées ou mises à jour. AUCUNE, TROIS_MOIS, UNE_ANNÉE ou INDÉFINIMENT. | Non |
| syncMaxRemoteServerAvailabilityCheckAttempts | Specifies how many times the availability of remote server will be checked before synchronization jobs fail. | Non |
| syncMaxAttempts | Spécifie le nombre maximum de tentatives pour les tâches de synchronisation | Non |
| syncDelayBetweenRemoteServerAvailabilityCheckAttempts | Délai entre les contrôles de disponibilité du serveur distant | Non |
| lastSuccessfulDataStatistics | Conserve l'horodatage de la dernière analyse de données réussie | Non |
| keyHideDailyPeriods | Pas en cours d'utilisation | Non |
| keyHideWeeklyPeriods || Non |
| keyHideBiWeeklyPeriods | Indicateur booléen utilisé pour masquer/afficher les périodes bihebdomadaires | Non |
| keyHideMonthlyPeriods || Non |
| keyHideBiMonthlyPeriods || Non |
| keyGatherAnalyticalObjectStatisticsInDashboardViews | Si l'on souhaite recueillir des statistiques analytiques sur les objets lorsqu'ils sont visualisés dans un tableau de bord. | Non |
| keyCountPassiveDashboardViewsInUsageAnalytics | Comptabilise les consultations « passives » des tableaux de bord (sans sélection d'un tableau de bord particulier) dans l'analyse de l'utilisation. | Non |
| keyDashboardContextMenuItemSwitchViewType | Permet aux utilisateurs de changer le type d'affichage des favoris du tableau de bord | Oui |
| keyDashboardContextMenuItemOpenInRelevantApp | Permet aux utilisateurs d'ouvrir les favoris du tableau de bord dans les applications pertinentes. | Oui |
| keyDashboardContextMenuItemShowInterpretationsAndDetails | Permet aux utilisateurs d'afficher les interprétations et les détails des favoris du tableau de bord | Oui |
| keyDashboardContextMenuItemViewFullscreen | Permet aux utilisateurs d'afficher les favoris du tableau de bord en plein écran | Oui |


## Paramètres de l'utilisateur { #webapi_user_settings } 

Vous pouvez manipuler les paramètres de l'utilisateur en interagissant avec la ressource *userSettings*. Un paramètre utilisateur est une simple paire clé-valeur, où la clé et la valeur sont des chaînes de texte en clair. Le paramètre utilisateur sera lié à l'utilisateur authentifié pour la requête de l'API Web. Pour obtenir une liste de tous les paramètres utilisateur, vous pouvez envoyer une requête *GET* à l'URL suivante :

    /api/33/userSettings

Les paramètres non définis par l'utilisateur seront remplacés par les paramètres équivalents 
du système. Pour ne renvoyer que les valeurs définies explicitement par l'utilisateur, 
vous pouvez ajouter ?useFallback=false à l'URL ci-dessus, comme ceci :

    /api/33/userSettings?useFallback=false

Pour enregistrer ou mettre à jour un paramètre pour l'utilisateur actuellement authentifié, vous pouvez
envoyer une requête *POST* à l'URL suivante :

    /api/33/userSettings/my-key?value=my-val

Vous pouvez spécifier explicitement l'utilisateur pour lequel le paramètre doit être sauvegardé en utilisant 
cette syntaxe :

    /api/33/userSettings/my-key?user=username&value=my-val

Vous pouvez également soumettre la valeur du paramètre dans le corps de la requête,
où le type de contenu est défini sur "texte/clair". Par exemple, vous pouvez utiliser
curl comme suit :

```bash
curl "https://play.dhis2.org/demo/api/33/userSettings/my-key" -d "My long value"
  -H "Content-Type: text/plain" -u admin:district
```

Par exemple, pour définir les paramètres linguistiques de l'interface utilisateur de l'utilisateur actuel en français, vous 
pouvez utiliser la commande suivante.

```bash
curl "https://play.dhis2.org/demo/api/33/userSettings/keyUiLocale?value=fr"
  -X POST -u admin:district
```

Vous devez remplacer my-key par votre véritable clé et my-val par votre valeur 
réelle. Pour récupérer la valeur d'une clé donnée en texte brut, vous pouvez envoyer une 
requête *GET* à l'URL suivante :

    /api/33/userSettings/my-key

Pour supprimer un paramètre utilisateur, vous pouvez envoyer une requête *DELETE* à l'URL
similaire à celle utilisée ci-dessus pour la récupération.

Les paramètres système disponibles sont énumérés ci-dessous.



Tableau : Paramètres de l'utilisateur

| Clé | Options | Description |
|---|---|---|
| cléStyle | light_blue/light_blue.css &#124; green/green.css &#124; vietnam/vietnam.css | Feuille de style de l'interface utilisateur. |
| Clé Message de notification par Email | faux &#124; vrai | Envoi ou non de notifications par email. |
|  clé Notification par message Sms | faux &#124; vrai | Envoi ou non de notifications SMS |
| cléUiLocale | Valeur locale | Locale de l'interface utilisateur. |
| cléDbLocale | Valeur locale | Locale du contenu de la base de données. |
| Propriété d'affichage de l'analyse clé | nom &#124; Nom court | Propriété à afficher pour les métadonnées dans les applications d'analyse. |
| type clé du domaine actuel | tous &#124 ; agrégat &#124 ; tracker | Type de domaine de l'élément de données à afficher dans les listes. |
| clé Sauvegarde automatique du formulaire de saisie de cas | faux &#124; vrai | Sauvegarder périodiquement les formulaires de saisie de cas. |
| clé Formulaire d'enregistrement automatique des entités suivies | faux &#124; vrai | Sauvegarder périodiquement les formulaires d'inscription des personnes. |
| clé Sauvegarde automatique du formulaire de saisie des données | faux &#124; vrai | Sauvegarder périodiquement les formulaires de saisie de données agrégées. |
| présentation du tableau de bord clé du tracker | faux &#124; vrai | Présentation du tableau de bord du tracker. |

## Configuration { #webapi_configuration } 

Pour accéder à la configuration, vous pouvez interagir avec la ressource 
*configuration*. Vous pouvez obtenir des réponses XML et JSON via l'en-tête *Accepter* 
ou en utilisant les extensions .json ou .xml. Vous pouvez *OBTENIR* toutes les propriétés 
de la configuration depuis : 

    /api/33/configuration

Vous pouvez envoyer des requêtes *GET* et *POST* aux ressources spécifiques 
suivantes :

    GET /api/33/configuration/systemId

    GET POST DELETE /api/33/configuration/feedbackRecipients

    GET POST DELETE /api/33/configuration/offlineOrganisationUnitLevel

    GET POST /api/33/configuration/infrastructuralDataElements

    GET POST /api/33/configuration/infrastructuralIndicators

    GET POST /api/33/configuration/infrastructuralPeriodType

    GET POST DELETE /api/33/configuration/selfRegistrationRole

    GET POST DELETE /api/33/configuration/selfRegistrationOrgUnit

Pour la configuration de la liste blanche CORS, vous pouvez effectuer une requête POST avec  
une série  d'URL à inscrire sur la liste blanche comme charge utile en utilisant « application/json » comme 
type de contenu, par exemple :

```json
["www.google.com", "www.dhis2.org", "www.who.int"]
```

    GET POST /api/33/configuration/corsWhitelist

Pour les requêtes POST, la valeur de configuration doit être envoyée sous forme de texte 
dans la charge utile de la requête. Le tableau suivant indique les valeurs de configuration 
appropriées pour chaque propriété.



Tableau : Valeurs de configuration

| Propriété de la configuration | Valeur |
|---|---|
| Bénéficiaires du retour d'information | Identifiant du Groupe d’utilisateurs |
| niveau de l'unité d'organisation hors ligne | Identifiant du niveau de l'unité d'organisation |
| éléments de données infrastructurelles | Identifiant du groupe d'éléments de données |
| Indicateurs infrastructurels | Identifiant du groupe d'indicateurs |
| Type de période infrastructurelle | Nom du type de période (par exemple « Mensuel ») |
| rôle d'auto-inscription | Identifiant du rôle d'utilisateur |
| Unité d'organisation d'auto-inscription | Identifiant de l'unité d'organisation |
| Mot de passe smtp | Mot de passe du serveur email SMTP |
| Url du serveur distant | Url au serveur distant |
| Nom d'utilisateur du serveur distant | Nom d'utilisateur pour l'authentification du serveur distant |
| mot de passe du serveur distant | Mot de passe pour l'authentification du serveur distant |
| corsWhitelist | Liste JSON des URL |

Par exemple, pour définir le groupe d'utilisateurs des destinataires du retour d'information, vous pouvez invoquer 
la commande curl suivante :

```bash
curl "localhost/api/33/configuration/feedbackRecipients" -d "wl5cDMuUhmF"
  -H "Content-Type:text/plain"-u admin:district
```

## Configuration en lecture uniquement { #webapi_readonly_configuration_interface } 

Pour accéder à tous les paramètres et propriétés de configuration, vous pouvez utiliser le point d'extrémité de configuration en lecture uniquement. Cela permet l'accès en lecture uniquement aux *Paramètres de l'utilisateur, Paramètres du système et aux paramètres de configuration du serveur DHIS2*. Vous pouvez obtenir des réponses XML et JSON grâce à l'en-tête *Accept*. Vous pouvez *OBTENIR* tous les paramètres à partir de :

    /api/33/configuration/settings

Vous pouvez obtenir des paramètres filtrés en fonction du type de paramètre :

    GET /api/33/configuration/settings/filter?type=USER_SETTING

    GET /api/33/configuration/settings/filter?type=CONFIGURATION

Plus d'un type peut être fourni :

    GET /api/33/configuration/settings/filter?type=USER_SETTING&type=SYSTEM_SETTING



Tableau : Paramètres du type de valeurs

| Valeur | Description |
|---|---|
| PARAMÈTRES DE_L'UTILISATEUR | Pour obtenir les paramètres d'utilisateur |
| PARAMÈTRES DU_SYSTÈME | Pour obtenir les paramètres du système |
| CONFIGURATION | Obtenir les paramètres du serveur DHIS |

> **Remarque**
>
> Les champs confidentiels seront fournis dans le résultat, mais sans valeur.

## Jetons { #webapi_tokens } 

La ressource *tokens* fournit des jetons d'accès à différents services.

### Compte Google Service { #webapi_tokens_google_service_account } 

Vous pouvez récupérer un jeton d'accès OAuth 2.0 du compte de service Google à l'aide 
d'une requête GET vers la ressource suivante.

    GET /api/tokens/google

Le jeton est valable pendant un certain temps, après quoi 
un autre jeton doit être demandé à cette ressource. La réponse 
contient un en-tête de contrôle de cache qui correspond à l'expiration du jeton. La 
réponse contiendra les propriétés suivantes au format JSON.



Tableau : Réponse du jeton

| Propriété | Description |
|---|---|
| jeton_d'accès | The OAuth 2.0 access token to be used when authentication against Google services. |
| expire_dans | Nombre de secondes avant l'expiration du jeton d'accès, généralement 3600 secondes (1 heure). |
| identifiant_du client | L'identifiant du client du compte du service Google. |

Cela suppose qu'un compte de service Google a été créé et configuré pour DHIS2. Veuillez consulter le guide d'installation pour plus d'informations.

## Contenu statique { #webapi_static_content } 

La ressource *staticContent* vous permet de télécharger et d'extraire des logos 
personnalisés utilisés dans DHIS2. La ressource permet à l'utilisateur de télécharger un fichier avec une 
clé associée, qui peut ensuite être extraite à l'aide de la clé. Seuls les fichiers PNG 
sont pris en charge et ne peuvent être téléchargés que vers les clés `logo_banner` et 
`logo_front`.

    /api/33/staticContent



Tableau : Clés de contenu statique

| Clé | Description |
|---|---|
| logo_bannière | Logo dans le menu supérieur de l'application sur le côté gauche. |
| façade_du logo | Logo sur la page de connexion au-dessus du formulaire de connexion. |

Pour télécharger un fichier, envoyez-le avec une requête *POST* à :

    POST /api/33/staticContent/<key>

Exemple de requête pour télécharger logo.png dans la clé `logo_front` :

```bash
curl -F "file=@logo.png;type=image/png" "https://play.dhis2.org/demo/api/33/staticContent/logo_front"
  -X POST -H "Content-Type: multipart/form-data" -u admin:district
```

Le téléchargement de plusieurs fichiers avec la même clé écrasera le fichier 
existant. Ainsi, la recherche d'un fichier pour une clé donnée ne renverra que 
le dernier fichier téléchargé.

To retrieve a logo, you can *GET* the following:

    GET /api/33/staticContent/<key>

Exemple de requêtes pour récupérer le fichier stocké pour `logo_front` :

* Ajout de « Accept : text/html » à l'en-tête HTTP.*__ Dans ce cas, le point d'extrémité renverra une image par défaut si rien n'est défini. Il renvoie un flux d'images lorsqu'une image personnalisée ou par défaut est trouvée.

```bash
curl "https://play.dhis2.org/demo/api/33/staticContent/logo_front"
  -H "Accept: text/html" -L -u admin:district
```

* Ajout de « Accepter : application/json » à l'en-tête HTTP.*__ Avec ce paramètre, le point d'extrémité ne renverra jamais d'image par défaut si le logo personnalisé n'est pas trouvé. Au lieu de cela, un message d'erreur sera renvoyé. Lorsque l'image personnalisée est trouvée, ce point d'extrémité renvoie une réponse JSON contenant le chemin/URL de l'image correspondante.

```bash
curl "https://play.dhis2.org/demo/api/33/staticContent/logo_front"
  -H "Accept: application/json" -L -u admin:district
```

Les messages de succès et d'erreur se présentent comme suit :

```json
{
  "images": {
    "png": "http://localhost:8080/dhis/api/staticContent/logo_front"
  }
}
```

```json
{
  "httpStatus": "Non trouvé",
  "httpStatusCode": 404,
  "statut": "ERREUR",
  "message": "Aucun fichier personnalisé n'a été trouvé."
}
```

Pour utiliser des logos personnalisés, vous devez activer les paramètres système 
correspondants en leur attribuant la valeur *vrai*. Si le paramètre correspondant est faux, 
le logo par défaut sera utilisé.

## Personnalisation de l'IU { #webapi_ui_customization } 

Pour personnaliser l'interface utilisateur de l'application DHIS2, vous pouvez insérer des styles JavaScript et CSS personnalisés via la ressource *files*.

```
POST GET DELETE /api/33/files/script
POST GET DELETE /api/33/files/style
```

Le contenu JavaScript et CSS inséré par le biais de cette ressource sera chargé par 
l'application web DHIS2. Cela peut être particulièrement utile dans certaines situations :

  - Remplacer les styles CSS de l'application DHIS2, tels que la balise
    page de connexion ou la page principale.

  - Définir des fonctions JavaScript communes à plusieurs formulaires de saisie de données 
    personnalisés et à des rapports basés sur HTML.

  - Y compris les styles CSS utilisés dans les formulaires de saisie de données personnalisés et 
    les rapports basés sur HTML.

### Javascript { #webapi_customization_javascript } 

Pour insérer Javascript à partir d'un fichier appelé *script.js*, vous pouvez interagir 
avec la ressource *files/script* à l'aide d'une requête POST :

```bash
curl --data-binary @script.js "localhost/api/33/files/script"
  -H "Content-Type:application/javascript" -u admin:district
```

Notez que nous utilisons l'option `--data-binary` pour préserver le formatage du 
contenu du fichier. Vous pouvez récupérer le contenu du JavaScript à l'aide d'une requête GET :

    /api/33/files/script

Pour supprimer le contenu JavaScript, vous pouvez utiliser une requête de type SUPPRIMER (DELETE).

### CSS { #webapi_customization_css } 

Pour insérer une feuille de style CSS à partir d'un fichier appelé *style.css*, vous pouvez interagir avec la ressource
*files/style* en utilisant une requête POST :

```bash
curl --data-binary @style.css "localhost/api/33/files/style"
  -H "Content-Type:text/css" -u admin:district
```

Vous pouvez récupérer le contenu CSS à l'aide d'une requête GET :

    /api/33/files/style

Pour supprimer le contenu JavaScript, vous pouvez utiliser une requête de type SUPPRIMER (DELETE).



# Tracker { #tracker } 

## Tracker Web API { #webapi_tracker_api } 

L'API Web du Tracker est constitué de 3 points d'extrémité qui ont un support CRUD complet (créer, lire, mettre à jour, supprimer). Les 3 points d'extrémité sont `/api/trackedEntityInstances`, `/api/enrollments` et `/api/events` et ils prennent en charge les instances d'entités suivies, les inscriptions et les événements.

### Tracked entity instance management { #webapi_tracked_entity_instance_management } 

Les instances d'entités suivies bénéficient d'une prise en charge CRUD complète dans l'API. Avec l'API d'inscription, la plupart des opérations nécessaires pour travailler avec les instances d'entités suivies et les programmes sont prises en charge.

    /api/33/trackedEntityInstances

#### Creating a new tracked entity instance { #webapi_creating_tei } 

Pour créer une nouvelle personne dans le système, vous devez utiliser la ressource *trackedEntityInstances* (instances d'entités suivies). Un modèle de charge est présenté ci-dessous :

```json
{
  "trackedEntity": "tracked-entity-id",
  "orgUnit": "org-unit-id",
  "geometry": "<Geo JSON>",
  "attributes": [{
    "attribute": "attribute-id",
    "value": "attribute-value"
  }]
}
```

Le champ "geometry" accepte un objet GeoJson, dont le type doit correspondre au featureType (type de fonctionnalité) du TrackedEntityType (type d'entité suivie). Voici un exemple d'objet GeoJson :

```json
{
  "type": "Point",
  "coordinates": [1, 1]
}
```

Le champ "coordinates" a été introduit dans la version 2.29 et accepte comme valeur une coordonnée ou un polygone.

Pour obtenir les ID de `relationship` et `attributes`, vous pouvez consulter respectivement les ressources `relationshipTypes` et `trackedEntityAttributes`.
Pour créer une instance d'entité suivie, vous devez utiliser la méthode HTTP *POST*.
Vous pouvez envoyer la charge à l'URL suivante :

    /api/trackedEntityInstances

Par exemple, créons une nouvelle instance pour une entité suivie de personne et spécifions ses attributs 'prénom' et 'nom' :

```json
{
  "trackedEntity": "nEenWmSyUEp",
  "orgUnit": "DiszpKrYNg8",
  "attributes": [
    {
      "attribute": "w75KJ2mc4zz",
      "value": "Joe"
    },
    {
      "attribute": "zDhUuAYrxNC",
      "value": "Smith"
    }
  ]
}
```

Pour envoyer ces données au serveur, vous pouvez utiliser la commande cURL comme suit :

```bash
curl -d @tei.json "https://play.dhis2.org/demo/api/trackedEntityInstances" -X POST
  -H "Content-Type: application/json" -u admin:district
```

Pour créer plusieurs instances à l'aide d'une seule requête, vous pouvez envelopper la charge dans un tableau extérieur comme ceci et effectuer une requête POST à la même ressource comme ci-dessus :[]()

```json
{
  "trackedEntityInstances": [
    {
      "trackedEntity": "nEenWmSyUEp",
      "orgUnit": "DiszpKrYNg8",
      "attributes": [
        {
          "attribute": "w75KJ2mc4zz",
          "value": "Joe"
        },
        {
          "attribute": "zDhUuAYrxNC",
          "value": "Smith"
        }
      ]
    },
    {
      "trackedEntity": "nEenWmSyUEp",
      "orgUnit": "DiszpKrYNg8",
      "attributes": [
        {
          "attribute": "w75KJ2mc4zz",
          "value": "Jennifer"
        },
        {
          "attribute": "zDhUuAYrxNC",
          "value": "Johnson"
        }
      ]
    }
  ]
}
```

Le système ne permet pas la création d'une instance d'entité suivie (ainsi que l'inscription et l'événement) avec un UID déjà utilisé dans le système. Cela signifie que les UID ne peuvent pas être réutilisés.

#### Updating a tracked entity instance { #webapi_updating_tei } 

Pour la mise à jour d'une instance d'entité suivie, la charge est identique à celle de la section précédente. La différence est que vous devez utiliser la méthode HTTP *PUT* pour la requête lors de l'envoi de la charge. Vous devrez également ajouter l'identifiant de la personne à la ressource *trackedEntityInstances* dans l'URL comme suit, où `<tracked-entity-instance-identifier>` doit être remplacé par l'identifiant de l'instance d'entité suivie :

    /api/trackedEntityInstances/<tracked-entity-instance-id>

La charge doit contenir tous les attributs et relations, même ceux qui n'ont pas été modifiés. Les attributs ou les relations qui étaient présents auparavant et qui ne sont plus présents dans la charge actuelle seront supprimés du système. Cela signifie que si des attributs/relations sont vides dans la charge actuelle, tous les attributs/relations existants seront supprimés du système. Depuis la version 2.31, il est possible d'ignorer les attributs/relations vides dans la charge en cours d'utilisation. Vous pouvez définir le paramètre de requête `ignoreEmptyCollection` sur `true` si vous ne voulez pas envoyer des attributs ou des relations et que vous ne voulez pas non plus qu'ils soient supprimés du système.

Il n'est pas autorisé de mettre à jour une instance d'entité suivie déjà supprimée. Il n'est pas non plus autorisé de marquer une instance d'entité suivie comme supprimée via une requête de mise à jour. Les mêmes règles s'appliquent aux inscriptions et aux événements.

#### Deleting a tracked entity instance { #webapi_deleting_tei } 

Pour supprimer une instance d'entité suivie, envoyez une requête à l'URL qui identifie cette instance d'entité suivie avec la méthode *DELETE*. L'URL est la même que celle utilisée plus haut pour la mise à jour.

#### Create and enroll tracked entity instances { #webapi_create_enroll_tei } 

Il est également possible de créer (et de mettre à jour) une instance d'entité suivie et de l'inscrire en même temps à un programme

```json
{
  "trackedEntity": "tracked-entity-id",
  "orgUnit": "org-unit-id",
  "attributes": [{
    "attribute": "attribute-id",
    "value": "attribute-value"
  }],
  "enrollments": [{
    "orgUnit": "org-unit-id",
    "program": "program-id",
    "enrollmentDate": "2013-09-17",
    "incidentDate": "2013-09-17"
   }, {
    "orgUnit": "org-unit-id",
    "program": "program-id",
    "enrollmentDate": "2013-09-17",
    "incidentDate": "2013-09-17"
   }]
}
```

Vous l'enverrez au serveur comme vous le feriez normalement lors de la création ou de la mise à jour d'une nouvelle instance d'entité suivie.

```bash
curl -X POST -d @tei.json -H "Content-Type: application/json"
  -u user:pass "http://server/api/33/trackedEntityInstances"
```

#### Complete example of payload including: tracked entity instance, enrollment and event { #webapi_create_enroll_tei_create_event } 

Il est également possible de créer (et de mettre à jour) une instance d'entité suivie, de l'inscrire en même temps à un programme et de créer un événement.

```json
{
  "trackedEntityType": "nEenWmSyUEp",
  "orgUnit": "DiszpKrYNg8",
  "attributes": [
    {
      "attribute": "w75KJ2mc4zz",
      "value": "Joe"
    },
    {
      "attribute": "zDhUuAYrxNC",
      "value": "Rufus"
    },
    {
     "attribute":"cejWyOfXge6",
     "value":"Male"
    }
  ],
  "enrollments":[
    {
      "orgUnit":"DiszpKrYNg8",
      "program":"ur1Edk5Oe2n",
      "enrollmentDate":"2017-09-15",
      "incidentDate":"2017-09-15",
      "events":[
        {
          "program":"ur1Edk5Oe2n",
          "orgUnit":"DiszpKrYNg8",
          "eventDate":"2017-10-17",
          "status":"COMPLETED",
          "storedBy":"admin",
          "programStage":"EPEcjy3FWmI",
          "coordinate": {
            "latitude":"59.8",
            "longitude":"10.9"
          },
          "dataValues": [
            {
              "dataElement":"qrur9Dvnyt5",
              "value":"22"
            },
            {
              "dataElement":"oZg33kd9taw",
              "value":"Male"
            }
         ]
      },
      {
         "program":"ur1Edk5Oe2n",
         "orgUnit":"DiszpKrYNg8",
         "eventDate":"2017-10-17",
         "status":"COMPLETED",
         "storedBy":"admin",
         "programStage":"EPEcjy3FWmI",
         "coordinate": {
           "latitude":"59.8",
           "longitude":"10.9"
         },
         "dataValues":[
           {
             "dataElement":"qrur9Dvnyt5",
             "value":"26"
           },
           {
             "dataElement":"oZg33kd9taw",
             "value":"Female"
           }
         ]
       }
     ]
    }
  ]  
}
```

Vous l'enverrez au serveur comme vous le feriez normalement lors de la création ou de la mise à jour d'une nouvelle instance d'entité suivie.

```bash
curl -X POST -d @tei.json -H "Content-Type: application/json"
  -u user:pass "http://server/api/33/trackedEntityInstances"
```

#### Generated tracked entity instance attributes { #webapi_generate_tei_attributes } 

Les attributs d'instances d'entités suivies dont les valeurs uniques sont générées automatiquement ont trois points d'extrémité qui sont utilisés par les applications. Ces points d'extrémité sont tous utilisés pour générer et réserver des valeurs.

Dans la version 2.29, nous avons introduit TextPattern pour définir et générer ces modèles. Tous les modèles existants seront convertis en modèles TextPattern valides lors de la mise à jour vers la version 2.29.

> **Remarque**
>
> À partir de la version 2.29, tous ces points d'extrémité vous demanderont d'inclure toutes les 
> variables rapportées par le point d'extrémité `requiredValues` et qui sont listées comme
> obligatoires. Les modèles existants, composés uniquement de `#`, seront mis à jour
> vers la nouvelle syntaxe TextPattern `RANDOM(<old-pattern>)`. Le > segment RANDOM
du TextPattern n'est pas une variable obligatoire, donc ce   > point d'extrémité fonctionnera comme auparavant pour les modèles définis avant la version 2.29.

##### Recherche des valeurs obligatoires { #finding-required-values } 

Un TextPattern peut contenir des variables qui changent en fonction de différents facteurs. Certains de ces facteurs sont inconnus du serveur. Pour cela, les valeurs de ces variables doivent être fournies lors de la génération et de la réservation des valeurs.

Cet point d'extrémité va renvoyer un plan de valeurs obligatoires et optionnelles, que le serveur va intégrer dans le TextPattern lorsqu'il génère de nouvelles valeurs. Les variables obligatoires doivent être fournies pour la génération, mais les variables optionnelles ne doivent être fournies que si vous savez ce que vous faites.

    GET /api/33/trackedEntityAttributes/Gs1ICEQTPlG/requiredValues

```json
{
  "REQUIRED": [
    "ORG_UNIT_CODE"
  ],
  "OPTIONAL": [
    "RANDOM"
  ]
}
```

##### Generate value endpoint { #webapi_generate_values } 

Les applications web en ligne et les autres clients qui souhaitent générer une valeur qui sera utilisée immédiatement peuvent utiliser le point d'extrémité de génération simple. Ce point d'extrémité génère une valeur dont l'unicité est garantie au moment de la génération. La valeur ne sera pas non plus réservée. Depuis la version 2.29, ce point d'extrémité réserve également la valeur générée pendant 3 jours.

Si votre TextPattern comprend des valeurs obligatoires, vous pouvez les utiliser comme paramètres dans l'exemple ci-dessous :

Le délai d'expiration peut également être modifié au moment de la génération, en ajoutant l'option `?expiration=<number-of-days>` à la requête.

    GET /api/33/trackedEntityAttributes/Gs1ICEQTPlG/generate?ORG_UNIT_CODE=OSLO

```json
{
  "ownerObject": "TRACKEDENTITYATTRIBUTE",
  "ownerUid": "Gs1ICEQTPlG",
  "key": "RANDOM(X)-OSL",
  "value": "C-OSL",
  "created": "2018-03-02T12:01:36.680",
  "expiryDate": "2018-03-05T12:01:36.678"
}
```

##### Generate and reserve value endpoint { #webapi_generate_reserve_values } 

Le point d'extrémité de génération et de réservation est utilisé par les clients hors ligne qui ont besoin d'enregistrer des entités suivies avec des identifiants uniques. Ils réservent un certain nombre d'identifiants uniques que ce dispositif utilisera ensuite lors de l'enregistrement de nouvelles instances d'entités suivies. Une requête est envoyée à ce point d'extrémité afin de récupérer un certain nombre de valeurs réservées pour les instances d'entités suivies. Un paramètre facultatif, "numberToReserve", indique le nombre d'identifiants à générer (par défaut, ce paramètre est défini sur 1).

Si votre TextPattern comprend des valeurs obligatoires, vous pouvez les utiliser comme paramètres dans l'exemple ci-dessous :

Comme pour le point d'extrémité de génération, ce point d'extrémité peut également spécifier le délai d'expiration de la même manière. En ajoutant `?expiration=<number-of-days>`, vous pouvez remplacer le délai par défaut de 60 jours.

    GET /api/33/trackedEntityAttributes/Gs1ICEQTPlG/generateAndReserve?numberToReserve=3&ORG_UNIT_CODE=OSLO

```json
[
  {
    "ownerObject": "TRACKEDENTITYATTRIBUTE",
    "ownerUid": "Gs1ICEQTPlG",
    "key": "RANDOM(X)-OSL",
    "value": "B-OSL",
    "created": "2018-03-02T13:22:35.175",
    "expiryDate": "2018-05-01T13:22:35.174"
  },
  {
    "ownerObject": "TRACKEDENTITYATTRIBUTE",
    "ownerUid": "Gs1ICEQTPlG",
    "key": "RANDOM(X)-OSL",
    "value": "Q-OSL",
    "created": "2018-03-02T13:22:35.175",
    "expiryDate": "2018-05-01T13:22:35.174"
  },
  {
    "ownerObject": "TRACKEDENTITYATTRIBUTE",
    "ownerUid": "Gs1ICEQTPlG",
    "key": "RANDOM(X)-OSL",
    "value": "S-OSL",
    "created": "2018-03-02T13:22:35.175",
    "expiryDate": "2018-05-01T13:22:35.174"
  }
]
```

##### Valeurs réservées { #reserved-values } 

Les valeurs réservées ne sont actuellement pas accessibles via l'API, mais elles sont renvoyées par les points d'extrémité `generate` (génération) et `generate And Reserve` (génération et réservation). Le tableau suivant explique les propriétés de l'objet de valeur réservée :

#####



Tableau : Valeurs réservées

| Propriété | Description |
|---|---|
| ownerObject  | Le type de métadonnées référencé lors de la génération et de la réservation de la valeur. Actuellement, seul TRACKEDENTITYATTRIBUTE (attribut d'entité suivie) est pris en charge. |
| ownerUid | L'uid de l'objet de métadonnées référencé lors de la génération et de la réservation de la valeur. |
| clé | Une valeur partiellement générée où les segments générés ne sont pas encore ajoutés. |
| valeur | La valeur réservée. C'est la valeur que vous envoyez au serveur lorsque vous stockez des données. |
| créé | Date et heure à laquelle la réservation a été effectuée |
| expiryDate | Date et heure à partir de laquelle la réservation ne sera plus valable. |

Les réservations expirées sont supprimées quotidiennement. Si un modèle change, les valeurs déjà réservées seront acceptées lors du stockage des données, même si elles ne correspondent pas au nouveau modèle, tant que la réservation n'a pas expiré.

#### Attributs d'image { #image-attributes } 

Travailler avec des attributs d'image ressemble beaucoup à travailler avec des valeurs de données de fichier. La valeur d'un attribut de type image est l'identifiant de la ressource de fichier associée. Une requête GET au point d'extrémité `/api/trackedEntityInstances/<entityId>/<attributeId>/image` renverra l'image proprement dite. Les paramètres facultatifs height (hauteur) et width (largeur) peuvent être utilisés pour spécifier les dimensions de l'image.

```bash
curl "http://server/api/33/trackedEntityInstances/ZRyCnJ1qUXS/zDhUuAYrxNC/image?height=200&width=200"
  > image.jpg
```

L'API prend également en charge un paramètre *dimension*. Il peut prendre trois valeurs possibles (attention aux lettres majuscules) : `SMALL` (254x254), `MEDIUM` (512x512), `LARGE` (1024x1024) ou `ORIGINAL`. Les attributs de type d'image seront stockés dans des tailles pré-générées et seront fournis par requête en fonction de la valeur du paramètre `dimension`.

```bash
curl "http://server/api/33/trackedEntityInstances/ZRyCnJ1qUXS/zDhUuAYrxNC/image?dimension=MEDIUM"
```

#### Tracked entity instance query { #webapi_tracked_entity_instance_query } 

Pour rechercher des instances d'entités suivies, vous pouvez interagir avec la ressource `/api/trackedEntityInstances`.

    /api/33/trackedEntityInstances

##### Request syntax { #webapi_tei_query_request_syntax } 



Tableau : Paramètres de requête pour les instances d'entités suivies

| Paramètre de requête | Description |
|---|---|
| filtre | Attributs à utiliser comme filtre pour la requête. Le paramètre peut être répété autant de fois que nécessaire. Les filtres peuvent être appliqués à une dimension selon le format <attribute-id\>:<operator\>:<filter\>[ :<operator\>:<filter\>]. Les valeurs du filtre sont insensibles à la casse et peuvent être répétées avec l'opérateur autant de fois que nécessaire. Les opérateurs peuvent être EQ | GT | GE | LT | LE | NE | LIKE | IN. |
| ou | Identifiants des unités d'organisation, séparés par des " ;". |
| ou Mode | Le mode de sélection des unités d'organisation. les différentes options sont SÉLECTIONNÉES | SUBORDONNÉES | DÉSCENDANTS | ACCESSIBLES | SAISIE | TOUTES. Par défaut, le mode est défini sur SÉLECTIONNÉES, et cela ne concerne que les unités d'organisation sélectionnées. Voir le tableau ci-dessous pour les explications. |
| de paludisme) ». | Identifiant du programme. Il détermine le programme auquel les instances doivent être inscrites. |
| programStatus (statut de programme) | Statut de l'instance pour le programme donné. Peut être ACTIF | TERMINÉ | ANNULÉ. |
| suivi | Statut du suivi de l'instance pour le programme donné. Peut être vrai, faux ou omis. |
| programStartDate | Date de début de l'inscription au programme donné pour l'instance d'entité suivie. |
| programEndDate | Date de fin de l'inscription au programme pour l'instance d'entité suivie. |
| Entité suivie | Identifiant de l'entité suivie ; il restreint les instances au type d'instance suivie donné. |
| page | Le numéro de page. La page par défaut est 1. |
| taille de la page | La taille de la page. La taille par défaut est de 50 lignes par page. |
| totalPages (pages totales) | Indique s'il faut inclure le nombre total de pages dans la réponse de pagination (ce qui implique un temps de réponse plus long). |
| skipPaging | Indique si la pagination doit être ignorée et si toutes les lignes doivent être renvoyées. |
| lastUpdatedStartDate | Filtre pour les TEI qui ont été mises à jour après cette date ; ne peut être utilisé avec *lastUpdatedDuration*. |
| lastUpdatedEndDate | Filtre pour les TEI qui ont été mises à jour jusqu'à cette date ; ne peut être utilisé avec *lastUpdatedDuration*. |
| lastUpdatedDuration (durée de la dernière mise à jour) | Ce paramètre inclut uniquement les éléments qui ont été mis à jour pendant la durée spécifiée. Le format est jj-hh-mm-ss, où  "j" = jours, "h" = heures, "m" = minutes et "s" = secondes. Il ne peut pas être utilisé avec *lastUpdatedStartDate* et/ou *lastUpdatedEndDate*. |
| Mode utilisateur attribué | Restreint le résultat à la TEI dont les événements sont attribués en fonction du mode de sélection de l'utilisateur. Il peut être CURRENT (actuel) | PROVIDED (fourni) | NONE (aucun) | ANY (tout). |
| assignedUser (Utilisateur assigné) | Permet de filtrer le résultat de manière à obtenir un ensemble limité de TEI avec des événements attribués aux UID donnés, en utilisant ceci : *assignedUser=id1;id2*. Ce paramètre ne sera pris en compte que si le assignedUserMode est PROVIDED ou null. L'API va générer une erreur si, par exemple, assignedUserMode=CURRENT et assignedUser=someId |
| trackedEntityInstance | Filtre le résultat de manière à obtenir un ensemble limité de TEI qui utilisent des uids d'instances d'entités suivies explicites. Vous pouvez le faire en utilisant ceci : *trackedEntityInstance=id1;id2*. Ce paramètre créera, au minimum, la limite externe des résultats, en constituant la liste de toutes les TEI à l'aide des uids fournis. Si d'autres paramètres/filtres de ce tableau sont utilisés, ils limiteront davantage les résultats à partir de la limite externe explicite. |
| includeDeleted | Indique s'il faut inclure ou non les fichiers supprimés de manière réversible. La valeur par défaut est "false". |
| potentialDuplicate (doublon potentiel) | Il est possible de filtrer le résultat en supposant qu'une TEI soit un doublon potentiel. true: renvoie les TEI marqués comme doublons potentiels. false: renvoie les TEI NON marqués comme doublons potentiels. En cas d'omission, nous ne vérifions pas si une TEI est un doublon potentiel ou pas.|

Les modes de sélection d'unités d'organisation disponibles sont expliqués dans le tableau suivant.



Tableau : Modes de sélection des unités d'organisation

| Mode | Description |
|---|---|
| SELECTED | Unités d'organisation définies dans la requête. |
| CHILDREN | Unités d'organisation sélectionnées et leurs subordonnées directs, c'est-à-dire les unités d'organisation au niveau inférieur. |
| DESCENDANTS | Unités d'organisation sélectionnées et tous leurs subordonnées, c'est-à-dire toutes les unités d'organisation qui leur sont inférieures dans la hiérarchie. |
| ACCESSIBLE | The data view organisation units associated with the current user and all children, i.e. all organisation units in the sub-hierarchy. Will fall back to data capture organisation units associated with the current user if the former is not defined. |
| CAPTURE | Les unités d'organisation de saisie de données associées à l'utilisateur actuel et toutes leurs subordonnées, c'est-à-dire toutes les unités d'organisation qui leur sont inférieures dans la hiérarchie. |
| ALL | Il s'agit de toutes les unités d'organisation du système. L'utilisateur doit disposer de l'autorité `TOUS` pour pouvoir l'utiliser. |

La requête n'est pas sensible à la casse. Les règles suivantes s'appliquent aux paramètres de la requête.

  - Au moins une unité d'organisation doit être spécifiée à l'aide de l'attribut *ou*.
    (un ou plusieurs), ou *ouMode=ALL* doit être spécifié.

  - Un seul des paramètres *program* et *trackedEntity* peut être
    spécifié (zéro ou un).

  - Si *programStatus* est spécifié, alors *program* doit également être
    spécifiés.

  - Si *followUp* est spécifié, alors *program* doit également être spécifié.

  - Si *programStartDate* ou *programEndDate* est spécifié, alors
    *program* doit également être spécifié.

  - Les éléments du filtre ne peuvent être spécifiés qu'une seule fois.

Une requête pour toutes les instances associées à une unité d'organisation spécifique peut ressembler à ceci :

    /api/33/trackedEntityInstances.json?ou=DiszpKrYNg8

Pour lancer une requête pour des instances à l'aide d'un attribut avec filtre et d'un attribut sans filtre, avec une unité d'organisation en utilisant le mode de requête de l'unité d'organisation subordonnée, utilisez ceci :

    /api/33/trackedEntityInstances.json?filter=zHXD5Ve1Efw:EQ:A
      &filter=AMpUYgxuCaE&ou=DiszpKrYNg8;yMCshbaVExv

Une requête pour les instances où un attribut est inclus dans la réponse et où un attribut est utilisé comme filtre :

    /api/33/trackedEntityInstances.json?filter=zHXD5Ve1Efw:EQ:A
      &filter=AMpUYgxuCaE:LIKE:Road&ou=DiszpKrYNg8

Une requête dans laquelle plusieurs opérandes et filtres sont spécifiés pour un élément de filtre :

    api/33/trackedEntityInstances.json?ou=DiszpKrYNg8&program=ur1Edk5Oe2n
      &filter=lw1SqmMlnfh:GT:150:LT:190

Pour lancer une requête sur un attribut en utilisant plusieurs valeurs dans un filtre *IN* :

    api/33/trackedEntityInstances.json?ou=DiszpKrYNg8
      &filter=dv3nChNSIxy:IN:Scott;Jimmy;Santiago

Pour limiter la réponse aux instances qui font partie d'un programme spécifique, vous pouvez inclure un paramètre de requête de programme :

    api/33/trackedEntityInstances.json?filter=zHXD5Ve1Efw:EQ:A&ou=O6uvpzGd5pu
      &ouMode=DESCENDANTS&program=ur1Edk5Oe2n

Pour spécifier les dates d'inscription au programme dans la requête :

    api/33/trackedEntityInstances.json?filter=zHXD5Ve1Efw:EQ:A&ou=O6uvpzGd5pu
      &program=ur1Edk5Oe2n&programStartDate=2013-01-01&programEndDate=2013-09-01

Pour limiter la réponse aux instances d'une entité suivie spécifique, vous pouvez inclure un paramètre de requête d'entité suivie :

    api/33/trackedEntityInstances.json?filter=zHXD5Ve1Efw:EQ:A&ou=O6uvpzGd5pu
      &ouMode=DESCENDANTS&trackedEntity=cyl5vuJ5ETQ

Par défaut, les instances sont renvoyées dans des pages de taille 50. Pour modifier cela, vous pouvez utiliser les paramètres de requête de page et de taille de page (pageSize) :

    api/33/trackedEntityInstances.json?filter=zHXD5Ve1Efw:EQ:A&ou=O6uvpzGd5pu
      &ouMode=DESCENDANTS&page=2&pageSize=3

Vous pouvez utiliser une gamme d'opérateurs pour le filtrage :



Tableau : Opérateurs de filtre

| Opérateur | Description |
|---|---|
| EQ | Egale à |
| GT | Supérieure à |
| GE | Supérieure ou égal à |
| LT | Inférieur à |
| LE | inférieur ou égal à |
| NE | Pas égal à |
| LIKE | Pareil (correspondance textuelle) |
| IN | Égal à l'une des multiples valeurs séparées par ";" |

##### Response format { #webapi_tei_query_response_format } 

Cette ressource prend en charge les représentations JSON, JSONP, XLS et CSV.

  - json (application/json)

  - jsonp (application/javascript)

  - xml (application/xml)

La réponse en JSON/XML est au format objet et peut ressembler à ce qui suit. Le filtrage des champs est possible, donc si vous voulez un affichage complet, vous pouvez ajouter `fields=*` à la requête :

```json
{
  "trackedEntityInstances": [
    {
      "lastUpdated": "2014-03-28 12:27:52.399",
      "trackedEntity": "cyl5vuJ5ETQ",
      "created": "2014-03-26 15:40:19.997",
      "orgUnit": "ueuQlqb8ccl",
      "trackedEntityInstance": "tphfdyIiVL6",
      "relationships": [],
      "attributes": [
        {
          "displayName": "Address",
          "attribute": "AMpUYgxuCaE",
          "type": "string",
          "value": "2033 Akasia St"
        },
        {
          "displayName": "TB number",
          "attribute": "ruQQnf6rswq",
          "type": "string",
          "value": "1Z 989 408 56 9356 521 9"
        },
        {
          "displayName": "Weight in kg",
          "attribute": "OvY4VVhSDeJ",
          "type": "number",
          "value": "68.1"
        },
        {
          "displayName": "Email",
          "attribute": "NDXw0cluzSw",
          "type": "string",
          "value": "LiyaEfrem@armyspy.com"
        },
        {
          "displayName": "Gender",
          "attribute": "cejWyOfXge6",
          "type": "optionSet",
          "value": "Female"
        },
        {
          "displayName": "Phone number",
          "attribute": "P2cwLGskgxn",
          "type": "phoneNumber",
          "value": "085 813 9447"
        },
        {
          "displayName": "First name",
          "attribute": "dv3nChNSIxy",
          "type": "string",
          "value": "Liya"
        },
        {
          "displayName": "Last name",
          "attribute": "hwlRTFIFSUq",
          "type": "string",
          "value": "Efrem"
        },
        {
          "code": "Height in cm",
          "displayName": "Height in cm",
          "attribute": "lw1SqmMlnfh",
          "type": "number",
          "value": "164"
        },
        {
          "code": "City",
          "displayName": "City",
          "attribute": "VUvgVao8Y5z",
          "type": "string",
          "value": "Kranskop"
        },
        {
          "code": "State",
          "displayName": "State",
          "attribute": "GUOBQt5K2WI",
          "type": "number",
          "value": "KwaZulu-Natal"
        },
        {
          "code": "Zip code",
          "displayName": "Zip code",
          "attribute": "n9nUvfpTsxQ",
          "type": "number",
          "value": "3282"
        },
        {
          "code": "National identifier",
          "displayName": "National identifier",
          "attribute": "AuPLng5hLbE",
          "type": "string",
          "value": "465700042"
        },
        {
          "code": "Blood type",
          "displayName": "Blood type",
          "attribute": "H9IlTX2X6SL",
          "type": "string",
          "value": "B-"
        },
        {
          "code": "Latitude",
          "displayName": "Latitude",
          "attribute": "Qo571yj6Zcn",
          "type": "string",
          "value": "-30.659626"
        },
        {
          "code": "Longitude",
          "displayName": "Longitude",
          "attribute": "RG7uGl4w5Jq",
          "type": "string",
          "value": "26.916172"
        }
      ]
    }
  ]
}
```

#### Tracked entity instance grid query { #webapi_tracked_entity_instance_grid_query } 

Pour effectuer une requête sur les instances d'entités suivies, vous pouvez interagir avec la ressource */api/trackedEntityInstances/grid*. Il existe deux types de requêtes : L'une où un paramètre de requête *query* et éventuellement des paramètres *attribute* sont définis, et l'autre où des paramètres *attribute* et *filter* sont définis. Ce point d'extrémité utilise un format de "grille" plus compact et constitue une alternative à la requête de la section précédente.

    /api/33/trackedEntityInstances/query

##### Request syntax { #webapi_tei_grid_query_request_syntax } 



Tableau : Paramètres de requête pour les instances d'entités suivies

| Paramètre de requête | Description |
|---|---|
| requête | Chaîne de requête. Le paramètre de requête "Attribute" peut être utilisé pour définir les attributs à inclure dans la réponse. Si aucun attribut n'est défini mais qu'un programme l'est, les attributs de ce programme seront utilisés. Si aucun programme n'est défini, tous les attributs seront utilisés. Il existe deux formats. Le premier est une chaîne de requête plan. Le second est au format <opérateur>:<requête>. Les opérateurs peuvent être EQ | LIKE. EQ signifie qu'il y a des correspondances exactes avec les mots, LIKE signifie qu'il y a des correspondances partielles avec les mots. La requête sera divisée sur l'espace, où chaque mot formera une requête logique AND. |
| attribut | Attributs à inclure dans la réponse. Ce paramètre peut également être utilisé comme filtre pour la requête. Il peut être répété autant de fois que nécessaire. Les filtres peuvent être appliqués à une dimension selon le format <attribute-id\>:<operator\>:<filter\>[:<operator\>:<filter\>]. Les valeurs des filtres sont insensibles à la casse et peuvent être répétées avec l'opérateur autant de fois que nécessaire. Les opérateurs peuvent être EQ | GT | GE | LT | LE | NE | LIKE | IN. Les filtres peuvent être omis afin d'inclure simplement l'attribut dans la réponse sans aucune contrainte. |
| filtre | Attributs à utiliser comme filtre pour la requête. Le paramètre peut être répété autant de fois que nécessaire. Les filtres peuvent être appliqués à une dimension selon le format <attribute-id\>:<operator\>:<filter\>[ :<operator\>:<filter\>]. Les valeurs du filtre sont insensibles à la casse et peuvent être répétées avec l'opérateur autant de fois que nécessaire. Les opérateurs peuvent être EQ | GT | GE | LT | LE | NE | LIKE | IN. |
| ou | Identifiants des unités d'organisation, séparés par des " ;". |
| ou Mode | Le mode de sélection des unités d'organisation. Les différentes options sont SELECTED (sélectionnées) | CHILDREN (subordonnées) | DESCENDANTS (descendants) | ACCESSIBLE (accessibles) | ALL (toutes). Par défaut, le mode est défini sur SELECTED, et cela ne concerne que les unités d'organisation sélectionnées. Voir le tableau ci-dessous pour les explications. |
| de paludisme) ». | Identifiant du programme. Il détermine le programme auquel les instances doivent être inscrites. |
| programStatus (statut de programme) | Statut de l'instance pour le programme donné. Peut être ACTIF | TERMINÉ | ANNULÉ. |
| suivi | Statut du suivi de l'instance pour le programme donné. Peut être vrai, faux ou omis. |
| programStartDate | Date de début de l'inscription au programme donné pour l'instance d'entité suivie. |
| programEndDate | Date de fin de l'inscription au programme pour l'instance d'entité suivie. |
| Entité suivie | Identifiant de l'entité suivie ; il restreint les instances au type d'instance suivie donné. |
| eventStatus (statut d'événement) | Status of any event associated with the given program and the tracked entity instance. Can be ACTIVE &#124; COMPLETED &#124; VISITED &#124; SCHEDULED &#124; OVERDUE &#124; SKIPPED. |
| eventStartDate | Date de début de l'événement associé au programme et au statut de l'événement. |
| eventEndDate | Date de fin de l'événement associé au programme et au statut d'événement. |
| Étape du programme | L'étape de programme à laquelle les filtres relatifs à l'événement doivent être appliqués. Si ce paramètre n'est pas fourni, toutes les étapes seront prises en compte. |
| skipMeta (ignorer les métadonnées) | Indique si les métadonnées de la réponse doivent être incluses. |
| page | Le numéro de page. La page par défaut est 1. |
| taille de la page | La taille de la page. La taille par défaut est de 50 lignes par page. |
| totalPages (pages totales) | Indique s'il faut inclure le nombre total de pages dans la réponse de pagination (ce qui implique un temps de réponse plus long). |
| skipPaging | Indique si la pagination doit être ignorée et si toutes les lignes doivent être renvoyées. |
| Mode utilisateur attribué | Restreint le résultat à la TEI dont les événements sont attribués en fonction du mode de sélection de l'utilisateur. Il peut être CURRENT (actuel) | PROVIDED (fourni) | NONE (aucun) | ANY (tout). |
| assignedUser (Utilisateur assigné) | Permet de filtrer le résultat de manière à obtenir un ensemble limité de TEI avec des événements attribués aux UID donnés, en utilisant ceci : *assignedUser=id1;id2*. Ce paramètre ne sera pris en compte que si le assignedUserMode est PROVIDED ou null. L'API va générer une erreur si, par exemple, assignedUserMode=CURRENT et assignedUser=someId |
| trackedEntityInstance | Filtre le résultat de manière à obtenir un ensemble limité de TEI qui utilisent des uids d'instances d'entités suivies explicites. Vous pouvez le faire en utilisant ceci : *trackedEntityInstance=id1;id2*. Ce paramètre créera, au minimum, la limite externe des résultats, en constituant la liste de toutes les TEI à l'aide des uids fournis. Si d'autres paramètres/filtres de ce tableau sont utilisés, ils limiteront davantage les résultats à partir de la limite externe explicite. |
| potentialDuplicate (doublon potentiel) | Il est possible de filtrer le résultat en supposant qu'une TEI soit un doublon potentiel. true: renvoie les TEI marqués comme doublons potentiels. false: renvoie les TEI NON marqués comme doublons potentiels. En cas d'omission, nous ne vérifions pas si une TEI est un doublon potentiel ou pas.|

Les modes de sélection d'unités d'organisation disponibles sont expliqués dans le tableau suivant.



Tableau : Modes de sélection des unités d'organisation

| Mode | Description |
|---|---|
| SELECTED | Unités d'organisation définies dans la requête. |
| CHILDREN | Subordonnées directs, c'est-à-dire les unités d'organisation qui se trouvent au niveau directement inférieur de celles définies dans la requête. |
| DESCENDANTS | Toutes les subordonnées, c'est-à-dire toutes les unités d'organisation qui se trouvent en dessous de celles définies dans la requête, y compris les subordonnées des subordonnées. |
| ACCESSIBLE | Tous les descendants des unités d'organisation de visualisation de données associées à l'utilisateur actuel. Si ce mode n'est pas défini, les unités d'organisation de saisie de données associées à l'utilisateur actuel seront utilisées. |
| CAPTURE | Les unités d'organisation de saisie de données associées à l'utilisateur actuel et toutes leurs subordonnées, c'est-à-dire toutes les unités d'organisation qui leur sont inférieures dans la hiérarchie. |
| ALL | All organisation units in the system. Requires authority. |

Vous pouvez spécifier "attribut" avec des filtres ou directement utiliser les paramètres de filtrage pour restreindre les instances à renvoyer.

Certaines règles s'appliquent aux attributs renvoyés.

  - Si "query" est spécifié sans aucun attribut ou programme, alors tous les attributs qui 
    sont marqués comme "Afficher dans la liste sans programme" seront inclus dans la réponse.

  - Si le programme est spécifié, tous les attributs liés au programme seront
    inclus dans la réponse.

  - Si le type d'entité suivie est spécifié, alors tous les attributs du type entité suivie
    seront inclus dans la réponse.

Vous pouvez spécifier des requêtes avec des mots séparés par des espaces - dans ce cas, le système recherchera chaque mot indépendamment et renverra les enregistrements où chaque mot est contenu dans n'importe quel attribut. Un élément de requête peut être spécifié une fois en tant qu'attribut et une fois en tant que filtre si nécessaire. La requête est insensible à la casse. Les règles suivantes s'appliquent aux paramètres de requête.

  - Au moins une unité d'organisation doit être spécifiée à l'aide de l'attribut *ou*.
    (un ou plusieurs), ou *ouMode=ALL* doit être spécifié.

  - Un seul des paramètres *program* et *trackedEntity* peut être
    spécifié (zéro ou un).

  - Si *programStatus* est spécifié, alors *program* doit également être
    spécifiés.

  - Si *followUp* est spécifié, alors *program* doit également être spécifié.

  - Si *programStartDate* ou *programEndDate* est spécifié, alors
    *program* doit également être spécifié.

  - Si *eventStatus* est spécifié, alors *eventStartDate* et
    *eventEndDate* doivent également être spécifiés.

  - Une requête ne peut pas être spécifiée en même temps que des filtres.

  - Les éléments d'attributs ne peuvent être spécifiés qu'une seule fois.

  - Les éléments du filtre ne peuvent être spécifiés qu'une seule fois.

Une requête pour toutes les instances associées à une unité d'organisation spécifique peut ressembler à ceci :

    /api/33/trackedEntityInstances/query.json?ou=DiszpKrYNg8

Une requête sur tous les attributs pour une valeur et une unité d'organisation spécifiques, en utilisant une correspondance exacte des mots :

    /api/33/trackedEntityInstances/query.json?query=scott&ou=DiszpKrYNg8

Une requête sur tous les attributs pour une valeur spécifique, en utilisant un mot partiel :

    /api/33/trackedEntityInstances/query.json?query=LIKE:scott&ou=DiszpKrYNg8

You can query on multiple words separated by the URL character for
space which is %20, will use a logical AND query for each
    word:

    /api/33/trackedEntityInstances/query.json?query=isabel%20may&ou=DiszpKrYNg8

Une requête dans laquelle sont spécifiés les attributs à inclure dans la réponse :

    /api/33/trackedEntityInstances/query.json?query=isabel
      &attribute=dv3nChNSIxy&attribute=AMpUYgxuCaE&ou=DiszpKrYNg8

Pour effectuer une requête sur des instances à l'aide d'un attribut avec filtre et d'un attribut sans filtre, avec une unité d'organisation en utilisant le mode de requête de l'unité d'organisation subordonnée, utilisez ceci :

    /api/33/trackedEntityInstances/query.json?attribute=zHXD5Ve1Efw:EQ:A
      &attribute=AMpUYgxuCaE&ou=DiszpKrYNg8;yMCshbaVExv

Une requête pour les instances où un attribut est inclus dans la réponse et où un attribut est utilisé comme filtre :

    /api/33/trackedEntityInstances/query.json?attribute=zHXD5Ve1Efw:EQ:A
      &filter=AMpUYgxuCaE:LIKE:Road&ou=DiszpKrYNg8

Une requête dans laquelle plusieurs opérandes et filtres sont spécifiés pour un élément de filtre :

    /api/33/trackedEntityInstances/query.json?ou=DiszpKrYNg8&program=ur1Edk5Oe2n
      &filter=lw1SqmMlnfh:GT:150:LT:190

Pour effectuer une requête sur un attribut en utilisant plusieurs valeurs dans un filtre IN :

    /api/33/trackedEntityInstances/query.json?ou=DiszpKrYNg8
      &attribute=dv3nChNSIxy:IN:Scott;Jimmy;Santiago

Pour limiter la réponse aux instances qui font partie d'un programme spécifique, vous pouvez inclure un paramètre de requête de programme :

    /api/33/trackedEntityInstances/query.json?filter=zHXD5Ve1Efw:EQ:A
      &ou=O6uvpzGd5pu&ouMode=DESCENDANTS&program=ur1Edk5Oe2n

Pour spécifier les dates d'inscription au programme dans la requête :

    /api/33/trackedEntityInstances/query.json?filter=zHXD5Ve1Efw:EQ:A
      &ou=O6uvpzGd5pu&program=ur1Edk5Oe2n&programStartDate=2013-01-01
      &programEndDate=2013-09-01

Pour limiter la réponse aux instances d'une entité suivie spécifique, vous pouvez inclure un paramètre de requête d'entité suivie :

    /api/33/trackedEntityInstances/query.json?attribute=zHXD5Ve1Efw:EQ:A
      &ou=O6uvpzGd5pu&ouMode=DESCENDANTS&trackedEntity=cyl5vuJ5ETQ

Par défaut, les instances sont renvoyées dans des pages de taille 50. Pour modifier cela, vous pouvez utiliser les paramètres de requête de page et de taille de page (pageSize) :

    /api/33/trackedEntityInstances/query.json?attribute=zHXD5Ve1Efw:EQ:A
      &ou=O6uvpzGd5pu&ouMode=DESCENDANTS&page=2&pageSize=3

Pour effectuer une requête sur les instances qui ont des événements d'un statut donné dans un intervalle de temps donné :

    /api/33/trackedEntityInstances/query.json?ou=O6uvpzGd5pu
      &program=ur1Edk5Oe2n&eventStatus=LATE_VISIT
      &eventStartDate=2014-01-01&eventEndDate=2014-09-01

Vous pouvez utiliser une gamme d'opérateurs pour le filtrage :



Tableau : Opérateurs de filtre

| Opérateur | Description |
|---|---|
| EQ | Egale à |
| GT | Supérieure à |
| GE | Supérieure ou égal à |
| LT | Inférieur à |
| LE | inférieur ou égal à |
| NE | Pas égal à |
| LIKE | Pareil (correspondance textuelle) |
| IN | Égal à l'une des multiples valeurs séparées par ";" |

##### Response format { #webapi_tei_grid_query_response_format } 

Cette ressource prend en charge les représentations JSON, JSONP, XLS et CSV.

  - json (application/json)

  - jsonp (application/javascript)

  - xml (application/xml)

  - csv (application/csv)

  - xls (application/vnd.ms-excel)

La réponse au format JSON se présente sous la forme d'un tableau et peut ressembler à ce qui suit. La section *headers* décrit le contenu de chaque colonne. Les colonnes "instance", "créé", "dernière mise à jour", "unité d'organisation" et "entité suivie" sont toujours présentes. Les colonnes suivantes correspondent aux attributs spécifiés dans la requête. La section *rows* contient une ligne par instance.

```json
{
  "headers": [{
    "name": "instance",
    "column": "Instance",
    "type": "java.lang.String"
  }, {
    "name": "created",
    "column": "Created",
    "type": "java.lang.String"
  }, {
    "name": "lastupdated",
    "column": "Last updated",
    "type": "java.lang.String"
  }, {
    "name": "ou",
    "column": "Org unit",
    "type": "java.lang.String"
  }, {
    "name": "te",
    "column": "Tracked entity",
    "type": "java.lang.String"
  }, {
    "name": "zHXD5Ve1Efw",
    "column": "Date of birth type",
    "type": "java.lang.String"
  }, {
    "name": "AMpUYgxuCaE",
    "column": "Address",
    "type": "java.lang.String"
  }],
  "metaData": {
    "names": {
      "cyl5vuJ5ETQ": "Person"
    }
  },
  "width": 7,
  "height": 7,
  "rows": [
    ["yNCtJ6vhRJu", "2013-09-08 21:40:28.0", "2014-01-09 19:39:32.19", "DiszpKrYNg8", "cyl5vuJ5ETQ", "A", "21 Kenyatta Road"],
    ["fSofnQR6lAU", "2013-09-08 21:40:28.0", "2014-01-09 19:40:19.62", "DiszpKrYNg8", "cyl5vuJ5ETQ", "A", "56 Upper Road"],
    ["X5wZwS5lgm2", "2013-09-08 21:40:28.0", "2014-01-09 19:40:31.11", "DiszpKrYNg8", "cyl5vuJ5ETQ", "A", "56 Main Road"],
    ["pCbogmlIXga", "2013-09-08 21:40:28.0", "2014-01-09 19:40:45.02", "DiszpKrYNg8", "cyl5vuJ5ETQ", "A", "12 Lower Main Road"],
    ["WnUXrY4XBMM", "2013-09-08 21:40:28.0", "2014-01-09 19:41:06.97", "DiszpKrYNg8", "cyl5vuJ5ETQ", "A", "13 Main Road"],
    ["xLNXbDs9uDF", "2013-09-08 21:40:28.0", "2014-01-09 19:42:25.66", "DiszpKrYNg8", "cyl5vuJ5ETQ", "A", "14 Mombasa Road"],
    ["foc5zag6gbE", "2013-09-08 21:40:28.0", "2014-01-09 19:42:36.93", "DiszpKrYNg8", "cyl5vuJ5ETQ", "A", "15 Upper Hill"]
  ]
}
```

#### Tracked entity instance filters { #webapi_tei_filters } 

To create, read, update and delete tracked entity instance filters you
can interact with the */api/trackedEntityInstanceFilters* resource.

    /api/33/trackedEntityInstanceFilters

##### Créer et mettre à jour une définition de filtre d'instance d'entité suivie { #create-and-update-a-tracked-entity-instance-filter-definition } 

Pour créer et mettre à jour un filtre d'instance d'entité suivie dans le système, vous devez utiliser la ressource *trackedEntityInstanceFilters*. Les définitions des filtres d'instances d'entités suivies sont utilisées dans l'application Saisie Tracker pour afficher les "listes de tâches" prédéfinies pertinentes sur l'interface utilisateur du Tracker.



Tableau : Charge utile

| Valeurs de charge utile | Description | Exemple |
|---|---|---|
| nom | Nom du filtre. Obligatoire. ||
| Description | Une description du filtre. ||
| sortOrder (ordre de tri) | Ordre de tri du filtre ; utilisé dans Saisie Tracker pour ordonner les filtres dans le tableau de bord du programme. ||
| style | Objet contenant un style css. | ( "color": "blue", "icon": "fa fa-calendar"} |
| de paludisme) ». | Objet contenant l'identifiant du programme. Obligatoire. | { "id" : "uy2gU8kTjF"} |
| Statut de l'inscription | The TEIs enrollment status. Can be none(any enrollmentstatus) or ACTIVE&#124;COMPLETED&#124;CANCELED ||
| followup | Lorsque ce paramètre est définie sur "true", le filtre ne renvoie que les TEI dont le statut d'inscription est followup (suivi). ||
| enrollmentCreatedPeriod | Period object containing a period in which the enrollment must be created. See *Period* definition table below. | { "periodFrom": -15, "periodTo": 15} |
| eventFilters | Une liste de filtres d'événements. Voir le tableau de définition des *filtres d'événements* ci-dessous. | [{"programStage": "eaDH9089uMp", "eventStatus": "OVERDUE", "eventCreatedPeriod": {"periodFrom": -15, "periodTo": 15}}] |



Tableau : Définition des filtres d'événements

||||
|---|---|---|
| Étape du programme | L'étape de programme dans laquelle la TEI a besoin d'un événement pour être renvoyée. | "eaDH9089uMp" |
| eventStatus (statut d'événement) | The events status. Can be none(any event status) or ACTIVE&#124;COMPLETED&#124;SCHEDULED&#124;OVERDUE | ACTIVE |
| eventCreatedPeriod | Objet période contenant une période au cours de laquelle l'événement doit être créé. Voir la définition de *Période* ci-dessous. | { "periodFrom": -15, "periodTo": 15} |
| Mode utilisateur attribué | Utilisée pour spécifier le mode de sélection des utilisateurs assignés à des événements. Les valeurs possibles sont CURRENT (événements attribués à l'utilisateur actuel)| PROVIDED (événements attribués aux utilisateurs figurant dans la liste "assignedUsers") | NONE (événements attribués à personne) | ANY (événements attribués à tout utilisateur). Si cette valeur est définie sur PROVIDED (ou null), les sections assignedUsers non vides dans la charge seront pris en compte. | "assignedUserMode": "PROVIDED" |
| assignedUser (Utilisateur assigné) | Utilisée pour spécifier une liste d'utilisateurs assignés à des événements. À utiliser avec le mode d'utilisateur assigné PROVIDED ci-dessus. | "assignedUsers": ["a3kGcGDCuk7", "a3kGcGDCuk8"] |



Tableau : Définition de la période

||||
|---|---|---|
| periodFrom | Nombre de jours à partir du jour actuel. Il peut s'agir d'un nombre entier positif ou négatif. | -15 |
| periodTo | Nombre de jours à partir du jour actuel. Doit être supérieur à periodFrom. Peut être un nombre entier positif ou négatif. | 15 |

##### Requête sur les filtres d'instances d'entités suivie { #tracked-entity-instance-filters-query } 

Pour rechercher des filtres d'instances d'entités suivies dans le système, vous pouvez interagir avec la ressource */api/trackedEntityInstanceFilters*.



Tableau : Paramètres de requête pour les filtres d'instances d'entités suivies

| Paramètre de requête | Description |
|---|---|
| de paludisme) ». | Identifiant du programme. Il limite le filtrage au programme donné. |

### Enrollment management { #webapi_enrollment_management } 

Les inscriptions bénéficient d'une prise en charge CRUD complète dans l'API. Avec l'API des instances d'entités suivies, la plupart des opérations nécessaires pour travailler avec les instances d'entités suivies et les programmes sont prises en charge.

    /api/33/enrollments

#### Enrolling a tracked entity instance into a program { #webapi_enrolling_tei } 

Pour inscrire des personnes à un programme, vous devez d'abord obtenir l'identifiant de la personne à partir de la ressource *trackedEntityInstances*. Ensuite, vous devez obtenir l'identifiant du programme à partir de la ressource *programs*. Un modèle de charge utile est présenté ci-dessous :

```json
{
  "trackedEntityInstance": "ZRyCnJ1qUXS",
  "orgUnit": "ImspTQPwCqd",
  "program": "S8uo8AlvYMz",
  "enrollmentDate": "2013-09-17",
  "incidentDate": "2013-09-17"
}
```

Cette charge doit être utilisée dans une requête *POST* à la ressource des inscriptions identifiée par l'URL suivante :

    /api/33/enrollments

Pour annuler ou terminer une inscription, vous pouvez adresser une requête *PUT* à la ressource `enrollments`, en indiquant l'identifiant de l'inscription et l'action que vous voulez réaliser. Pour annuler une inscription pour une entité suivie :

    /api/33/enrollments/<enrollment-id>/cancelled

Pour terminer l'inscription d'une instance d'entité suivie, vous pouvez envoyez une requête *PUT* à l'URL suivante :

    /api/33/enrollments/<enrollment-id>/completed

Pour supprimer une inscription, vous pouvez envoyer une requête *DELETE* à l'URL suivante :

    /api/33/enrollments/<enrollment-id>

#### Enrollment instance query { #webapi_enrollment_instance_query } 

Pour rechercher des inscriptions, vous pouvez interagir avec la ressource */api/enrollments*.

    /api/33/enrollments

##### Request syntax { #webapi_enrollment_query_request_syntax } 



Tableau : Paramètres de la requête d'inscription

| Paramètre de requête | Description |
|---|---|
| ou | Identifiants des unités d'organisation, séparés par des " ;". |
| ou Mode | Le mode de sélection des unités d'organisation. Les différentes options sont SELECTED (sélectionnées) | CHILDREN (subordonnées) | DESCENDANTS (descendants) | ACCESSIBLE (accessibles) | CAPTURE (saisie) | ALL (toutes). Par défaut, le mode est défini sur SELECTED, et cela ne concerne que les unités d'organisation sélectionnées. Voir le tableau ci-dessous pour les explications. |
| de paludisme) ». | Identifiant du programme. Il détermine le programme auquel les instances doivent être inscrites. |
| programStatus (statut de programme) | Statut de l'instance pour le programme donné. Peut être ACTIF | TERMINÉ | ANNULÉ. |
| suivi | Statut du suivi de l'instance pour le programme donné. Peut être vrai, faux ou omis. |
| programStartDate | Date de début de l'inscription au programme donné pour l'instance d'entité suivie. |
| programEndDate | Date de fin de l'inscription au programme pour l'instance d'entité suivie. |
| lastUpdatedDuration (durée de la dernière mise à jour) | Inclure uniquement les éléments qui ont été mis à jour pendant la durée spécifiée. Le format est , où les unités de temps prises en charge sont "j" (jours), "h" (heures), "m" (minutes) et "s" (secondes). |
| Entité suivie | Identifiant de l'entité suivie ; il restreint les instances au type d'instance suivie donné. |
| trackedEntityInstance | Identifiant de l'instance d'entité suivie. Il ne doit pas être utilisé en même temps que trackedEntity. |
| page | Le numéro de page. La page par défaut est 1. |
| taille de la page | La taille de la page. La taille par défaut est de 50 lignes par page. |
| totalPages (pages totales) | Indique s'il faut inclure le nombre total de pages dans la réponse de pagination (ce qui implique un temps de réponse plus long). |
| skipPaging | Indique si la pagination doit être ignorée et si toutes les lignes doivent être renvoyées. |
| includeDeleted | Indique s'il faut inclure ou non les inscriptions supprimés de manière réversible. La valeur par défaut est "false". |

Les modes de sélection d'unités d'organisation disponibles sont expliqués dans le tableau suivant.



Tableau : Modes de sélection des unités d'organisation

| Mode | Description |
|---|---|
| SELECTED | Unités d'organisation définies dans la requête (par défaut). |
| CHILDREN | Subordonnées directs, c'est-à-dire les unités d'organisation qui se trouvent au niveau directement inférieur de celles définies dans la requête. |
| DESCENDANTS | Toutes les subordonnées, c'est-à-dire toutes les unités d'organisation qui se trouvent en dessous de celles définies dans la requête, y compris les subordonnées des subordonnées. |
| ACCESSIBLE | Tous les descendants des unités d'organisation de visualisation de données associées à l'utilisateur actuel. Si ce mode n'est pas défini, les unités d'organisation de saisie de données associées à l'utilisateur actuel seront utilisées. |
| ALL | All organisation units in the system. Requires authority. |

La requête n'est pas sensible à la casse. Les règles suivantes s'appliquent aux paramètres de la requête.

  - Au moins une unité d'organisation doit être spécifiée à l'aide de l'attribut *ou*.
    (un ou plusieurs), ou *ouMode=ALL* doit être spécifié.

  - Un seul des paramètres *program* et *trackedEntity* peut être
    spécifié (zéro ou un).

  - Si *programStatus* est spécifié, alors *program* doit également être
    spécifiés.

  - Si *followUp* est spécifié, alors *program* doit également être spécifié.

  - Si *programStartDate* ou *programEndDate* est spécifié, alors
    *program* doit également être spécifié.

Une requête pour toutes les inscriptions associées à une unité d'organisation spécifique peut ressembler à ceci :

    /api/33/enrollments.json?ou=DiszpKrYNg8

Pour limiter la réponse aux inscriptions qui font partie d'un programme spécifique, vous pouvez inclure un paramètre de requête de programme :

    /api/33/enrollments.json?ou=O6uvpzGd5pu&ouMode=DESCENDANTS&program=ur1Edk5Oe2n

Pour spécifier les dates d'inscription au programme dans la requête :

    /api/33/enrollments.json?&ou=O6uvpzGd5pu&program=ur1Edk5Oe2n
      &programStartDate=2013-01-01&programEndDate=2013-09-01

Pour limiter la réponse aux inscriptions d'une entité suivie spécifique, vous pouvez inclure un paramètre de requête d'entité suivie :

    /api/33/enrollments.json?ou=O6uvpzGd5pu&ouMode=DESCENDANTS&trackedEntity=cyl5vuJ5ETQ

Pour limiter la réponse aux inscriptions d'une entité suivie spécifique, vous pouvez inclure un paramètre de requête d'instance d'entité suivie. Dans ce cas, nous avons limité la réponse aux inscriptions disponibles pour l'utilisateur actuel :

    /api/33/enrollments.json?ouMode=ACCESSIBLE&trackedEntityInstance=tphfdyIiVL6

Par défaut, les inscriptions sont renvoyées dans des pages de taille 50. Pour modifier cela, vous pouvez utiliser les paramètres de requête 'page' et 'taille de page' (pageSize) :

    /api/33/enrollments.json?ou=O6uvpzGd5pu&ouMode=DESCENDANTS&page=2&pageSize=3

##### Response format { #webapi_enrollment_query_response_format } 

Cette ressource prend en charge les représentations JSON, JSONP, XLS et CSV.

  - json (application/json)

  - jsonp (application/javascript)

  - xml (application/xml)

La réponse en JSON/XML est au format objet et peut ressembler à ce qui suit. Le filtrage des champs est possible, donc si vous voulez un affichage complet, vous pouvez ajouter `fields=*` à la requête :

```json
{
  "enrollments": [
    {
      "lastUpdated": "2014-03-28T05:27:48.512+0000",
      "trackedEntity": "cyl5vuJ5ETQ",
      "created": "2014-03-28T05:27:48.500+0000",
      "orgUnit": "DiszpKrYNg8",
      "program": "ur1Edk5Oe2n",
      "enrollment": "HLFOK0XThjr",
      "trackedEntityInstance": "qv0j4JBXQX0",
      "followup": false,
      "enrollmentDate": "2013-05-23T05:27:48.490+0000",
      "incidentDate": "2013-05-10T05:27:48.490+0000",
      "status": "ACTIVE"
    }
  ]
}
```

### Événements { #webapi_events } 

Cette section traite de l'envoi et de la lecture d'événements.

    /api/33/events

#### Sending events { #webapi_sending_events } 

DHIS2 prend en charge trois types d'événements : les événements uniques sans enregistrement (également appelés événements anonymes), les événements uniques avec enregistrement et les événements multiples avec enregistrement. L'enregistrement implique que les données sont rattachées à une instance d'entité suivie qui est identifiée à l'aide d'un identifiant.

Pour envoyer des événements à DHIS2, vous devez interagir avec la ressource *events*. L'approche utilisée pour envoyer des événements est similaire à celle utilisée pour envoyer des valeurs de données agrégées. Vous aurez besoin d'un *programme* qui peut être recherché à l'aide de la ressource *programs*, d'une *unité d'organisation* qui peut être recherchée à l'aide de la ressource *organisationUnits*, et d'une liste d'identifiants d'éléments de données valides qui peuvent être recherchés à l'aide de la ressource *dataElements*. Pour les événements avec enregistrement, un identifiant d'*instance d'entité suivie* est nécessaire. Pour savoir comment l'obtenir, consultez la section sur la ressource *trackedEntityInstances*. Pour envoyer des événements à des programmes comportant plusieurs étapes, il vous faudra également inclure l'identifiant *programStage* (étape de programme). Les identifiants des étapes de programme se trouvent dans la ressource *programStages*.

Voici un exemple simple d'événement unique sans enregistrement au format XML. Dans cet exemple, nous envoyons vers la base de données de démonstration, des événements du programme "Morbidité et mortalité des patients hospitalisés" pour l'établissement "Ngelehun CHC"  :

```xml
<?xml version="1.0" encoding="utf-8"?>
<event program="eBAyeGv0exc" orgUnit="DiszpKrYNg8"
  eventDate="2013-05-17" status="COMPLETED" storedBy="admin">
  <coordinate latitude="59.8" longitude="10.9" />
  <dataValues>
    <dataValue dataElement="qrur9Dvnyt5" value="22" />
    <dataValue dataElement="oZg33kd9taw" value="Male" />
    <dataValue dataElement="msodh3rEMJa" value="2013-05-18" />
  </dataValues>
</event>
```

To perform some testing we can save the XML payload as a file
called*event.xml* and send it as a POST request to the events resource
in the API using curl with the following command:

```bash
curl -d @event.xml "https://play.dhis2.org/demo/api/33/events"
  -H "Content-Type:application/xml" -u admin:district
```

La même charge au format JSON se présente comme suit :

```json
{
  "program": "eBAyeGv0exc",
  "orgUnit": "DiszpKrYNg8",
  "eventDate": "2013-05-17",
  "status": "COMPLETED",
  "completedDate": "2013-05-18",
  "storedBy": "admin",
  "coordinate": {
    "latitude": 59.8,
    "longitude": 10.9
  },
  "dataValues": [
    {
      "dataElement": "qrur9Dvnyt5",
      "value": "22"
    },
    {
      "dataElement": "oZg33kd9taw",
      "value": "Male"
    },
    {
      "dataElement": "msodh3rEMJa",
      "value": "2013-05-18"
    }
  ]
}
```

Pour l'envoyer, vous pouvez l'enregistrer dans un fichier appelé *event.json* et utiliser curl comme suit :

```bash
curl -d @event.json "localhost/api/33/events" -H "Content-Type:application/json"
  -u admin:district
```

Nous pouvons également envoyer plusieurs événements en même temps. Une charge au format XML pourrait ressembler à ceci :

```xml
<?xml version="1.0" encoding="utf-8"?>
<events>
  <event program="eBAyeGv0exc" orgUnit="DiszpKrYNg8"
    eventDate="2013-05-17" status="COMPLETED" storedBy="admin">
    <coordinate latitude="59.8" longitude="10.9" />
    <dataValues>
      <dataValue dataElement="qrur9Dvnyt5" value="22" />
      <dataValue dataElement="oZg33kd9taw" value="Male" />
    </dataValues>
  </event>
  <event program="eBAyeGv0exc" orgUnit="DiszpKrYNg8"
    eventDate="2013-05-17" status="COMPLETED" storedBy="admin">
    <coordinate latitude="59.8" longitude="10.9" />
    <dataValues>
      <dataValue dataElement="qrur9Dvnyt5" value="26" />
      <dataValue dataElement="oZg33kd9taw" value="Female" />
    </dataValues>
  </event>
</events>
```

Vous recevrez un récapitulatif de l'importation avec la réponse qui peut être inspecté afin d'obtenir des informations sur le résultat de la requête, par exemple le nombre de valeurs qui ont été importées avec succès. La charge au format JSON ressemble à ceci :

```json
{
  "events": [
  {
    "program": "eBAyeGv0exc",
    "orgUnit": "DiszpKrYNg8",
    "eventDate": "2013-05-17",
    "status": "COMPLETED",
    "storedBy": "admin",
    "coordinate": {
      "latitude": "59.8",
      "longitude": "10.9"
    },
    "dataValues": [
      {
        "dataElement": "qrur9Dvnyt5",
        "value": "22"
      },
      {
        "dataElement": "oZg33kd9taw",
        "value": "Male"
      }
    ]
  },
  {
    "program": "eBAyeGv0exc",
    "orgUnit": "DiszpKrYNg8",
    "eventDate": "2013-05-17",
    "status": "COMPLETED",
    "storedBy": "admin",
    "coordinate": {
      "latitude": "59.8",
      "longitude": "10.9"
    },
    "dataValues": [
      {
        "dataElement": "qrur9Dvnyt5",
        "value": "26"
      },
      {
        "dataElement": "oZg33kd9taw",
        "value": "Female"
      }
    ]
  } ]
}
```

Vous pouvez également utiliser GeoJson pour stocker tout type de géométrie sur votre événement. Voici un exemple de charge utilisant GeoJson et non les anciennes propriétés de latitude et de longitude :

```json
{
  "program": "eBAyeGv0exc",
  "orgUnit": "DiszpKrYNg8",
  "eventDate": "2013-05-17",
  "status": "COMPLETED",
  "storedBy": "admin",
  "geometry": {
    "type": "POINT",
    "coordinates": [59.8, 10.9]
  },
  "dataValues": [
    {
      "dataElement": "qrur9Dvnyt5",
      "value": "22"
    },
    {
      "dataElement": "oZg33kd9taw",
      "value": "Male"
    },
    {
      "dataElement": "msodh3rEMJa",
      "value": "2013-05-18"
    }
  ]
}
```

Le récapitulatif de l'importation contient également l'identifiant *reference* de l'événement que vous venez d'envoyer, ainsi qu'un élément *href* qui indique l'emplacement du serveur de cet événement. Le tableau ci-dessous décrit la signification de chaque élément.



Tableau : Format de la ressource des événements

| Paramètre | Type | Obligatoire | Options (par défaut en premier) | Description |
|---|---|---|---|---|
| de paludisme) ». | chaîne | vrai || Identifiant de l'événement unique sans enregistrement |
| orgUnit (Unité d'organisation) | chaîne | vrai || Identifiant de l'unité d'organisation où l'événement a eu lieu |
| eventDate (date de l'événement) | date | vrai || La date à laquelle l'événement s'est produit |
| completedDate | date | faux || La date à laquelle l'événement se termine. Si elle n'est pas fournie, la date du jour est sélectionnée comme date de fin de l'événement. |
| statut | enum | faux | ACTIVE | COMPLETED | VISITED | SCHEDULE | OVERDUE | SKIPPED | Spécifie si l'événement est terminé ou non |
| Stocké par | chaîne | faux | Par défaut, il s'agit de l'utilisateur actuel | L'utilisateur qui a stocké cet événement (peut être le nom d'utilisateur, le nom du système, etc.) |
| coordinate | double | faux || Fait référence à l'emplacement géographique où l'événement a eu lieu (latitude et longitude). |
| élément de données | chaîne | vrai || Identifiant de l'élément de données |
| valeur | chaîne | vrai || Valeur des données ou mesure pour cet événement |

##### Correspondance des unités d'organisation (paramètre orgUnit) { #orgunit-matching } 

Par défaut, le paramètre orgUnit correspondra à l'identifiant. Vous pouvez également sélectionner le schéma de correspondance de l'identifiant de l'unité d'organisation en utilisant le paramètre orgUnitIdScheme=SCHEME, où les options sont : *ID*, *UID*, *UUID*, *CODE* et *NAME*. Il existe également le schéma *ATTRIBUTE:*, qui correspond à une valeur d'attribut de métadonnées *unique*.

#### Updating events { #webapi_updating_events } 

Pour mettre à jour un événement existant, le format de la charge reste le même, mais il faudra ajouter l'identifiant à la fin de la chaîne de l'URL à laquelle vous adressez la requête, et la requête doit être de type PUT.

La charge doit contenir tous les attributs, même ceux qui n'ont pas été modifiés. Les attributs qui étaient présents auparavant et qui ne sont plus présents dans la charge actuelle seront supprimés par le système.

Il n'est pas autorisé de mettre à jour un événement déjà supprimé. Il en va de même pour les instances d'entité suivie et les inscriptions.

```bash
curl -X PUT -d @updated_event.xml "localhost/api/33/events/ID"
  -H "Content-Type: application/xml" -u admin:district
```

```bash
curl -X PUT -d @updated_event.json "localhost/api/33/events/ID"
  -H "Content-Type: application/json" -u admin:district
```

#### Deleting events { #webapi_deleting_events } 

Pour supprimer un événement existant, il suffit d'envoyer une requête DELETE avec une référence d'identifiant au serveur que vous utilisez.

```bash
curl -X DELETE "localhost/api/33/events/ID" -u admin:district
```

#### Assigning user to events { #webapi_user_assign_event } 

Un utilisateur peut être affecté à un événement. Pour ce faire, il suffit d'inclure la propriété appropriée dans la charge lors de la mise à jour ou de la création de l'événement.

      "assignedUser": "<id>"

L'id fait référence à l'identifiant de l'utilisateur. Un seul utilisateur peut être affecté à un événement à la fois.

L'affectation des utilisateurs doit être activée dans la phase de programmation avant que les utilisateurs puissent être affectés à des événements.
#### Getting events { #webapi_getting_events } 

Pour obtenir un événement existant, vous pouvez envoyer une requête GET comprenant l'identifiant comme ceci :

```bash
curl "http://localhost/api/33/events/ID" -H "Content-Type: application/xml" -u admin:district
```

#### Querying and reading events { #webapi_querying_reading_events } 

Cette section explique comment lire les événements qui ont été stockés dans l'instance DHIS2. Pour pouvoir utiliser les données d'événements de manière plus avancée, veuillez consulter la section consacrée à l'analyse des événements. Le format de sortie du point d'extrémité `/api/events` correspondra au format utilisé pour lui envoyer des événements (ce format n'est pas pris en charge par l'api d'analyse d'événements). Les formats XML et JSON sont pris en charge. Pour pouvoir les utiliser, il suffit d'ajouter un fichier .json/.xml ou de définir l'en-tête *Accept* approprié. La requête est paginée par défaut et la taille de la page par défaut est de 50 événements. Le filtrage par *champs* fonctionne comme avec les métadonnées ; ajoutez le paramètre *fields* et spécifiez les propriétés que vous voulez, ce qui nous donne *fields=program,status*.



Tableau : Paramètres de requête de la ressource des événements

| Clé | Type | Obligatoire | Description |
|---|---|---|---|
| de paludisme) ». | identifiant | true (if not programStage is provided) | Identifiant du programme |
| Étape du programme | identifiant | faux | Identifiant de l'étape de programme |
| programStatus (statut de programme) | enum | faux | Statut de l'événement dans le programme ; peut être ACTIVE | COMPLETED | CANCELLED |
| suivi | booléen | faux | Détermine si l'événement est pris en compte pour le suivi dans le programme ; peut être vrai | faux ou omis. |
| trackedEntityInstance | identifiant | faux | Identifiant de l'instance d'entité suivie |
| orgUnit (Unité d'organisation) | identifiant | vrai | Identifiant de l'unité d'organisation |
| ou Mode | enum | faux | Mode de sélection de l'unité d'organisation ; peut être SELECTED | CHILDREN | DESCENDANTS |
| date de début | date | faux | Seulement les événements plus récents que cette date |
| date de fin | date | faux | Uniquement les événements antérieurs à cette date |
| statut | enum | faux | Status of event, can be ACTIVE &#124; COMPLETED &#124; VISITED &#124; SCHEDULED &#124; OVERDUE &#124; SKIPPED |
| lastUpdatedStartDate | date | faux | Filtre pour les événements qui ont été mises à jour après cette date ; ne peut être utilisé avec *lastUpdatedDuration*. |
| lastUpdatedEndDate | date | faux | Filtre pour les événements qui ont été mises à jour jusqu'à cette date ; ne peut être utilisé avec *lastUpdatedDuration*. |
| lastUpdatedDuration (durée de la dernière mise à jour) | chaîne | faux | Ce paramètre inclut uniquement les éléments qui ont été mis à jour pendant la durée spécifiée. Le format est jj-hh-mm-ss, où  "j" = jours, "h" = heures, "m" = minutes et "s" = secondes. Il ne peut pas être utilisé avec *lastUpdatedStartDate* et/ou *lastUpdatedEndDate*. |
| skipMeta (ignorer les métadonnées) | booléen | faux | Exclut la partie métadonnées de la réponse (améliore les performances) |
| page | entier | faux | Numéro de page |
| taille de la page | entier | faux | Nombre d'éléments dans chaque page |
| totalPages (pages totales) | booléen | faux | Indique s'il faut inclure le nombre total de pages dans la réponse de pagination. |
| skipPaging | booléen | faux | Indique s'il faut ignorer la pagination dans la requête et renvoyer tous les événements. |
| dataElementIdScheme (Schéma d'identifiant d'élément de données) | chaîne | faux | Schéma d'identification des éléments de données à utiliser pour l'exportation. Les options valides sont UID, CODE et ATTRIBUTE :{ID} |
| categoryOptionComboIdScheme (Schéma de l'identifiant de la combinaison d'options de catégorie) | chaîne | faux | Schéma d'identification des combinaisons d'options d'attribut à utiliser pour l'exportation. Les options valides sont UID, CODE et ATTRIBUTE :{ID} |
| orgUnitIdScheme (Schéma de l'identifiant de l'unité d'organisation) | chaîne | faux | Schéma d'identification des unités d'organisation à utiliser pour l'exportation. Les options valides sont UID, CODE et ATTRIBUTE :{ID} |
| programIdScheme (Schéma d'identification du programme) | chaîne | faux | Schéma d'identification des programmes à utiliser pour l'exportation. Les options valides sont UID, CODE et ATTRIBUTE :{ID} |
| programmeStageIdScheme (Schéma d'identification de l'étape de programme) | chaîne | faux | Schéma d'identification des étapes programme à utiliser pour l'exportation. Les options valides sont UID, CODE et ATTRIBUTE :{ID} |
| idScheme | chaîne | faux | Permet de définir le schéma d'identification  à la fois pour l'élément de données, la combinaison d'options de catégorie, l'unité d'organisation, le programme et l'étape de programme. |
| Ordre | chaîne | faux | Ordre dans lequel les événements doivent être extraits de l'API. Utilisation : order=<property\>:asc/desc - L'ordre croissant est l'ordre par défaut. <br>Propriétés : event | program | programStage | enrollment | enrollmentStatus | orgUnit | orgUnitName | trackedEntityInstance | eventDate | followup | status | dueDate | storedBy | created | lastUpdated | completedBy | completedDate<br> order=orgUnitName :DESC order=lastUpdated:ASC |
| événement | chaîne délimitée par des virgules | faux | Filtre le résultat pour obtenir un ensemble limité d’identifiants en utilisant *event=id1;id2*. |
| skipEventId | booléen | faux | Ignore les identifiants d'événement dans la réponse |
| attributeCc (\*\*) | chaîne | faux | Identifiant de la combinaison de catégories d'attribut (doit être combiné aux options de catégorie d'attribut (*attributCos*)) |
| attributeCos (\*\*) | chaîne | faux | Identifiants d'options de catégorie d'attribut, séparés par ";"(cette clé doit être utilisée avec la combinaison de catégories d'attribut (*attributeCc*)) |
| async | faux &#124; vrai | faux | Indique si l'importation doit être asynchrone ou synchrone. |
| includeDeleted | booléen | faux | S'il est défini sur "vrai", les événements supprimés mais pas définitivement seront inclus dans le résultat de votre requête. |
| Mode utilisateur attribué | enum | faux | Mode de sélection de l'utilisateur assigné ; peut être CURRENT | PROVIDED | NONE | ANY. |
| assignedUser (Utilisateur assigné) | chaînes délimitées par des virgules | faux | Permet de filtrer le résultat de manière à obtenir un ensemble limité d'événements attribués aux UID donnés, en utilisant ceci : *assignedUser=id1;id2*. Ce paramètre ne sera pris en compte que si le assignedUserMode est 'PROVIDED' ou 'null'. L'API va générer une erreur si, par exemple, assignedUserMode=CURRENT et assignedUser=someId |

> **Remarque**
>
> Si la requête ne contient ni `attributeCC` ni `attributeCos`, le serveur renvoie des événements pour toutes les combinaisons d'options d'attribut pour lesquelles l'utilisateur a un accès en lecture.

##### Exemples { #examples }

Requête sur de tous les événements associés aux subordonnées d'une unité d'organisation donnée :

    /api/29/events.json?orgUnit=YuQRtpLP10I&ouMode=CHILDREN

Requête pour tous les événements associés à tous les descendants d'une unité d'organisation donnée, c'est-à-dire toutes les unités d'organisation qui lui sont inférieurs dans la hiérarchie :

    /api/33/events.json?orgUnit=O6uvpzGd5pu&ouMode=DESCENDANTS

La requête pour tous les événements disposant d'un programme et d'une unité d'organisation :

    /api/33/events.json?orgUnit=DiszpKrYNg8&program=eBAyeGv0exc

Requête pour tous les événements associés à un programme et à une unité d'organisation, ordonnés par date d'échéance en ordre croissant :

    /api/33/events.json?orgUnit=DiszpKrYNg8&program=eBAyeGv0exc&order=dueDate

La requête pour les 10 événements avec la date d'événement la plus récente dans un programme et une unité d'organisation - par pagination et ordonnés par date d'échéance en ordre décroissant :

    /api/33/events.json?orgUnit=DiszpKrYNg8&program=eBAyeGv0exc
      &order=eventDate:desc&pageSize=10&page=1

La requête pour tous les événements avec un programme et une unité d'organisation pour une instance d'entité suivie donnée :

    /api/33/events.json?orgUnit=DiszpKrYNg8
      &program=eBAyeGv0exc&trackedEntityInstance=gfVxE3ALA9m

Requête pour tous les événements associés à un programme et une unité d'organisation plus ancien(ne) ou égal(e) au 03/02/2014 :

    /api/33/events.json?orgUnit=DiszpKrYNg8&program=eBAyeGv0exc&endDate=2014-02-03

La requête pour tous les événements avec une étape de programme, une unité d'organisation et une instance d'entité suivie de l'an 2014 :

    /api/33/events.json?orgUnit=DiszpKrYNg8&program=eBAyeGv0exc
      &trackedEntityInstance=gfVxE3ALA9m&startDate=2014-01-01&endDate=2014-12-31

Requête pour des fichiers associés aux valeurs de données d'événement. Si l'on veut récupérer un fichier image, un paramètre supplémentaire peut être fourni pour récupérer l'image dans différentes options de dimensions. Si aucune dimension n'est fournie, le système renvoie l'image originale. Le paramètre sera ignoré si les fichiers ne sont pas des images, par exemple des fichiers PDF. Les valeurs possibles pour les dimensions sont *small(254 x 254), medium(512 x 512), large(1024 x 1024) ou original*. Toute valeur autre que celles mentionnées sera rejetée et l'image originale sera renvoyée.

    /api/33/events/files?eventUid=hcmcWlYkg9u&dataElementUid=C0W4aFuVm4P&dimension=small

Retrieve events with specified Organisation unit and Program, and use _Attribute:Gq0oWTf2DtN_ as
identifier scheme

    /api/events?orgUnit=DiszpKrYNg8&program=lxAQ7Zs9VYR&idScheme=Attribute:Gq0oWTf2DtN

Retrieve events with specified Organisation unit and Program, and use UID as identifier scheme for
orgUnits, Code as identifier scheme for Program stages, and _Attribute:Gq0oWTf2DtN_ as identifier
scheme for the rest of the metadata with assigned attribute.

    api/events.json?orgUnit=DiszpKrYNg8&program=lxAQ7Zs9VYR&idScheme=Attribute:Gq0oWTf2DtN
      &orgUnitIdScheme=UID&programStageIdScheme=Code

#### Requête pour les grilles d'événements { #event-grid-query } 

En plus du point d'extrémité des requêtes d'événements ci-dessus, il existe un point d'extrémité pour les requêtes de grilles d'événements où un format de "grille" d'événements plus compact  est renvoyé. Vous pouvez le faire en interagissant avec /api/events/query.json|xml|xls|csv.

    /api/33/events/query

La plupart des paramètres de requête mentionnés dans la section sur la requête et la lecture d'événements ci-dessus sont valables ici. Toutefois, étant donné que la grille à renvoyer comporte un ensemble spécifique de colonnes qui s'appliquent à toutes les lignes (événements), il est obligatoire de spécifier une étape de programme. Il n'est pas possible de combiner des événements de différents programmes ou étapes de programme dans le renvoi.

Le renvoi d'événements appartenant à une même étape de programme ouvre également la voie à de nouvelles fonctionnalités, par exemple le tri et la recherche d'événements sur la base des valeurs de leurs éléments de données. api/events/query prend en charge ces fonctionnalités. Voici quelques exemples :

Une requête pour obtenir une grille d'événements qui contient uniquement des éléments de données sélectionnés pour une étape de programme :

    /api/33/events/query.json?orgUnit=DiszpKrYNg8&programStage=Zj7UnCAulEk
      &dataElement=qrur9Dvnyt5,fWIAEtYVEGk,K6uUAvq500H&order=lastUpdated:desc
      &pageSize=50&page=1&totalPages=true

Une requête qui renvoie une grille d'événements qui contient tous les éléments de données d'une étape de programme :

    /api/33/events/query.json?orgUnit=DiszpKrYNg8&programStage=Zj7UnCAulEk
      &includeAllDataElements=true

Une requête pour filtrer les événements sur la base de la valeur de l'élément de données

    /api/33/events/query.json?orgUnit=DiszpKrYNg8&programStage=Zj7UnCAulEk
      &filter=qrur9Dvnyt5:GT:20:LT:50

Outre le filtrage, l'exemple ci-dessus illustre également une chose : le fait qu'il n'y a pas d'éléments de données mentionnés à renvoyer dans la grille. Dans ce cas, par défaut, le système ne renvoie que les éléments de données marqués "Afficher dans le rapport" dans la configuration des étapes de programme.

Nous pouvons également étendre la requête ci-dessus pour obtenir une grille triée (par ordre ascendant ou descendant) sur la base des valeurs de l'élément de données

    /api/33/events/query.json?orgUnit=DiszpKrYNg8&programStage=Zj7UnCAulEk
      &filter=qrur9Dvnyt5:GT:20:LT:50&order=qrur9Dvnyt5:desc

#### Event filters { #webapi_event_filters } 

Pour créer, lire, mettre à jour et supprimer des filtres d'événements, vous pouvez interagir avec la ressource `/api/eventFilters`.

    /api/33/eventFilters

##### Création et mise à jour d'une définition de filtre d'événement { #create-and-update-an-event-filter-definition } 

Pour créer et mettre à jour un filtre d'événement dans le système, vous devez utiliser la ressource *eventFilters*. La méthode *POST* est utilisée pour créer et la méthode *PUT* est utilisée pour la mise à jour. Les définitions des filtres d'événements sont utilisées dans l'application Saisie Tracker pour afficher les "listes de tâches" prédéfinies pertinentes sur l'interface utilisateur du Tracker.



Tableau : Charge de la requête

| Propriété de requête | Description | Exemple |
|---|---|---|
| nom | Nom du filtre. | "name":"My working list" |
| Description | Une description du filtre. | "description":"for listing all events assigned to me". |
| de paludisme) ». | L'uid du programme. | "program" : "a3kGcGDCuk6" |
| Étape du programme | L'uid de l'étape de programme. | "programStage" : "a3kGcGDCuk6" |
| eventQueryCriteria | Objet contenant des paramètres pour les requêtes, le tri et le filtrage des événements. | "eventQueryCriteria": {     "organisationUnit":"a3kGcGDCuk6",     "status": "COMPLETED",     "createdDate": {       "from": "2014-05-01",       "to": "2019-03-20"     },     "dataElements": ["a3kGcGDCuk6:EQ:1", "a3kGcGDCuk6"],     "filters": ["a3kGcGDCuk6:EQ:1"],     "programStatus": "ACTIVE",     "ouMode": "SELECTED",     "assignedUserMode": "PROVIDED",     "assignedUsers" : ["a3kGcGDCuk7", "a3kGcGDCuk8"],     "followUp": false,     "trackedEntityInstance": "a3kGcGDCuk6",     "events": ["a3kGcGDCuk7", "a3kGcGDCuk8"],     "fields": "eventDate,dueDate",     "order": "dueDate:asc,createdDate:desc"   } |



Tableau : Définition des critères de requêtes d'événements

||||
|---|---|---|
| suivi | Permet de filtrer les événements en fonction de l'indicateur de suivi de l'inscription. Les valeurs possibles sont true | false. | "followUp": true |
| organisationUnit | Utilisée pour spécifier l'identifiant de l'unité d'organisation | "organisationUnit": "a3kGcGDCuk7" |
| ou Mode | Utilisée pour spécifier le mode de sélection des unités d'organisation. Les valeurs possibles sont SELECTED| CHILDREN|DESCENDANTS|ACCESSIBLE|CAPTURE|ALL | "ouMode": "SELECTED" |
| Mode utilisateur attribué | Utilisée pour spécifier le mode de sélection de l'utilisateur pour les événements. Les valeurs possibles sont CURRENT| PROVIDED| NONE | ANY. Voir le tableau ci-dessous pour comprendre ce que chaque valeur indique. Si elle est définie sur PROVIDED (ou "null"), les sections assignedUsers non vides dans la charge seront pris en compte. | "assignedUserMode": "PROVIDED" |
| assignedUser (Utilisateur assigné) | Utilisée pour spécifier une liste d'utilisateurs assignés à des événements. À utiliser avec le mode d'utilisateur assigné PROVIDED ci-dessus. | "assignedUsers": ["a3kGcGDCuk7", "a3kGcGDCuk8"] |
| displayOrderColumns | Utilisée pour spécifier l'ordre de sortie des colonnes | "displayOrderColumns": ["eventDate", "dueDate", "program"] |
| Ordre | To specify ordering/sorting of fields and its directions in comma separated values. A single item in order is of the form "dataItem:direction". | "order"="a3kGcGDCuk6:desc,eventDate:asc" |
| Filtres de données | Permet de spécifier les filtres à appliquer lors de l'établissement de la liste des événements | "dataFilters"=[{       "dataItem": "abcDataElementUid",       "le": "20",       "ge": "10",       "lt": "20",       "gt": "10",       "in": ["India", "Norway"],       "like": "abc",       "dateFilter": {         "startDate": "2014-05-01",         "endDate": "2019-03-20",         "startBuffer": -5,         "endBuffer": 5,         "period": "LAST_WEEK",         "type": "RELATIVE"       }     }] |
| statut | Tout statut d'événement valide | "eventStatus": "COMPLETED" |
| événements | permet de spécifier une liste d'événements | "events"=["a3kGcGDCuk6"] |
| completedDate | Filtrage de la date par l'objet "DateFilterPeriod " en fonction de date de finition. | "completedDate": {     "startDate": "2014-05-01",     "endDate": "2019-03-20",     "startBuffer": -5,     "endBuffer": 5,     "period": "LAST_WEEK",     "type": "RELATIVE"   } |
| eventDate (date de l'événement) | Filtrage de la date par l'objet "DateFilterPeriod " sur la base de la date de l'événement. | "eventDate": {     "startBuffer": -5,     "endBuffer": 5,     "type": "RELATIVE"   } |
| dueDate | Filtrage de la date par l'objet "DateFilterPeriod " en fonction de date d'échéance. | "dueDate": {     "period": "LAST_WEEK",     "type": "RELATIVE"   } |
| lastUpdatedDate | Filtrage de la date par l'objet "DateFilterPeriod " sur la base de la date de la dernière mise à jour. | "lastUpdatedDate": {     "startDate": "2014-05-01",     "endDate": "2019-03-20",     "type": "ABSOLUTE"   } |



Tableau : Définition de l'objet DateFilterPeriod

||||
|---|---|---|
| type | Spécifie si le type de période "date" est ABSOLUTE (absolu) ou RELATIVE (relatif) | "type" : "RELATIVE" |
| période | Spécifie si une période relative doit être utilisée. Ceci est applicable uniquement lorsque "type" est RELATIVE. (voir la section [Périodes relatives](#webapi_date_relative_period_values) pour consulter les périodes relatives prises en charge) | "period" : "THIS_WEEK" |
| date de début | Date de début absolue ; applicable uniquement lorsque le "type" est ABSOLUTE. | "startDate":"2014-05-01" |
| date de fin | Date de fin absolue ; applicable uniquement lorsque le "type" est ABSOLUTE. | "startDate":"2014-05-01" |
| startBuffer | Date de début personnalisée relative ; applicable uniquement lorsque le "type" est RELATIVE. | "startBuffer":-10 |
| endBuffer | Date de fin personnalisée relative ; applicable uniquement lorsque le "type" est RELATIVE. | "startDate":+10 |

Les modes de sélection des utilisateurs assignés disponibles sont expliqués dans le tableau suivant.



Tableau : Modes de sélection des utilisateurs assignés (attribution d'événements)

| Mode | Description |
|---|---|
| ACTUEL | Attribué à l'utilisateur actuellement connecté |
| FOURNI | Attribué aux utilisateurs indiqués dans le paramètre "assignedUser". |
| AUCUNE | Attribué à aucun utilisateur. |
| TOUT | Attribué à tout utilisateur. |

Un exemple de charge pouvant être utilisée pour créer/mettre à jour un filtre d'événement est présenté ci-dessous.

```json
{
  "program": "ur1Edk5Oe2n",
  "description": "Simple Filter for TB events",
  "name": "TB events",
  "eventQueryCriteria": {
    "organisationUnit":"DiszpKrYNg8",
    "eventStatus": "COMPLETED",
    "eventDate": {
      "startDate": "2014-05-01",
      "endDate": "2019-03-20",
      "startBuffer": -5,
      "endBuffer": 5,
      "period": "LAST_WEEK",
      "type": "RELATIVE"
    },
    "dataFilters": [{
      "dataItem": "abcDataElementUid",
      "le": "20",
      "ge": "10",
      "lt": "20",
      "gt": "10",
      "in": ["India", "Norway"],
      "like": "abc"
    },
    {
      "dataItem": "dateDataElementUid",
      "dateFilter": {
        "startDate": "2014-05-01",
        "endDate": "2019-03-20",
        "type": "ABSOLUTE"
      }
    },
    {
      "dataItem": "anotherDateDataElementUid",
      "dateFilter": {
        "startBuffer": -5,
        "endBuffer": 5,
        "type": "RELATIVE"
      }
    },
    {
      "dataItem": "yetAnotherDateDataElementUid",
      "dateFilter": {
        "period": "LAST_WEEK",
        "type": "RELATIVE"
      }
    }],
    "programStatus": "ACTIVE"
  }
}
```


##### Récupération et suppression des filtres d'événements { #retrieving-and-deleting-event-filters } 

Un filtre d'événement spécifique peut être récupéré en utilisant l'API suivante

    GET /api/33/eventFilters/{uid}

Tous les filtres d'événements peuvent être récupérés en utilisant l'API suivante.

    GET /api/33/eventFilters?fields=*

Tous les filtres d'événements pour un programme spécifique peuvent être récupérés à l'aide de l'API suivante :

    GET /api/33/eventFilters?filter=program:eq:IpHINAT79UW

Un filtre d'événement peut être supprimé à l'aide de l'API suivante

    DELETE /api/33/eventFilters/{uid}

### Relations { #relationships } 
Les relations sont des liens entre deux entités dans le Tracker. Ces entités peuvent être des instances d'entités suivies, des inscriptions et des événements.

Il existe plusieurs points d'extrémité qui vous permettent de voir, de créer, de supprimer et de mettre à jour les relations. Le plus courant est /api/trackedEntityInstances, où vous pouvez inclure des relations dans la charge pour les créer, les mettre à jour ou les supprimer si vous les omettez - de la même manière que vous travaillez avec les inscriptions et les événements dans le même point d'extrémité. Tous les points d'extrémité du Tracker, c'est-à-dire /api/trackedEntityInstances, /api/enrollments et /api/events listent également leurs relations si une requête est spécifiée dans le filtre de champ.

Toutefois, le point d'extrémité communément utilisé pour les relations est /api/relationships. Il fournit toutes les opérations CRUD normales pour les relations.

List all relationships require you to provide the UID of the trackedEntityInstance, Enrollment or event that you want to list all the relationships for:  

    GET /api/relationships?tei=ABCDEF12345
    GET /api/relationships?enrollment=ABCDEF12345
    GET /api/relationships?event=ABCDEF12345

Cette requête renverra une liste de toutes les relations que vous pouvez voir. Cela inclut l'instance d'entité suivie, l'inscription ou l'événement que vous avez spécifié. Chaque relation est représentée par le JSON suivant :

```json
{
  "relationshipType": "dDrh5UyCyvQ",
  "relationshipName": "Mother-Child",
  "relationship": "t0HIBrc65Rm",
  "bidirectional": false,
  "from": {
    "trackedEntityInstance": {
      "trackedEntityInstance": "vOxUH373fy5"
    }
  },
  "to": {
    "trackedEntityInstance": {
      "trackedEntityInstance": "pybd813kIWx"
    }
  },
  "created": "2019-04-26T09:30:56.267",
  "lastUpdated": "2019-04-26T09:30:56.267"
}
```

Vous pouvez également visualiser les relations spécifiées en utilisant le point d'extrémité suivant :

    GET /api/relationships/<id>

Pour créer ou mettre à jour une relation, vous pouvez utiliser les points d'extrémité suivants :

    POST /api/relationships
    PUT /api/relationships

Et utilisez la structure de charge suivante :

```json
{
  "relationshipType": "dDrh5UyCyvQ",
  "from": {
    "trackedEntityInstance": {
      "trackedEntityInstance": "vOxUH373fy5"
    }
  },
  "to": {
    "trackedEntityInstance": {
      "trackedEntityInstance": "pybd813kIWx"
    }
  }
}
```

Pour supprimer une relation, vous pouvez utiliser ce point d'extrémité :

      DELETE /api/relationships/<id>

Dans nos exemples de charges, nous utilisons une relation entre instances d'entités suivies. C'est pourquoi les propriétés "from" et "to" de nos charges incluent des objets "trackedEntityInstance". Si votre relation inclut d'autres entités, vous pouvez utiliser les propriétés suivantes :

```json
{
  "enrollment": {
    "enrollment": "<id>"
  }
}
```

```json
{
  "event": {
    "event": "<id>"
  }
}
```

### Update strategies { #webapi_tei_update_strategies } 

Deux stratégies de mise à jour sont prises en charge pour les trois points d'extrémité du Tracker : l'inscription et la création d'événements. Ceci est utile lorsque vous avez généré un identifiant au niveau du client et que vous n'êtes pas sûr s'il a été créé ou non sur le serveur.



Tableau : Stratégies du Tracker disponibles

| Paramètre | Description |
|---|---|
| CRÉER | Permet de créer uniquement. C'est le fonctionnement par défaut. |
| CREATE_AND_UPDATE | Ce paramètre essaie de trouver une correspondance avec l'ID, s'il existe, puis de le mettre à jour. S'il n'existe pas, il le crée. |

Pour modifier ce paramètre, utilisez le paramètre de stratégie :

    POST /api/33/trackedEntityInstances?strategy=CREATE_AND_UPDATE

### Tracker bulk deletion { #webapi_tracker_bulk_deletion } 

La suppression en bloc d'objets Tracker fonctionne de la même manière que l'ajout et la mise à jour d'objets Tracker. La seule différence est que la stratégie d'importation (`importStrategy`) est *DELETE*.

*Exemple : Suppression en bloc d'instances d'entités suivies :*

```json
{
  "trackedEntityInstances": [
    {
      "trackedEntityInstance": "ID1"
    }, {
      "trackedEntityInstance": "ID2"
    }, {
      "trackedEntityInstance": "ID3"
    }
  ]
}
```

```bash
curl -X POST -d @data.json -H "Content-Type: application/json"
  "http://server/api/33/trackedEntityInstances?strategy=DELETE"
```

*Exemple : Suppression en bloc d'inscriptions :*

```json
{
  "enrollments": [
    {
       "enrollment": "ID1"
    }, {
      "enrollment": "ID2"
    }, {
      "enrollment": "ID3"
    }
  ]
}
```

```bash
curl -X POST -d @data.json -H "Content-Type: application/json"
  "http://server/api/33/enrollments?strategy=DELETE"
```

*Exemple : Suppression en bloc d'événements:*

```json
{
  "events": [
    {
      "event": "ID1"
    }, {
      "event": "ID2"
    }, {
      "event": "ID3"
    }
  ]
}
```

```bash
curl -X POST -d @data.json -H "Content-Type: application/json"
  "http://server/api/33/events?strategy=DELETE"
```

### Identifier reuse and item deletion via POST and PUT methods { #webapi_updating_and_deleting_items } 

Les points d'extrémité du Tracker */trackedEntityInstances*, */enrollments*, */events* prennent en charge les opérations CRUD. Le système garde la trace des identifiants utilisés. Ainsi, un élément qui a été créé puis supprimé (par exemple, un événement ou une inscription) ne peut pas être créé ou mis à jour à nouveau. Si l'on tente de supprimer un élément déjà supprimé, le système renvoie une réponse de succès, car la suppression d'un élément déjà supprimé n'implique aucun changement.

Le système ne permet pas de supprimer un élément via une méthode de mise à jour (*PUT*) ou de création (*POST*). Par conséquent, l'attribut *deleted* est ignoré dans les méthodes *PUT* et *POST*, et dans la méthode *POST*, il est défini par défaut sur *false*.

### Import parameters { #webapi_import_parameters } 

Le processus d'importation peut être personnalisé à l'aide d'un ensemble de paramètres d'importation :



Tableau : Paramètres d'importation

| Paramètre | Valeurs (par défaut en premier) | Description |
|---|---|---|
| dataElementIdScheme (Schéma d'identifiant d'élément de données) | identifiant &#124; nom &#124; code &#124; attribut:ID | Propriété de l'objet d'élément de données à utiliser pour faire correspondre les données. |
| orgUnitIdScheme (Schéma de l'identifiant de l'unité d'organisation) | identifiant &#124; nom &#124; code &#124; attribut:ID | Propriété de l'objet d'unité d'organisation à utiliser pour faire correspondre les données. |
| idScheme | id | name | code| attribute:ID | Propriété de tous les objets, y compris les éléments de données, les unités d'organisation et les combinaisons d'options de catégorie, à utiliser pour mapper les valeurs de données. |
| dryRun | faux &#124; vrai | Pour sauvegarder les modifications sur le serveur ou pour renvoyer le résumé de l'importation. |
| strategy | CRÉER &#124; METTRE À JOUR &#124; CRÉER _ET_METTRE À JOUR &#124; SUPPRIMER | Sauvegarde des objets de tous les statuts d'importation, nouveaux ou mis à jour, sur le serveur. |
| skipNotifications | vrai &#124; faux | Indique s'il faut envoyer des notifications pour les événements terminés. |
| skipFirst | vrai &#124; faux | Ne concerne que l'importation de fichiers CSV. Il indique si le fichier CSV contient une ligne d'en-tête qui doit être ignorée. |
| importReportMode (mode de rapport d'importation) | FULL, ERRORS, DEBUG | Définit le mode de `rapport d'importation` ; contrôle ce qui est rapporté après l'importation. `ERRORS` n'inclut que les *rapports d'objets* pour les objets qui contiennent des erreurs. `FULL` renvoie un *rapport d'objet* pour tous les objets importés, et `DEBUG` renvoie la même chose plus un nom pour l'objet (si disponible). |

#### CSV Import / Export { #webapi_events_csv_import_export } 

Outre les formats XML et JSON pour l'importation et l'exportation d'événements, le format CSV a été introduit dans DHIS2.17. La prise en charge de ce format s'appuie sur ce qui a été décrit dans la dernière section, nous ne parlerons donc ici que des parties spécifiques au format CSV.

Pour utiliser le format CSV, vous devez soit utiliser le point d'extrémité `/api/events.csv` ou ajouter *content-type : text/csv* pour l'importation, et *accept :text/csv* pour l'exportation, lorsque vous utilisez le point d'extrémité `/api/events`.

The order of column in the CSV which are used for both export and import
is as follows:



Tableau : Colonne CSV

| Index | Clé | Type | Description |
|---|---|---|---|
| 1 | événement | identifiant | Identifiant de l'événement |
| 2 | statut | enum | Status of event, can be ACTIVE &#124; COMPLETED &#124; VISITED &#124; SCHEDULED &#124; OVERDUE &#124; SKIPPED |
| 3 | de paludisme) ». | identifiant | Identifiant du programme |
| 4 | Étape du programme | identifiant | Identifiant de l'étape de programme |
| 5 | inscription | identifiant | Identifiant de l'inscription (instance de programme) |
| 6 | orgUnit (Unité d'organisation) | identifiant | Identifiant de l'unité d'organisation |
| 7 | eventDate (date de l'événement) | date | Date de l'événement |
| 8 | dueDate | date | Date d'échéance |
| 9 | latitude | double | Latitude à laquelle l'événement s'est produit |
| 10 | longitude | double | Longitude à laquelle l'événement s'est produit |
| 11 | élément de données | identifiant | Identifiant de l'élément de données |
| 12 | valeur | chaîne | Valeur / mesure de l'événement |
| 13 | Stocké par | chaîne | L'événement a été enregistré par (par défaut, l'utilisateur actuel) |
| 14 | Fourni ailleurs | booléen | Valable lorsque la valeur est collectée ailleurs |
| 14 | completedDate | date | Date d'achèvement de l'événement |
| 14 | completedBy (terminé par) | chaîne | Nom d'utilisateur de l'utilisateur qui a terminé l'événement |

*Exemple de 2 événements avec 2 valeurs de données différentes chacun :*

```csv
EJNxP3WreNP,COMPLETED,<pid>,<psid>,<enrollment-id>,<ou>,2016-01-01,2016-01-01,,,<de>,1,,
EJNxP3WreNP,COMPLETED,<pid>,<psid>,<enrollment-id>,<ou>,2016-01-01,2016-01-01,,,<de>,2,,
qPEdI1xn7k0,COMPLETED,<pid>,<psid>,<enrollment-id>,<ou>,2016-01-01,2016-01-01,,,<de>,3,,
qPEdI1xn7k0,COMPLETED,<pid>,<psid>,<enrollment-id>,<ou>,2016-01-01,2016-01-01,,,<de>,4,,
```

#### Import strategy: SYNC { #webapi_sync_import_strategy } 

La stratégie d'importation SYNC ne doit être utilisée que par la tâche de synchronisation interne et non pour l'importation régulière. La stratégie SYNC permet aux 3 opérations (CREATE, UPDATE, DELETE) d'être présentes dans la charge au moment moment.

### Tracker Ownership Management { #webapi_tracker_ownership_management } 

Un nouveau concept appelé "Propriété du Tracker" est introduit à partir de la version 2.30. Désormais, il n'y aura plus qu'une seule unité d'organisation propriétaire pour une instance d'entité suivie dans le cadre d'un programme. Les programmes configurés avec un niveau d'accès *PROTECTED* (protégé) ou *CLOSED* (fermé) respecteront les privilèges de propriété. Seuls les utilisateurs appartenant à l'unité d'organisation propriétaire d'une combinaison entité suivie-programme pourront accéder aux données liées à ce programme pour cette entité suivie.

#### Tracker Ownership Override : Break the Glass { #webapi_tracker_ownership_override_api } 

Il est possible d'annuler temporairement ce privilège de propriété pour un programme configuré avec un niveau d'accès *PROTECTED*. Tout utilisateur sera en mesure d'obtenir temporairement l'accès aux données liées au programme s'il fournit une raison d'accéder aux données de la combinaison Entité suivie - Programme. Ce fait d'obtenir temporairement l'accès est appelé *briser la glace*. Actuellement, l'accès temporaire est accordé pour une durée de 3 heures. DHIS2 vérifie l'aspect "briser la glace" ainsi que la raison fournie par l'utilisateur. Il n'est pas possible d'obtenir un accès temporaire à un programme qui a été configuré avec un niveau d'accès *CLOSED*. Pour briser la glace d'une combinaison Entité suivie - Programme, la requête POST suivante peut être utilisée :

    /api/33/tracker/ownership/override?trackedEntityInstance=DiszpKrYNg8
      &program=eBAyeGv0exc&reason=patient+showed+up+for+emergency+care

#### Tracker Ownership Transfer { #webapi_tracker_ownership_transfer_api } 

Il est possible de transférer la propriété d'une combinaison Entité suivie - Programme d'une unité d'organisation à une autre. Cela peut s'avérer utile en cas de transfert de patients ou de migration. Seul un propriétaire (ou un utilisateur qui a utilisé la fonction de brise glace) peut transférer la propriété. Pour transférer la propriété d'une combinaison Entité suivie - Programme à une autre unité d'organisation, vous pouvez utiliser la requête "PUT" suivante :

    /api/33/tracker/ownership/transfer?trackedEntityInstance=DiszpKrYNg8
      &program=eBAyeGv0exc&ou=EJNxP3WreNP


## Doublons potentiels { #potential-duplicates } 

Les doublons potentiels sont les enregistrements sur les lesquels nous travaillons dans le cadre de la déduplication des données. En raison de la nature de la fonction de déduplication, ce point d'extrémité d'API est quelque peu restreint.

Un doublon potentiel représente une paire d'enregistrements qui sont soupçonnés d'être des doublons.

La charge d'un doublon potentiel se présente comme suit :

```json
{
  "teiA": "<id>",
  "teiB": "<id>",
  "status": "OPEN|INVALID|MERGED"
}
```

Vous pouvez récupérer une liste de doublons potentiels en utilisant le point d'extrémité suivant :

    GET /api/potentialDuplicates

| Le nom du paramètre | Description | Type | Valeurs autorisées |
|---|---|---|---|
| teis | Liste des instances d'entités suivies | Liste de chaînes (séparées par une virgule)| identifiant de l'instance d'entité suivie existante |
| statut | Statut de doublon potentiel | chaîne | `OPEN <default>`, `INVALID`, `MERGED`, `ALL` |

| Code de statut | Description
|---|---|
| 400 | Invalid input status

Vous pouvez inspecter des enregistrements individuels susceptibles d'être dupliqués :

    GET /api/potentialDuplicates/<id>

| Code de statut | Description
|---|---|
| 404 | Doublon potentiel non trouvé

You can also filter potential duplicates by Tracked Entity Instance (referred as tei) :

    GET /api/potentialDuplicates/tei/<tei>

| Le nom du paramètre | Description | Type | Valeurs autorisées |
|---|---|---|---|
| statut | Statut de doublon potentiel | chaîne | `OPEN`, `INVALID`, `MERGED`, `ALL <default>` |

| Code de statut | Description
|---|---|
| 400 | Invalid input status
| 403 | User do not have access to read tei
| 404 | Tei not found

Pour créer un nouveau doublon potentiel, vous pouvez utiliser ce point d'extrémité :

    POST /api/potentialDuplicates

The payload you provide must include both teiA and teiB

```json
{
  "teiA": "<id>",
  "teiB": "<id>"
}
```

| Code de statut | Description
|---|---|
| 400 | Input teiA or teiB is null or has invalid id
| 403 | User do not have access to read teiA or teiB
| 404 | Tei not found
| 409 | Pair of teiA and teiB already existing

Pour mettre à jour un statut de doublon potentiel :

    PUT /api/potentialDuplicates/<id>

| Le nom du paramètre | Description | Type | Valeurs autorisées |
|---|---|---|---|
| statut | Statut de doublon potentiel | chaîne | `OPEN`, `INVALID`, `MERGED` |

| Code de statut | Description
|---|---|
| 400 | Vous ne pouvez pas mettre à jour un doublon potentiel en le faisant passer à MERGED. Pour ce faire, vous devez effectuer une requête de fusion.
| 400 | Vous ne pouvez pas mettre à jour un doublon potentiel qui a déjà le statut MERGED.

## Flag Tracked Entity Instance as Potential Duplicate { #flag-tracked-entity-instance-as-potential-duplicate } 

To flag as potential duplicate a Tracked Entity Instance (referred as tei)

 `PUT /api/trackedEntityInstances/{tei}/potentialDuplicate`

| Le nom du paramètre | Description | Type | Valeurs autorisées |
|---|---|---|---|
| flag | either flag or unflag a tei as potential duplicate | chaîne | `true`, `false` |


| Code de statut | Description
|---|---|
| 400 | Invalid flag must be true of false
| 403 | User do not have access to update tei
| 404 | Tei not found

## Fusion des instances d'entités suivies { #merging-tracked-entity-instances } 
Les instances d'entités suivies peuvent désormais être fusionnées si elles sont compatibles. Pour lancer une fusion, la première étape consiste à définir deux instances d'entités suivies en tant que doublons potentiels. Le point d'extrémité de fusion déplacera les données de l'instance d'entité suivie dupliquée vers l'instance d'entité suivie originale, et supprimera les données restantes de l'instance dupliquée.

Pour fusionner un doublon potentiel ou les deux instances d'entités suivies que le doublon potentiel représente, le point d'extrémité suivant peut être utilisé :

    POST /potentialDuplicates/<id>/merge

| Le nom du paramètre | Description | Type | Valeurs autorisées |
|---|---|---|---|
| mergeStrategy | Stratégie à utiliser pour fusionner le doublon potentiel  | enum | AUTO(default) or MANUAL |

Le point d'extrémité accepte un seul paramètre, "mergeStrategy", qui détermine la stratégie à utiliser lors de la fusion. Avec la stratégie AUTO, le serveur tentera de fusionner les deux entités suivies automatiquement, sans aucune intervention de l'utilisateur. Cette stratégie permet uniquement de fusionner des entités suivies qui n'ont pas de données incompatibles (voir les exemples ci-dessous). L'autre stratégie, MANUAL, exige que l'utilisateur envoie une charge décrivant la manière dont la fusion doit être effectuée. Pour voir des exemples et des règles pour chaque stratégie, consultez leurs sections respectives ci-dessous.

### Stratégie de fusion AUTO { #merge-strategy-auto } 
La fusion automatique évalue la possibilité de fusionner les deux instances d'entités suivies et les fusionne si elles sont jugées fusionnables. La fusion est basée sur l'existence ou non de divergences entre les deux instances d'entités suivies. Les divergences concernent les données qui ne peuvent pas être fusionnées automatiquement. Voici quelques exemples de divergences possibles :
- Le même attribut a des valeurs différentes dans chaque instance d'entité suivie
- Les deux instances d'entités suivies sont inscrites au même programme
- Les instances d'entités suivies sont de différents types

En cas de conflit, un message d'erreur est renvoyé à l'utilisateur.

Si aucun conflit n'est détecté, toutes les données du doublon qui ne se trouvent pas déjà dans l'instance originale seront déplacées vers cette dernière. Il s'agit notamment des valeurs d'attributs, des inscriptions (y compris les événements) et des relations. Une fois la fusion terminée, le doublon est supprimé et le doublon potentiel est marqué MERGED.

Lorsque vous effectuez une requête de fusion automatique comme celle-ci, une charge n'est pas nécessaire et cette partie sera ignorée.

### Stratégie de fusion MANUAL { #merge-strategy-manual } 
The manual merge is suitable when the merge has resolvable conflicts, or when not all the data is required to be moved over during a merge. For example, if an attribute has different values in both tracked
entity instances, the user can specify whether to keep the original value, or move over the duplicate's value. Since the manual merge is the user explicitly requesting to move data, there are some different 
checks being done here:
- La relation ne peut pas être entre l'original et le doublon (ceci résulte en une relation d'autoréférencement invalide).
- La relation ne peut pas être du même type et concerner le même objet dans les deux instances d'entités suivies (par exemple, entre l'original et un autre, et entre le doublon et un autre ; il en résulterait une relation dupliquée).

Il existe deux façons d'effectuer une fusion manuelle : Avec et sans charge.

When a manual merge is requested without a payload, we are telling the API to merge the two tracked entity instances without moving any data. In other words, we are just removing the duplicate and marking the 
potentialDuplicate MERGED. This might be valid in a lot of cases where the tracked entity instance was just created, but not enrolled for example.

Dans le cas contraire, si une requête de fusion manuelle est effectuée avec une charge, celle-ci indique les données qui doivent être transférées du doublon vers l'original. La charge se présente comme suit :
```json
{
  "attributes": ["B58KFJ45L9D"],
  "enrollments": ["F61SJ2DhINO"],
  "relationships": ["ETkkZVSNSVw"]
}
```

This payload contains three lists, one for each of the types of data that can be moved. Attributes is a list of uids for Tracked Entity Attributes, enrollments is a list of uids for enrollments and relationships 
a list of uids for relationships. The uids in this payload have to refer to data that actually exists on the duplicate. There is no way to add new data or change data using the merge endpoint - Only moving data.


### Informations complémentaires sur la fusion { #additional-information-about-merging } 
Actuellement, il n'est pas possible de fusionner les instances d'entités suivies qui sont inscrites à un même programme, en raison de la complexité accrue. Une alternative consiste à supprimer manuellement les inscriptions de l'une des instances avant de commencer la fusion.

Toutes les fusions sont basées sur des données déjà conservées dans la base de données ; le service de fusion actuel ne valide donc pas ces données à nouveau. Cela signifie que si des données étaient déjà invalides, elles ne seront pas signalées lors de la fusion. La seule validation effectuée dans le service concerne les relations, tel qu'indiqué dans la section précédente.



## Modèle de notification de programme { #program-notification-template } 

Program Notification Template lets you create message templates which can be sent as a result of different type of events.
Message and Subject templates will be translated into actual values and can be sent to the configured destination. Each program notification template will be
transformed to either MessageConversation object or ProgramMessage object based on external or internal notificationRecipient. These intermediate objects will
only contain translated message and subject text.
There are multiple configuraiton parameters in Program Notification Tempalte which are critical for correct working of notifications.
All those are explained in the table below.

    POST /api/programNotificationTemplates

```json
{
    "name": "Case notification",
    "notificationTrigger": "ENROLLMENT",
    "subjectTemplate": "Case notification V{org_unit_name}",
    "displaySubjectTemplate": "Case notification V{org_unit_name}",
    "notifyUsersInHierarchyOnly": false,
    "sendRepeatable": false,
    "notificationRecipient": "ORGANISATION_UNIT_CONTACT",
    "notifyParentOrganisationUnitOnly": false,
    "displayMessageTemplate": "Case notification A{h5FuguPFF2j}",
    "messageTemplate": "Case notification A{h5FuguPFF2j}",
    "deliveryChannels": [
        "EMAIL"
    ]
}
```

Les champs sont expliqués dans le tableau suivant.


Tableau : Charge du Modèle de notification de programme

| Champ | Obligatoire | Description | Valeurs |
|---|---|---|---|
| nom | Oui | name of Program Notification Tempalte | case-notification-alert |
| notificationTrigger | Oui | Définit le moment où la notification doit être déclenchée. Les valeurs possibles sont ENROLLMENT, COMPLETION, PROGRAM_RULE, SCHEDULED_DAYS_DUE_DATE.| INSCRIPTION |
| subjectTemplate | Non | Subject template string | Case notification V{org_unit_name} |
| messageTemplate | Oui | Chaîne du modèle de message | Case notification A{h5FuguPFF2j} |
| notificationRecipient | OUI | Destinataire de la notification. Les valeurs possibles sont USER_GROUP, ORGANISATION_UNIT_CONTACT, TRACKED_ENTITY_INSTANCE, USERS_AT_ORGANISATION_UNIT, DATA_ELEMENT, PROGRAM_ATTRIBUTE, WEB_HOOK.  | USER_GROUP |
| deliveryChannels | Non | Le canal qui doit être utilisé pour envoyer cette notification. Les différentes options sont SMS, EMAIL et HTTP. | SMS |
| sendRepeatable | Non | Détermine si la notification doit être envoyée plusieurs fois | faux |

NOTE : WEB_HOOK notificationRecipient est utilisé uniquement pour envoyer (POST) des requêtes http à un système externe. Assurez-vous de choisir le canal HTTP lorsque vous utilisez WEB_HOOK.

### Récupération et suppression du Modèle de notification de programme { #retrieving-and-deleting-program-notification-template } 

La liste des modèles de notification de programme peut être récupérée à l'aide de la méthode GET.

    GET /api/programNotificationTemplates

Pour un modèle particulier de notification de programme.

    GET /api/33/programNotificationTemplates/{uid}

Pour obtenir une liste filtrée des Modèles de notification de programme

    GET /api/programNotificationTemplates/filter?program=<uid>
    GET /api/programNotificationTemplates/filter?programStage=<uid>

Le Modèle de notification de programme peut être supprimé à l'aide de la méthode DELETE.

    DELETE /api/33/programNotificationTemplates/{uid}


## Messages de programme { #program-messages } 

"Message de programme" vous permet d'envoyer des messages à des instances d'entités suivies, à des adresses associées à des unités d'organisation, à des numéros de téléphone et à des adresses électroniques. Vous pouvez envoyer des messages via la ressource `messages`.

    /api/33/messages

### Envoi de messages de programme { #sending-program-messages } 

Les messages de programme peuvent être envoyés à l'aide de deux canaux :

  - SMS (SMS)

  - Adresse électronique (EMAIL)

Les messages de programme peuvent être envoyés à différents destinataires :

  - Instance d'entité suivie : Le système recherchera les attributs de 
    type PHONE_NUMBER ou EMAIL (en fonction des canaux spécifiés) et utilisera les valeurs d'attribut correspondantes.
    spécifiés) et utilisera les valeurs d'attribut correspondantes.

  - Unité d'organisation : Le système utilisera le numéro de téléphone ou l'adresse électronique
    enregistrés pour l'unité d'organisation.

  - Liste de numéros de téléphone : Le système utilisera les numéros de téléphone définis.
     

  - Liste d'adresses électroniques : Le système utilisera les adresses électroniques définies.
     

Vous trouverez ci-dessous un exemple de charge JSON pour l'envoi de messages à l'aide de requêtes POST. Notez que la ressource "message" accepte un objet enveloppeur nommé `programMessages` qui peut contenir un nombre quelconque de messages de programme.

    POST /api/33/messages

```json
{
  "programMessages": [{
    "recipients": {
      "trackedEntityInstance": {
        "id": "UN810PwyVYO"
      },
      "organisationUnit": {
        "id": "Rp268JB6Ne4"
      },
      "phoneNumbers": [
        "55512345",
        "55545678"
      ],
      "emailAddresses": [
        "johndoe@mail.com",
        "markdoe@mail.com"
      ]
    },
    "programInstance": {
      "id": "f3rg8gFag8j"
    },
    "programStageInstance": {
      "id": "pSllsjpfLH2"
    },
    "deliveryChannels": [
      "SMS", "EMAIL"
    ],
    "notificationTemplate": "Zp268JB6Ne5",
    "subject": "Outbreak alert",
    "text": "An outbreak has been detected",
    "storeCopy": false
  }]
}
```

Les champs sont expliqués dans le tableau suivant.



Tableau : Charge du message de programme

| Champ | Obligatoire | Description | Valeurs |
|---|---|---|---|
| recipients² | Oui | Destinataires du message du programme. Au moins un destinataire doit être spécifié. Un nombre quelconque de destinataires/types peut être spécifié pour un message. | Il peut s'agir d'une instance d'entité suivie, d'une unité d'organisation, d'un tableau de numéros de téléphone ou d'un tableau d'adresses électroniques. |
| programInstance | Soit ceci, soit programStageInstance (instance d'étape de programme) est requis. | L'instance du programme ou l'inscription au programme | ID de l'inscription. |
| programStageInstance | Soit ceci, soit programInstance (instance de programme) est requis. | L'instance ou l'événement de l'étape de programme. | ID de l'événement. |
| deliveryChannels | Oui | Tableau des canaux d'envoi de messages. | SMS | EMAIL |
| subject | Non | L'objet du message. Ne s'applique pas au canal SMS. | Text. |
| texte | Oui | Le texte du message. | Text. |
| storeCopy | Non | Indique si une copie du message doit être stockée dans DHIS2. | false (par défaut) | true |

Un exemple minimaliste d'envoi de message par SMS à une instance d'entité suivie ressemble à ceci :

```bash
curl -d @message.json "https://play.dhis2.org/demo/api/33/messages"
  -H "Content-Type:application/json" -u admin:district
```

```json
{
  "programMessages": [{
    "recipients": {
      "trackedEntityInstance": {
        "id": "PQfMcpmXeFE"
      }
    },
    "programInstance": {
      "id": "JMgRZyeLWOo"
    },
    "deliveryChannels": [
      "SMS"
    ],
    "text": "Please make a visit on Thursday"
  }]
}
```

### Récupération et suppression des messages de programme { #retrieving-and-deleting-program-messages } 

La liste des messages peut être récupérée à l'aide de la fonction GET.

    GET /api/33/messages

Pour obtenir la liste des messages Tracker envoyés, le point d'extrémité ci-dessous peut être utilisé. L'uid de l'instance de programme ou de l'instance d'étape de programme doit être fourni.

    GET /api/33/messages/scheduled/sent?programInstance={uid}
    GET /api/33/messages/scheduled/sent?programStageInstance={uid}

Pour obtenir la liste de tous les messages planifiés

    GET /api/33/messages/scheduled
    GET /api/33/messages/scheduled?scheduledAt=2020-12-12

Un message spécifique peut également être récupéré à l'aide de la méthode GET.

    GET /api/33/messages/{uid}

Un message peut être supprimé à l'aide de la méthode DELETE.

    DELETE /api/33/messages/{uid}


### Requête pour des messages de programme { #querying-program-messages } 

L'API des messages de programme prend en charge les requêtes de messages de programme en utilisant des paramètres de requête. Les messages peuvent être filtrés en fonction des paramètres de requête mentionnés ci-dessous. Toutes les requêtes doivent utiliser la méthode GET HTTP pour récupérer les informations.



Table: Query program messages API

| Paramètre | URL |
|---|---|
| programInstance | /api/33/messages?programInstance=6yWDMa0LP7 |
| programStageInstance | /api/33/messages?programStageInstance=SllsjpfLH2 |
| trackedEntityInstance | /api/33/messages?trackedEntityInstance=xdfejpfLH2 |
| organisationUnit | /api/33/messages?ou=Sllsjdhoe3 |
| processedDate | /api/33/messages?processedDate=2016-02-01 |


# New Tracker { #new-tracker } 

Version 2.36 of DHIS2 introduced a set of new tracker endpoints dedicated to importing and querying tracker objects (Including tracked entities, enrollments, events, and relationships).
These new endpoints set a discontinuity with earlier implementations. Re-engineering the endpoints allowed developers to improve, redesign, and formalize the API's behavior to improve the Tracker services.

The newly introduced endpoints consist of:

* `POST /api/tracker`
* `GET /api/tracker/enrollments`
* `GET /api/tracker/events`
* `GET /api/tracker/trackedEntities`
* `GET /api/tracker/relationships`

> **NOTE**
>
> - The old endpoints are marked as deprecated but still work as before.
> - Some functionality is not yet ready in the new endpoints, but they support their primary use-cases.
> - These endpoints currently only support the `JSON` format as input/output.
> - Support for the `CSV` format will also be available in the future.

## Changes in the API { #changes-in-the-api } 

Property names used in the API have changed to use consistent naming across all the new endpoints.

### Tracker Import changelog (`POST`) { #tracker-import-changelog-post } 

The following table highlights the differences between the previous tracker import endpoints (/api/trackedEntityInstance, /api/enrollments, /api/events and /api/relatiosnhips) and the new endpoint (/api/tracker). All endpoints are still currently available.

|Objet Tracker|Avant|Maintenant|
|---|---|---|
|**Attribut**|`created` (créé)<br>`lastUpdated` (dernière mise à jour)|`createdAt` (créé à) <br>`updatedAt` (mis à jour à)|
|**Valeur de données**|`created` (créé)<br>`lastUpdated` (dernière mise à jour)|`createdAt` (créé à) <br>`updatedAt` (mis à jour à)|
|**Inscription**|`created`<br>`createdAtClient`<br>`lastUpdated`<br>`lastUpdatedAtClient`<br>`trackedEntityInstance`<br>`enrollmentDate`<br>`incidentDate`<br>`completedDate`|`createdAt`<br>`createdAtClient`<br>`updatedAt`<br>`updatedAtClient`<br>`trackedEntity`<br>`enrolledAt`<br>`occurredAt`<br>`completedAt`|
|**Manifestation**|`trackedEntityInstance`<br>`eventDate`<br>`dueDate`<br>`created`<br>`createdAtClient`<br>`lastUpdated`<br>`lastUpdatedAtClient`<br>`completedDate`|`trackedEntity`<br>`occurredAt`<br>`scheduledAt`<br>`createdAt`<br>`createdAtClient`<br>`updatedAt`<br>`updatedAtClient`<br>`completedAt`|
|**Remarque**|`storedDate`|`storedAt`|
|**Propriétaire du programme**|`ownerOrgUnit`<br>`trackedEntityInstance`|`orgUnit`<br>`trackedEntity`|
|**Élément de relation**|`trackedEntityInstance.trackedEntityInstance`<br>`enrollment.enrollment`<br>`event.event`|`trackedEntity`<br>`enrollment`<br>`event`|
|**Relation**|`created` (créé)<br>`lastUpdated` (dernière mise à jour)|`createdAt` (créé à) <br>`updatedAt` (mis à jour à)|
|**Entité suivie**|`trackedEntityInstance`<br>`created`<br>`createdAtClient`<br>`lastUpdated`<br>`lastUpdatedAtClient`|`trackedEntity`<br>`createdAt`<br>`createdAtClient`<br>`updatedAt`<br>`updatedAtClient`|

### Tracker Export changelog (`GET`) { #tracker-export-changelog-get } 

The `GET` endpoints all conform to the same naming conventions reported in the previous paragraph. Additionally, we made some changes regarding the request parameters to respect the same naming conventions here as well.

These tables highlight the old endpoint differences in request parameters for `GET` endpoints compared to the new

#### Modifications apportées aux paramètres de requête pour `GET /api/tracker/enrollments` { #request-parameter-changes-for-get-apitrackerenrollments }
|Avant|Maintenant|
|---|---|
|`uo`|`orgUnit` (unité d'organisation)|
|`lastUpdated`<br>`lastUpdateDuration`|`updatedAfter`<br>`updatedWithin`|
|`programStartDate`<br>`programEndDate`|`enrolledAfter`<br>`enrolledBefore`|
|`trackedEntityInstance`|`trackedEntity` (entité suivie)|

#### Modifications apportées aux paramètres de requête pour `GET /api/tracker/events` { #request-parameter-changes-for-get-apitrackerevents }
|Avant|Maintenant|
|---|---|
|`trackedEntityInstance`|`trackedEntity` (entité suivie)|
|`startDate`<br>`endDate`|`occurredAfter`<br>`occurredBefore`|
|`dueDateStart`<br>`dueDateEnd`|`scheduledAfter`<br>`scheduledBefore`|
|`dernière mise à jour`|Supprimé - obsolète, voir : <br><ul><li>`updatedAfter`</li><li> `updatedBefore`</li></ul>|
|`lastUpdatedStartDate`<br>`lastUpdateEndDate`<br>`lastUpdateDuration`|`updatedAfter`<br>`updatedBefore`<br>`updatedWithin`|

#### Modifications apportées aux paramètres de requête pour `GET /api/tracker/trackedEntities` { #request-parameter-changes-for-get-apitrackertrackedentities } 
|Avant|Maintenant|
|---|---|
|`trackedEntityInstance`|`trackedEntity` (entité suivie)|
|`uo`|`orgUnit` (unité d'organisation)|
|`programStartDate`<br>`programEndDate`|Supprimé - obsolète, voir <br><ul> <li> `enrollmentEnrolledAfter`</li><li> `enrollmentEnrolledBefore`</li></ul>|
|`programEnrollmentStartDate`<br>`programEnrollmentEndDate`|`enrollmentEnrolledAfter`<br>`enrollmentEnrolledBefore`|
|`programIncidentStartDate`<br>`programIncidentEndDate`|`enrollmentOccurredAfter`<br>`enrollmentOccurredBefore`|
|`eventStartDate`<br>`eventEndDate`|`eventOccurredAfter`<br>`eventOccurredBefore`|
|`lastUpdatedStartDate`<br>`lastUpdateEndDate`<br>`lastUpdateDuration`|`updatedAfter`<br>`updatedBefore`<br>`updatedWithin`|


## Objets Tracker { #webapi_nti_tracker_objects }

Tracker est constitué de différents types d'objets interconnectés destinés à représenter les données. Dans cette section, nous montrerons et décrirons chacun des objets utilisés dans l'API du Tracker.

### Entité suivie { #tracked-entity }

Les `entités suivies` constituent la base du modèle Tracker.

| Propriété | Description | Obligatoire | Updateable | Type | Exemple |
|---|---|---|---|---|---|
| Entité suivie | L’identifiant de l’entité suivie. Il est généré au cas où il n'est pas fourni | Non | Oui | Chaîne : Uid | ABCDEF12345 |
| TrackedEntityType (Type d'entité suivie) | Le type d’entité suivie. | Oui | Non | Chaîne : Uid | ABCDEF12345 |
| créé à | Date à laquelle l'utilisateur a créé l'entité suivie. Elle est définie sur le serveur. | Non | Oui | Date : ISO 8601 | AAAA-MM-JJThh:mm:ss |
| crééAtClient (Création au niveau du client) | Date à laquelle l'utilisateur a créé l'entité suivie au niveau du client. | Non | Non | Date : ISO 8601 | AAAA-MM-JJThh:mm:ss |
| updatedAt (mis à jour à) | Date de la dernière mise à jour de l'objet. Elle est définie sur le serveur. | Non | Oui | Date : ISO 8601 | AAAA-MM-JJThh:mm:ss |
| updatedAtClient (mise à jour au niveau du client) | Date de la dernière mise à jour de l'objet au niveau du client. | Non | Non | Date : ISO 8601 | AAAA-MM-JJThh:mm:ss |
| orgUnit (Unité d'organisation) | L'unité d'organisation dans laquelle l'utilisateur a créé l'entité suivie. | Oui | Non | Chaîne : Uid | ABCDEF12345 |
| inactif | Indique si l'entité suivie est inactive ou non. | Non | Non | Booléen | Par défaut : Faux, Vrai |
| supprimé | Indique si l'entité suivie a été supprimée. Ne peut être modifié qu'au moment de la suppression. | Non | Oui | Booléen | Faux jusqu'à suppression |
| géométrie | Il s'agit d'une représentation géographique de l'entité suivie. Elle est basée sur le « type de fonctionnalité » du type d'entité suivie. | Non | Non | GeoJson | {<br>"type": "POINT",<br>"coordonnées": [123.0, 123.0]<br>} |
| Stocké par | Référence client indiquant celui a stocké/créé l’entité suivie. | Non | Non | Chaîne : Toute | John Doe |
| les attributs | Une liste de valeurs d'attributs d'entité suivie appartenant à l'entité suivie. | Non | Non | Liste des valeurs d'attributs d'entités suivies | Voir l'attribut |
| inscriptions | Une liste des inscriptions appartenant à l’entité suivie. | Non | Non | Liste des inscriptions | Voir les inscriptions |
| relations | Une liste de relations connectées à l'entité suivie. | Non | Non | Liste des relations | Voir les relations |
| Propriétaires du programme | Liste des unités d'organisation qui ont accès via des programmes spécifiques à cette entité suivie. Voir « Propriété du programme » pour en savoir plus. | Non | Non | Liste des propriétaires du programme | Voir la section « Propriété du programme » |

> **Note**
>
> `Tracked Entities` "owns" all `Tracked Entity Attribute Values` (Or "attributes" as described in the previous table). However, `Tracked Entity Attributes` are either connected to a `Tracked Entity` through its `Tracked Entity Type` or a `Program`. We often refer to this separation as `Tracked Entity Type Attrbiutes` and `Tracked Entity Program Attributes`. The importance of this separation is related to access control and limiting what information the user can see.
>
> The "attributes" referred to in the `Tracked Entity` are `Tracked Entity Type Attributes`.


### Inscription { #enrollment } 
Les `Entités suivies` peuvent s'inscrire aux `Programmes` pour lesquels elles sont éligibles. Les entités suivies sont éligibles tant que le programme est configuré avec le même `Type d'entité suivie` que l'entité suivie. Nous représentons l'inscription avec l'objet `Inscription`, que nous décrivons dans cette section.


| Propriété | Description | Obligatoire | Immuable | Type | Exemple |
|---|---|---|---|---|---|
| inscription | L’identifiant de l'inscription. Il est généré au cas où il n'est pas fourni | Non | Oui | Chaîne : Uid | ABCDEF12345 |
| de paludisme) ». | Le programme que représente l’inscription. | Oui | Non | Chaîne : Uid | ABCDEF12345 |
| Entité suivie | Une référence à l’entité suivie inscrite. | Oui | Oui | Chaîne : Uid | ABCDEF12345 |
| TrackedEntityType (Type d'entité suivie) | Uniquement pour lire les données. Il s'agit du type de l'entité suivie inscrite | Non | Oui | Chaîne : Uid | ABCDEF12345 |
| statut | Statut de l'inscription. Il est ACTIF au cas où n'est pas fourni. | Non | Non | Énumération | ACTIF, TERMINÉ, ANNULÉ |
| orgUnit (Unité d'organisation) | L'unité d'organisation dans laquelle l'utilisateur a inscrit l'entité suivie. | Oui | Non | Chaîne : Uid | ABCDEF12345 |
| orgUnitName (nom de l'unité d'organisation) | Uniquement pour lire les données. Il s'agit du nom de l'unité d'organisation où l'inscription a eu lieu. | Non | Non | Chaîne : Toute | Sierra Leone |
| créé à | Date à laquelle l'utilisateur a créé l'objet. Elle est définie sur le serveur. | Non | Oui | Date : ISO 8601 | AAAA-MM-JJThh:mm:ss |
| crééAtClient (Création au niveau du client) | Date à laquelle l'utilisateur a créé l'objet au nibveau du client | Non | Non | Date : ISO 8601 | AAAA-MM-JJThh:mm:ss |
| updatedAt (mis à jour à) | Date de la dernière mise à jour de l'objet. Elle est définie sur le serveur. | Non | Oui | Date : ISO 8601 | AAAA-MM-JJThh:mm:ss |
| updatedAtClient (mise à jour au niveau du client) | Date de la dernière mise à jour de l'objet au niveau du client. | Non | Non | Date : ISO 8601 | AAAA-MM-JJThh:mm:ss |
| enrolledAt (inscrit à) | Date à laquelle l'utilisateur a inscrit l'entité suivie. | Oui | Oui | Date : ISO 8601 | AAAA-MM-JJThh:mm:ss |
| occurredAt (s'est produit à) | Date à laquelle l'inscription a eu lieu. | Non | Oui | Date : ISO 8601 | AAAA-MM-JJThh:mm:ss |
| completedAt (terminé à) | Date à laquelle l'utilisateur a terminé l'inscription. Elle est définie sur le serveur. | Non | Oui | Date : ISO 8601 | AAAA-MM-JJThh:mm:ss |
| completedBy (terminé par) | Fait référence à la personne qui a effectué l'inscription | Non | Non | John Doe |
| suivi | Indique si l'inscription nécessite un suivi. La valeur est "Faux" si rien n'est fourni | Non | Non | Booléen | Par défaut : Faux, Vrai |
| supprimé | Indique si l'inscription a été supprimée. Ne peut être modifié qu'au moment de la suppression. | Non | Oui | Booléen | Faux jusqu'à suppression |
| géométrie | Il s'agit d'une représentation géographique de l'inscription. Elle se base sur le « type de fonctionnalité » du programme. | Non | Non | GeoJson | {<br>"type": "POINT",<br>"coordonnées": [123.0, 123.0]<br>} |
| Stocké par | Référence client indiquant celui a stocké/créé l'inscription. | Non | Non | Chaîne : Toute | John Doe |
| les attributs | Une liste de valeurs d'attributs d'entité suivie associées à l'inscription. | Non | Non | Liste des valeurs d'attributs d'entités suivies | Voir l'attribut |
| événements | Une liste des événements appartenant à l'inscription. | Non | Non | Liste des événements | Voir les évènements |
| relations | Une liste des relations liées à l'inscription. | Non | Non | Liste des relations | Voir les relations |
| notes | Notes liées à l'inscription. Elles ne peuvent qu'être créées. | Non | Oui | Liste des notes | Voir les notes |

> **Note**
>
> `Tracked Entities` "owns" all `Tracked Entity Attribute Values` (Or "attributes" as described in the previous table). However, `Tracked Entity Attributes` are either connected to a `Tracked Entity` through its `Tracked Entity Type` or a `Program`. We often refer to this separation as `Tracked Entity Type Attrbiutes` and `Tracked Entity Program Attributes`. The importance of this separation is related to access control and limiting what information the user can see.
>
> The "attributes" referred to in the `Enrollment` are `Tracked Entity Program Attributes`.


### Événements { #events } 
Les `Événements` font partie d'un `PROGRAMME D'ÉVÉNEMENT` ou d'un `PROGRAMME TRACKER`. Pour le `PROGRAMME TRACKER`, les événements appartiennent à une `Inscription`, laquelle appartient à une `Entité suivie`. D'un autre côté, `PROGRAMME D'ÉVÉNEMENT` concerne les `Événements` non rattachées à une `Inscription` ou à une `Entité suivie` spécifique. La différence réside dans le fait que nous effectuons ou non un suivi pour une `Entité suivie` spécifique. Nous désignons parfois les événements `PROGRAMME D'ÉVÉNEMENT` "événements anonymes "ou "événements uniques" puisqu'ils ne se représentent qu'eux-mêmes et non une autre `Entité suivie`.

Dans l'API, la différence majeure est que tous les événements sont soit rattachés à la même inscription (`PROGRAMME D'ÉVÈNEMENT`), soit à des inscriptions différentes (`PROGRAMME TRACKER`). Le tableau ci-dessous signalera les cas exceptionnels entre ces deux.

| Propriété | Description | Obligatoire | Immuable | Type | Exemple |
|---|---|---|---|---|---|
| événement | L'identifiant de l'événement. Il est généré au cas où il n'est pas fourni | Non | Oui | Chaîne : Uid | ABCDEF12345 |
| Étape du programme | L'étape du programme que représente l'événement. | Oui | Non | Chaîne : Uid | ABCDEF12345 |
| inscription | A reference to the enrollment which owns the event. | Oui | Oui | Chaîne : Uid | ABCDEF12345 |
| de paludisme) ». | Uniquement pour lire les données. Il s'agit du type de programme de l'inscription qui possède l'événement. | Non | Oui | Chaîne : Uid | ABCDEF12345 |
| Entité suivie | Uniquement pour lire les données. Il s'agit de l'entité suivie propriétaire de l'événement. Ceci ***ne s'applique pas au `PROGRAMME D'ÉVÉNEMENT`*** | Non | Non | Chaîne : Uid | ABCDEF12345 |
| statut | Statut de l'évènement. Il est ACTIF au cas où n'est pas fourni. | Non | Non | Énumération | ACTIF, EFFECTUÉ, VISITÉ, HORAIRE, EN RETARD, SAUTÉ |
| Statut de l'inscription | Uniquement pour lire les données. Il s'agit du statut de l'inscription propriétaire de l'événement. Ceci ***ne s'applique pas au `PROGRAMME D'ÉVÉNEMENT`*** | Non | Non | Énumération | ACTIF, TERMINÉ, ANNULÉ |
| orgUnit (Unité d'organisation) | Il s'agit de l'unité d'organisation dans laquelle l'utilisateur a enregistré l'événement. | Oui | Non | Chaîne : Uid | ABCDEF12345 |
| orgUnitName (nom de l'unité d'organisation) | Uniquement pour lire les données. Il s'agit du nom de l'unité d'organisation où l'utilisateur a enregistré l'évènement. | Non | Non | Chaîne : Toute | Sierra Leone |
| créé à | Date à laquelle l'utilisateur a créé l'évènement. Elle est définie sur le serveur. | Non | Oui | Date : ISO 8601 | AAAA-MM-JJThh:mm:ss |
| crééAtClient (Création au niveau du client) | Date à laquelle l'utilisateur a créé l'évènement au niveau du client | Non | Non | Date : ISO 8601 | AAAA-MM-JJThh:mm:ss |
| updatedAt (mis à jour à) | Date de la dernière mise à jour de l'évènement. Elle est définie sur le serveur. | Non | Oui | Date : ISO 8601 | AAAA-MM-JJThh:mm:ss |
| updatedAtClient (mise à jour au niveau du client) | Date de la dernière mise à jour de l'évènement au niveau du client. | Non | Non | Date : ISO 8601 | AAAA-MM-JJThh:mm:ss |
| scheduledAt (programmé à) | Date à laquelle l'évènement a été programmée. | Oui | Oui | Date : ISO 8601 | AAAA-MM-JJThh:mm:ss |
| occurredAt (s'est produit à) | Date à laquelle quelque chose se passe. | Non | Oui | Date : ISO 8601 | AAAA-MM-JJThh:mm:ss |
| completedAt (terminé à) | Date à laquelle l'utilisateur a effectué l'évènement. Elle est définie sur le serveur. | Non | Oui | Date : ISO 8601 | AAAA-MM-JJThh:mm:ss |
| completedBy (terminé par) | Fait référence à la personne qui a effectué l'évènement | Non | Non | Chaîne : Toute | John Doe |
| suivi | Indique si l'événement a été marqué pour un suivi. Faux si non fourni | Non | Non | Booléen | Par défaut : Faux, Vrai |
| supprimé | Indique si l'évènement a été supprimée. Ne peut être modifié qu'au moment de la suppression. | Non | Oui | Booléen | Faux jusqu'à suppression |
| géométrie | Il s'agit d'une représentation géographique de l'évènement. Elle se base sur le « type de fonctionnalité » de l'étape de programme. | Non | Non | GeoJson | {<br>"type": "POINT",<br>"coordonnées": [123.0, 123.0]<br>} |
| Stocké par | Référence client indiquant celui a stocké/créé l'évènement. | Non | Non | Chaîne : Toute | John Doe |
| attributeOptionCombo (combinaison d'options d'attribut) | Combinaison d'options d'attribut pour l'événement. Utiliser l'option par défaut s’il n’est pas fourni ou configuré. | Non | Non | Chaîne : Uid | ABCDEF12345
| attributeCategoryOptions (options de catégorie d'attribut) | Il s'agit de l'option de catégorie d'attribut pour l'événement. Utiliser l'option par défaut si rien n’est fourni ou configuré. | Non | Non | Chaîne : Uid | ABCDEF12345
| assignedUser (Utilisateur assigné) | Fait référence à un utilisateur qui a été assigné à l'événement. | Non | Non | Chaîne : Uid | ABCDEF12345 |
| dataValues (Valeurs de données) | Liste des valeurs de données liées à l'événement. | Non | Non | Liste des valeurs d'attributs d'entités suivies | Voir l'attribut |
| relations | Liste des relations liées à l'évènement. | Non | Non | Liste des relations | Voir les relations |
| notes | Notes liées à l'évènement. Elles ne peuvent qu'être créées. | Non | Oui | Liste des notes | Voir les notes |

### Relation { #relationship }

Les `Relations` sont des objets qui relient deux autres objets Tracker. Les contraintes auxquelles chaque côté de la relation doit se conformer sont basées sur le `Type de relation` de la `Relation`.


| Propriété | Description | Obligatoire | Immuable | Type | Exemple |
|---|---|---|---|---|---|
| relation | L'identifiant de la relation. Il est généré au cas où il n'est pas fourni | Non | Oui | Chaîne : Uid | ABCDEF12345 |
| type de relation | Il s'agit du type de relation. Il détermine quels objets peuvent être reliés dans une relation. | Oui | Oui | Chaîne : Uid | ABCDEF12345 |
| Nom de la relation | Uniquement pour lire les données. Il s'agit du nom du type de relation de cette relation | Non | Non | Chaîne : Toute | Sibling |
| créé à | Date à laquelle l'utilisateur a créé la relation. Elle est définie sur le serveur. | Non | Oui | Date : ISO 8601 | AAAA-MM-JJThh:mm:ss |
| updatedAt (mis à jour à) | Date de la dernière mise à jour de la relation. Elle est définie sur le serveur. | Non | Oui | Date : ISO 8601 | AAAA-MM-JJThh:mm:ss |
| bidirectionnel | Uniquement pour lire les données. Indique si le type de relation est bidirectionnel ou non. | Non | Non | Booléen | Vrai ou faux |
| de, à | Fait référence à chaque côté de la relation. Doit être conforme aux contraintes définies dans le type de relation | Oui | Oui | Élément de la relation | {"trackedEntity": "ABCEF12345"}, {"enrollment": "ABCDEF12345"} or {"event": "ABCDEF12345"} |

> **Note**
>
>`Relationship item` represents a link to an object. Since a `relationship` can be between any tracker object like `tracked entity`, `enrollment`, and `event`, the value depends on the `relationship type`. For example, if the `relationship type` connects from an `event` to a `tracked entity`, the format is strict:
>```json
>{
>   "from": {
>     "event": "ABCDEF12345"    
>   },
>   "to": {
>     "trackedEntity": "FEDCBA12345"
>   }
>}
>```

### Attribut { #attribute } 
Les `Attributs` sont les valeurs qui décrivent les `entités suivies`. Ils peuvent être reliés via un `type d'entité suivi` ou un `programme`. Implicitement, cela signifie que les `attributs` peuvent faire partie à la fois d'une `entité suivie` et d'une `inscription`.

| Propriété | Description | Obligatoire | Immuable | Type | Exemple |
|---|---|---|---|---|---|
| attribut | Fait référence à l’attribut d’entité suivi représenté. | Oui | Oui | Chaîne : Uid | ABCDEF12345 |
| code | Uniquement pour lire les données. Il s'agit du code de l'attribut de l'entité suivie | Non | Non | Chaîne : Toute | ABC |
| Nom d'affichage | Uniquement pour lire les données. Il s'agit du nom d'affichage de l'attribut de l'entité suivie | Non | Non | Chaîne : Toute | Nom |
| créé à | Date à laquelle la valeur a été ajoutée. Elle est définie sur le serveur. | Non | Oui | Date : ISO 8601 | AAAA-MM-JJThh:mm:ss |
| updatedAt (mis à jour à) | Date de la dernière mise à jour de la valeur. Elle est définie sur le serveur. | Non | Oui | Date : ISO 8601 | AAAA-MM-JJThh:mm:ss |
| Stocké par | Référence client indiquant celui a stocké/créé la valeur. | Non | Non | Chaîne : Toute | John Doe |
| Type de valeur | Uniquement pour lire les données. Il s'agit du type de valeur que l'attribut représente. | Non | Non | Énumération | TEXTE, ENTIER et plus |
| valeur | La valeur de l'attribut d'entité suivi. | Non | Non | Chaîne : Toute | John Doe |

> **Remarque**
>
> Pour les `attributs`, seules les propriétés "attribut" et "valeur" sont requises lors de l'ajout des données. Une "valeur" peut être nulle, ce qui suppose que l'utilisateur doit la supprimer.
>
> Dans le contexte des objets Tracker, nous considérons les `Attributs d'entité suivie` et les `Valeurs d'attribut d'entité suivie` comme des "attributs". Cependant, les attributs sont également des éléments distincts, liés aux métadonnées. Il est donc essentiel de séparer les attributs Tracker et les attributs de métadonnées. Dans l'API du Tracker, il est possible de référencer les attributs des métadonnées lors de la spécification du `Schéma d'identification` (voir les paramètres de requête pour plus d'informations).

### Valeurs de données { #data-values }
Alors que les `Attributs` décrivent une `entité suivie` ou une `inscription`, les `valeurs de données` décrivent un `évènement`. La différence majeure est que les `attributs ` ne peuvent avoir qu'une seule valeur pour une `entité suivie` donnée. En revanche, les `valeurs de données` peuvent avoir plusieurs valeurs différentes selon les `événements` - même si les `événements` appartiennent tous à la même `inscription` ou à la même `entité suivie`.

| Propriété | Description | Obligatoire | Immuable | Type | Exemple |
|---|---|---|---|---|---|
| élément de données | L'élément de données que cette valeur représente. | Oui | Oui | Chaîne : Uid | ABCDEF12345 |
| valeur | La valeur de la valeur des données. | Non | Non | Chaîne : Toute | 123 |
| Fourni ailleurs | Indique si l'utilisateur a fourni la valeur ailleurs ou non. Faux si la valeur n'a pas été fournie. | Non | Non | Booléen | Faux ou vrai |
| créé à | Date à laquelle l'utilisateur a ajouté la valeur. Elle est définie sur le serveur. | Non | Oui | Date : ISO 8601 | AAAA-MM-JJThh:mm:ss |
| updatedAt (mis à jour à) | Date de la dernière mise à jour de la valeur. Elle est définie sur le serveur. | Non | Oui | Date : ISO 8601 | AAAA-MM-JJThh:mm:ss |
| Stocké par | Référence client indiquant celui a stocké/créé la valeur. | Non | Non | Chaîne : Toute | John Doe |


> **Remarque**
>
> Pour les `éléments de données`, seules les propriétés "élément de données" et "valeur" sont requises lors de l'ajout des données. Une "valeur" peut être nulle, et dans ce cas l'utilisateur doit la supprimer.

### Notes Tracker { #tracker-notes }

Le Tracker de DHIS2 permet de recueillir des données à l'aide d'éléments de données et d'attributs d'entités suivies. Cependant, il est parfois nécessaire d'enregistrer des informations supplémentaires ou des commentaires sur le sujet en question. Ces informations supplémentaires peuvent être saisies à l'aide de notes Tracker. Les notes Tracker correspondent aux commentaires sur les valeurs de données dans DHIS2 Agrégé.

Il existe deux types de notes Tracker : les notes enregistrées au niveau de l'événement et celles enregistrées au niveau de l'inscription. Une inscription peut comporter un ou plusieurs événements. Des commentaires sur chaque événement - par exemple, pourquoi un événement a été manqué, reprogrammé, ou pourquoi seuls quelques éléments de données ont été renseignés et ainsi de suite - peuvent être documentés à l'aide de notes d'événements. Chaque événement d'une inscription peut avoir son propre récit ou ses propres notes. Il est alors possible d'enregistrer, par exemple, une observation générale de ces événements à l'aide de la note d'inscription racine. Les notes d'inscription permettent également de documenter, par exemple, les raisons pour lesquelles une inscription est annulée. C'est à l'utilisateur de faire preuve d'imagination et de déterminer quand et comment utiliser les notes.

L'inscription et l'événement peuvent avoir autant de notes que nécessaire - il n'y a pas de limite. Toutefois, ces notes ne peuvent ni être supprimées ni être mises à jour. Elles servent en quelque sorte de journal de bord. Pour modifier une note, il faut en créer une autre. La seule façon de supprimer une note est de supprimer l'objet racine, à savoir l'événement ou l'inscription. 

Les notes Tracker n'ont pas de point d'extrémité qui leur soit dédié. Elles sont échangées dans le cadre de la charge utile de l'événement racine et/ou de l'inscription. Vous trouverez ci-dessous un exemple de charge utile.

```json
{
  "trackedEntityInstance": "oi3PMIGYJH8",
  <entity_details>,
  ],
  "enrollments": [
    {
      "enrollment": "EbRsJr8LSSO",
      <enrollment_details>
      "notes": [
        {
          "note": "vxmCvYcPdaW",
          "value": "Enrollment note 2.",
        },
        {
          "value": "Enrollment note 1",
        }
      ],

      "events": [
        {
          "event": "zfzS9WeO0uM",
          <event_details>,
          "notes": [
            {
              "note": "MAQFb7fAggS",
              "value": "Event Note 1.",
            },
            {
              "value": "Event Note 2.",
            }
          ],
        },
        {
          ...
        }
      ]
    }
  ]
}
```


| Propriété | Description | Obligatoire | Immuable | Type | Exemple |
|---|---|---|---|---|---|
| note | La référence de la note. Elle est générée si rien n'est fourni | Non | Oui | Chaîne : Uid | ABCDEF12345 |
| valeur | Le contenu de la note. | Oui | Oui | Chaîne : Toute | Ceci est une note |
| Stocké à | Date à laquelle l'utilisateur a ajouté la note. Elle est définie sur le serveur. | Non | Oui | Date : ISO 8601 | AAAA-MM-JJThh:mm:ss |
| updatedAt (mis à jour à) | Timestamp when the note was last updated. Set on the server. | Non | Oui | Date : ISO 8601 | AAAA-MM-JJThh:mm:ss |
| Stocké par | Référence client indiquant celui a stocké/créé la note. | Non | Non | Chaîne : Toute | John Doe |

## Importation Tracker (`POST /api/tracker`) { #webapi_nti_import }

Le point d'extrémité `POST /api/tracker` permet aux clients d'importer les objets Tracker suivants dans DHIS2 :

* **Entités suivies**
* **Inscriptions**
* **Événements**
* **Relations**
* Données intégrées dans d'autres [objets Tracker](#webapi_nti_tracker_objects)

Les principaux changements à noter par rapport aux autres points d'extrémité dédiés à l'importation Tracker sont :

1. La charge utile d'importation peut être ***imbriquée*** ou ***plate***
2. L'appel peut être ***synchrone*** ou ***asynchrone***

### Paramètres de requête { #request-parameters }

Actuellement, le point d'extrémité de l'importation Tracker prend en charge les paramètres suivants :

| Le nom du paramètre | Description | Type | Valeurs autorisées |
|---|---|---|---|
| async | Indique si l’importation doit avoir lieu de manière asynchrone ou synchrone. | Booléen | `VRAI`, `FAUX` |
| Mode de rapport | Uniquement lors d'une importation synchrone. Voir le "Récapitulatif de l'importation" pour plus d’informations. | Énumération | `COMPLET`, `ERREURS`, `AVERTISSEMENTS` |
| Mode d'importation  | Indicates the mode of import. Can either be validation only or commit (Default) | Énumération | `VALIDATION`, `COMMIT` |
| idScheme | Indicates the overall idScheme to use when importing. Default is AUTO (UID). Can be overridden for specific metadata (Listed below) | Énumération | `UID`, `CODE`, `NAME`, `ATTRIBUTE`, `AUTO` |
| dataElementIdScheme (Schéma d'identifiant d'élément de données) | Indique le schéma d'identification à utiliser pour les éléments de données lors de l'importation. | Énumération | `UID`, `CODE`, `NAME`, `ATTRIBUTE`, `AUTO` |
| orgUnitIdScheme (Schéma de l'identifiant de l'unité d'organisation) | Indique le schéma d'identification à utiliser pour les unités d'organisation lors de l'importation. | Énumération | `UID`, `CODE`, `NAME`, `ATTRIBUTE`, `AUTO` |
| programIdScheme (Schéma d'identification du programme) | Indique le schéma d'identification à utiliser pour les programmes lors de l'importation. | Énumération | `UID`, `CODE`, `NAME`, `ATTRIBUTE`, `AUTO` |
| programmeStageIdScheme (Schéma d'identification de l'étape de programme) | Indique le schéma d'identification à utiliser pour les étapes de programme lors de l'importation. | Énumération | `UID`, `CODE`, `NAME`, `ATTRIBUTE`, `AUTO` |
| categoryOptionComboIdScheme (Schéma de l'identifiant de la combinaison d'options de catégorie) | Indique le schéma d'identification à utiliser pour les combinaisons d'options de catégorie lors de l'importation. | Énumération | `UID`, `CODE`, `NAME`, `ATTRIBUTE`, `AUTO` |
| categoryOptionIdScheme (Schéma de l'identifiant d'option de catégorie) | Indique le schéma d'identification à utiliser pour les options de catégorie lors de l'importation. | Énumération | `UID`, `CODE`, `NAME`, `ATTRIBUTE`, `AUTO` |
| importStrategy (stratégie d'importation) | Indique l'effet que l'importation doit avoir. Les différentes possibilités sont `CRÉER`, `METTRE À JOUR`, `CRÉER_ET_METTRE À JOUR` et `SUPPRIMER`. Respectivement, elles permettent d'importer de nouvelles données, d'importer des modifications à des données existantes, d'importer de nouvelles données ou des mises à jour à des données existantes et, enfin, de supprimer des données. | Énumération | `CRÉER`, `METTRE À JOUR`, `CRÉER_ET_METTRE À JOUR` et `SUPPRIMER` |
| Mode atomique | Indique comment l'importation répond aux erreurs de validation. S'il est défini sur `TOUS`, toutes les données importées doivent être valides avant que chaque donnée ne soit commitée. Par contre s'il est défini sur `OBJET`, seules les données commitées doivent être valides, tandis que d'autres données peuvent être invalides. | Énumération | `TOUS`, `OBJET` |
| flushMode (mode de vidage) | Indique la fréquence de vidange. Il s'agit de la fréquence à laquelle les données sont introduites dans la base de données au cours de l'importation. Il est principalement utilisé à des fins de débogage et ne doit pas être modifié dans un environnement de production. | Énumération | `AUTO`, `OBJET` |
| Mode de validation | Indique l'intégralité de l'étape de validation. Il peut être ignoré, configuré pour échouer rapidement (retour à la première erreur) ou complet (par défaut), ce qui renverra toutes les erreurs trouvées. | Énumération | `COMPLET`, `ÉCHOUER_RAPIDEMENT`, `IGNORER` |
| Validation du modèle de saut | S'il est défini sur 'vrai', la validation du modèle des attributs générés sera sautée. | Booléen | `VRAI`, `FAUX` |
| Sauter les effets secondaires | Si défini sur 'vrai', les effets secondaires de l'importation seront ignorés. | Booléen | `VRAI`, `FAUX` |
| Sauter les règles | Si défini sur 'vrai', l'exécution des règles de programme pour l'importation sera ignorée. | Booléen | `VRAI`, `FAUX` |

### Charges utiles plates et imbriquées { #flat-and-nested-payloads }

L'importateur prend en charge les charges utiles plates et imbriquées. La principale différence réside dans la manière dont le client exige que ses données soient structurées.

**Charge utile plate**
: La charge utile de type plate est simple. Elle peut contenir des collections pour chacun des principaux objets Tracker dont nous disposons. Cela fonctionne de manière transparente avec les données existantes, auxquelles des UID sont déjà attribués. Cependant, pour les nouvelles données, le client devra fournir de nouveaux UID pour toute référence entre objets. Par exemple, si vous importez une nouvelle entité suivie avec une nouvelle inscription, l'entité suivie demande au client de fournir un UID afin que l'inscription puisse être rattachée à cet UID.

**Charge utile imbriqué**
: Les charges utiles imbriquées sont la structure la plus couramment utilisée. Ici, les objets Tracker sont intégrés dans leur objet racine - par exemple, une inscription dans une entité suivie. L'avantage avec cette structure est que le client n'a pas besoin de fournir d'UID pour toutes ces connexions puisqu'il se verra attribuer la connexion au cours du processus d'importation, étant donné qu'elles sont imbriquées les unes aux autres.

> **REMARQUE**
>
> Même si les charges utiles imbriquées peuvent s'avérer plus simples à gérer pour les clients, elles seront toujours aplaties avant l'importation. Cela signifie que pour les importations volumineuses, le fait de fournir une charge utile plate permettra non seulement d'avoir plus de contrôle mais aussi moins de surcharge sur le processus d'importation.

Ci-dessous, des exemples de versions **PLATES** et **IMBRIQUÉES** de la charge utile. Les mêmes données sont utilisées dans les deux cas.

#### Charge utile ***PLATE*** { #flat-payload }

```json
{
  "trackedEntities": [
    {
      "orgUnit": "O6uvpzGd5pu",
      "trackedEntity": "Kj6vYde4LHh",
      "trackedEntityType": "Q9GufDoplCL"
    }
  ],
  "enrollments": [
    {
      "orgUnit": "O6uvpzGd5pu",
      "program": "f1AyMswryyQ",
      "trackedEntity": "Kj6vYde4LHh",
      "enrollment": "MNWZ6hnuhSw",
      "trackedEntityType": "Q9GufDoplCL",
      "enrolledAt": "2019-08-19T00:00:00.000",
      "deleted": false,
      "occurredAt": "2019-08-19T00:00:00.000",
      "status": "ACTIVE",
      "notes": [],
      "attributes": [],
    }
  ],
  "events": [
    {
      "scheduledAt": "2019-08-19T13:59:13.688",
      "program": "f1AyMswryyQ",
      "event": "ZwwuwNp6gVd",
      "programStage": "nlXNK4b7LVr",
      "orgUnit": "O6uvpzGd5pu",
      "trackedEntity": "Kj6vYde4LHh",
      "enrollment": "MNWZ6hnuhSw",
      "enrollmentStatus": "ACTIVE",
      "status": "ACTIVE",
      "occurredAt": "2019-08-01T00:00:00.000",
      "attributeCategoryOptions": "xYerKDKCefk",
      "deleted": false,
      "attributeOptionCombo": "HllvX50cXC0",
      "dataValues": [
        {
          "updatedAt": "2019-08-19T13:58:37.477",
          "storedBy": "admin",
          "dataElement": "BuZ5LGNfGEU",
          "value": "20",
          "providedElsewhere": false
        },
        {
          "updatedAt": "2019-08-19T13:58:40.031",
          "storedBy": "admin",
          "dataElement": "ZrqtjjveTFc",
          "value": "Male",
          "providedElsewhere": false
        },
        {
          "updatedAt": "2019-08-19T13:59:13.691",
          "storedBy": "admin",
          "dataElement": "mB2QHw1tU96",
          "value": "[-11.566044,9.477801]",
          "providedElsewhere": false
        }
      ],
      "notes": []
    },
    {
      "scheduledAt": "2019-08-19T13:59:13.688",
      "program": "f1AyMswryyQ",
      "event": "XwwuwNp6gVE",
      "programStage": "PaOOjwLVW23",
      "orgUnit": "O6uvpzGd5pu",
      "trackedEntity": "Kj6vYde4LHh",
      "enrollment": "MNWZ6hnuhSw",
      "enrollmentStatus": "ACTIVE",
      "status": "ACTIVE",
      "occurredAt": "2019-08-01T00:00:00.000",
      "attributeCategoryOptions": "xYerKDKCefk",
      "deleted": false,
      "attributeOptionCombo": "HllvX50cXC0",
      "notes": []
    }
  ],
  "relationships": [
    {
      "relationshipType": "Udhj3bsdHeT",
      "from": {
        "trackedEntity": "Kj6vYde4LHh"
      },
      "to": {
        "trackedEntity": "Gjaiu3ea38E"
      }
    }
  ]
}
```

#### Charge utile ***IMBRIQUÉES*** { #nested-payload }

```json
{
  "trackedEntities": [
    {
      "orgUnit": "O6uvpzGd5pu",
      "trackedEntity": "Kj6vYde4LHh",
      "trackedEntityType": "Q9GufDoplCL",
      "relationships": [
        {
          "relationshipType": "Udhj3bsdHeT",
          "from": {
            "trackedEntity": "Kj6vYde4LHh"
          },
          "to": {
            "trackedEntity": "Gjaiu3ea38E"
          }
        }
      ],
      "enrollments": [
        {
          "orgUnit": "O6uvpzGd5pu",
          "program": "f1AyMswryyQ",
          "trackedEntity": "Kj6vYde4LHh",
          "enrollment": "MNWZ6hnuhSw",
          "trackedEntityType": "Q9GufDoplCL",
          "enrolledAt": "2019-08-19T00:00:00.000",
          "deleted": false,
          "occurredAt": "2019-08-19T00:00:00.000",
          "status": "ACTIVE",
          "notes": [],
          "relationships": [],
          "attributes": [],
          "events": [
            {
              "scheduledAt": "2019-08-19T13:59:13.688",
              "program": "f1AyMswryyQ",
              "event": "ZwwuwNp6gVd",
              "programStage": "nlXNK4b7LVr",
              "orgUnit": "O6uvpzGd5pu",
              "trackedEntity": "Kj6vYde4LHh",
              "enrollment": "MNWZ6hnuhSw",
              "enrollmentStatus": "ACTIVE",
              "status": "ACTIVE",
              "occurredAt": "2019-08-01T00:00:00.000",
              "attributeCategoryOptions": "xYerKDKCefk",
              "deleted": false,
              "attributeOptionCombo": "HllvX50cXC0",
              "dataValues": [
                {
                  "updatedAt": "2019-08-19T13:58:37.477",
                  "storedBy": "admin",
                  "dataElement": "BuZ5LGNfGEU",
                  "value": "20",
                  "providedElsewhere": false
                },
                {
                  "updatedAt": "2019-08-19T13:58:40.031",
                  "storedBy": "admin",
                  "dataElement": "ZrqtjjveTFc",
                  "value": "Male",
                  "providedElsewhere": false
                },
                {
                  "updatedAt": "2019-08-19T13:59:13.691",
                  "storedBy": "admin",
                  "dataElement": "mB2QHw1tU96",
                  "value": "[-11.566044,9.477801]",
                  "providedElsewhere": false
                }
              ],
              "notes": [],
              "relationships": []
            },
            {
              "scheduledAt": "2019-08-19T13:59:13.688",
              "program": "f1AyMswryyQ",
              "event": "XwwuwNp6gVE",
              "programStage": "PaOOjwLVW23",
              "orgUnit": "O6uvpzGd5pu",
              "trackedEntity": "Kj6vYde4LHh",
              "enrollment": "MNWZ6hnuhSw",
              "enrollmentStatus": "ACTIVE",
              "status": "ACTIVE",
              "occurredAt": "2019-08-01T00:00:00.000",
              "attributeCategoryOptions": "xYerKDKCefk",
              "deleted": false,
              "attributeOptionCombo": "HllvX50cXC0",
              "notes": [],
              "relationships": []
            }
          ]
        }
      ]
    }
  ]
}
```

### SYNC et ASYNC { #sync-and-async }
Pour l'utilisateur, la principale différence entre une importation synchrone et une importation asynchrone est la réponse immédiate de l'API. Dans le cas d'une importation synchrone, la réponse sera renvoyée avec le récapitulatif de l'importation (importSummary) dès que l'importation sera terminée. En revanche, pour les importations asynchrones, la réponse sera immédiate et contiendra une référence à travers laquelle le client pourra demander des mises à jour de l'importation.

Dles importations importantes, il peut être avantageux pour le client d'utiliser l'importation asynchrone pour éviter d'attendre trop longtemps une réponse.


Des exemples de réponse **ASYNC** sont présentés ci-dessous. Pour la réponse **SYNC**, consultez la [section importSummary](#webapi_nti_import_summary).

```json
{
    "httpStatus": "OK",
    "httpStatusCode": 200,
    "status": "OK",
    "message": "Tracker job added",
    "response": {
        "responseType": "TrackerJob",
        "id": "LkXBUdIgbe3",
        "location": "https://play.dhis2.org/dev/api/tracker/jobs/LkXBUdIgbe3"
    }
}
```

### Récapitulatif des importations { #webapi_nti_import_summary }

L'API du Tracker dispose de deux points d'extrémité de base qui permettent aux consommateurs d'obtenir des commentaires sur leurs importations. Ces points d'extrémité concernent plus les tâches d'importation asynchrone, mais ils sont également disponibles pour les importations synchrones. Ces points d'extrémité renverront soit le journal de l'importation, soit le récapitulatif de l'importation lui-même.

> **Remarque**
>
> Ces points d'extrémité s'appuient sur des informations stockées dans la mémoire de l'application. Cela signifie que les informations seront indisponibles après certaines situations, telle qu'un redémarrage de l'application ou après un grand nombre de requêtes d'importation qui commencent après celle-ci.

Après avoir soumis une requête d'importation Tracker, nous pouvons accéder aux points d'extrémité suivants afin de surveiller la progression de la tâche en fonction des journaux :

`GET /tracker/jobs/{uid}`

| Paramètre|Description|Exemple
|---|---|---|
|`{uid}`| L'UID d'une tâche d'importation Tracker existante | ABCDEF12345

#### exemple de ***REQUÊTE*** { #request-example }

`GET /tracker/jobs/mEfEaFSCKCC`

#### Exemple de ***RÉPONSE*** { #response-example }

```json
[
  {
    "uid": "mEfEaFSCKCC",
    "level": "INFO",
    "category": "TRACKER_IMPORT_JOB",
    "time": "2021-01-01T00:00:06.00",
    "message": "TRACKER_IMPORT_JOB ( mEfEaFSCKCC ) finished in 6.00000 sec. Import:Done",
    "completed": true,
    "id": "mEfEaFSCKCC"
  },
  {
    "uid": "mEfEaFSCKCC",
    "level": "DEBUG",
    "category": "TRACKER_IMPORT_JOB",
    "time": "2021-01-01T00:00:05.00",
    "message": "TRACKER_IMPORT_JOB ( mEfEaFSCKCC ) commit completed in 1.00000 sec. Import:commit",
    "completed": true,
    "id": "mEfEaFSCKCC"
  },
  {
    "uid": "mEfEaFSCKCC",
    "level": "DEBUG",
    "category": "TRACKER_IMPORT_JOB",
    "time": "2021-01-01T00:00:04.00",
    "message": "TRACKER_IMPORT_JOB ( mEfEaFSCKCC ) programruleValidation completed in 1.00000 sec. Import:programruleValidation",
    "completed": true,
    "id": "mEfEaFSCKCC"
  },
  {
    "uid": "mEfEaFSCKCC",
    "level": "DEBUG",
    "category": "TRACKER_IMPORT_JOB",
    "time": "2021-01-01T00:00:03.00",
    "message": "TRACKER_IMPORT_JOB ( mEfEaFSCKCC ) programrule completed in 1.00000 sec. Import:programrule",
    "completed": true,
    "id": "mEfEaFSCKCC"
  },
  {
    "uid": "mEfEaFSCKCC",
    "level": "DEBUG",
    "category": "TRACKER_IMPORT_JOB",
    "time": "2021-01-01T00:00:02.00",
    "message": "TRACKER_IMPORT_JOB ( mEfEaFSCKCC ) validation completed in 1.00000 sec. Import:validation",
    "completed": true,
    "id": "mEfEaFSCKCC"
  },
  {
    "uid": "mEfEaFSCKCC",
    "level": "DEBUG",
    "category": "TRACKER_IMPORT_JOB",
    "time": "2021-01-01T00:00:01.00",
    "message": "TRACKER_IMPORT_JOB ( mEfEaFSCKCC ) preheat completed in 1.00000 sec. Import:preheat",
    "completed": true,
    "id": "mEfEaFSCKCC"
  },
  {
    "uid": "mEfEaFSCKCC",
    "level": "INFO",
    "category": "TRACKER_IMPORT_JOB",
    "time": "2021-01-01T00:00:00.00",
    "message": "TRACKER_IMPORT_JOB ( mEfEaFSCKCC ) started by admin ( xE7jOejl9FI ) Import:Start",
    "completed": true,
    "id": "mEfEaFSCKCC"
  }
]
```

De plus, le point d'extrémité suivant renverra le récapitulatif de la tâche d’importation. Ce récapitulatif ne sera disponible qu'une fois l'importation terminée :

`GET /tracker/jobs/{uid}/report`

| Paramètre|Description|Exemple
|---|---|---|
|path `/{uid}`| L'UID d'une tâche d'importation Tracker existante | ABCDEF12345
|`reportMode` (Mode de rapport)| Le niveau du rapport à renvoyer | `FULL`&#124;`ERRORS`&#124;`WARNINGS`|

#### exemple de ***REQUÊTE*** { #request-example }

`GET /tracker/jobs/mEfEaFSCKCC/report`

#### Exemple de ***RÉPONSE*** { #response-example }

La [charge utile de la réponse](#sample-responses) est la même que celle renvoyée après une requête d'importation synchrone.

> **Remarque**
>
> Les deux points d'extrémité sont principalement utilisés pour l'importation asynchrone. Cependant, `GET /tracker/jobs/{uid}` devrait également fonctionner pour les demandes synchrones car au final il utilise le même processus d'importation et la même journalisation que les demandes asynchrones.

### Structure du récapitulatif d'importation { #import-summary-structure }

La structure globale des récapitulatifs d'importation se présente comme suit, en fonction du `mode de rapport` faisant l'objet de la requête :
```json
{
  "status": "...",
  "validationReport": { },
  "stats": { },
  "timingsStats": { },
  "bundleReport": { },
  "message" : { }
}
```

***statut***

La propriété `statut` du récapitulatif d'importation indique l'état global de l'importation. Si aucune erreur ou avertissement n'est signalé(e) lors de l'importation, le `statut` est `OK`. Par contre, si une erreur ou un avertissement est signalé(e) lors de l'importation, le statut devient `ERREUR` ou `AVERTISSEMENT`.

Le `statut` dépend du `Rapport de validation` le plus important. `ERREUR` est le plus important, suivi de `AVERTISSEMENT` et enfin `OK`. Cela implique que `ERREUR` est signalé si une seule erreur a été détectée lors de l'importation, quel que soit le nombre d'avertissements.

> **Remarque**
>
> Si l'importation est faite selon le mode atomique "OBJET", où les données sont importées sans erreurs de validation, le statut sera toujours `ERREUR` si des erreurs sont détectées.

***Rapport de validation***

Le `Rapport de validation` peut inclure des `Rapports d'erreur` et des `Rapports d'avertissement` si des erreurs ou des avertissements étaient présents lors de l'importation. Lorsqu'ils sont présents, ils fournissent une liste détaillée des erreurs ou avertissements rencontrés.

Ci-dessous, un exemple d'erreur de validation lors de l'importation d'une `ENTIÉE_SUIVIE` :
```json
{
  "validationReport": {
    "errorReports": [
      {
        "message": "Could not find TrackedEntityType: `Q9GufDoplCL`.",
        "errorCode": "E1005",
        "trackerType": "TRACKED_ENTITY",
        "uid": "Kj6vYde4LHh"
      },
      ...
    ],
    "warningReports" : [ ... ]
  }
}
```

Le rapport contient un message et un code décrivant l'erreur (voir la section [codes d'erreur] (#error-codes) pour plus d'informations sur les erreurs). Il contient également le `type de tracker` et l'`uid`, lesquels permettent d'identifier l'emplacement de l'erreur dans les données. Dans ce cas, il y avait une `ENTITÉ_SUIVIE` avec l'uid `Kj6vYde4LHh` qui renvoyait à un type d'entité suivi qui n'a pas été trouvé.

> **Remarque**
>
> Les `uid` des objets trackers servent de noms à ces objets dans la charge utile. Par exemple, l'`uid` d'une entité suivie dans la charge utile serait "trackedEntity". La même chose s'applique aux inscriptions, aux événements et aux relations qui portent respectivement les noms "enrollment", "event" et "relationship".
>
> Si aucun uid n'est fourni dans la charge utile, le processus d'importation générera de nouveaux uids. Cela signifie que le rapport d'erreur peut faire référence à un uid qui n'existe pas dans votre charge utile.
>
> Les erreurs signalent des problèmes avec la charge utile que l'importateur ne peut pas contourner. Toute erreur empêchera l'importation de ces données. Les avertissements, en revanche, sont des problèmes qui peuvent être contournés en toute sécurité, mais dont l'utilisateur doit être informé. Les avertissements ne bloquent pas l'importation des données.

***Statistiques***

Les statistiques donnent un aperçu rapide de l'importation. Une fois l'importation terminée, ces statistiques indiqueront la quantité de données créées, mises à jour, supprimées ou ignorées.

Exemple:
```json
{
  "stats": {
    "created": 2,
    "updated": 2,
    "deleted": 1,
    "ignored": 5,
    "total": 10
  }
}
```
`cre` fait référence au nombre de nouveaux objets créés. En général, les objets sans UID existant dans la charge utile seront traités comme de nouveaux objets.

`updated` fait référence au nombre d'objets mis à jour. Si un objet a un UID défini dans la charge utile, il sera considéré comme étant à jour tant que ce même UID se trouve dans la base de données.

`deleted` fait référence au nombre d'objets supprimés lors de l'importation. La suppression ne se produit que lorsque l'importation est configurée pour supprimer des données et uniquement lorsque les objets présents dans la charge utile ont des UID existants définis.

`ignored` fait référence aux objets qui n'ont pas été conservés. Les objets peuvent être ignorés pour plusieurs raisons, par exemple pour éviter de créer un objet qui existe déjà. Ignorer des objets ne pose pas de réels problèmes, car si un objet est ignoré, c'est parce que sa création n'était pas nécessaire ou cela lié à la configuration de l'importation.

***timingStats*** (Statistiques de temps)

`timingStats` représente le temps écoulé dans les différentes étapes de l'importation. Ces statistiques ne donnent pas le temps total exact de l'importation, mais plutôt le temps passé dans le code pour les différentes étapes.

Les `timingStats` servent principalement à déboguer les importations qui posent des problèmes afin de voir quelle partie de l'importation rencontre des problèmes.
```json
{
  "timingsStats": {
    "timers": {
      "preheat": "0.234086 sec.",
      "preprocess": "0.000058 sec.",
      ...
      "totalImport": "0.236810 sec.",
      "validation": "0.001533 sec."
    }
  }
}
```

***bundleRapport*** (Rapport d'ensemble)

Une fois l'importation terminée, le `bundleReport` contient tous les [objets tracker](#tracker-objects) importés.

Prenons en exemple l'`ENTITÉ_SUIVIE` :
```json
{
  "bundleReport": {
    "status": "OK",
    "typeReportMap": {
      "TRACKED_ENTITY": {
        "trackerType": "TRACKED_ENTITY",
        "stats": {
          "created": 1,
          "updated": 0,
          "deleted": 0,
          "ignored": 0,
          "total": 1
        },
        "objectReports": [
          {
            "trackerType": "TRACKED_ENTITY",
            "uid": "FkxTQC4EAKK",
            "index": 0,
            "errorReports": []
          }
        ]
      },
      ...
    }
  }
}
```
Comme nous l'avons vu, chaque type d'objet Tracker sera rapporté, et chacun a ses propres statistiques et `objectReports`(rapports d'objets). Ces `rapports d'objets` fourniront des détails sur chaque objet importé, notamment leur type, leur UID et tout rapport d'erreur ou d'avertissement qui les concerne.

***message***

Si l'importation se termine brusquement, le `message`  va contenir des informations supplémentaires sur ce qui s'est passé.

### Niveau du rapport récapitulatif de l'importation { #import-summary-report-level }

Comme indiqué précédemment, `GET /tracker/jobs/{uid}/report` peut être récupéré à l'aide d'un paramètre `reportMode` spécifique. Par défaut, le point d'extrémité renverra un `importSummary` avec `pour reportMode` `ERROR`.

| Paramètre | Description |
|---|---|
| `COMPLET` | Renvoie tout à partir de `AVERTISSEMENTS`, en plus des `timingsStats` |
| `AVERTISSEMENTS` | Renvoie tout à partir de `ERREURS`, en plus de `warningReports` (rapports d'avertissement) dans `validationReports` (rapports de validation) |
| `ERREURS` (par défaut) | Renvoie uniquement `errorReports` (rapports d'erreurs) dans `validationReports` |

De plus, tous les `reportModes` (modes de rapports) renverront `statut`, `statistiques`, `bundleReport` et `message` le cas échéant.

### Codes d'erreur { #webapi_nti_error_codes }

Il existe plusieurs codes d'erreur pour différents scénarios d'erreur. Le tableau suivant contient la liste des codes d'erreur générés par la nouvelle API du Tracker, ainsi que les messages d'erreur et quelques descriptions supplémentaires. Les espaces réservés dans les messages d'erreur (`{0}`, `{1}`, `{2}`..) sont généralement des uids, sauf indication contraire.

| Code d'erreur | Message d'erreur | Description |
|:--|:----|:----|
| E1000 | Utilisateur : `{0}`, n'a pas d'accès en écriture à l'unité d'organisation : `{1}`. | Cela signifie que l'unité d'organisation `{1}` ne fait pas partie du champ de saisie de l'utilisateur `{0}` pour que l'opération d'écriture soit autorisée. |
| E1001 | L'utilisateur : `{0}`, n'a pas d'accès en écriture de données sur le type d'entité suivie : `{1}`. | L'erreur se produit lorsque l'utilisateur n'est pas autorisé à créer ou à modifier les données du Type d'entité suivie `{1}`
| E1002 | L'instance d'entité suivie `{0}` existe déjà. | Cette erreur se produit lorsque l'on essaie de créer une nouvelle entité suivie avec un uid déjà existant. Veillez à utiliser un nouvel uid lors de l'ajout d'une nouvelle entité suivie. |
| E1005 | Impossible de trouver le Type d'entité suivie : `{0}`. | L'erreur se produit lorsque l'on essaie de récupérer un Type d'entité suivie non existant avec l'uid `{0}` . Cela peut également signifier que l'utilisateur n'a pas d'accès en lecture au Type d'entité suivie. |
| E1006 | L'attribut : `{0}` n'existe pas. | L'erreur se produit lorsque le système n'a pas pu trouver un attribut d'entité suivie correspondant avec l'uid `{0}`. Cela peut également signifier que l'utilisateur n'a pas accès à l'attribut d'entité suivie. |
| E1007 | Erreur de validation du type de valeur d'attribut : `{0}` ; Erreur : `{1}`. | Incompatibilité entre le type de valeur d'un attribut d'entité suivie et la valeur d'attribut qui lui est fournie. L'erreur de validation réelle sera affichée dans `{1}`. |
| E1009 | Le ressource de fichier : `{0}` a déjà été attribuée à un autre objet. | L'uid de ressource de fichier `{0}` est déjà attribué à un autre objet du système. |
| E1010 | Impossible de trouver le programme : `{0}` lié à l'événement. | Le système n'a pas pu trouver un programme avec l'uid `{0}` spécifié dans la charge utile Événement. Cela peut également signifier que le programme spécifique n'est pas accessible par l'utilisateur connecté. |
| E1011 | Impossible de trouver l'unité d'organisation : `{0}` lié à l'événement. | Le système n'a pas pu trouver une unité d'organisation avec l'uid `{0}` spécifié dans la charge utile de l'événement.  |
| E1012 | La géométrie n'est pas conforme au FeatureType (type de fonctionnalité) : `{0}`. | Le type de fonctionnalité fourni est soit NONE (aucun), soit il est incompatible pour la valeur géométrique fournie. |
| E1013 | Impossible de trouver le ProgramStage (étape de programme) : `{0}`, lié à l'événement. | Le système n'a pas pu trouver une étape de programme avec l'uid `{0}` spécifié dans la charge utile de l'événement. Cela peut également signifier que l'étape de programme n'est pas accessible à l'utilisateur connecté.  |
| E1014 | Un programme identifié `{0}` est un programme sans enregistrement. Aucune inscription ne peut être faite dans un programme sans enregistrement. | Les inscriptions ne peuvent être créées que pour les programmes avec des enregistrements. |
| E1015 | L'instance d'entité suivie : `{0}` a déjà une inscription active dans le programme `{1}`. | Il est impossible de s'inscrire à un programme si une autre inscription active existe déjà pour le programme. L’inscription active devra au moins être terminée au préalable. |
| E1016 | L'instance d'entité suivie : `{0}` a déjà une inscription active dans le programme : `{1}`, et ce programme n'autorise qu'une seule inscription . | Conformément à la configuration du programme `{1}`, une entité suivie ne peut être inscrite qu'une seule fois à ce programme. Il semble que l'entité suivie `{0}` ait déjà une inscription ACTIVE ou TERMINÉE dans ce programme. Une autre inscription ne peut donc pas être ajoutée. |
| E1018 | L'attribut : `{0}` est obligatoire dans le programme `{1}` mais il n'est pas déclaré dans l'inscription `{2}`. | La valeur de l'attribut est manquante dans la charge utile, pour un attribut défini comme obligatoire pour un programme. Assurez-vous que les valeurs des attributs obligatoires sont fournies dans la charge utile.  |
| E1019 | Seuls les attributs du programme sont autorisés pour l'inscription ; attributs non valides : `{0}`. | L'uid d'attribut `{0}` spécifié dans la charge utile d'inscription n'est pas associé au programme.  |
| E1020 | La date d'inscription : `{0}` ne peut pas être une date ultérieure.` | Il est impossible de créer une inscription à une date ultérieure à moins que le Programme ne le permette dans sa configuration. |
| E1021 | La date d'incidence identifiée `{0}` ne peut pas être une date ultérieure.` | La date d'incidence ne peut pas être une date ultérieure à moins que le Programme ne le permette dans sa configuration. |
| E1022 | L'instance d'entité suivie `{0}` doit avoir le même type d'entité suivie que le programme `{1}`. | Le programme est configuré pour accepter un UID de type d'entité suivie différent de celui fourni dans la charge utile d’inscription. |
| E1023 | La DisplayIncidentDate (date d'affichage de l'incident) est vraie mais la propriété occurredAt (survenu à) est nulle ou a un format invalide : `{0}`. | Le programme est configuré avec la date d'affichage de l'incident mais sa date est nulle ou invalide dans la charge utile. |
| E1025 | La propriété enrolledAt (inscrit à) est nulle ou a un format non valide : `{0}`. | La date d'inscription est obligatoire pour une inscription. Assurez-vous qu'il ne soit pas nul et qu'il ait un format de date valide. |
| E1029 | L'unité d'organisation Évènement identifiée `{0}` et le Programme `{1}` ne correspondent pas. | La charge utile de l'événement utilise un programme `{1}` qui n'est pas configuré pour être accessible par l'unité d'organisation `{0}`. |
| E1030 | L'Événement `{0}` existe déjà. | Cette erreur se produit lorsque l'on essaie d'ajouter un nouvel événement avec un uid déjà existant. Veillez à utiliser un nouvel uid lors de l'ajout d'un nouvel événement. |
| E1031 | La date à laquelle l'événement est survenu (OccurredAt) est manquante. | La propriété OccuredAt (est survenue) est nulle ou a un format de date invalide dans la charge utile. |
| E1032 | L'Événement `{0}` n'existe pas. | |
| E1033 | La valeur d'inscription de l'Événement `{0}`  est NULLE. | |
| E1035 | La valeur d'inscription de l'Étape de programme `{0}`  est NULLE. | |
| E1036 | L'instance d'entité suivie de l'Événement `{0}` ne pointe pas vers un objet existant. | Le système n'a pas pu trouver une entité suivie avec l'UID spécifié dans la charge utile de l'événement. Cela peut également signifier que l'utilisateur n'a pas d'accès en lecture à l'entité suivie. |
| E1039 | L'Étape de programme `{0}` n'est pas répétable et un événement existe déjà. | Un événement existe déjà pour l'étape de programme de l’inscription. Étant donné que l'étape de programme est configuré pour être non répétable, un autre événement ne peut pas être ajouté pour la même étape de programme.  |
| E1041 | L'unité d'organisation Inscription `{0}` et le Programme `{1}` ne correspondent pas. | La charge utile de l'inscription contient un programme `{1}` qui n'est pas configuré pour être accessible par l'unité d'organisation `{0}`. |
| E1042 | L'Événement `{0}` doit avoir une date de fin. | Si le programme est configuré pour avoir des completeExpiryDays (dates d'expiration complètes), alors la date de fin est obligatoire pour la charge utile d'un événement TERMINÉ. La propriété "completedDate" d'un événement dont le statut est "COMPLETED" (TERMINÉ) doit être non nulle et correspondre à un format de date valide. |
| E1048 | L'objet : `{0}`, uid : `{1}`, a un format d'uid invalide. | Un uid valide comporte 11 caractères. Le premier caractère doit être une lettre de l'alphabet (a-z ou A-Z) et les 10 caractères restants peuvent être alphanumériques (a-z ou A-Z ou 0-9). |
| E1049 | Impossible de trouver l'unité d'organisation : `{0}` lié à l'entité suivie. | Le système n'a pas trouvé une Unité d'Organisation avec l'uid `{0}`. |
| E1050 | La date à laquelle l'événement est programmé (ScheduledAt) est manquante. | La propriété "ScheduledAt" dans la charge utile de l'événement est soit manquante, soit son format de date est invalide. |
| E1055 | La combinaison d'options d'attribut (AttributeOptionCombo) par défaut n'est pas autorisée car le programme n'a pas de combinaison de catégories (CategoryCombo) par défaut. | Le programme est configuré pour contenir une combinaison de catégories différente de celle par défaut, mais la requête utilise la combinaison d'options d'attribut par défaut. |
| E1056 | La date d'événement : `{0}`, est antérieure à la date de début : `{1}`, pour l'option d'attribut (AttributeOption) : `{2}`. | L'option de catégorie a une date de début configurée ; la date de l'événement dans la charge utile ne peut pas être antérieure à cette date de début. |
| E1057 | La date d'événement : `{0}`, est postérieure à la date de début : `{1}`, pour l'option d'attribut (AttributeOption) : `{2}`. | L'option de catégorie a une date de fin configurée ; la date de l'événement dans la charge utile ne peut pas être postérieure à cette date de fin.  |
| E1063 | L'instance d'entité suivie `{0}` n'existe pas. | L'erreur se produit lorsque l'on essaie de récupérer une Entité suivie qui n'existe pas avec l'uid `{0}`. Cela peut également signifier que l'utilisateur n'a pas d'accès en lecture à l'Entité suivie. |
| E1064 | Valeur d'attribut non unique `{0}` pour l'attribut `{1}` | La valeur de l'attribut doit être unique dans le champ d'application défini. L'erreur indique que la valeur de l'attribut existe déjà pour une autre Entité suivie. |
| E1068 | Impossible de trouver l'Instance d'entité suivie : `{0}`, lié à l'inscription. | Le système n'a pas pu trouver l'entité suivie spécifiée dans la charge utile d'inscription. Cela peut également signifier que l'utilisateur n'a pas d'accès en lecture à cette entité suivie. |
| E1069 | Impossible de trouver le programme : `{0}` lié à l'inscription. | Le système n'a pas pu trouver le programme spécifié dans la charge utile d'inscription. Cela peut également signifier que l'utilisateur n'a pas d'accès en lecture à cet programme . |
| E1070 | Impossible de trouver l'unité d'organisation : `{0}` lié à l'inscription. | Le système n'a pas pu trouver l'unité d'organisation spécifiée dans la charge utile d'inscription. |
| E1074 | FeatureType (Type de fonctionnalité) est manquant. | |
| E1075 | L'attribut : `{0}`, n'a pas d'uid. | |
| E1076 | `{0}` `{1}` est obligatoire et ne peut pas être nul | |
| E1077 | La valeur du texte de l'attribut : `{0}`, dépasse la longueur maximale autorisée : `{0}`. | |
| E1080 | L'Inscription `{0}` existe déjà. | Cette erreur se produit lorsque l'on essaie de créer une nouvelle inscription avec un uid déjà existant. Veillez à utiliser un nouvel uid pour une nouvelle inscription. |
| E1081 | L'Inscription `{0}` n'existe pas. | L'erreur se produit lorsque l'on essaie de récupérer une Inscription qui n'existe pas avec l'uid `{0}`. Cela peut également signifier que l'utilisateur n'a pas d'accès en lecture à cette Inscription. |
| E1082 | L'Événement : `{0}`, est déjà supprimé et ne peut pas être modifié. | Si l’événement est supprimé mais pas définitivement (soft delete), aucune modification n’est autorisée sur cet événement. |
| E1083 | L'Utilisateur : `{0}`, n'est pas autorisé à modifier les événements terminés. | Seul un super utilisateur ou un utilisateur disposant de l'autorité "F_UNCOMPLETE_EVENT" peut modifier les événements terminés. Les événements terminés sont les événements dont le statut est "TERMINÉ". |
| E1084 | La référence de la ressource de fichier : `{0}`, est introuvable. | |
| E1085 | La valeur de l'Attribut : `{0}`, ne correspond pas au type de valeur : `{1}`. | Incompatibilité entre le type de valeur d'un attribut et la valeur d'attribut fournie. |
| E1089 | L'Événement : `{0}`, fait référence à une Étape de programme `{1}` qui n'appartient pas au Programme `{2}`. | L’uid de l'Étape de programme et l’uid de Programme présent dans la charge utile de l’Événement sont incompatibles. |
| E1090 | L'attribut : `{0}` est obligatoire dans le type d'entité suivie `{1}` mais il n'est pas déclaré dans l'entité suivie `{2}`. | Des valeurs manquent dans la charge utile pour les attributs de type d'entité suivie obligatoires. |
| E1091 | L'utilisateur : `{0}` n'a pas d'accès en écriture de données sur le Programme : `{1}`. | La configuration du partage du Programme est telle que l'utilisateur n'a pas d'accès en écriture pour ce programme. |
| E1095 | L'utilisateur : `{0}` n'a pas d'accès en écriture de données sur l'Étape de programme : `{1}`. | La configuration du partage de l'Étape de programme est telle que l'utilisateur n'a pas d'accès en écriture pour cette Étape de programme.  |
| E1096 | L'utilisateur : `{0}` n'a pas d'accès en lecture de données sur le Programme : `{1}`. | La configuration du partage du Programme est telle que l'utilisateur n'a pas d'accès en lecture pour ce programme. |
| E1099 | L'utilisateur : `{0}` n'a pas d'accès en écriture sur l'Option de catégorie : `{1}`. | La configuration du partage de l'Option de catégorie est telle que l'utilisateur n'a pas d'accès en écriture pour cette Option de catégorie. |
| E1100 | L'Utilisateur : `{0}`, ne dispose pas de l'autorité 'F_TEI_CASCADE_DELETE' pour supprimer l'Instance d'entité suivie : `{1}`. | Certaines Inscriptions n'ont pas été supprimées pour cette Entité suivie. Si l'utilisateur ne dispose pas de l'autorité "F_TEI_CASCADE_DELETE", ces inscriptions devront d'abord être supprimées explicitement avant qu'il puisse supprimer l'Entité suivie. |
| E1102 | L'Utilisateur : `{0}`, n'a pas accès à la combinaison de l'Entité suivie : `{1}` et du Programme : `{2}`. | Cette erreur se produit lorsque l'unité d'organisation de l'utilisateur ne possède pas cette entité suivie, pour ce programme spécifique. L'unité d'organisation propriétaire de la combinaison Entité Suivie-Programme (TrackedEntity-Program) doit se trouver dans le champ de saisie (dans certains cas, dans le champ de recherche) de l'utilisateur. |
| E1103 | L'Utilisateur : `{0}`, ne dispose pas de l'autorité 'F_ENROLLMENT_CASCADE_DELETE' pour supprimer l'Inscription : `{1}`. | Certains Événements n'ont pas été supprimées pour cette Inscription. Si l'utilisateur ne dispose pas de l'autorité 'F_ENROLLMENT_CASCADE_DELETE', ces Événements devront d'abord être supprimées explicitement avant qu'il puisse supprimer l'Inscription. |
| E1104 | L'utilisateur : `{0}` n'a pas d'accès en lecture de données sur le programme : `{1}` et le type d'entité suivie : `{2}`. | La configuration du partage du Type d'entité suivie associé au Programme est telle que l'utilisateur n'a pas d'accès en lecture de données pour ce type d'entité suivie. |
| E1112 | La Valeur d'attribut : `{0}`, est définie sur 'confidentiel' mais le système n'est pas correctement configuré pour crypter les données. | Soit les fichiers JCE sont manquants, soit la propriété de configuration `encryption.password` peut être manquante dans `dhis.conf`. |
| E1113 | L'Inscription : `{0}`, est déjà supprimée et ne peut plus être modifiée. | Si l'inscription est supprimée mais pas définitivement (soft delete), aucune modification n’est autorisée sur cette inscription. |
| E1114 | L'Entité suivie : `{0}`, est déjà supprimée et ne peut donc plus être modifiée. | Si l'entité suivie est supprimée mais pas définitivement (soft delete), aucune modification n’est autorisée sur cette entité suivie. |
| E1115 | Impossible de trouver la combinaison d'options de catégorie : `{0}`. | |
| E1116 | Impossible de trouver la l'Option de catégorie : `{0}`. | Cela peut également signifier que l'utilisateur n'a pas accès à cette option de catégorie.|
| E1117 | La Combinaison d'options de catégorie n'existe pas pour la combinaison de catégories et les options de catégorie fournies : `{0}`. | |
| E1118 | L'utilisateur attribué `{0}` n'est pas un uid valide. | |
| E1119 | Une note de Tracker avec l'uid `{0}` existe déjà. | |
| E1120 | L'Étape de programme `{0}` n'autorise pas l'attribution d'utilisateurs | La charge utile d'événement a attribué un identifiant d'utilisateur (uid) mais l'étape de programme n’est pas configurée pour autoriser l'attribution d’utilisateurs. |
| E1121 | Propriété d'entité suivie obligatoire manquante : `{0}`. | |
| E1122 | La propriété d'inscription requise est manquante : `{0}`. | |
| E1123 | La propriété d'événement requise est manquante : `{0}`. | |
| E1124 | La propriété de relation requise est manquante : `{0}`. | |
| E1125 | La valeur `{0}` n'est pas une option valide pour `{1}` `{2}` dans l'ensemble d'options `{3}` | |
| E1017 | L'attribut : `{0}` n'existe pas. | |
| E1093 | L'utilisateur : `{0}` n'a pas d'accès en écriture sur l'unité d'organisation : `{1}`. | |
| E1094 | Il n'est pas permis de mettre à jour l'Inscription : `{0}`, Programme existant `{1}`. | La charge utile d’inscription pour inscription existante a un uid de programme différent de celui avec lequel l'inscription a été initialement faite. |
| E1110 | Il n'est pas permis de mettre à jour l'Événement : `{0}`, Programme existant `{1}`. | La charge utile d'Événement pour un Événement existant a un uid de programme différent de celui avec lequel il a été initialement créé.  |
| E1111 | Nous avons un attribut généré : `{0}`, mais aucun modèle. | |
| E1043 | La date de fin de l'événement : `{0}`, a expiré ; il n'est donc  plus possible d'apporter des modifications à cet événement. | A user without 'F_EDIT_EXPIRED' autthority cannot update an Event that has passed its expiry days as configured in its Program. |
| E1046 | L'Événement : `{0}`, doit avoir au moins une date (d'événement ou de programmation). | La propriété occuredAt (survenu à) ou selectedAt (sélectionné à) doit être présente dans la charge utile de l’événement. |
| E1047 | La date de l'événement : `{0}`, appartient à une période expirée. Un tel événement ne peut être créé. | Les propriétés occuredAt et scheduledAt de l'événement ont une valeur antérieure à la date de début du type de période (PeriodType).  |
| E1300 | Généré par la règle du programme (`{0}`) - `{1}` | |
| E1302 | Généré par la règle de programme (`{0}`) - L'élément de données `{1}` n'est pas valide : `{2}` | |
| E1303 | Généré par la règle de programme (`{0}`) - L'élément de données obligatoire `{1}` n'est pas présent | |
| E1304 | Généré par la règle de programme (`{0}`) - L'élément de données `{1}` n'est pas valide | |
| E1305 | Généré par la règle de programme (`{0}`) - L'élément de données `{1}` ne fait pas partie de l'étape de programme `{2}` | |
| E1306 | Généré par la règle de programme (`{0}`) - L'attribut obligatoire `{1}` n'est pas présent | |
| E1307 | Généré par la règle de programme (`{0}`) - Impossible d'attribuer une valeur à l'élément de données `{1}`. La valeur fournie doit être vide ou correspondre à la valeur calculée `{2}` | |
| E1308 | Généré par la règle de programme (`{0}`) - L'élément de données `{1}` est remplacé dans l'événement `{2}` | |
| E1309 | Généré par la règle de programme (`{0}`) - Impossible d'attribuer une valeur à l'attribut `{1}`. La valeur fournie doit être vide ou correspondre à la valeur calculée `{2}` | |
| E1310 | Généré par la règle de programme (`{0}`) - L'attribut `{1}` est remplacé dans l'instance d'entité suivie `{2}` | |
| E4000 | La relation : `{0}` ne peut pas être reliée à elle-même | |
| E4001 | L'élément de relation `{0}` n'est pas valide pour la relation `{1}`  : un élément ne peut être relié qu'à une seule entité Tracker. | |
| E4006 | Impossible de trouver le Type de relation : `{0}`. | |
| E4009 | Le Type de relation `{0}` n'est pas valide. | |
| E4010 | La contrainte du type de relation `{0}` nécessite un {1} mais un {2} a été trouvé . | |
| E4011 | La relation : `{0}` ne peut pas être maintenue car {1} {2} référencé par cette relation n'est pas valide. | |
| E4012 | Impossible de trouver `{0}` : `{1}`, liés à la relation. | |
| E4013 | La contrainte du type de relation `{0}` est manquante {1}. | |
| E4014 | La contrainte du type de relation `{0}` nécessite une entité suivie de type `{1}` mais c'est un type `{2} ` qui a été trouvé. | |
| E9999 | N/A | Message d'erreur non défini. |

### Validation { #webapi_nti_validation }

Lors de l'importation de données à l'aide de l'importateur du Tracker, une série de validations est effectuée pour garantir la validité des données. Cette section décrit certains des différents types de validation effectués afin d'avoir une meilleure compréhension si la validation échoue pour votre importation.

#### Propriétés requises { #required-properties }

Chaque objet Tracker possède quelques propriétés qui doivent être présentes lors de l'importation des données. Pour obtenir une liste exhaustive des propriétés requises, consultez la [section sur les objets Tracker] (#webapi_nti_tracker_objects).

Lors de la validation des propriétés requises, nous parlons généralement de références à d'autres données ou métadonnées. Dans ces cas, on note trois critères principaux :

1. La référence est présente et non nulle dans la charge utile.
2. La référence pointe vers le bon type de données et existe dans la base de données
3. L'utilisateur est autorisé à voir la référence

Si la première condition n'est pas remplie, l'importation échouera et un message indiquant une référence manquante sera généré. Cependant, si la référence indique un objet qui n'existe pas ou auquel l'utilisateur n'a pas accès, le message généré indiquera que la référence n'a pas été trouvée.

#### Formats { #formats }

Certaines propriétés des objets Tracker requièrent un format spécifique. Lors de l'importation des données, chacune de ces propriétés est validée au regard du format attendu et renvoie des erreurs en fonction de la propriété dont le format est incorrect. Voici quelques exemples de propriétés validées de cette manière :

- UID (Ceux-ci couvrent toutes les références à d’autres données ou métadonnées dans DHIS2.)
- Dates
- Géométrie (Les coordonnées doivent correspondre au format spécifié par son type)

#### Accès des utilisateurs { #user-access }
Toutes les données importées seront validées en fonction des métadonnées ([Partage](#webapi_nti_metadata_sharing)) et des unités d'organisation ([Champs d'application des unités d'organisation](#webapi_nti_ou_scope)) référencées dans les données. Vous pourrez trouver plus d’informations sur les champs d'application du partage et des unités d’organisation dans les sections suivantes.

Le partage est validé en même temps que la recherche des références dans la base de données. Les métadonnées auxquelles l'utilisateur n'a pas accès seront traitées comme si elles n'existaient pas. L'importation validera toutes les métadonnées référencées dans les données.

Les unités d'organisation, quant à elles, servent un double objectif. D'une part, elles permettent de s'assurer que les données ne soient importées que pour une unité d'organisation figurant dans le "champ de saisie" de l'utilisateur. D'autre part, elles sont également utilisées pour restreindre les programmes disponibles. Cela signifie que si vous essayez d'importer des données pour une unité d'organisation qui n'a pas accès au programme que vous importez, l'importation ne sera pas valide.

Les utilisateurs disposant de l'autorité `TOUS` ne sont pas affectés par les limites des champs d'application de partage et d'unité d'organisation lorsqu'ils importent des données. Cependant, ils ne peuvent pas importer d'inscriptions dans des unités d'organisation qui n'ont pas accès au programme d'inscription.

#### Valeurs d'attribut et de données { #attribute-and-data-values }

Les attributs et les valeurs de données font partie respectivement d'une entité suivie et d'un événement. Cependant, les attributs peuvent être liés à une entité suivie soit par son type (TrackedEntityType), soit par son programme (Program). Les attributs peuvent également être uniques.

La première validation effectuée lors de l'importation consiste à s'assurer que la valeur fournie pour un attribut ou un élément de données est conforme au type de valeur attendu. Par exemple, supposons que vous importiez une valeur pour un élément de données de type numérique. Dans ce cas, la valeur doit être numérique. Toute erreur liée à une non-concordance entre un type et une valeur se traduira par le même code d'erreur, mais avec un message spécifique lié au type de violation.

Les attributs et les valeurs de données obligatoires sont également vérifiés. Actuellement, la suppression des attributs obligatoires n'est pas autorisée. Dans certains cas d'utilisation, les valeurs doivent être envoyées séparément, tandis que dans d'autres, toutes les valeurs doivent être envoyées en une seule fois. Les programmes peuvent être configurés pour valider les attributs obligatoires `ON_COMPLETE` (complet ou `ON_UPDATE_AND_INSERT` pour s'adapter à ces cas d'utilisation.

Les attributs uniques sont validés au moment de l'importation. Cela signifie que tant que la valeur fournie est unique pour l'attribut et ce dans tout le système, l'importation sera acceptée. Cependant, si la valeur unique est utilisée par une autre entité suivie que celle qui est importée, l'importation échouera.

#### Configuration { #configuration }

Les dernières validations dans l'importateur sont des validations basées sur la configuration des métadonnées pertinentes par l'utilisateur. Pour plus d'informations sur chaque configuration, consultez les sections correspondantes. Trouvez ci-après quelques exemples de validations configurables :
- Type de fonctionnalité (pour la géométrie)
- Événements attribuables à l'utilisateur
- Autoriser les dates futures
- Inscrire une fois
- Et plus.

Ces configurations apporteront des modifications supplémentaires à la manière dont la validation est effectuée lors de l'importation.

### Règles de programme { #webapi_nti_program_rules }

Les utilisateurs peuvent configurer des [Règles de programme](#webapi_program_rules), qui vont ajouter un fonctionnement conditionnel aux formulaires du Tracker. En plus d'exécuter ces règles dans les applications du Tracker, l'importateur du Tracker va également procéder à une sélection de ces règles. Puisque l'importateur exécute également ces règles, nous pouvons garantir un niveau de validation supplémentaire.

Toutes les actions de règles de programme ne sont pas prises en charge, car elles ne sont adaptées qu'à une présentation de type « frontend ». Une liste complète des actions de règles de programme prises en charge est présentée ci-dessous.

  |Action de règle de programme|Pris en charge|
  |---|:---:|
  |**DISPLAYTEXT** (afficher le texte)| |
  |**DISPLAYKEYVALUEPAIR** (afficher la paire clé-valeur)| |
  |**HIDEFIELD** (cacher le champ)||
  |**HIDESECTION** (cacher la section)||
  |**ASSIGN** (attribuer )|**X**|
  |**SHOWWARNING** (afficher un avertissement)|**X**|
  |**SHOWERROR** (afficher l'erreur)|**X**|
  |**WARNINGONCOMPLETION** (avertissement à la fin)|**X**|
  |**ERRORONCOMPLETION** (erreur à la fin)|**X**|
  |**CREATEEVENT** (créer un événement)||
  |**SETMANDATORYFIELD** (définir un champ obligatoire)|**X**|
  |**SENDMESSAGE** (envoyer un message)|**X**|
  |**SCHEDULEMESSAGE** (planifier un message)|**X**|

Les règles de programme sont évaluées dans l'importateur de la même manière que dans les applications du Tracker. En résumé, les conditions suivantes sont prises en compte lors de l'application des règles de programme :

* La règle de programme doit être liée aux données importées ; par exemple, une étape de programme ou un élément de données.
* La condition de la règle de programme doit être évaluée comme étant vraie

Les résultats des règles de programme dépendent des actions définies dans ces règles :

* Les actions des règles de programme peuvent aboutir à 2 résultats différents : avertissements ou erreurs.
  * Les erreurs feront échouer la validation, tandis que les avertissements seront rapportés sous forme de message dans le récapitulatif de l'importation.
    * Les actions SHOWWARNING (afficher l'avertissement) et WARNINGONCOMPLETION (avertissement à la fin) ne peuvent générer que des avertissements.
    * Les actions SHOWERROR (afficher l'erreur), ERRORONCOMPLETION (erreur à la fin), et SETMANDATORYFIELD (définir un champ obligatoire) ne peuvent générer que des erreurs.
    * L'action ASSIGN (attribuer) peut générer à la fois des avertissements et des erreurs.
      * Lorsque l'action attribue une valeur à un attribut/élément de données vide, un avertissement est généré.
      * Lorsque l'action attribue une valeur à un attribut/élément de données qui a déjà la même valeur à attribuer, un avertissement est généré.
      * Lorsque l'action attribue une valeur à un attribut/élément de données qui a déjà une valeur et que la valeur à attribuer est différente, une erreur est générée à moins que le paramètre système `RULE_ENGINE_ASSIGN_OVERWRITE` soit défini sur "vrai".

Les règles de programme peuvent également entraîner des actions non voulues, telles que l'envoi et la planification de messages. Pour plus d’informations sur les actions non voulues, veuillez consulter la section suivante.

> **REMARQUE**
>
> Les règles de programme peuvent être ignorées lors de l'importation à l'aide du paramètre `skipProgramRules` (ignorer les règles de programme).

### Actions non voulues { #webapi_nti_side_effects }

Une fois qu'une importation est terminée, des tâches spécifiques peuvent être déclenchées du fait de cette importation. Ces tâches sont ce que nous appelons des « effets secondaires ». Ces tâches exécutent des opérations qui n'affectent pas l'importation elle-même.

Les effets secondaires sont des tâches qui s'exécutent séparément de l'importation, mais qui sont toujours déclenchées par une importation. Étant donné que les effets secondaires sont dissociés de l'importation, ils peuvent échouer même si l'importation réussit. De plus, les effets secondaires ne sont exécutés que lorsque l'importation réussit ; ils ne peuvent donc pas échouer dans l'autre sens.

Voici donc les effets secondaires actuellement pris en charge :

  |Effets secondaires|Pris en charge|Description|
  |---|:---:|---|
  |**Notification de Tracker**|**X**| Les mises à jour peuvent déclencher des notifications. Celles qui déclenchent des notifications sont **inscription**, **mise à jour d'événement**, **achèvement d'événement ou d'inscription**. |
  |**Notification de règle de programme**|**X**| Les règles de programme peuvent déclencher des notifications. Notez que ces notifications font partie des effets des règles de programme qui sont générés via le moteur de règles de DHIS2.|

  > **REMARQUE**
  >
  > Certaines configurations peuvent contrôler l'exécution des effets secondaires. La fonction `skipSideEffects` (ignorer les effets secondaires) peut être activée lors de l'importation pour ignorer complètement les effets secondaires. Par exemple, vous pouvez utiliser ce paramètre lors de l'importation d'un objet pour lequel vous ne voulez pas déclencher de notifications.

### Attribuer un utilisateur à des événements { #webapi_nti_user_event_assignment }

Certains processus bénéficient du fait que des événements soient traités comme des tâches, et pour cette raison, vous pouvez attribuer un utilisateur à un événement.

L'attribution d'un utilisateur à un événement ne modifie pas l'accès ou les autorisations des utilisateurs, mais crée un lien entre l'événement et l'utilisateur.
Lorsqu'un utilisateur est attribué à un événement, vous pouvez lancer des requêtes sur les événements à partir de l'API en utilisant le champ `assignedUser` (utilisateur attribué) en tant que paramètre.

Lorsque vous voulez attribuer un utilisateur à un événement, fournissez simplement l'UID de cet utilisateur dans le champ `assignedUser`. Voir l'exemple suivant :

```json
{
  ...
  "events": [
    {
      "event": "ZwwuwNp6gVd",
      "programStage": "nlXNK4b7LVr",
      "orgUnit": "O6uvpzGd5pu",
      "enrollment": "MNWZ6hnuhSw",
      "assignedUser" : "M0fCOxtkURr"
    }
  ],
  ...
}
```

Dans cet exemple, l'utilisateur avec l'uid `M0fCOxtkURr` sera attribué à l'événement avec l'uid `ZwwuwNp6gVd`. Un seul utilisateur peut être attribué à un événement unique.

Pour utiliser cette fonctionnalité, l'attribution d'utilisateurs doit être activée pour l'étape de programme concernée et l'uid fourni pour l'utilisateur doit renvoyer à un utilisateur existant et valide.

## Exportation Tracker  { #webapi_nti_export }

Tracker export endpoints are a set of services that allow clients to query and retrieve objects stored using the import endpoint.

Besides differences highlighted in **[Changes in the API](#Changes-in-the-API)**, request parameters for these endpoints match older ones.

These endpoints are still being developed and are subject to change. However, 
the `request` and `response` interfaces will most likely not undergo significant changes.

Tracker export endpoints deal with the following Tracker objects:

- **Tracked Entities**
- **Événements**
- **Inscriptions**
- **Relations**

> **NOTE**
>
> - These endpoints currently only support `JSON`, but `CSV` will be supported in the near future.
>
> - These endpoints adopt the new naming convention documented in **[Changes in the API](#Changes-in-the-API)**
>
> - The following functionalities are still missing but available in older endpoints:
>
>     - field filtering

### Paramètres de requête courants { #common-request-parameters }

Le point d'extrémité suivant prend en charge les paramètres normalisés pour la pagination.

- **Entités suivies** `GET /api/tracker/trackedEntities`
- **Évènements** `GET /api/tracker/events`
- **Inscriptions** `GET /api/tracker/enrollments`
- **Relations** `GET /api/tracker/relationships`

#### Paramètres de requête pour la pagination { #request-parameters-for-pagination }

|Paramètre de requête|Type|Valeurs autorisées|Description|
|---|---|---|---|
|`page`|`Entier`| Tout entier positif |Numéro de page à renvoyer. La valeur par défaut est 1 si rien n'est fourni.|
|`taille de la page`|`Entier`| Tout entier positif |Taille de la page. La valeur par défaut est 50. |
|`totalPages` (pages totales)|`Booléen`| `vrai`, `faux` |Indique s'il faut renvoyer le nombre total de pages dans la réponse |
|`skipPaging` (ignorer la pagination)|`Booléen`| `vrai`, `faux` |Indique si la pagination doit être ignorée et si toutes les lignes doivent être renvoyées. La valeur par défaut est `faux`, ce qui signifie que par défaut toutes les requêtes sont paginées, sauf si `skipPaging=true` (c'est-à-dire si le paramètre "ignorer la pagination" est définie sur "vrai")|
|`ordre`|`Chaîne`|comma-delimited list of `OrderCriteria` in the form of `propName:sortDirection`.<br><br> Example: `createdAt:desc`<br><br>**Note:** `propName` is case sensitive, `sortDirection` is case insensitive|Sort the response based on given `OrderCriteria`|

> **Attention**
>
> Sachez que les performances sont directement liées à la quantité de données qui fait l'objet de la requête. Le renvoi des pages plus volumineuses prendra plus de temps.

#### Paramètres de requête pour le mode de sélection de l'unité d'organisation{ #request-parameters-for-organisational-unit-selection-mode }

Les modes de sélection d'unités d'organisation disponibles sont expliqués dans le tableau suivant.

|Mode|Description|
|---|---|
|`SÉLECTIONNÉ`|  Unités d'organisation définies dans la requête.|
|`SUBORDONNÉES`|  Les unités d'organisation sélectionnées et leurs subordonnées directs, c'est-à-dire les unités d'organisation au niveau inférieur.|
|`DESCENDANTS`| Les unités d'organisation sélectionnées et tous leurs subordonnées, c'est-à-dire toutes les unités d'organisation de niveau inférieur dans la hiérarchie.|
|`ACCESSIBLE`|  Il s'agit des unités d'organisation de visualisation de données associées à l'utilisateur actuel et toutes leurs subordonnées, c'est-à-dire toutes les unités d'organisation qui leur sont inférieures dans la hiérarchie. Les unités d'organisation de saisie de données associées à l'utilisateur actuel seront utilisées si celles dédiées à la visualisation ne sont pas définies.|
|`SAISIE`| Il s'agit des unités d'organisation de saisie de données associées à l'utilisateur actuel et toutes leurs subordonnées, c'est-à-dire toutes les unités d'organisation qui leur sont inférieures dans la hiérarchie.|
|`TOUS`| Il s'agit de toutes les unités d'organisation du système. L'utilisateur doit disposer de l'autorité `TOUS` pour pouvoir l'utiliser.|

#### Paramètre de requête pour filtrer les réponses { #request-parameter-to-filter-responses } 

All new export endpoints support a `fields` parameter which allows to filter the response based on a simple grammar.

`fields` parameter accepts a comma separated list of field names or patterns and responses are filtered based on it

##### Exemples { #examples }

|Exemple de paramètre|Signification|
|:---|:---|
|`fields=createdAt,uid` (champs=créés à, uid)| only returns `createdAt` and `uid` fields for the requested object|
|`fields=enrollments.uid`| only returns `uid` field for nested `enrollments`|
|`fields=enrollments[uid]`| same as above with a different syntax|
|`fields=enrollments[uid,enrolledAt]`| only returns `uid` and `enrolledAt` fields for nested `enrollments`|
|`fields=**`| don't filter (same behaviour as not passing the `field` parameter at all)|

### Les entités suivies { #tracked-entities } 

Deux points d'extrémité sont dédiés aux entités suivies :

- `GET /api/tracker/trackedEntities`
  - récupère les entités suivies correspondant aux critères donnés
- `GET /api/tracker/trackedEntities/{id}`
  - récupère une entité suivie en fonction de l'identifiant fourni

#### Point d'extrémité de la collection d'entités suivies `GET /api/tracker/trackedEntities` { #tracked-entities-collection-endpoint-get-apitrackertrackedentities }

Le but de ce point d'extrémité est de récupérer les entités suivies correspondant aux critères fournis par le client.

Le point d'extrémité renvoie une liste d'entités suivies qui correspondent aux paramètres de la requête.

##### Syntaxe de la requête { #request-syntax }

|Paramètre de requête|Type|Valeurs autorisées|Description|
|---|---|---|---|
|`requête`|`Chaîne`|`{operator}:{filter-value}`|Crée un filtre sur les attributs d'entité suivie. Seule la valeur du filtre est obligatoire. L'opérateur `EQ` est utilisé si l'`opérateur` n'est pas spécifié.|
|`attribut`|`Chaîne`|Comma separated values of attribute `UID` | Pour chaque entité suivie dans la réponse, renvoie uniquement les attributs spécifiés |
|`filtre`|`Chaîne`|Comma separated values of filters|Filter is properties or attributes with operator and value.<br>Example: `filter=updatedAfter:lt:2000-01-01`<br>Multiple filters are allowed. User needs access to attribute to being able to have a filter on it|
|`orgUnit` (unité d'organisation)|`Chaîne`|semicolon-delimited list of organisational unit `UID`|Renvoie uniquement les instances d'entités suivies appartenant aux unités d'organisation fournies|
|Pour plus d'informations sur le `ouMode` (mode d'unité d'organisation) voir [ouModes](#Request-parameters-for-Organisational-Unit-selection-mode)|`Chaîne`|`SELECTED`&#124;`CHILDREN`&#124;`DESCENDANTS`&#124;`ACCESSIBLE`&#124;`CAPTURE`&#124;`ALL`|Le mode de sélection des unités d'organisation peut l'être. La valeur par défaut est `SÉLECTIONNÉ`, qui fait uniquement référence aux unités d'organisation sélectionnées.|
|`programme`|`Chaîne`|`UID` de programme| un `UID` de programme dans lequel les instances présentes dans la réponse doivent être inscrites|
|`statut du programme`|`Chaîne`|`ACTIVE`&#124;`COMPLETED`&#124;`CANCELLED`|Le statut du programme de l’instance d’entité suivie dans le programme donné|
|`programStage` (étape de programme)|`Chaîne`|`UID`|un `UID` d'étape de programme pour lequel les instances présentes dans la réponse doivent avoir des événements|
|`followUp` (suivi)|`Booléen`|`vrai`, `faux`|Indique si l'instance d'entité suivie est marquée pour le suivi du programme spécifié.|
|`updatedAfter` (mis à jour après)|`DateTime` (date et heure)| [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) | Date de début de la dernière mise à jour|
|`updatedBefore` (mis à jour avant)|`DateTime` (date et heure)| [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) | Date de fin de la dernière mise à jour|
|`updatedWithin`|`Durée`|[ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Durations) | Renvoie les TEI qui ne dépassent pas la durée spécifiée|
|`enrollmentEnrolledAfter` (Inscription après)|`DateTime` (date et heure)|[ISO-8601](https://en.wikipedia.org/wiki/ISO_8601)|Date de début de l'incident dans le programme donné|
|`enrollmentEnrolledBefore` (Inscription avant)|`DateTime` (date et heure)|[ISO-8601](https://en.wikipedia.org/wiki/ISO_8601)|Date de fin de l'incident dans le programme donné|
|`enrollmentOccurredAfter` (Inscription survenue après)|`DateTime` (date et heure)|[ISO-8601](https://en.wikipedia.org/wiki/ISO_8601)|Date de début de l'incident dans le programme donné|
|`enrollmentOccurredBefore` (inscription survenue avant)|`DateTime` (date et heure)|[ISO-8601](https://en.wikipedia.org/wiki/ISO_8601)|Date de fin de l'incident dans le programme donné|
|`TrackedEntityType` (Type d'entité suivie)|`Chaîne`|UID du type d'entité suivi|Renvoie uniquement les instances d'entité suivies d'un type donné|
|`trackedEntity` (entité suivie)|`Chaîne`|semicolon-delimited list of tracked entity instance `UID`|Filtrez le résultat de manière à obtenir un ensemble limité d'entités suivies qui utilisent les uids explicites des instances d'entités suivies. Faites-le en utilisant le paramètre `trackedEntity=id1;id2`. Ce paramètre créera, au minimum, la limite externe des résultats, en constituant la liste de toutes les entités suivies à l'aide des uids fournis. Si d'autres paramètres/filtres de ce tableau sont utilisés, ils limiteront davantage les résultats à partir de la limite externe explicite.|
|`assignedUserMode` (mode utilisateur attribué)|`Chaîne`|`CURRENT`&#124;`PROVIDED`&#124;`NONE`&#124;`ANY`|Restricts result to tracked entities with events assigned based on the assigned user selection mode|
|`assignedUser` (utilisateur attribué)|`Chaîne`|Semicolon-delimited list of user UIDs to filter based on events assigned to the users.|Il est possible de filtrer le résultat pour obtenir un ensemble limité d'entités suivies avec des événements attribués aux UID donnés, à l'aide du paramètre `assignedUser=id1;id2`. Ce paramètre ne sera pris en compte que si le "mode utilisateur assigné" est `FOURNI` ou `nul`. L'API va générer une erreur si, par exemple, `assignedUserMode=CURRENT` et `assignedUser=someId`|
|`eventStatus` (statut d'événement)|`Chaîne`|`ACTIVE`&#124;`COMPLETED`&#124;`VISITED`&#124;`SCHEDULE`&#124;`OVERDUE`&#124;`SKIPPED`|Il s'agit du statut de tous les événements présents dans le programme spécifié|
|`eventOccurredAfter` (événement survenu après)|`DateTime` (date et heure)|[ISO-8601](https://en.wikipedia.org/wiki/ISO_8601)|Date de début de l'événement pour le programme donné|
|`eventOccurredBefore` (événement survenu avant)|`DateTime` (date et heure)|[ISO-8601](https://en.wikipedia.org/wiki/ISO_8601)|Date de fin de l'événement pour le programme donné|
|`skipMeta`|`Booléen`|`vrai`, `faux`|Indique s’il convient de ne pas inclure les métadonnées dans la réponse.|
|`includeDeleted` (inclure les éléments supprimés)|`Booléen`|`vrai`, `faux`|Indique s’il faut inclure les éléments supprimés mais pas définitivement (soft delete)|
|`includeAllAttributes` (inclure tous les attributs)|`Booléen`|`vrai`, `faux`|Indique s'il faut inclure tous les attributs TEI|
|`attachment`|`Chaîne`| |Il s'agit du nom du fichier en cas d'exportation sous forme de fichier|
|`potentialDuplicate` (doublon potentiel)|`Booléen`|`vrai`, `faux`| Filter the result based on the fact that a tei is a Potential Duplicate. true: return teis flagged as Potential Duplicates. false: return teis NOT flagged as Potential Duplicates. If omitted, we don't check whether a tei is a Potential Duplicate or not. |

La requête n'est pas sensible à la casse. Les règles suivantes s'appliquent aux paramètres de la requête.

- Au moins une unité d'organisation doit être spécifiée avec le paramètre `orgUnit`
  (un ou plusieurs), ou `ouMode=ALL` doit être spécifié.

- Un seul des paramètres `program` et `trackedEntity` peut être
  spécifié (zéro ou un).

- Si `programStatus` est spécifié, alors `program` doit également être
  spécifiés.

- Si `followUp` est spécifié, alors `program` doit également être spécifié.

- Si `enrollmentEnrolledAfter` ou `enrollmentEnrolledBefore` est spécifié, alors
  `program` doit également être spécifié.

- Les éléments du filtre ne peuvent être spécifiés qu'une seule fois.

##### Exemples de requêtes { #example-requests }

Une requête pour toutes les instances associées à une unité d'organisation spécifique peut ressembler à ceci :

    GET /api/tracker/trackedEntities?orgUnit=DiszpKrYNg8

Pour lancer une requête pour des instances à l'aide d'un attribut avec filtre et d'un attribut sans filtre, avec une unité d'organisation en utilisant le mode de requête de l'unité d'organisation subordonnée, utilisez ceci :

    GET /api/tracker/trackedEntities?filter=zHXD5Ve1Efw:EQ:A
        &attribure=AMpUYgxuCaE&orgUnit=DiszpKrYNg8;yMCshbaVExv

Une requête pour les instances où les attributs sont inclus dans la réponse et où un attribut est utilisé comme filtre :

    GET /api/tracker/trackedEntities?filter=zHXD5Ve1Efw:EQ:A
        &filter=AMpUYgxuCaE:LIKE:Road
        &orgUnit=DiszpKrYNg8

Une requête dans laquelle plusieurs opérandes et filtres sont spécifiés pour un élément de filtre :

    GET /api/tracker/trackedEntities?orgUnit=DiszpKrYNg8
        &program=ur1Edk5Oe2n
        &filter=lw1SqmMlnfh:GT:150
        &filter=lw1SqmMlnfh:LT:190

Pour lancer une requête sur un attribut en utilisant plusieurs valeurs dans un filtre *IN* :

    GET /api/tracker/trackedEntities?orgUnit=DiszpKrYNg8
        &filter=dv3nChNSIxy:IN:Scott;Jimmy;Santiago

Pour limiter la réponse aux instances qui font partie d'un programme spécifique, vous pouvez inclure un paramètre de requête de programme :

    GET GET /api/tracker/trackedEntities?filter=zHXD5Ve1Efw:EQ:A
        &orgUnit=O6uvpzGd5pu&ouMode=DESCENDANTS
        &program=ur1Edk5Oe2n

Pour spécifier les dates d'inscription au programme dans la requête :

    GET /API/tracker/trackedEntities?
        &orgUnit=O6uvpzGd5pu&program=ur1Edk5Oe2n
        &enrollmentEnrolledAfter=2013-01-01
        &enrollmentEnrolledBefore=2013-09-01

Pour limiter la réponse aux instances d'une entité suivie spécifique, vous pouvez inclure un paramètre de requête d'entité suivie :

    GET /api/tracker/trackedEntities?filter=zHXD5Ve1Efw:EQ:A
        &orgUnit=O6uvpzGd5pu
        &ouMode=DESCENDANTS
        &trackedEntity=cyl5vuJ5ETQ

Par défaut, les instances sont renvoyées dans des pages de taille 50. Pour modifier cela, vous pouvez utiliser les paramètres de requête de page et de taille de page (pageSize) :

    GET /api/tracker/trackedEntities?filter=zHXD5Ve1Efw:EQ:A
        &orgUnit=O6uvpzGd5pu
        &ouMode=DESCENDANTS
        &page=2&pageSize=3

Vous pouvez utiliser une gamme d'opérateurs pour le filtrage :

|Opérateur|  Description|
|---|---|
|`EQ`|  Egale à|
|`GT`|  Supérieure à|
|`GE`|  Supérieure ou égal à|
|`LT`|  Inférieur à|
|`LE`|  inférieur ou égal à|
|`NE`|  Pas égal à|
|`LIKE`|  Pareil (correspondance textuelle)|
|`IN`|  Égal à l'une des multiples valeurs séparées par ";"|

##### Format de réponse { #response-format }

La réponse `JSON` peut ressembler à ceci :

Responses can be filtered on desired fields, see [Request parameter to filter responses](#Request-parameter-to-filter-responses)

```json
{
  "instances": [
    {
      "trackedEntity": "IzHblRD2sDH",
      "trackedEntityType": "nEenWmSyUEp",
      "createdAt": "2014-03-26T15:40:36.669",
      "createdAtClient": "2014-03-26T15:40:36.669",
      "updatedAt": "2014-03-28T12:28:17.544",
      "orgUnit": "g8upMTyEZGZ",
      "inactive": false,
      "deleted": false,
      "relationships": [],
      "attributes": [
        {
          "attribute": "VqEFza8wbwA",
          "code": "MMD_PER_ADR1",
          "displayName": "Address",
          "createdAt": "2016-01-12T00:00:00.000",
          "updatedAt": "2016-01-12T00:00:00.000",
          "valueType": "TEXT",
          "value": "1061 Marconi St"
        },
        {
          "attribute": "RG7uGl4w5Jq",
          "code": "Longitude",
          "displayName": "Longitude",
          "createdAt": "2016-01-12T00:00:00.000",
          "updatedAt": "2016-01-12T00:00:00.000",
          "valueType": "TEXT",
          "value": "27.866613"
        },
        ...,
        ...,
      ],
      "enrollments": [],
      "programOwners": []
    }
  ],
  "page": 1,
  "total": 39,
  "pageSize": 1
}
```

#### Point d'extrémité d'objet unique des entités suivies `GET /api/tracker/trackedEntities/{uid}`

Le but de ce point d'extrémité est de récupérer une entité suivie en se basant sur son UID.

##### Syntaxe de la requête { #request-syntax }

`GET /api/tracker/trackedEntities/{uid}?program={programUid}&fields={fields}`

|Paramètre de requête|Type|Valeurs autorisées|Description|
|---|---|---|---|
|`uid`|`Chaîne`|`uid`|Renvoie l'instance d'entité suivie disposant de l'`uid` spécifié|
|`programme`|`Chaîne`|`uid`| Inclut les attributs du programme dans la réponse (seuls ceux auxquels l'utilisateur a accès) |
|`champs`|`Chaîne`| **Currently:** <br>`*`&#124;`relationships`&#124;`enrollments`&#124;`events`&#124;`programOwners`<br><br>**Planned:**<br> a `String` specifying which fields to include in the response|Inclut les sous-objets spécifiés dans la réponse| 

##### Exemples de requêtes { #example-requests }

Une requête pour une instance d'entité suivie :

    GET /api/tracker/trackedEntities/IzHblRD2sDH?program=ur1Edk5Oe2n&fields=*

##### Format de réponse { #response-format }

This endpoint supports returning sub-objects when the `fields` request parameter is passed.

```json
{
    "trackedEntity": "IzHblRD2sDH",
    "trackedEntityType": "nEenWmSyUEp",
    "createdAt": "2014-03-26T15:40:36.669",
    "updatedAt": "2014-03-28T12:28:17.544",
    "orgUnit": "g8upMTyEZGZ",
    "inactive": false,
    "deleted": false,
    "relationships": [],
    "attributes": [
        {
            "attribute": "w75KJ2mc4zz",
            "code": "MMD_PER_NAM",
            "displayName": "First name",
            "createdAt": "2016-01-12T09:10:26.986",
            "updatedAt": "2016-01-12T09:10:35.884",
            "valueType": "TEXT",
            "value": "Wegahta"
        },
        {
            "attribute": "zDhUuAYrxNC",
            "displayName": "Last name",
            "createdAt": "2016-01-12T09:10:26.986",
            "updatedAt": "2016-01-12T09:10:35.884",
            "valueType": "TEXT",
            "value": "Goytiom"
        }
    ],
    "enrollments": [
        {
            "enrollment": "uT5ZysTES7j",
            "createdAt": "2017-03-28T12:28:17.539",
            "createdAtClient": "2016-03-28T12:28:17.539",
            "updatedAt": "2017-03-28T12:28:17.544",
            "trackedEntity": "IzHblRD2sDH",
            "trackedEntityType": "nEenWmSyUEp",
            "program": "ur1Edk5Oe2n",
            "status": "ACTIVE",
            "orgUnit": "g8upMTyEZGZ",
            "orgUnitName": "Njandama MCHP",
            "enrolledAt": "2020-11-10T12:28:17.532",
            "occurredAt": "2020-10-12T12:28:17.532",
            "followUp": false,
            "deleted": false,
            "events": [
                {
                    "event": "ixDYEGrNQeH",
                    "status": "ACTIVE",
                    "program": "ur1Edk5Oe2n",
                    "programStage": "ZkbAXlQUYJG",
                    "enrollment": "uT5ZysTES7j",
                    "enrollmentStatus": "ACTIVE",
                    "trackedEntity": "IzHblRD2sDH",
                    "relationships": [],
                    "scheduledAt": "2019-10-12T12:28:17.532",
                    "followup": false,
                    "deleted": false,
                    "createdAt": "2017-03-28T12:28:17.542",
                    "createdAtClient": "2016-03-28T12:28:17.542",
                    "updatedAt": "2017-03-28T12:28:17.542",
                    "attributeOptionCombo": "HllvX50cXC0",
                    "attributeCategoryOptions": "xYerKDKCefk",
                    "dataValues": [],
                    "notes": []
                }
            ],
            "relationships": [],
            "attributes": [],
            "notes": []
        }
    ],
    "programOwners": [
        {
            "orgUnit": "g8upMTyEZGZ",
            "trackedEntity": "IzHblRD2sDH",
            "program": "ur1Edk5Oe2n"
        }
    ]
}
```

### Événements (`GET /api/tracker/events`) { #events-get-apitrackerevents }

Deux points d'extrémité sont dédiés aux événements :

- `GET /api/tracker/events`
    - récupère les événements correspondant aux critères donnés
- `GET /api/tracker/events/{id}`
    - récupère un événement en fonction de l'identifiant fourni

#### Point d'extrémité de la collecte d'événements `GET /api/tracker/events` { #events-collection-endpoint-get-apitrackerevents }

Renvoie une liste d'événements en fonction des filtres fournis.

|Paramètre de requête|Type|Valeurs autorisées|Description|
|---|---|---|---|
|`programme`|`Chaîne`|`uid`| Identifiant du programme|
|`programStage` (étape de programme)|`Chaîne`|`uid`| Identifiant de l'étape de programme|
|`statut du programme`|`énumération`| `ACTIVE`&#124;`COMPLETED`&#124;`CANCELLED`| Statut de l'événement dans le programme | 
|`followUp` (suivi)|`booléen`| `vrai`, `faux` | Détermine si l'événement est pris en compte pour un suivi dans le programme. La valeur par défaut est `vrai`|
|`trackedEntityInstance`|`Chaîne`|`uid`| Identifiant de l'instance d'entité suivie|
|`orgUnit` (unité d'organisation)|`Chaîne`|`uid`| Identifiant de l'unité d'organisation|
|Pour plus d'informations sur le `ouMode` (mode d'unité d'organisation) voir [ouModes](#Request-parameters-for-Organisational-Unit-selection-mode)|`Chaîne`| `SELECTED`&#124;`CHILDREN`&#124;`DESCENDANTS`|  Mode de sélection de l'unité d'organisation| 
|`occurredAfter` (survenu après)|`DateTime` (date et heure)|[ISO-8601](https://en.wikipedia.org/wiki/ISO_8601)| Seulement les événements plus récents que cette date|
|`occurredBefore` (survenu avant)|`DateTime` (date et heure)|[ISO-8601](https://en.wikipedia.org/wiki/ISO_8601)| Uniquement les événements antérieurs à cette date|
|`statut`|`Chaîne`|`COMPLETED`&#124;`VISITED`&#124;`SCHEDULED`&#124;`OVERDUE`&#124;`SKIPPED` | Statut de l'événement|
|`occurredAfter` (survenu après)|`DateTime` (date et heure)|[ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) | Filter for events which were occurred after this date.|
|`occurredBefore` (survenu avant)|`DateTime` (date et heure)| [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601)| Filter for events which were occurred up until this date.|
|`scheduledAfter` (programmé après)|`DateTime` (date et heure)|[ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) | Filtre pour les événements programmés après cette date.|
|`scheduledBefore` (programmé av|`DateTime` (date et heure)| [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601)| Filter for events which were scheduled up until this date.|
|`updatedAfter` (mis à jour après)|`DateTime` (date et heure)| [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601)| Filtre pour les événements qui ont été mis à jour après cette date. Ne peut pas être utilisé avec `updatedWithin`.|
|`updatedBefore` (mis à jour avant)|`DateTime` (date et heure)|[ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) | Filtre pour les événements qui ont été mis à jour jusqu'à cette date. Ne peut pas être utilisé avec `updatedWithin`.|
|`updatedWithin`|`Durée`| [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Durations)| Incluez uniquement les éléments mis à jour pendant la durée indiquée.<br><br> Le format est [ISO-8601#Duration](https : //en.wikipedia.org/wiki/ISO_8601#Durations)|
|`skipMeta`|`Booléen`| `vrai`, `faux` | Exclut la partie métadonnées de la réponse (améliore les performances)|
|`dataElementIdScheme` (Schéma d'identification de l'élément de données)|`Chaîne`| `UID`&#124;`CODE`&#124;`ATTRIBUTE:{ID}`| Schéma d’identification de l'élément de données à utiliser pour l’exportation.|
|categoryOptionComboIdScheme (`Schéma d'identification de la combinaison d'options de catégorie`)|`Chaîne`| `UID`&#124;`CODE`&#124;`ATTRIBUTE:{ID}`| Schéma d'identification de la combinaison d'options de catégorie à utiliser pour l'exportation|
|`orgUnitIdScheme` (Schéma d'identification de l'unité d'organisation)|`Chaîne`| `UID`&#124;`CODE`&#124;`ATTRIBUTE:{ID}`| Schéma d'ID de l'unité d'organisation à utiliser pour l'exportation|
|`programIdScheme` (Schéma d'identification du programme)|`Chaîne`| `UID`&#124;`CODE`&#124;`ATTRIBUTE:{ID}`| Schéma d’identification de programme à utiliser pour l’exportation.|
|`programStageIdScheme` (Schéma d'identification d'étape de programme)|`Chaîne`| `UID`&#124;`CODE`&#124;`ATTRIBUTE:{ID}`| Schéma d’identification d'étape de programme à utiliser pour l’exportation.|
|`idScheme` (Schéma d'identification)|`chaîne`| `UID`&#124;`CODE`&#124;`ATTRIBUTE:{ID}`| Permet de définir le schéma d'identification  à la fois pour l'élément de données, la combinaison d'options de catégorie, l'unité d'organisation, le programme et l'étape de programme.|
|`ordre`|`Chaîne`|comma-delimited list of `OrderCriteria` in the form of `propName:sortDirection`.<br><br> Example: `createdAt:desc`<br><br>**Note:** `propName` is case sensitive, `sortDirection` is case insensitive|Sort the response based on given `OrderCriteria`|
|`événement`|`Chaîne`|liste d'`uid` délimités par des virgules| Filtre le résultat pour obtenir un ensemble limité d’identifiants en utilisant event=id1;id2.|
|`skipEventId` (ignorer l'identifiant de l'élément)|`Booléen`| | Ignore les identifiants d'événement dans la réponse|
|`attributeCc` (voir la note)|`Chaîne`| Identifiant de la combinaison de catégories d'attribut (doit être combiné aux options de catégorie d'attribut (attributCos))|
|`attributeCos` (voir la note)|`Chaîne`| Identifiants d'options de catégorie d'attribut, séparés par ";"(doit être combiné à la combinaison de catégories d'attribut (attributeCc))|
|`includeDeleted` (inclure les éléments supprimés)|`Booléen`| |  S'il est défini sur "vrai", les événements supprimés mais pas définitivement seront inclus dans le résultat de votre requête.|
|`assignedUserMode` (mode utilisateur attribué)|`Chaîne`| `CURRENT`&#124;`PROVIDED`&#124;`NONE`&#124;`ANY`| Mode de sélection de l'utilisateur assigné|
|`assignedUser` (utilisateur attribué)|`Chaîne`|liste d'`uid` délimités par des virgules| Il est possible de filtrer le résultat pour obtenir un ensemble limité d'événements qui sont attribués aux UID donnés, à l'aide du paramètre `assignedUser=id1;id2`. <br><br>Ce paramètre ne sera pris en compte que si le "mode d'utilisateur assigné" est `FOURNI` ou `nul`. <br><br>L'API va générer une erreur si, par exemple, `assignedUserMode=CURRENT` et `assignedUser=someId`|

> **Remarque**
>
> Si la requête ne contient ni `attributeCC` ni `attributeCos`,
> le serveur renvoie des événements pour toutes les combinaisons d'options d'attribut pour lesquelles l'utilisateur a un accès en lecture.

##### Exemples de requêtes { #example-requests }

La requête pour tous les événements ayant des subordonnées d'une unité d'organisation particulière :

    GET /api/tracker/events?orgUnit=YuQRtpLP10I&ouMode=CHILDREN

La requête pour tous les événements contenant tous les descendants d'une unité d'organisation donnée, c'est-à-dire toutes les unités d'organisation qui lui sont inférieurs dans la hiérarchie :

    GET /api/tracker/events?orgUnit=O6uvpzGd5pu&ouMode=DESCENDANTS

La requête pour tous les événements disposant d'un programme et d'une unité d'organisation :

    GET /api/tracker/events?orgUnit=DiszpKrYNg8&program=eBAyeGv0exc

La requête pour tous les événements disposant d'un programme et d'une unité d'organisation, triés par date d'échéance en ordre croissant :

    GET /api/tracker/events?orgUnit=DiszpKrYNg8&program=eBAyeGv0exc&order=dueDate

La requête pour les 10 événements avec la date d'événement la plus récente dans un programme et une unité d'organisation - par pagination et ordonnés par date d'échéance en ordre décroissant :

    GET /api/tracker/events?orgUnit=DiszpKrYNg8&program=eBAyeGv0exc
      &order=eventDate:desc&pageSize=10&page=1

La requête pour tous les événements avec un programme et une unité d'organisation pour une instance d'entité suivie donnée :

    GET /api/tracker/events?orgUnit=DiszpKrYNg8
      &program=eBAyeGv0exc&trackedEntityInstance=gfVxE3ALA9m

La requête pour tous les événements avec un programme et une unité d'organisation plus ancien(ne) ou égal(e) au 03/02/2014 :

    GET /api/tracker/events?orgUnit=DiszpKrYNg8&program=eBAyeGv0exc&endDate=2014-02-03

La requête pour tous les événements avec une étape de programme, une unité d'organisation et une instance d'entité suivie de l'an 2014 :

    GET /api/tracker/events?orgUnit=DiszpKrYNg8&program=eBAyeGv0exc
      &trackedEntityInstance=gfVxE3ALA9m&occurredAfter=2014-01-01&occurredBefore=2014-12-31

Pour récupérer les événements avec l'unité d'organisation et le programme spécifiés, et utiliser l'`Attribut : Gq0oWTf2DtN` comme schéma d'identification

    GET /api/tracker/events?orgUnit=DiszpKrYNg8&program=lxAQ7Zs9VYR&idScheme=Attribute:Gq0oWTf2DtN

Pour récupérer les événements avec l'unité d'organisation et le programme spécifiés, et utiliser l'UID comme schéma d'identification pour les unités d'organisation, le code comme schéma d'identification pour les étapes du programme, et _Attribute:Gq0oWTf2DtN_ comme schéma d'identification pour le reste des métadonnées avec les attributs assignés.

    GET /api/tracker/events?orgUnit=DiszpKrYNg8&program=lxAQ7Zs9VYR&idScheme=Attribute:Gq0oWTf2DtN
      &orgUnitIdScheme=UID&programStageIdScheme=Code

##### Format de réponse { #response-format }

La réponse `JSON` peut ressembler à ceci :

Please note that field filtering (`fields=...`) support is planned but not yet implemented.

```json
{
    "instances": [
        {
            "href": "https://play.dhis2.org/dev/api/tracker/events/rgWr86qs0sI",
            "event": "rgWr86qs0sI",
            "status": "ACTIVE",
            "program": "kla3mAPgvCH",
            "programStage": "aNLq9ZYoy9W",
            "orgUnit": "DiszpKrYNg8",
            "orgUnitName": "Ngelehun CHC",
            "relationships": [],
            "occurredAt": "2021-10-12T00:00:00.000",
            "followup": false,
            "deleted": false,
            "createdAt": "2018-10-20T12:09:19.492",
            "updatedAt": "2018-10-20T12:09:19.492",
            "attributeOptionCombo": "amw2rQP6r6M",
            "attributeCategoryOptions": "RkbOhHwiOgW",
            "dataValues": [
                {
                    "createdAt": "2015-10-20T12:09:19.640",
                    "updatedAt": "2015-10-20T12:09:19.640",
                    "storedBy": "system",
                    "providedElsewhere": false,
                    "dataElement": "HyJL2Lt37jN",
                    "value": "12"
                },
              ...
            ],
            "notes": []
        }
    ],
    "page": 1,
    "pageSize": 1
}
```
#### Point d'extrémité d'objet unique d'événements `GET /api/tracker/events/{uid}`

Le but de ce point d'extrémité est de récupérer un événement en se basant sur son UID.

##### Syntaxe de la requête { #request-syntax }

`GET /api/tracker/events/{uid}?fields={fields}`

|Paramètre de requête|Type|Valeurs autorisées|Description|
|---|---|---|---|
|`uid`|`Chaîne`|`uid`|Renvoie l'événement disposant de l'`uid` spécifié|
|`champs`|`Chaîne`| **Not implemented yet**|Include specified properties in the response| 

##### Exemples de requêtes { #example-requests }

Une requête pour un événement :

    GET /api/tracker/events/rgWr86qs0sI

##### Format de réponse { #response-format }

```json
{
  "href": "https://play.dhis2.org/dev/api/tracker/events/rgWr86qs0sI",
  "event": "rgWr86qs0sI",
  "status": "ACTIVE",
  "program": "kla3mAPgvCH",
  "programStage": "aNLq9ZYoy9W",
  "enrollment": "Lo3SHzCnMSm",
  "enrollmentStatus": "ACTIVE",
  "orgUnit": "DiszpKrYNg8",
  "orgUnitName": "Ngelehun CHC",
  "relationships": [],
  "occurredAt": "2021-10-12T00:00:00.000",
  "followup": false,
  "deleted": false,
  "createdAt": "2018-10-20T12:09:19.492",
  "createdAtClient": "2017-10-20T12:09:19.492",
  "updatedAt": "2018-10-20T12:09:19.492",
  "attributeOptionCombo": "amw2rQP6r6M",
  "attributeCategoryOptions": "RkbOhHwiOgW",
  "dataValues": [
    {
      "createdAt": "2015-10-20T12:09:19.640",
      "updatedAt": "2015-10-20T12:09:19.640",
      "storedBy": "system",
      "providedElsewhere": false,
      "dataElement": "HyJL2Lt37jN",
      "value": "12"
    },
    {
      "createdAt": "2015-10-20T12:09:19.514",
      "updatedAt": "2015-10-20T12:09:19.514",
      "storedBy": "system",
      "providedElsewhere": false,
      "dataElement": "b6dOUjAarHD",
      "value": "213"
    },
    {
      "createdAt": "2015-10-20T12:09:19.626",
      "updatedAt": "2015-10-20T12:09:19.626",
      "storedBy": "system",
      "providedElsewhere": false,
      "dataElement": "UwCXONyUtGs",
      "value": "3"
    },
    {
      "createdAt": "2015-10-20T12:09:19.542",
      "updatedAt": "2015-10-20T12:09:19.542",
      "storedBy": "system",
      "providedElsewhere": false,
      "dataElement": "fqnXmRYo5Cz",
      "value": "123"
    },
    {
      "createdAt": "2015-10-20T12:09:19.614",
      "updatedAt": "2015-10-20T12:09:19.614",
      "storedBy": "system",
      "providedElsewhere": false,
      "dataElement": "Qz3kfeKgLgL",
      "value": "23"
    },
    {
      "createdAt": "2015-10-20T12:09:19.528",
      "updatedAt": "2015-10-20T12:09:19.528",
      "storedBy": "system",
      "providedElsewhere": false,
      "dataElement": "W7aC8jLASW8",
      "value": "12"
    },
    {
      "createdAt": "2015-10-20T12:09:19.599",
      "updatedAt": "2015-10-20T12:09:19.599",
      "storedBy": "system",
      "providedElsewhere": false,
      "dataElement": "HrJmqlBqTFG",
      "value": "3"
    }
  ],
  "notes": []
}
```

### Inscriptions (`GET /api/tracker/enrollments`) { #enrollments-get-apitrackerenrollments }

Deux points d'extrémité sont dédiés aux inscriptions :

- `GET /api/tracker/enrollments`
    - récupère les inscriptions correspondant aux critères donnés
- `GET /api/tracker/enrollments/{id}`
    - récupère une inscription en fonction de l'identifiant fourni

#### Point d'extrémité de la collecte d'inscriptions `GET /api/tracker/enrollments` { #enrollment-collection-endpoint-get-apitrackerenrollments }

Renvoie une liste d'événements en fonction des filtres.

|Paramètre de requête|Type|Valeurs autorisées|Description|
|---|---|---|---|
|`orgUnit` (unité d'organisation)|`Chaîne`|`uid`| Identifiant de l'unité d'organisation|
|Pour plus d'informations sur le `ouMode` (mode d'unité d'organisation) voir [ouModes](#Request-parameters-for-Organisational-Unit-selection-mode)|`Chaîne`| `SELECTED`&#124;`CHILDREN`&#124;`DESCENDANTS`&#124;`ACCESSIBLE`&#124;`CAPTURE`&#124;`ALL| Mode de sélection de l'unité d'organisation| 
|`programme`|`Chaîne`|`uid`| Identifiant du programme|
|`statut du programme`|`énumération`| `ACTIVE`&#124;`COMPLETED`&#124;`CANCELLED`| Statut du programme |
|`followUp` (suivi)|`booléen`| `vrai`, `faux` | Statut du suivi de l'instance du programme donné. Peut être `vrai`, `faux` ou omis.|
|`updatedAfter` (mis à jour après)|`DateTime` (date et heure)|[ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) | Seules les inscriptions mises à jour après cette date|
|`updatedWithin`|`Durée`| [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601)| Seules les inscriptions mises à jour depuis une durée donnée |
|`enrolledAfter` (inscrit après)|`DateTime` (date et heure)| [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601)|  Seules les inscriptions plus récentes que cette date|
|`enrolledBefore` (inscrit avant)|`DateTime` (date et heure)| [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601)| Seules les inscriptions antérieures à cette date|
|`TrackedEntityType` (Type d'entité suivie)|`Chaîne`|`uid`| Identifiant du type d'entité suivie|
|`trackedEntity` (entité suivie)|`Chaîne`|`uid`| Identifiant de l'instance d'entité suivie|
|`inscription`|`Chaîne`|Liste d'`uid` délimités par des virgules| Filtre le résultat pour obtenir un ensemble limité d’identifiants en utilisant enrollement=id1;id2.|
|`includeDeleted` (inclure les éléments supprimés)|`Booléen`| |  S'il est défini sur "vrai", les événements supprimés mais pas définitivement seront inclus dans le résultat de votre requête.|

La requête n'est pas sensible à la casse. Les règles suivantes s'appliquent aux paramètres de la requête.

- Au moins une unité d'organisation doit être spécifiée avec le paramètre `orgUnit`
  (un ou plusieurs), ou *ouMode=ALL* doit être spécifié.

- Un seul des paramètres *program* et *trackedEntity* peut être
  spécifié (zéro ou un).

- Si *programStatus* est spécifié, alors *program* doit également être
  spécifiés.

- Si *followUp* est spécifié, alors *program* doit également être spécifié.

- Si *enrolledAfter* ou *enrolledBefore* est spécifié, alors *program* doit également être spécifié.

##### Exemples de requêtes { #example-requests }

Une requête pour toutes les inscriptions associées à une unité d'organisation spécifique peut ressembler à ceci :

    GET /api/tracker/enrollments?orgUnit=DiszpKrYNg8

Pour limiter la réponse aux inscriptions qui font partie d'un programme spécifique, vous pouvez inclure un paramètre de requête de programme :

    GET /api/tracker/enrollments?orgUnit=O6uvpzGd5pu&ouMode=DESCENDANTS&program=ur1Edk5Oe2n

Pour spécifier les dates d'inscription au programme dans la requête :

    GET /api/tracker/enrollments?&orgUnit=O6uvpzGd5pu&program=ur1Edk5Oe2n
      &enrolledAfter=2013-01-01&enrolledBefore=2013-09-01

Pour limiter la réponse aux inscriptions d'une entité suivie spécifique, vous pouvez inclure un paramètre de requête d'entité suivie :

    GET /api/tracker/enrollments?orgUnit=O6uvpzGd5pu&ouMode=DESCENDANTS&trackedEntity=cyl5vuJ5ETQ

Pour limiter la réponse aux inscriptions d'une entité suivie spécifique, vous pouvez inclure un paramètre de requête d'instance d'entité suivie. Dans ce cas, nous avons limité la réponse aux inscriptions disponibles pour l'utilisateur actuel :

    GET /API/tracker/enrollments?ouMode=ACCESSIBLE&trackedEntity=tphfdyIiVL6

##### Format de réponse { #response-format }

La réponse `JSON` peut ressembler à ceci :

Please note that field filtering (`fields=...`) support is planned but not yet implemented.

```json
{
  "instances": [
    {
      "enrollment": "iKaBMOyq7QQ",
      "createdAt": "2017-03-28T12:28:19.812",
      "createdAtClient": "2016-03-28T12:28:19.812",
      "updatedAt": "2017-03-28T12:28:19.817",
      "trackedEntity": "PpqV8ytvW5i",
      "trackedEntityType": "nEenWmSyUEp",
      "program": "ur1Edk5Oe2n",
      "status": "ACTIVE",
      "orgUnit": "NnQpISrLYWZ",
      "orgUnitName": "Govt. Hosp. Bonthe",
      "enrolledAt": "2020-10-23T12:28:19.805",
      "occurredAt": "2020-10-07T12:28:19.805",
      "followUp": false,
      "deleted": false,
      "events": [],
      "relationships": [],
      "attributes": [],
      "notes": []
    }
  ],
  "page": 1,
  "total": 1,
  "pageSize": 5
}
```

#### Point d'extrémité d'objet unique d'inscriptions `GET /api/tracker/enrollments/{uid}`

Le but de ce point d'extrémité est de récupérer une inscription en se basant sur son UID.

##### Syntaxe de la requête { #request-syntax }

`GET /api/tracker/enrollment/{uid}`

|Paramètre de requête|Type|Valeurs autorisées|Description|
|---|---|---|---|
|`uid`|`Chaîne`|`uid`|Renvoie l'inscription disposant de l'`uid` spécifié|
|`champs`|`Chaîne`| **Not implemented yet**|Inclut les sous-objets spécifiés dans la réponse| 

##### Exemples de requêtes { #example-requests }

Une requête pour une inscription :

    GET /api/tracker/enrollments/iKaBMOyq7QQ

##### Format de réponse { #response-format }

```json
{
  "enrollment": "iKaBMOyq7QQ",
  "createdAt": "2017-03-28T12:28:19.812",
  "createdAtClient": "2016-03-28T12:28:19.812",
  "updatedAt": "2017-03-28T12:28:19.817",
  "trackedEntity": "PpqV8ytvW5i",
  "trackedEntityType": "nEenWmSyUEp",
  "program": "ur1Edk5Oe2n",
  "status": "ACTIVE",
  "orgUnit": "NnQpISrLYWZ",
  "orgUnitName": "Govt. Hosp. Bonthe",
  "enrolledAt": "2020-10-23T12:28:19.805",
  "occurredAt": "2020-10-07T12:28:19.805",
  "followUp": false,
  "deleted": false,
  "events": [],
  "relationships": [],
  "attributes": [],
  "notes": []
}
```

### Relations (`GET /api/tracker/relationships`) { #relationships-get-apitrackerrelationships }

Les relations sont des liens entre deux entités dans le Tracker.
Ces entités peuvent être des instances d'entités suivies, des inscriptions et des événements.

The purpose of this endpoint is to retrieve Relationships between objects.

Unlike other tracked objects endpoints, Relationship only expose one endpoint:

- `GET /api/tracker/relationships?[tei={teiUid}|enrollment={enrollmentUid}|event={eventUid}]&fields=[fields]`

#### Paramètres de requête { #request-parameters }

|Paramètre de requête|Type|Valeurs autorisées|Description|
|---|---|---|---|
|`tei`|`Chaîne`|`uid`| Identifiant d'une instance d'entité suivie|
|`inscription`|`Chaîne`|`uid`| Identifiant d'une inscription |
|`événement`|`Chaîne`|`uid`| Identifier of and Event|
|`champs`|`Chaîne`| | **Not implemented yet:** Only includes specified properties in the response| 

Les règles suivantes s'appliquent aux paramètres de requête.

- only one parameter among `tei`,`enrollment`,`event` can be passed

> **NOTE**
>
> Using tracked entity, Enrollment or Event params, will return any relationship where the tei, enrollment or
> event is part of the relationship (either from or to). As long as user has access, that is.
>

#### Exemple de réponse { #example-response }

```json
{
  "instances": [
    {
      "relationship": "SSfIicJKbh5",
      "relationshipName": "Focus to Case",
      "relationshipType": "Mv8R4MPcNcX",
      "createdAt": "2019-08-21T13:29:45.648",
      "updatedAt": "2019-08-21T13:31:42.064",
      "bidirectional": false,
      "from": {
        "trackedEntity": "neR4cmMY22o"
      },
      "to": {
        "trackedEntity": "rEYUGH97Ssd"
      }
    },
    {
      "relationship": "S9kZGYPKk3x",
      "relationshipName": "Focus to Case",
      "relationshipType": "Mv8R4MPcNcX",
      "createdAt": "2019-08-21T13:29:45.630",
      "updatedAt": "2019-08-21T13:31:42.071",
      "bidirectional": false,
      "from": {
        "trackedEntity": "neR4cmMY22o"
      },
      "to": {
        "trackedEntity": "k8TU70vWtnP"
      }
    }
  ],
  "page": 1,
  "pageSize": 2
}
```

## Contrôle de l'accès au Tracker { #webapi_nti_access_control }

Le Tracker a quelques concepts différents en ce qui concerne le contrôle d'accès, tels que le partage, les champs d'application des unités d'organisation, la propriété et les niveaux d'accès. Les sections suivantes fournissent une brève introduction aux différents sujets.

### Partage de métadonnées { #webapi_nti_metadata_sharing }


Le paramètre de partage est une fonctionnalité standard de DHIS2 qui s'applique aux métadonnées/données du Tracker et de l'Agrégé, ainsi qu'aux tableaux de bord et aux éléments de visualisation. Au cœur du partage se trouve la possibilité de définir qui peut voir/faire quoi. En général, il existe cinq configurations de partage possibles : aucun accès, lecture des métadonnées, écriture des métadonnées, lecture des données et écriture des données. Ces configurations d'accès peuvent être accordées au niveau de l'utilisateur et/ou du groupe d'utilisateurs (pour plus de flexibilité). En ce qui concerne le Tracker, les métadonnées suivantes et leur configuration de partage sont d'une importance particulière : Élément de données, option de catégorie, programme, étape de programme, type d'entité suivie, attribut d'entité suivie, ainsi que les tableaux de bord et les éléments de tableau de bord liés au Tracker.

Le fonctionnement des paramètres de partage est simple : les paramètres sont appliqués lors des processus d'importation/exportation des données Tracker. Pour lire des valeurs, il faut disposer d'un accès en lecture aux données. Un utilisateur qui souhaite modifier des données doit disposer d'un accès en écriture. De même, un utilisateur qui souhaite modifier des métadonnées doit disposer d'un accès en écriture aux métadonnées.

Un point essentiel concernant les données Tracker est la nécessité d'adopter une approche holistique.
Par exemple, un utilisateur ne pourra pas voir la valeur de l'élément de données s'il n'a accès qu'à l'élément de données en lecture. L'utilisateur doit disposer d'un accès en lecture aux données pour accéder au stade du programme parent et au programme auquel l'élément de données appartient. Il en va de même pour la combinaison d'options de catégorie. Dans Tracker, l'événement est lié à AttributeOptionCombo, qui se compose d'une combinaison d'options de catégorie. Par conséquent, pour qu'un utilisateur puisse lire les données d'un événement, il doit avoir un accès en lecture à toutes les options de catégorie et aux catégories correspondantes qui constituent la combinaison d'options d'attributs de l'événement en question. Si un utilisateur n'a pas accès à une seule option de catégorie ou à une seule catégorie, il n'a pas accès à l'ensemble de l'événement.

Lorsqu'il s'agit d'accéder aux données d'inscription, il est essentiel d'avoir d'abord accès à l'entité suivie. L'accès à une entité suivie est contrôlé par le partage des paramètres du programme, du type d'entité suivie et de l'attribut d'entité suivie. Une fois que l'on a accédé à l'inscription, il est possible d'accéder aux données d'événement, là encore en fonction de l'étape du programme et des paramètres de partage des éléments de données.

Un autre point essentiel à prendre en considération est la manière de définir l'accès aux différentes étapes d'un programme. Il peut arriver que nous devions accorder l'accès à une étape spécifique - par exemple, « Résultat de laboratoire » - à un groupe d'utilisateurs spécifique (techniciens de laboratoire). Dans ce cas, nous pouvons accorder un accès en écriture aux données de l'étape « Résultat du laboratoire », probablement un accès en lecture à une ou plusieurs étapes au cas où nous voudrions que les techniciens de laboratoire lisent d'autres résultats médicaux, ou aucun accès si nous pensons qu'il n'est pas nécessaire qu'ils consultent des données autres que celles relatives au laboratoire.

En résumé, DHIS2 dispose d'un paramètre de partage très précis que nous pouvons utiliser pour implémenter les mécanismes de contrôle d'accès au niveau des données et des métadonnées. Ces paramètres de partage peuvent être appliqués directement au niveau de l'utilisateur ou du groupe d'utilisateurs. Le paramètre de partage à appliquer dépend du cas d'utilisation.

Pour plus d'informations sur le partage de données, consultez [Partage de données](https://docs.dhis2.org/en/use/user-guides/dhis-core-version-master/configuring-the-system/about-sharing -of-objects.html#data-sharing-for-event-based-programs).

### Champs d'application des unités d'organisation { #webapi_nti_ou_scope }

Les unités d'organisation font partie des objets les plus fondamentaux de DHIS2. Elles définissent un univers dans lequel un utilisateur est autorisé à enregistrer et/ou à lire des données. Trois types d'unités d'organisation peuvent être attribués à un utilisateur. Il s'agit de la saisie de données, de la consultation de données et de la recherche Tracker. Comme leur nom l'indique, ces unités d'organisation définissent un champ d'application dans lequel un utilisateur est autorisé à effectuer les opérations requises.

Cependant, pour mieux affiner le champ d'application, DHIS2 Tracker introduit un concept que nous appelons **OrganisationUnitSelectionMode** (mode de sélection de l'unité d'organisation). Ce mode est souvent utilisé lors de l'exportation d'objets Tracker. Par exemple, si un utilisateur dispose d'un champ de recherche particulier, cela signifie-t-il que nous devons utiliser ce champ chaque fois que l'utilisateur tente de rechercher un objet Tracker, d'inscription ou d'événement ? Ou bien l'utilisateur souhaite-t-il limiter la recherche à l'unité d'organisation sélectionnée, ou à l'ensemble de l'unité d'organisation de saisie, etc.

Les utilisateurs peuvent affiner un champ d'application en transmettant une valeur spécifique de ouMode (mode d'unité d'organisation) dans leur requête API :

*api/tracker/trackedEntities?orgUnit=UID&ouMode=specific_organisation_unit_selection_mode*

Actuellement, six modes de sélection sont disponibles : *SÉLECTIONNÉ, SUBORDONNÉES, DESCENDANTS, SAISIE, ACCESSIBLE et TOUS*.

1. **SÉLECTIONNÉ** : comme son nom l'indique, toutes les opérations prévues par l'API qui fait la requête se limitent à l'unité d'organisation sélectionnée.
2. **SUBORDONNÉES** : dans ce mode, le champ d'application de l'unité d'organisation sera construite avec l'unité d'organisation sélectionnée et ses subordonnés immédiats.
3. **DESCENDANTS** : ici, il s'agit de l'unité d'organisation sélectionnée et toutes les unités qui se trouvent en dessous de celle-ci, pas seulement les subordonnés immédiats.
4. **SAISIE** : comme le nom l'indique, il s'agit ici des unités d'organisation destinées à la saisie des données. Il convient de noter que, parmi les trois unités d'organisation pouvant être attribuées à un utilisateur, celle de la saisie de données est obligatoire. Si un utilisateur ne dispose pas d'unités d'organisation pour la visualisation des données et pour la recherche Tracker, le système reviendra à la saisie des données. De cette manière, nous sommes toujours sûrs que l'utilisateur possède au moins un univers.
5. **ACCESSIBLE** : techniquement, il s'agit du même champ d'application que les unités d'organisation de recherche Tracker de l'utilisateur.
6. **TOUS** : "TOUS" s'applique parfaitement aux superutilisateurs. Pour ces derniers, ce champ d'application désigne toutes les unités d’organisation disponibles dans le système. Cependant, pour les non-superutilisateurs, TOUS se limite aux unités d'organisation ACCESSIBLES.

Il n'est pas judicieux de transmettre ces modes lors des opérations d'importation du Tracker. En effet, lors de l'écriture des données Tracker, chaque objet doit être rattaché à une unité d'organisation spécifique. Le système vérifiera alors si chacune des unités d'organisation mentionnées relève du champ d'application de la SAISIE. Si ce n'est pas le cas, le système rejettera simplement l'opération d'écriture.

Notez qu'il existe quatre types d'associations d'unités d'organisation pour les objets Tracker. Une entité suivie a une unité d'organisation, communément appelée unité d'organisation d'enregistrement. Les inscriptions ont une unité d'organisation qui leur est associée, pareil pour les événements. Pour finir, il existe également une unité d'organisation "propriétaire" pour une combinaison Entité Suivie-Programme. 

Lors de la récupération des objets Tracker, selon le contexte, le champ d'application de l'unité d'organisation est appliquée à l'une des quatre associations d'unités d'organisation ci-dessus.

Par exemple, lors de la récupération d'entités suivies en dehors d'un programme, le champ d'application de l'unité d'organisation est appliquée à l'unité d'organisation d'enregistrement de l'entité suivie. Par contre, lors de la récupération d'entités suivies, en plus de données de programme spécifiques, le champ d'application de l'unité d'organisation est appliquée à l'unité d'organisation "propriétaire".

  * **Explique leur lien avec la propriété - Lien vers la propriété du programme**

### Propriété du programme Tracker { #webapi_nti_ownership }

Un nouveau concept appelé Propriété du Tracker est introduit depuis la version 2.30. Il s'agit d'une nouvelle association d'unités d'organisation pour une combinaison Entité Suivie - Programme.
Nous l'appelons l'Unité d'Organisation Propriétaire d'une Entité Suivie dans le cadre d'un Programme.
L'unité d'organisation Propriétaire est utilisée pour définir les accès lors de la lecture et de l'écriture des données Tracker associées à un programme.
Cette unité d'organisation, conjointement avec la configuration [Niveau d'accès](#webapi_nti_access_level) du programme, décide de l'accès aux données liées au programme (inscriptions et événements). 
Un utilisateur peut accéder aux données du programme d'une entité suivie si l'unité d'organisation propriétaire correspondante pour cette combinaison 'Entité suivie-Programme' se trouve dans le champ d'application de l'unité d'organisation de l'utilisateur (Recherche/Saisie). Pour les programmes configurés avec le niveau d'accès *OUVERT* ou *AUDITÉ*, l'unité d'organisation propriétaire doit se trouver dans le champ d'application de recherche de l'utilisateur.
Pour les programmes configurés avec le niveau d'accès *PROTÉGÉ* ou * FERMÉ*, l'unité d'organisation propriétaire doit se trouver dans le champ d'application de saisie de l'utilisateur pour que ce dernier puisse accéder aux données de programme correspondantes pour l'entité suivie en question.

#### Remplacement de la propriété du Tracker : briser le verre { #webapi_nti_tracker_ownership_override }

Il est possible d'annuler temporairement ce privilège de propriété pour un programme configuré avec un niveau d'accès *PROTÉGÉ*. Tout utilisateur sera en mesure d'obtenir temporairement l'accès aux données relatives au programme si l'utilisateur fournit une raison d'accéder aux données de la combinaison Entité suivie - Programme. Ce fait d'obtenir temporairement l'accès est appelé *briser le verre*. Actuellement, l'accès temporaire est accordé pour une durée de trois heures. DHIS2 vérifie l'aspect "briser le verre" ainsi que la raison fournie par l'utilisateur. Il n'est pas possible d'obtenir un accès temporaire à un programme qui a été configuré avec un niveau d'accès *Fermé*. Pour briser le verre d'une combinaison Entité suivie - Programme, la requête POST suivante peut être utilisée :

    /API/33/tracker/ownership/override?trackedEntityInstance=DiszpKrYNg8
      &program=eBAyeGv0exc&reason=patient+showed+up+for+emergency+care

#### Transfert de la propriété du Tracker { #webapi_nti_tracker_ownership_transfer }

Il est possible de transférer la propriété d'une combinaison Entité suivie - Programme d'une unité d'organisation à une autre. Cela peut s'avérer utile en cas de transfert de patients ou de migration. Seul un utilisateur disposant d'un accès à la propriété (ou d'un accès temporaire en brisant la glace) peut transférer la propriété. Pour transférer la propriété d'une combinaison Entité suivie - Programme à une autre unité d'organisation, la requête "PUT" suivante peut être utilisée :

    /API/33/tracker/ownership/transfer?trackedEntityInstance=DiszpKrYNg8
      &program=eBAyeGv0exc&ou=EJNxP3WreNP


### Niveau d'accès { #webapi_nti_access_level }

DHIS2 traite les données Tracker avec un niveau de protection supplémentaire. En plus de la protection standard des métadonnées et des données via les paramètres de partage, les données Tracker sont protégées par des mécanismes supplémentaires en matière de niveau d'accès. Actuellement, quatre niveaux d'accès peuvent être configurés pour un programme : Ouvert, Audité, Protégé et Fermé.

Ces niveaux d'accès ne sont déclenchés que lorsque les utilisateurs tentent d'interagir avec les données du programme, c'est-à-dire les données relatives aux inscriptions et aux événements. La configuration des différents niveaux d'accès du programme correspond à un degré d'ouverture (ou de fermeture) des données du programme. Notez que tous les autres paramètres de partage sont toujours respectés et que le niveau d'accès n'est qu'une couche supplémentaire de contrôle d'accès. Voici une brève description des quatre niveaux d'accès qui peuvent être configurés pour un programme. 

1. Ouvert : Ce niveau d'accès est le moins restrictif des niveaux d'accès. Les utilisateurs peuvent accéder aux données d'un programme OUVERT et les modifier si l'unité d'organisation propriétaire fait partie du champ de recherche de l'utilisateur. Avec ce niveau d'accès, il est possible d'accéder à des données qui se trouvent hors du champ de saisie et de les modifier sans justification ni conséquence. 
2.  Audité : Il s'agit du même niveau d'accès que le niveau Ouvert. La différence est que le système ajoutera automatiquement une entrée dans le journal d'audit sur les données auxquelles l'utilisateur accède.
3.  Protégé : Ce niveau d'accès est légèrement plus restreint. Les données contenues dans un programme PROTÉGÉ ne peuvent être consultées par les utilisateurs que si l'unité d'organisation propriétaire fait partie du champ de saisie de l'utilisateur donnée. Cependant, un utilisateur qui n'a que l'unité d'organisation propriétaire dans son champ de recherche peut en obtenir la propriété temporaire en [brisant la glace] (#webapi_nti_tracker_ownership_override). L'utilisateur doit fournir une justificla raison pour laquelle il accède aux données en question. Le système enregistre alors la justification et l'audit d'accès et accorde à l'utilisateur un accès temporaire de 3 heures. Notez que si le concept "briser la glace" est appliqué, l'unité d'organisation propriétaire reste inchangée et seul l'utilisateur qui a brisé la glace bénéficie de l'accès temporaire. 
4.  Fermé : Il s'agit du niveau d'accès le plus restreint. Les données enregistrées pour le compte de programmes configurés avec le niveau d'accès FERMÉ ne seront pas accessibles si l'unité d'organisation propriétaire n'est pas dans le champ de saisie de l'utilisateur. Il est également impossible de briser la vitre ou d'obtenir une propriété temporaire dans cette configuration. Notez qu'il est toujours possible de transférer la propriété à une autre unité d'organisation. Seul un utilisateur ayant accès à ces données peut transférer la propriété d'une combinaison Entité Suivie - Programme à une autre unité d'organisation. Si la propriété est transférée, l'unité d'organisation propriétaire est mise à jour.



# Adresses électronique { #email } 

## Adresses électronique { #webapi_email } 

L'API Web propose une ressource pour l'envoi de courriers électroniques. Pour que des courriels puissent 
être envoyés, il faut que la configuration SMTP soit correctement établie 
et qu'une adresse électronique de notification du système soit définie pour 
l'instance DHIS2. Vous pouvez définir les paramètres SMTP à partir de l'écran des paramètres 
de messagerie et l'adresse électronique de notification du système à partir de l'écran des paramètres généraux 
de DHIS2.

    /api/33/email

### Notification du système { #webapi_email_system_notification } 

La ressource *notification* vous permet d'envoyer des notifications par courriel au système 
avec un sujet et un texte donnés en JSON ou XML. Le courriel sera envoyé à 
l'adresse électronique de notification définie dans les paramètres généraux du système 
DHIS2 :

```json
{
  "subject": "Integrity check summary",
  "text": "All checks ran successfully"
}
```

Vous pouvez envoyer une notification par courrier électronique au système en envoyant un message à la ressource notification
comme suit :

```bash
curl -d @email.json "localhost/api/33/email/notification" -X POST
  -H "Content-Type:application/json" -u admin:district
```

### E-mails sortants { #outbound-emails } 

Vous pouvez également envoyer une notification générale par courrier électronique en postant dans la ressource de notification
comme indiqué ci-dessous. `F_SEND_EMAIL` ou `ALL`
doit être présente dans le système pour pouvoir utiliser cette API. Le paramètre
est facultatif. La chaîne "DHIS 2" sera envoyée comme sujet par défaut
s'il n'est pas fourni dans l'url. L'url doit être encodée pour pouvoir utiliser cette
API.

```bash
curl "localhost/api/33/email/notification?recipients=xyz%40abc.com&message=sample%20email&subject=Test%20Email"
  -X POST -u admin:district
```

### Message de test { #webapi_email_test_message } 

Pour tester si la configuration SMTP est correcte en vous envoyant à 
vous-même un e-mail de test, vous pouvez interagir avec la ressource *test*. Pour envoyer des courriels de test, 
il faut que votre compte utilisateur DHIS2 soit associé à une adresse 
électronique valide. Vous pouvez envoyer un courriel de test comme suit :

```bash
curl "localhost/api/33/email/test" -X POST -H "Content-Type:application/json" -u admin:district
```






# Magasin de données { #data-store } 

## Magasin de données { #webapi_data_store } 

En utilisant la ressource *dataStore* ("magasin de données"), les développeurs peuvent stocker des données arbitraires pour 
leurs applications. L'accès à la clé d'un magasin de données est basé sur ses paramètres de partage. 
Par défaut, toutes les clés créées sont accessibles au public (lecture et écriture). 
En outre, l'accès à l'espace de noms d'un datastore est limité à l'accès de l'utilisateur 
à l'application correspondante, si l'application a réservé l'espace de noms. 
Par exemple, un utilisateur ayant accès à l'application « sampleApp » pourra également 
utiliser l'espace de noms sampleApp dans le magasin de données. Si un espace de noms 
n'est pas réservé, aucun accès spécifique n'est requis pour l'utiliser.

    /api/33/dataStore

Note that there are reserved namespaces used by the system that require 
special authority to be able to read or write entries. 
For example the namespace for the android settings app `ANDROID_SETTINGS_APP`
will require `F_METADATA_MANAGE` authority.

### Structure du magasin de données { #webapi_data_store_structure } 

Les données du magasin de données se composent d'un espace de noms, d'une clé et d'une valeur. La 
combinaison de l'espace de noms et de la clé est unique. Le type de données de la valeur est JSON.



Tableau : Structure du magasin de données

| Élément | Description | Type de données |
|---|---|---|
| Espace de noms | Espace-noms pour l'organisation des données | Chaîne |
| Clé | Clé d'identification des valeurs. | Chaîne |
| Valeur | Valeur contenant les informations à saisir | JSON |
| Chiffré | Indique si la valeur de la clé donnée doit être chiffrée | Booléen |

### Obtenir des clés et des espaces de noms  { #webapi_data_store_get_keys_and_namespaces } 

Pour obtenir une liste de tous les espaces de noms existants :

    GET /api/33/dataStore

Exemple de requête curl pour le listing :

```bash
curl "play.dhis2.org/demo/api/33/dataStore" -u admin:district
```

Exemple de réponse : 

```json
[
  "foo",
  "bar"
]
```

Pour obtenir la liste de toutes les clés d'un espace de noms :

    GET /api/33/dataStore/<namespace>

Exemple de requête curl pour le listing :

```bash
curl "play.dhis2.org/demo/api/33/dataStore/foo" -u admin:district
```

Exemple de réponse : 

```json
[
  "key_1",
  "key_2"
]
```

Pour récupérer une valeur pour une clé existante dans un espace de noms :

    GET /api/33/dataStore/<namespace>/<key>

Exemple de requête curl pour l'extraction :

```bash
curl "play.dhis2.org/demo/api/33/dataStore/foo/key_1"-u admin:district
```

Exemple de réponse : 

```json
{
  "foo":"bar"
}
```

Pour récupérer les métadonnées d'une clé existante dans un espace de noms :

    GET /api/33/dataStore/<namespace>/<key>/metaData

Exemple de requête curl pour l'extraction :

```bash
curl "play.dhis2.org/demo/api/33/dataStore/foo/key_1/metaData" -u admin:district
```

Exemple de réponse : 

```json
{
  "id": "dsKeyUid001", 
  "created": "...",
  "user": {...},
  "namespace": "foo",
  "key": "key_1"
}
```

### Créer des valeurs { #webapi_data_store_create_values } 

Pour créer une nouvelle clé et une nouvelle valeur pour un espace de noms :

    POST /api/33/dataStore/<namespace>/<key>

Exemple de requête curl pour créer, en présumant que la charge JSON est valide :

```bash
curl "https://play.dhis2.org/demo/api/33/dataStore/foo/key_1" -X POST
  -H "Content-Type: application/json" -d "{\"foo\":\"bar\"}" -u admin:district
```

Exemple de réponse : 

```json
{
  "httpStatus": "OK",
  "httpStatusCode": 201,
  "status": "OK",
  "message": "Key 'key_1' created."
}
```

Si vous souhaitez que les données que vous stockez soient cryptées (par exemple les informations 
d'identification de l'utilisateur ou autres), vous pouvez ajouter une requête à l'URL comme suit :

    GET /api/33/dataStore/<namespace>/<key>?encrypt=true

### Mettre à jour les valeurs { #webapi_data_store_update_values } 

Pour mettre à jour une clé qui existe dans un espace de noms :

    PUT /api/33/dataStore/<namespace>/<key>

Exemple de requête curl pour mettre à jour, en présumant que la charge JSON est valide :

```bash
curl "https://play.dhis2.org/demo/api/33/dataStore/foo/key_1" -X PUT -d "[1, 2, 3]"
  -H "Content-Type: application/json" -u admin:district
```

Exemple de réponse : 

```json
{
  "httpStatus": "OK",
  "httpStatusCode": 200,
  "status": "OK",
  "message": "Key 'key_1' updated."
}
```

### Touches de suppression { #webapi_data_store_delete_keys } 

Pour supprimer une clé existante d'un espace de noms :

    DELETE /api/33/dataStore/<namespace>/<key>

Exemple de requête curl pour la suppression :

```bash
curl "play.dhis2.org/demo/api/33/dataStore/foo/key_1" -X DELETE -u admin:district
```

Exemple de réponse : 

```json
{
  "httpStatus": "OK",
  "httpStatusCode": 200,
  "status": "OK",
  "message": "Key 'key_1' deleted from namespace 'foo'."
}
```

Pour supprimer toutes les clés d'un espace de noms :

    DELETE /api/33/dataStore/<namespace>

Exemple de requête curl pour la suppression :

```bash
curl "play.dhis2.org/demo/api/33/dataStore/foo" -X DELETE -u admin:district
```

Exemple de réponse : 

```json
{
  "httpStatus": "OK",
  "httpStatusCode": 200,
  "status": "OK",
  "message": "Namespace 'foo' deleted."
}
```

### Sharing datastore keys { #webapi_data_store_sharing } 

Sharing of datastore keys follows the same principle as for other metadata sharing (see
[Sharing](#webapi_sharing)).

To get sharing settings for a specific datastore key:

    GET /api/33/sharing?type=dataStore&id=<uid>

Where the id for the datastore key comes from the `/metaData` endpoint for that key:

    /api/33/dataStore/<namespace>/<key>/metaData

To modify sharing settings for a specific datastore key:

    POST /api/33/sharing?type=dataStore&id=<uid>

avec la requête suivante:

```json
{
  "object": {
    "publicAccess": "rw------",
    "externalAccess": false,
    "user": {},
    "userAccesses": [],
    "userGroupAccesses": [
      {
        "id": "hj0nnsVsPLU",
        "access": "rw------"
      },
      {
        "id": "qMjBflJMOfB",
        "access": "r-------"
      }
    ]
  }
}
```

## Magasin de données de l'utilisateur { #webapi_user_data_store } 

Outre le *magasin de données* qui est partagé par tous les utilisateurs du 
système, un magasin de données basé sur l'utilisateur est également disponible. Les données stockées dans le 
*magasin de données de l'utilisateur* sont associées à des utilisateurs individuels, afin que chaque utilisateur 
puisse avoir des données différentes dans le même espace de noms et la même combinaison de touches. Tous 
les appels au *magasin de données de l'utilisateur* seront associés à l'utilisateur 
connecté. Cela signifie que l'on ne peut voir, modifier, supprimer et ajouter que les valeurs 
associées à l'utilisateur connecté.

    /api/33/userDataStore

### Structure du magasin de données de l'utilisateur { #webapi_user_data_store_structure } 

Le *magasin de données de l'utilisateur* se compose d'un utilisateur, d'un espace de noms, de clés et de valeurs
associées. La combinaison d'un utilisateur, d'un espace de noms et d'une clé est unique.



Tableau : Structure du magasin de données de l'utilisateur

| Élément | Description | Type de données |
|---|---|---|
| Utilisateur | L'utilisateur auquel ces données sont associées | Chaîne |
| Espace de noms | L'espace de noms auquel appartient la clé | Chaîne |
| Clé | La clé sur laquelle une valeur est stockée | Chaîne |
| Valeur | La valeur stockée | JSON |
| Chiffré | Indique si la valeur doit être cryptée | Booléen |

### Obtenir des espaces de noms { #webapi_user_data_store_get_namespaces } 

Renvoie un tableau de tous les espaces de noms existants

    GET /api/33/userDataStore

Exemple
    requête:

```bash
curl -H "Content-Type: application/json" -u admin:district "play.dhis2.org/api/33/userDataStore"
```

```json
[
  "foo",
  "bar"
]
```

### Obtenir des clés { #webapi_user_data_store_get_keys } 

Renvoie un tableau de toutes les clés existantes dans un espace de noms donné

    GET /api/userDataStore/<namespace>

Exemple de requête:

```bash
curl -H "Content-Type: application/json" -u admin:district "play.dhis2.org/api/33/userDataStore/foo"
```

```json
[
  "key_1",
  "key_2"
]
```

### Obtenir des valeurs { #webapi_user_data_store_get_values } 

Renvoie la valeur d'un espace de noms et d'une clé donnés

    GET /api/33/userDataStore/<namespace>/<key>

Exemple de requête:

```bash
curl -H "Content-Type: application/json" -u admin:district "play.dhis2.org/api/33/userDataStore/foo/bar"
```

```json
{
  "some": "value"
}
```

### Créer une valeur { #webapi_user_data_store_create_values } 

Ajoute une nouvelle valeur à une clé donnée dans un espace de noms donné.

    POST /api/33/userDataStore/<namespace>/<key>

Exemple de requête:

```bash
curl -X POST -H "Content-Type: application/json" -u admin:district -d "['some value']"
  "play.dhis2.org/api/33/userDataStore/foo/bar"
```

```json
{
  "httpStatus": "Created",
  "httpStatusCode": 201,
  "status": "OK",
  "message": "Key 'bar' in namespace 'foo' created."
}
```

Si vous souhaitez que la valeur soit cryptée (par exemple, les informations d'identification de l'utilisateur
et autres), vous pouvez ajouter une requête à l'url comme ceci :

    GET /api/33/userDataStore/<namespace>/<key>?encrypt=true

### Mettre à jour les valeurs  { #webapi_user_data_store_update_values } 

Met à jour une valeur existante

    PUT /api/33/userDataStore/<namespace>/<key>

Exemple de requête:

```bash
curl -X PUT -H "Content-Type: application/json" -u admin:district -d "['new value']"
  "play.dhis2.org/api/33/userDataStore/foo/bar"
```

```json
{
  "httpStatus":"Created",
  "httpStatusCode":201,
  "status":"OK",
  "message":"Key 'bar' in namespace 'foo' updated."
}
```

### Clé de suppression { #webapi_user_data_store_delete_key } 

Supprimer une clé

    DELETE /api/33/userDataStore/<namespace>/<key>

Exemple de requête:

```bash
curl -X DELETE -u admin:district "play.dhis2.org/api/33/userDataStore/foo/bar"
```

```json
{
  "httpStatus":"OK",
  "httpStatusCode":200,
  "status":"OK",
  "message":"Key 'bar' deleted from the namespace 'foo."
}
```

### Supprimer un espace de noms { #webapi_user_data_store_delete_namespace } 

Supprimer toutes les clés de l'espace de noms donné

    DELETE /api/33/userDataStore/<namespace>

Exemple de requête:

```bash
curl -X DELETE -u admin:district "play.dhis2.org/api/33/userDataStore/foo"
```

```json
{
  "httpStatus":"OK",
  "httpStatusCode":200,
  "status":"OK",
  "message":"All keys from namespace 'foo' deleted."
}
```







# Profil d'unité d'organisation { #org_unit_profile }

La ressource profil d'unité d'organisation permet de définir et d'extraire un profil d'information pour les unités d'organisation dans DHIS 2.

```
/api/organisationUnitProfile
```

Un seul profil d'unité d'organisation peut être créé et s'applique à toutes les unités d'organisation.

La partie information du profil de l'unité d'organisation comprend :

- Nom, nom abrégé, description, unité d'organisation mère, niveau, date d'ouverture, date de fermeture, URL.
- Personne de contact, adresse, e-mail, numéro de téléphone (s'il existe).
- Localisation (longitude/latitude).
- Attributs de métadonnées (configurables).
- Ensembles de groupes d'unités d'organisation et groupes (configurables).
- Données agrégées pour les éléments de données, les indicateurs, les taux de déclaration, les indicateurs de programme (configurables).

## Créer un profil d'unité d'organisation { #create-organisation-unit-profile } 

Pour définir le profil de l'unité d'organisation, vous pouvez utiliser une requête `POST` :

```
POST /api/organisationUnitProfile
```

La charge au format JSON ressemble à ceci, où `attributes` fait référence aux attributs de métadonnées, `groupSets` fait référence aux ensembles de groupes d'unités d'organisation et `dataItems` fait référence aux éléments de données, aux indicateurs, aux ensembles de données et aux indicateurs de programme :

```json
{
  "attributes": [
    "xqWyz9jNCA5",
    "n2xYlNbsfko"
  ],
  "groupSets": [
    "Bpx0589u8y0",
    "J5jldMd8OHv"
  ],
  "dataItems": [
    "WUg3MYWQ7pt",
    "vg6pdjObxsm",
    "DTVRnCGamkV",
    "Uvn6LCg7dVU",
    "eTDtyyaSA7f"
  ]
}
```

L'autorité `F_ORG_UNIT_PROFILE_ADD` est nécessaire pour définir le profil.

## Obtenir le profil d'une unité d'organisation { #get-organisation-unit-profile } 

Pour extraire la définition du profil de l'unité d'organisation, vous pouvez utiliser une requête `GET` :

```
GET /api/organisationUnitProfile
```

La réponse sera au format JSON.

## Obtenir les données du profil d'une unité d'organisation { #get-organisation-unit-profile-data } 

Pour extraire les données du profil d'une unité d'organisation, vous pouvez utiliser une requête `GET` :

```
GET /api/organisationUnitProfile/{org-unit-id}/data?period={iso-period}
```

Le endpoint des données du profil de l'unité d'organisation combinera la définition du profil avec les valeurs d'informations/données qui lui sont associées. 

* La variable de chemin `org-unit-id` est obligatoire et fait référence à l'identifiant de l'unité d'organisation pour laquelle des données agrégées doivent être fournies.
* Le paramètre de requête `iso-period` est facultatif et se réfère à l'identifiant ISO de la période pour fournir des données agrégées pour les éléments de données. Si aucun n'est spécifié, la période relative _cette année_ sera utilisée comme solution de repli.

La réponse comprendra les sections suivantes :

* `info` : Informations fixes sur l'unité d'organisation.
* `attributes` : Attributs de métadonnées avec les valeurs d'attributs correspondantes.
* `groupSets` : Ensembles de groupes d'unités d'organisation avec le groupe d'unités d'organisation correspondant dont l'unité d'organisation est membre.
* `dataItems` (éléments de données) : Éléments de données avec la valeur de données agrégées correspondante.

Notez que des contrôles d'accès sont effectués et que les éléments de métadonnées qui ne sont pas accessibles à l'utilisateur actuel seront omis.

Voici donc un exemple de requête :

```
GET /api/organisationUnitProfile/DiszpKrYNg8/data?period=2021
```

La réponse aux données de profil au format JSON se présente comme suit : les champs `id` (identifiant) et `label` (étiquette) renvoient à l'élément de métadonnées, et le champ `value` (valeur) renvoie à la valeur associée :

```json
{
  "info": {
    "id": "DiszpKrYNg8",
    "code": "OU_559",
    "name": "Ngelehun CHC",
    "shortName": "Ngelehun CHC",
    "parentName": "Badjia",
    "level": 4,
    "levelName": "Facility",
    "openingDate": "1970-01-01T00:00:00.000",
    "longitude": -11.4197,
    "latitude": 8.1039
  },
  "attributes": [
    {
      "id": "n2xYlNbsfko",
      "label": "NGO ID",
      "value": "GHE51"
    },
    {
      "id": "xqWyz9jNCA5",
      "label": "TZ code",
      "value": "NGE54"
    }
  ],
  "groupSets": [
    {
      "id": "Bpx0589u8y0",
      "label": "Facility Ownership",
      "value": "Public facilities"
    },
    {
      "id": "J5jldMd8OHv",
      "label": "Facility Type",
      "value": "CHC"
    }
  ],
  "dataItems": [
    {
      "id": "WUg3MYWQ7pt",
      "label": "Total Population",
      "value": 3503
    },
    {
      "id": "DTVRnCGamkV",
      "label": "Total population < 1 year",
      "value": 140
    },
    {
      "id": "vg6pdjObxsm",
      "label": "Population of women of child bearing age (WRA)",
      "value": 716
    },
    {
      "id": "Uvn6LCg7dVU",
      "label": "ANC 1 Coverage",
      "value": 368.2
    },
    {
      "id": "eTDtyyaSA7f",
      "label": "FIC <1y",
      "value": 291.4
    }
  ]
}
```

## Télécharger l'image de l'unité d'organisation { #upload-image-for-organisation-unit } 

Pour télécharger une image pour une unité d'organisation, vous pouvez utiliser le endpoint `fileResources`.

```
/api/fileResources
```

Le endpoint `fileResource` accepte un fichier brut comme corps de la requête. Les formats `JPG`, `JPEG` et `PNG` sont supportés pour les images d'unités d'organisation. Le domaine pour les images d'unités d'organisation est `ORG_UNIT`.

Veuillez consulter *Ressources de fichiers* dans la section *Métadonnées* pour plus de détails sur le endpoint `fileResources`. 

Pour télécharger une image, vous pouvez envoyer une requête `POST` avec `ORG_UNIT` comme paramètre de requête de domaine ainsi que l'image comme charge de la requête. L'en-tête `Content-Type` (type de contenu) doit correspondre au type de fichier téléchargé.

```
POST /api/fileResources?domain=ORG_UNIT
```

La propriété `id ` (identifiant) de l'objet `response` (réponse) > `fileResource` (ressource de fichier) dans la réponse JSON contiendra une référence à l'identifiant de la ressource de fichier.

L'entité unité d'organisation a une propriété `image` qui fait référence à l'image de la ressource fichier. Pour définir la référence de la ressource fichier sur une unité d'organisation, vous pouvez envoyer une requête `PATCH` à l'unité d'organisation avec une charge JSON :

```
PATCH /api/organisationUnits/{id}
```

```json
{ 
  "image": "{file-resource-id}" 
}
```

Vous pouvez également utiliser une requête `PUT` avec l'unité d'organisation complète (les champs sont omis pour des raisons de concision) :

```
PUT /api/organisationUnits/{id}
```

```json
{
  "id": "Rp268JB6Ne4",
  "name": "Adonkia CHP",
  "image": {
    "id":  "{file-resource-iid}"
  }
}
```

## Obtenir l'image d'une unité d'organisation { #get-image-for-organisation-unit } 

L'entité unité d'organisation possède un objet `image` qui fait référence à une ressource fichier par identifiant. Vous pouvez obtenir les informations sur l'unité d'organisation à partir du endpoint `organisationUnits`. S'il est défini, le format JSON ressemble à ceci :

```
GET /api/organisationUnits/{id}
```

```json
{
  "id": "Rp268JB6Ne4",
  "name": "Adonkia CHP",
  "image": {
    "id":  "{file-resource-id}"
  }
}
```

L'identifiant de la ressource du fichier image peut être utilisé pour faire une demande au endpoint `fileResources` afin de récupérer le contenu du fichier :

```
GET /api/fileResources/{id}/data
```

L'en-tête `Content-Type` (type de contenu) reflète le type de fichier récupéré.



# Applications { #apps } 

## Applications { #webapi_apps } 

Le endpoint `/api/apps` peut être utilisé pour installer, supprimer et 
lister des applications. La clé de l'application est basée sur le nom de l'application, mais tous 
les caractères non alphanumériques sont supprimés, et les espaces sont remplacés par un tiret. 
*My app!* renverra la clé *My-app*.

> **Remarque**
>
> Avant la version 2.28, la clé d'application était dérivée du nom de l'archive ZIP
> , à l'exclusion de l'extension du fichier. Les URLs utilisant l'ancien format
> devraient toujours renvoyer l'application correcte dans l'api.

    /api/33/apps

### Obtenir les applications { #webapi_get_apps } 

> **Remarque**
>
> Avant la version 2.28, la propriété d'application folderName faisait référence au chemin réel
> de l'application installée. Avec la possibilité de stocker les applications sur des services en nuage, 
> l'objectif de folderName a changé et fait désormais référence à la clé de
> l'application.

Vous pouvez lire les clés des applications en listant toutes les applications de la ressource apps
et en recherchant la propriété *key*. Pour lister toutes les applications installées au format
JSON :

```bash
curl -u user:pass -H "Accept: application/json" "http://server.com/api/33/apps"
```

Vous pouvez aussi simplement orienter votre navigateur web vers l'URL de la ressource :

    http://server.com/api/33/apps

La liste des applications peut également être filtrée par type d'application et par nom, en ajoutant 
un ou plusieurs paramètres *filtre* à l'URL :

    http://server.com/api/33/apps?filter=appType:eq:DASHBOARD_APP&filter=name:ilike:youtube

Les noms d'applications prennent en charge les opérateurs de filtrage *eq* et *ilike*, tandis que *appType*
ne prend en charge que *eq*.

### Installer une application { #webapi_install_app } 

Pour installer une application, la commande suivante peut être exécutée :

```bash
curl -X POST -u user:pass -F file=@app.zip "http://server.com/api/33/apps"
```

### Supprimer une application { #webapi_delete_app } 

Pour supprimer une application, vous pouvez exécuter la commande suivante :

```bash
curl -X DELETE -u user:pass "http://server.com/api/33/apps/<app-key>"
```

### Recharger les applications { #webapi_reload_apps } 

Pour forcer le rechargement des applications actuellement installées, vous pouvez lancer la 
commande suivante. Cette commande est utile si vous avez ajouté manuellement un fichier directement 
dans le système de fichiers, au lieu de le télécharger via l'interface utilisateur de 
DHIS2.

```bash
curl -X PUT -u user:pass "http://server.com/api/33/apps"
```

### Partager des applications entre instances { #webapi_share_apps_between_instances } 

Si l'instance DHIS2 a été configurée pour utiliser le stockage en nuage, les applications
seront désormais installées et stockées sur le service en nuage. Cela permettra à
plusieurs instances de partager les mêmes versions des applications installées, au lieu 
d'installer les mêmes applications sur chaque instance individuelle.

> **Remarque**
>
> Avant la version 2.28, les applications installées étaient uniquement stockées sur le système de fichiers 
> local de l'instance. Les applications installées avant la version 2.28 seront toujours disponibles sur
> l'instance où elles ont été installées, mais elles ne seront pas partagées avec d'autres
> instances, car elles sont toujours situées sur le système de fichiers local de l'instance.

## App store { #webapi_app_store } 

L'API Web expose le contenu de l'App Store DHIS2 sous la forme d'une représentation JSON
que l'on peut trouver dans la ressource `/api/appHub`.

    /api/33/appHub

### Obtenir les applications { #webapi_get_app_store_apps } 

Vous pouvez extraire les applications à l'aide d'une requête GET :

    GET /api/33/appHub

Un exemple de réponse JSON est décrit ci-dessous.

```json
{
  [
    {
      "name": "Tabular Tracker Capture",
      "description": "Tabular Tracker Capture is an app that makes you more effective.",
      "sourceUrl": "https://github.com/dhis2/App-repository",
      "appType": "DASHBOARD_WIDGET",
      "status": "PENDING",
      "id": "NSD06BVoV21",
      "developer": {
        "name": "DHIS",
        "organisation": "Uio",
        "address": "Oslo",
        "email": "dhis@abc.com",
      },
      "versions": [
        {
          "id": "upAPqrVgwK6",
          "version": "1.2",
          "minDhisVersion": "2.17",
          "maxDhisVersion": "2.20",
          "downloadUrl": "https://dhis2.org/download/appstore/tabular-capture-12.zip",
          "demoUrl": "http://play.dhis2.org/demo"
        }
      ],
      "images": [
        {
          "id": "upAPqrVgwK6",
          "logo": "true",
          "imageUrl": "https://dhis2.org/download/appstore/tabular-capture-12.png",
          "description": "added feature snapshot",
          "caption": "dialog",
        }
      ]
    }
  ]
}
```

### Installer des applications { #webapi_install_app_store_apps } 

Vous pouvez installer des applications sur votre instance DHIS2 en supposant que vous avez les 
permissions appropriées. Une application est référencée en utilisant la propriété `id` 
de la version correspondante de l'application. Une application est installée par une requête 
POST avec l'identifiant de la version à la ressource suivante :

    POST /api/33/appHub/{app-version-id}

