---
edit_url: "https://github.com/dhis2/dhis2-docs/blob/master/src/developer/web-api/metadata.md"
revision_date: '2024-10-25'
tags:
- Vývoj
- Hlavní verze jádra DHIS
---

# Metadata { #webapi_metadata }

## Schémata identifikátorů { #webapi_identifier_schemes } 

This section provides an explanation of the identifier scheme concept.
Identifier schemes are used to map metadata objects to other metadata
during import, and to render metadata as part of exports. Note
that not all schemes work for all API calls, and not all
schemes can be used for both input and output. This is outlined in the
sections explaining the various API endpoints.

Úplná sada dostupných typů objektů schématu identifikátorů je uvedena níže s použitím názvu vlastnosti pro použití v dotazech:

  - idScheme

  - dataElementIdScheme

  - categoryOptionComboIdScheme

  - orgUnitIdScheme

  - programIdScheme

  - programStageIdScheme

  - trackedEntityIdScheme

  - trackedEntityAttributeIdScheme

The general idScheme applies to all types of objects. It can be
overridden by specific object types.

The default scheme for all parameters is UID (stable DHIS2
identifiers). The supported identifier schemes are described in the
table below.

Tabulka: Hodnoty schématu

| Schéma | Popis |
|---|---|
| ID, UID | Shoda na stabilním identifikátoru DHIS2, toto je výchozí schéma ID. |
| CODE | Shoda na kódu DHIS2, který se používá hlavně k výměně dat s externím systémem. |
| NÁZEV | Match on DHIS2 Name, please note that this uses what is available as *object.name*, and not the translated name. Also note that names are not always unique, and in that case, they can not be used. |
| ATTRIBUTE:ID | Match on metadata attribute, this attribute needs to be assigned to the type you are matching on, and also that the unique property is set to *true*. The main usage of this is also to exchange data with external systems, it has some advantages over *CODE* since multiple attributes can be added, so it can be used to synchronize with more than one system. |

Note that identifier schemes is not an independent feature but needs to
be used in combination with resources such as data value import, metadata import and
GeoJson import.

Například pro zadání CODE jako obecného schématu ID a přepsání pomocí UID pro schéma ID organizační jednotky můžete použít tyto parametry dotazu:

    ?idScheme=CODE&orgUnitIdScheme=UID

As another example, to specify an attribute for the organisation unit id
scheme, code for the data element id scheme and use the default UID id
scheme for all other objects you can use these parameters:

    ?orgUnitIdScheme=ATTRIBUTE:j38fk2dKFsG&dataElementIdScheme=CODE

## Procházení webového API { #webapi_browsing_the_web_api } 

The entry point for browsing the Web API is `/api`. This resource
provides links to all available resources. Four resource representation
formats are consistently available for all resources: HTML, XML, JSON,
and JSONP. Some resources will have other formats available, like MS
Excel, PDF, CSV, and PNG. To explore the API from a web browser, navigate
to the `/api` entry point and follow the links to your desired
resource, for instance `/api/dataElements`. For all resources which
return a list of elements certain query parameters can be used to modify
the response:

Tabulka: Parametry databázového dotazu

| Parametr | Hodnoty možností | Výchozí možnost | Popis |
|---|---|---|---|
| stránkování | true &#124; false | true | Udává, zda chcete vrátit seznamy prvků na stránkách. |
| strana | číslo | 1 | Definuje, které číslo stránky se má vrátit. |
| pageSize | číslo | 50 | Definuje počet prvků, které se mají vrátit pro každou stránku. |
| řazení | property:asc/iasc/desc/idesc || Order the output using a specified order, only properties that are both persisted and simple (no collections, idObjects etc) are supported. iasc and idesc are case insensitive sorting. If it is wanted to sort for more than one property, separate them using a comma.  |

Příkladem použití těchto parametrů k získání úplného seznamu skupin datových prvků ve formátu odpovědi XML je:

    /api/dataElementGroups.xml?links=false&paging=false

You can query for elements on the name property instead of returning
a full list of elements using the *query* query variable. In this example
we query for all data elements with the word "anaemia" in the name:

    /api/dataElements?query=anaemia

Můžete získat konkrétní stránky a velikosti stránek takových objektů:

    /api/dataElements.json?page=2&pageSize=20

Stránkování můžete zcela deaktivovat takto:

    /api/indicatorGroups.json?paging=false

Chcete-li řadit výsledek na základě konkrétní vlastnosti:

    /api/indicators.json?order=shortName:desc

To order the result based on created datetime property first (descending order) and then by name property (ascending order):

    /api/indicators.json?order=created:desc,name:asc

You can find an object based on its ID across all object types through
the *identifiableObjects* resource:

    /api/identifiableObjects/<id>

### Překlad { #webapi_translation } 

DHIS2 supports translations of database content, such as data elements,
indicators, and programs. All metadata objects in the Web API have
properties meant to be used for display / UI purposes, which include
*displayName*, *displayShortName*, *displayDescription* and
*displayFormName* (for data elements and tracked entity attributes).

Tabulka: Možnosti překladu

| Parametr | Hodnoty | Popis |
|---|---|---|
| přeložit | true &#124; false | Přeložte vlastnosti display\* do výstupu metadat (displayName, displayShortName, displayDescription a displayFormName pro datové prvky a sledované atributy entit). Výchozí hodnota je true. |
| národní prostředí | Místní použití | Přeložit výstup metadat pomocí zadaného národního prostředí (vyžaduje translate=true). |

### Překladové API { #webapi_translation_api } 

The translations for an object is rendered as part of the object itself
in the *translations* array. Note that the *translations* array in the
JSON/XML payloads is normally pre-filtered for you, which means they
can not directly be used to import/export translations (as that would
normally overwrite locales other than current users).

Příklad datového prvku s překladovým polem filtrovaným na národní prostředí uživatele:

```json
{
  "id": "FTRrcoaog83",
  "displayName": "Accute French",
  "translations": [
    {
      "property": "SHORT_NAME",
      "locale": "fr",
      "value": "Accute French"
    },
    {
      "property": "NAME",
      "locale": "fr",
      "value": "Accute French"
    }
  ]
}
```

Příklad datového prvku s vypnutými překlady:

```json
{
  "id": "FTRrcoaog83",
  "displayName": "Accute Flaccid Paralysis (Deaths < 5 yrs)",
  "translations": [
    {
      "property": "FORM_NAME",
      "locale": "en_FK",
      "value": "aa"
    },
    {
      "property": "SHORT_NAME",
      "locale": "en_GB",
      "value": "Accute Flaccid Paral"
    },
    {
      "property": "SHORT_NAME",
      "locale": "fr",
      "value": "Accute French"
    },
    {
      "property": "NAME",
      "locale": "fr",
      "value": "Accute French"
    },
    {
      "property": "NAME",
      "locale": "en_FK",
      "value": "aa"
    },
    {
      "property": "DESCRIPTION",
      "locale": "en_FK",
      "value": "aa"
    }
  ]
}
```

Note that even if you get the unfiltered result, and are using the
appropriate type endpoint i..e `/api/dataElements` we do not allow
updates, as it would be too easy to make mistakes and overwrite the
other available locales.

To read and update translations you can use the special translations
endpoint for each object resource. These can be accessed by *GET* or
*PUT* on the appropriate `/api/<object-type>/<object-id>/translations` endpoint.

As an example, for a data element with identifier `FTRrcoaog83`, you could use
`/api/dataElements/FTRrcoaog83/translations` to get and update
translations. The fields available are `property` with options *NAME*,
*SHORT_NAME*, *FORM_NAME*, *DESCRIPTION*, `locale` which supports any valid
locale ID and the translated property `value`.

Příklad vlastnosti NAME pro francouzské národní prostředí:

```json
{
  "property": "NAME",
  "locale": "fr",
  "value": "Paralysie Flasque Aiguë (Décès <5 ans)"
}
```

This payload would then be added to a translation array, and sent back
to the appropriate endpoint:

```json
{
  "translations": [
    {
      "property": "NAME",
      "locale": "fr",
      "value": "Paralysie Flasque Aiguë (Décès <5 ans)"
    }
  ]
}
```

For a data element with ID *FTRrcoaog83* you can *PUT* this to
`/api/dataElements/FTRrcoaog83/translations`. Make sure to send all
translations for the specific object and not just for a single locale
(if not you will potentially overwrite existing locales for other
locales).

Stavový kód bude `204 No Content` , pokud byla hodnota dat úspěšně uložena nebo aktualizována, nebo `404 Not Found` , pokud došlo k chybě ověření (např. více než jeden  `SHORT_NAME`  pro stejné `locale`).


### Verze webového rozhraní API { #webapi_api_versions } 

Webové rozhraní API je verzováno od verze DHIS 2.25. Verzování API se řídí číslováním hlavních verzí DHIS2. Příklad: verze API pro DHIS 2.33 je `33`.

You can access a specific API version by including the version number
after the `/api` component, as an example like this:

    /api/33/dataElements

If you omit the version part of the URL, the system will use the current
API version. As an example, for DHIS 2.25, when omitting the API part,
the system will use API version 25. When developing API clients it is
recommended to use explicit API versions (rather than omitting the API
version), as this will protect the client from unforeseen API changes.

The last three API versions will be supported. As an example, DHIS
version 2.27 will support API version 27, 26 and 25.

Note that the metadata model is not versioned and that you might
experience changes e.g. in associations between objects. These changes
will be documented in the DHIS2 major version release notes.

## Filtr objektů metadat { #webapi_metadata_object_filter } 

To filter the metadata there are several filter operations that can be
applied to the returned list of metadata. The format of the filter
itself is straight-forward and follows the pattern
*property:operator:value*, where *property* is the property on the
metadata you want to filter on, *operator* is the comparison operator
you want to perform and *value* is the value to check against (not all
operators require value). 

Please see the *schema* section to discover which properties are available. 
In addition to the listed properties filters can apply to custom attribute 
values by using the attribute's ID as property name.

Recursive filtering, ie. filtering on associated objects or collection of 
objects, is supported as well.

Tabulka: Dostupné operátory

| Operátor | Typy | Požadovaná hodnota | Popis |
|---|---|---|---|
| eq | řetězec &#124; booleovský &#124; celé číslo &#124; plovoucí &#124; výčet &#124; sběr (kontroluje velikost) &#124; datum | true | Rovnost |
| !eq | řetězec &#124; booleovský &#124; celé číslo &#124; plovoucí &#124; výčet &#124; sběr (kontroluje velikost) &#124; datum | true | Nerovnost |
| ieq | řetězec  | true  | Case insensitive string, match exact |
| ne | řetězec &#124; booleovský &#124; celé číslo &#124; plovoucí &#124; výčet &#124; sběr (kontroluje velikost) &#124; datum | true | Nerovnost |
| like | řetězec | true | Řetězec rozlišující malá a velká písmena, shodujte se kdekoli |
| !like | řetězec | true | Řetězec rozlišující malá a velká písmena, nikde se neshoduje |
| $like | řetězec | true | Řetězec rozlišující malá a velká písmena, shoduje se na začátku |
| !$like | řetězec | true | Řetězec rozlišující malá a velká písmena, neshoduje se na začátku |
| like$ | řetězec | true | Řetězec rozlišující malá a velká písmena, shoduje konec |
| !like$ | řetězec | true | Řetězec rozlišující malá a velká písmena, konec se neshoduje |
| ilike | řetězec | true | Řetězec necitlivý na malá a velká písmena, shoduje kdekoli |
| !ilike | řetězec | true | Řetězec necitlivý na malá a velká písmena, nikde se neshoduje |
| $ilike | řetězec | true | Řetězec nerozlišující malá a velká písmena, shoduje se na začátku |
| !$ilike | řetězec | true | Řetězec nerozlišuje velká a malá písmena, neshoduje se na začátku |
| ilike$ | řetězec | true | Řetězec nerozlišující malá a velká písmena, shoduje se na konci |
| !ilike$ | řetězec | true | Řetězec nerozlišující malá a velká písmena, neshoduje se na konci |
| gt | řetězec &#124; booleovský &#124; celé číslo &#124; plovoucí &#124; odběr (kontroluje velikost) &#124; datum | true | Větší než |
| ge | řetězec &#124; booleovský &#124; celé číslo &#124; plovoucí &#124; odběr (kontroluje velikost) &#124; datum | true | Větší než nebo rovno |
| lt | řetězec &#124; booleovský &#124; celé číslo &#124; plovoucí &#124; odběr (kontroluje velikost) &#124; datum | true | Menší než |
| le | řetězec &#124; booleovský &#124; celé číslo &#124; plovoucí &#124; odběr (kontroluje velikost) &#124; datum | true | Menší než nebo rovno |
| null | all | false | Vlastnost je nulová |
| !null | all | false | Vlastnost není nulová |
| empty | odběr | false | Odběr je prázdný |
| token | řetězec | true | Shoda na více tokenech ve vlastnosti vyhledávání |
| !token | řetězec | true | Neshoda u více tokenů ve vlastnosti vyhledávání |
| in | string &#124; boolean &#124; integer &#124; float &#124; date | true | Najděte objekty odpovídající 1 nebo více hodnotám |
| !in | string &#124; boolean &#124; integer &#124; float &#124; date | true | Najděte objekty, které neodpovídají 1 nebo více hodnotám |

Operators will be applied as logical *and* query. If you need a *or*
query, you can have a look at the *in* filter and the section below.
The filtering mechanism allows for recursion. See below for some examples.

Získejte datové prvky s ID vlastností ID1 nebo ID2:

    /api/dataElements?filter=id:eq:ID1&filter=id:eq:ID2

Get data elements, ignoring case, with name property MyDataElement:

    /api/dataElements?filter=name:ieq:mydataelement

Získejte všechny datové prvky, které mají datovou sadu s ID ID1:

    /api/dataElements?filter=dataSetElements.dataSet.id:eq:ID1

Get all data elements with aggregation operator *sum* and value type
*int*:

    /api/dataElements.json?filter=aggregationOperator:eq:sum&filter=type:eq:int

You can do filtering within collections, e.g. to get data elements which
are members of the *ANC* data element group you can use the following
query using the id property of the associated data element groups:

    /api/dataElements.json?filter=dataElementGroups.id:eq:qfxEYY9xAl6

To get data elements with a particular attribute value for a metadata 
attribute, a filter for the attribute ID and the attribute value can be 
specified using the same collection query syntax:

    /api/dataElements.json?filter=attributeValues.attribute.id:eq:n2xYlNbsfko&filter=attributeValues.value:eq:AFP

Get data elements which have any option set:

    /api/dataElements?filter=optionSet:!null

Since all operators are *and* by default, you can't find a data
element matching more than one id, for that purpose you can use the *in*
operator.

    /api/dataElements.json?filter=id:in:[fbfJHSPpUQD,cYeuwXTCPkU]

### Logické operátory { #webapi_metadata_logical_operator } 

As mentioned in the section before, the default logical operator applied
to the filters is *AND* which means that all object filters must be
matched. There are however cases where you want to match on one of
several filters (maybe id and code field) and in those cases, it is
possible to switch the root logical operator from *AND* to *OR*
using the *rootJunction* parameter.

Example: Normal filtering where both id and code must match to have a
result returned

    /api/dataElements.json?filter=id:in:[id1,id2]&filter=code:eq:code1

Example: Filtering where the logical operator has been switched to OR
and now only one of the filters must match to have a result
    returned

    /api/dataElements.json?filter=id:in:[id1,id2]&filter=code:eq:code1&rootJunction=OR

### Filtr identifikovatelných tokenů { #identifiable-token-filter } 

In addition to the specific property based filtering mentioned above,
we also have *token* based *AND* filtering across a set of
properties: id, code, and name (also shortName if available). These
properties are commonly referred to as *identifiable*. The idea is to
filter metadata whose id, name, code or short name containing something.

Example: Filter all data elements containing *2nd* in any of the
following: id,name,code, shortName

    /api/dataElements.json?filter=identifiable:token:2nd

Je také možné zadat více hodnot filtrování.

Příklad: Získejte všechny datové prvky, kde se *ANC visit* nachází v kterékoli z *identifikovatelných* vlastností. Systém vrací všechny datové prvky, kde se oba tokeny (ANC a návštěva) nacházejí kdekoli v identifikovatelných vlastnostech.

    /api/dataElements.json?filter=identifiable:token:ANC visit

It is also possible to combine the identifiable filter with property-based filter and expect the *rootJunction* to be applied.

    /api/dataElements.json?filter=identifiable:token:ANC visit&filter=displayName:ilike:tt1

    /api/dataElements.json?filter=identifiable:token:ANC visit
      &filter=displayName:ilike:tt1&rootJunction=OR

### Indexable only filter for tracked entity attributes { #indexable-only-filter-for-tracked-entity-attributes } 

For tracked entity attributes, there is a special filter in addition to the previous mentioned filtering capabilities. 
Some of the tracked entity attributes are candidates for creating a trigram index for better lookup performance. 
Using the *indexableOnly* parameter set to true, the results can be filtered to include only the attributes that are trigram indexable.

Example: Get all tracked entity attributes that are indexable.

    /api/trackedEntityAttributtes.json?indexableOnly=true

Additional filters along with the `indexableOnly` parameter can be specified.

Example: Get all tracked entity attributes where *ANC* is found in any of the *name* property. The system returns the tracked entity attributes where the name matches the provided keyword as well as if the attribute is indexable.

    /api/trackedEntityAttributtes.json?filter=name:like:ANC&indexableOnly=true

## Filtr pole metadat { #webapi_metadata_field_filter } 

In many situations, the default views of the metadata can be too
verbose. A client might only need a few fields from each object and want
to remove unnecessary fields from the response. To discover which fields
are available for each object please see the *schema* section.
In addition to the listed properties custom attributes can be included
for top level objects by using the attribute's ID as property name.

The format for include/exclude allows for infinite recursion. To filter
at the "root" level you can just use the name of the field,
i.e. `?fields=id,name` which would only display the `id` and
`name` fields for every object. For objects that are either collections or
complex objects with properties on their own, you can use the format
`?fields=id,name,dataSets[id,name]` which would return `id`, `name` of
the root, and the `id` and `name` of every data set on that object.
Negation can be done with the exclamation operator, and we have a set of
presets of field select. Both XML and JSON formats are supported.

**Příklad**: Získejte `id` a` name` ve zdroji indikátorů:

    /api/indicators?fields=id,name

**Example**: Get `id` and `name` from data elements, and `id` and `name`
from the associated data sets:

    /api/dataElements?fields=id,name,dataSets[id,name]

**Example**: Get `id`, `name` and the value of a user defined attribute 
with ID `DnrLSdo4hMl` for organisation units:

    /api/organisationUnits?fields=id,name,DnrLSdo4hMl

The attribute is then included as property `DnrLSdo4hMl` of each
matching object in the response. This can be renamed using the `rename` 
transformer as shown in the next section.

To exclude a field from the output you can use the exclamation `!`
operator. This is allowed anywhere in the query and will simply not
include that property as it might have been inserted in some of the
presets.

A few presets (selected fields groups) are available and can be applied
using the `:` operator.

Tabulka: operátory vlastností

| Operátor | Popis |
|---|---|
| <field-name\> | Zahrnout vlastnost s názvem, pokud existuje. |
| <object\>[<field-name\>, ...] | Zahrnuje pole buď v kolekci (bude použito na každý objekt v této kolekci), nebo jen na jednom objektu. |
| !<field-name\>, <object\>[!<field-name\> | Nezahrnujte tento název pole, funguje také uvnitř objektů/odběrů. Užitečné, když použijete předvolbu k zahrnutí polí. |
| \*, <object\>[\*] | Zahrnuje všechna pole na určitém objektu, pokud je použita na kolekci, bude zahrnovat všechna pole na všech objektech v dané kolekci. |
| :<preset\> | Alias pro výběr více polí. V současné době jsou k dispozici tři předvolby, popis naleznete v tabulce níže. |

Tabulka: Předvolby pole

| Preset | Popis |
|---|---|
| all | Všechna pole objektu |
| \* | Alias pro všechny |
| identifikovatelné | Includes id, name, code, created, lastUpdated and lastUpdatedBy fields |
| pojmenovatelné | Zahrnuje pole id, name, shortName, code, description, created a lastUpdated |
| trvalé | Vrací veškerou trvalou vlastnost na objektu, nebere v úvahu, pokud je objekt vlastníkem relace. |
| vlastník | Vrací veškerou trvalou vlastnost na objekt, kde je objekt vlastníkem všech vlastností, tuto datovou část lze použít k aktualizaci prostřednictvím rozhraní API. |

**Příklad**: Zahrňte všechna pole z datových sad kromě organizačních jednotek:

    /api/dataSets?fields=:all,!organisationUnits

**Příklad**: Zahrnout pouze ID, název a kolekci organizačních jednotek z datové sady, ale ID z organizačních jednotek vyloučit:

    /api/dataSets/BfMAe6Itzgt?fields=id,name,organisationUnits[:all,!id]

**Příklad**: Zahrňte pojmenovatelné vlastnosti ze všech indikátorů:

    /api/indicators.json?fields=:nameable

### Transformátory polí { #webapi_field_transformers } 

Transformace pole lze použít k transformaci vlastností. Syntaxe je popsána níže.

    /api/dataElements/ID?fields=id~rename(i),name~rename(n)

This will rename the *id* property to *i* and *name* property to *n*.

Na jednu vlastnost lze použít více transformátorů opakováním operátoru transformátoru:

    /api/dataElementGroups.json?fields=id,displayName,dataElements~isNotEmpty~rename(haveDataElements)

Podporované transformátory jsou popsány v tabulce níže.

Tabulka: Dostupné transformátory

| Název | Argumenty | Popis |
|---|---|---|
| velikost || Udává velikosti řetězců (délka) a sbírek |
| isEmpty || Je řetězec nebo sbírka prázdná |
| isNotEmpty || Není řetězec nebo sbírka prázdná |
| rename | Arg1: name | Přejmenuje název vlastnosti |
| stránkování | Arg1: page,Arg2: pageSize | Stránky kolekce, výchozí velikost stránky je 50. |
| pluck | Volitelný Arg1: fieldName | Převede pole objektů na pole vybraného pole tohoto objektu. Ve výchozím nastavení je použito první pole vrácené kolekcí (obvykle ID). |
| keyBy | Volitelný Arg1: fieldName | Převede pole objektů na objekt, kde je jako klíč použit název_pole (výchozí id). To může být užitečné například pro rychlé vyhledávání v JavaScriptu |

#### Příklady { #webapi_field_transformers_examples } 

Příklady použití transformátoru jsou uvedeny níže.

Získejte velikost sbírky:

    /api/dataElements?fields=dataSets~size

Otestujte, zda je kolekce prázdná:

    /api/dataElements?fields=dataSets~isEmpty

Otestujte, zda kolekce není prázdná:

    /api/dataElements?fields=dataSets~isNotEmpty

Přejmenovat vlastnosti:

    /api/dataElements/ID?fields=id~rename(i),name~rename(n)

Použít stránkování na kolekci:

    /api/dataElementGroups?fields=id,displayName,dataElements~paging(1;20)

Získejte pole s ID organizačních jednotek:

    /api/categoryOptions.json?fields=id,organisationUnits~pluck

Získejte pole s názvy organizačních jednotek:

    /api/categoryOptions.json?fields=id,organisationUnits~pluck[name]

Zadejte pole dataElements do pole `id`:

    /api/dataElementGroups.json?fields=id,name,dataElements~keyBy[id,name,valueType]

Zadejte pole dataElements pomocí pole `valueType`, protože vícenásobné požadavky budou mít za následek pole (datových prvků):

    /api/dataElementGroups.json?fields=id,name,dataElements~keyBy(valueType)[id,name,valueType]

## Vytváření, čtení, aktualizace, mazání, ověřování metadat { #webapi_metadata_crud } 

All metadata entities in DHIS2 have their own API endpoint which supports
*CRUD* operations (create, read, update and delete). The endpoint URLs
follows this format:

    /api/<entityName>

The _entityName_ uses the camel-case notation. As an example, the endpoint
for _data elements_ is:

    /api/dataElements

> **_NOTE:_**  When updating objects, all existing property values will be overwritten, even if the new value is null. Please use [JSON Patch API](#webapi_partial_updates) in case you want do partial update to an object.

### Vytvořit / aktualizovat parametry { #webapi_metadata_create_update } 

Následující parametry dotazu na dotaz jsou k dispozici ve všech koncových bodech metadat.

Tabulka: Dostupné filtry dotazů

| Param | Typ | Požadované | Možnosti (nejprve výchozí) | Popis |
|---|---|---|---|---|
| preheatCache | boolean | false | true &#124; false | Zapněte/vypněte předehřívání mapy mezipaměti. Toto je ve výchozím nastavení zapnuto. Vypnutím této možnosti se počáteční doba načítání importéru výrazně zkrátí (ale zpomalí se samotný import). To se většinou používá pro případy, kdy máte malý soubor XML/JSON, který chcete importovat, a nechcete čekat na předehřívání mapy mezipaměti. |
| importStrategy | enum | false | CREATE_AND_UPDATE &#124; CREATE &#124; UPDATE &#124; DELETE | Chcete -li použít strategii importu, další informace naleznete níže. |

### Vytváření a aktualizace objektů { #webapi_creating_updating_objects } 

For creating new objects you will need to know the endpoint, the type
format, and make sure that you have the required authorities. As an
example, we will create and update a *constant*. To figure out the
format, we can use the new *schema* endpoint for getting format
description. So we will start with getting that info:

    http://<server>/api/schemas/constant.json

From the output, you can see that the required authorities for create
are `F_CONSTANT_ADD`, and the important properties are: *name* and
*value*. From this, we can create a JSON payload and save it as a file
called constant.json:

```json
{
  "name": "PI",
  "value": "3.14159265359"
}
```

Stejný obsah jako datový obsah XML:

```xml
<constant name="PI" xmlns="http://dhis2.org/schema/dxf/2.0">
  <value>3.14159265359</value>
</constant>
```

We are now ready to create the new *constant* by sending a POST request to
the `constants` endpoint with the JSON payload using curl:

```bash
curl -d @constant.json "http://server/api/constants" -X POST
  -H "Content-Type: application/json" -u user:password
```

Konkrétní příklad zveřejnění konstanty na demo serveru:

```bash
curl -d @constant.json "https://play.dhis2.org/api/constants" -X POST
  -H "Content-Type: application/json" -u admin:district
```

Pokud vše proběhlo dobře, měli byste vidět výstup podobný:

```json
{
  "status": "SUCCESS",
  "importCount": {
    "imported": 1,
    "updated": 0,
    "ignored": 0,
    "deleted": 0
  },
  "type": "Constant"
}
```

The process will be exactly the same for updating, you make your changes
to the JSON/XML payload, find out the *ID* of the constant, and then
send a PUT request to the endpoint including ID:

```bash
curl -X PUT -d @pi.json -H "Content-Type: application/json"
  -u user:password "http://server/api/constants/ID"
```

### Mazání objektů { #webapi_deleting_objects } 

Deleting objects is very straight forward, you will need to know the
*ID* and the endpoint of the type you want to delete, let's continue our
example from the last section and use a *constant*. Let's assume that
the id is *abc123*, then all you need to do is the send the DELETE
request to the endpoint + id:

```bash
curl -X DELETE -u user:password "http://server/api/constants/ID"
```

Úspěšné odstranění by mělo vrátit stav HTTP 204 (žádný obsah).

### Přidávání a odebírání objektů ze sbírek { #webapi_adding_removing_objects_collections } 

The collections resource lets you modify collections of
objects.

#### Přidávání nebo odebírání jednotlivých objektů { #webapi_collections_adding_removing_single_objects } 

In order to add or remove objects to or from a collection of objects you
can use the following
    pattern:

    /api/{collection-object}/{collection-object-id}/{collection-name}/{object-id}

You should use the POST method to add, and the DELETE method to remove
an object. When there is a many-to-many relationship between objects,
you must first determine which object owns the relationship. If it isn't
clear which object this is, try the call both ways to see which works.

Součásti vzoru jsou:

  - collection object: The type of objects that owns the collection you
    chtít upravit.

  - collection object id: Identifikátor objektu, který vlastní
    collection you want to modify.

  - collection name: Název kolekce, kterou chcete upravit.

  - object id: Identifikátor objektu, který chcete přidat nebo odebrat
    from the collection.

As an example, in order to remove a data element with identifier IDB
from a data element group with identifier IDA you can do a DELETE
request:

    DELETE /api/dataElementGroups/IDA/dataElements/IDB

To add a category option with identifier IDB to a category with
identifier IDA you can do a POST
request:

    POST /api/categories/IDA/categoryOptions/IDB

#### Přidání nebo odebrání více objektů { #webapi_collections_adding_removing_multiple_objects } 

You can add or remove multiple objects from a collection in one request
with a payload like this:

```json
{
  "identifiableObjects": [{
      "id": "IDA"
    }, {
      "id": "IDB"
    }, {
      "id": "IDC"
    }
  ]
}
```

Pomocí tohoto datového obsahu můžete přidávat, nahrazovat nebo mazat položky:

*Přidávání položek:*

    POST /api/categories/IDA/categoryOptions

*Replacing Items:*

    PUT /api/categories/IDA/categoryOptions

*Delete
Items:*

    DELETE /api/categories/IDA/categoryOptions

#### Přidávání a odebírání objektů v jednom požadavku { #webapi_collections_adding_removing_objects_single_request } 

You can both add and remove objects from a collection in a single POST
request to the following URL:

    POST /api/categories/IDA/categoryOptions

Formát datového obsahu je:

```json
{
  "additions": [{
      "id": "IDA"
    }, {
      "id": "IDB"
    }, {
      "id": "IDC"
    }
  ],
  "deletions": [{
      "id": "IDD"
    }, {
      "id": "IDE"
    }, {
      "id": "IDF"
    }
  ]
}
```

### Ověřování datového obsahu { #webapi_validating_payloads } 

DHIS 2 podporuje systémovou validaci datového obsahu metadat, což znamená, že operace vytváření a aktualizace na koncových bodech API budou před povolením změn kontrolovány na platném datovém obsahu. Chcete-li zjistit, jaké validace platí pro konkrétní koncový bod, podívejte se na koncový bod `/api/schemas`, tj. chcete-li zjistit, jaká omezení má datový prvek, přejděte na `/api/schemas/dataElement`.

You can also validate your payload manually by sending it to the proper
schema endpoint. If you wanted to validate the constant from the create
section before, you would send it like this:

    POST /api/schemas/constant

Jednoduchý (nevalidující) příklad by byl:

```bash
curl -X POST -d "{\"name\": \"some name\"}" -H "Content-Type: application/json"
  -u admin:district "https://play.dhis2.org/dev/api/schemas/dataElement"
```

Což přinese výsledek:

```json
[
   {
      "message" : "Required property missing.",
      "property" : "type"
   },
   {
      "property" : "aggregationOperator",
      "message" : "Required property missing."
   },
   {
      "property" : "domainType",
      "message" : "Required property missing."
   },
   {
      "property" : "shortName",
      "message" : "Required property missing."
   }
]
```

### Částečné aktualizace { #webapi_partial_updates } 

Pro naše koncové body API, které se zabývají metadaty, podporujeme částečné aktualizace (PATCH) pomocí opravy JSON [standardní] (https://tools.ietf.org/html/rfc6902). Užitná zátěž v podstatě nastiňuje sadu operací, které chcete použít na existující objekt metadat. Podrobnosti a příklady oprav JSON najdete na [jsonpatch.com] (http://jsonpatch.com/). Podporovány jsou tři operátory: `add`, `remove` a `replace`.

Níže je uvedeno několik příkladů relevantních pro DHIS2. Všimněte si, že jakákoli aktualizace datové části by měla být považována za operaci HTTP PUT, tj. jakákoli mutace musí vést k platnému datovému obsahu metadat PUT.

Výchozí `importReportMode` pro opravu JSON je `ERRORS_NOT_OWNER`, což znamená, že při aktualizaci jakékoli vlastnosti, která není vlastněna tímto konkrétním objektem (například při pokusu o přidání skupiny indikátorů přímo do indikátoru), se zobrazí chyba.

Podle specifikace opravy JSON musíte při odesílání oprav vždy použít typ mime `application/json-patch+json`.

#### Příklady { #examples } 

##### Update name and value type of data element { #update-name-and-value-type-of-data-element } 

```
PATCH /api/dataElements/{id}
```

```json
[
  {"op": "add", "path": "/name", "value": "New Name"},
  {"op": "add", "path": "/valueType", "value": "INTEGER"}
] 
```

##### Add new data element to a data element group { #add-new-data-element-to-a-data-element-group } 

```
PATCH /api/dataElementGroups/{id}
```

```json
[
  {"op": "add", "path": "/dataElements/-", "value": {"id": "data-element-id"}}
]
```

##### Remove all data element associations from a data element group { #remove-all-data-element-associations-from-a-data-element-group } 

```
PATCH /api/dataElementGroups/{id}
```

```json
[
  {"op": "remove", "path": "/dataElements"}
]
```

##### Change domain and value type of a data element { #change-domain-and-value-type-of-a-data-element } 

```
PATCH /api/dataElements/{id}
```

```json
[
    {"op": "add", "path": "/domainType", "value": "TRACKER"},
    {"op": "add", "path": "/valueType", "value": "INTEGER"}
]
```

##### Remove a specific orgUnit from an orgUnit group { #remove-a-specific-orgunit-from-an-orgunit-group } 

```
PATCH /api/organisationUnitGroups/{id}
```

```json
[
  {"op": "remove", "path": "/organisationUnits/1"}
]
```

#### Blocked add dataElementGroup to dataElement { #blocked-add-dataelementgroup-to-dataelement } 

```
PATCH /api/dataElements/{id}?importReportMode=ERRORS_NOT_OWNER
```

```json
[
    {"op": "add", "path": "/dataElementGroups/-", "value": {"id": "data-element-group-id"}}
]
```

#### Blocked update name of dataElementGroup in dataElement { #blocked-update-name-of-dataelementgroup-in-dataelement } 

```
PATCH /api/dataElements/{id}?importReportMode=ERRORS_NOT_OWNER
```

```json
[
    {"op": "add", "path": "/dataElementGroups/0", "value": {"name": "new-name"}}
]
```
#### Remove collection item by id { #remove-collection-item-by-id } 

```
PATCH /api/dataSets/{id}?importReportMode=ERRORS_NOT_OWNER
```

```json
[
    {"op": "remove-by-id", "path": "/organisationUnits", "id": "u6CvKyF0Db5"}
]
```

#### Patch request with invalid path { #patch-request-with-invalid-path } 
Pokud je vlastnost `cesta` neplatná nebo neexistuje, opravná služba vrátí chybu, jak je uvedeno níže


```
PATCH /api/dataSets/{id}?importReportMode=ERRORS_NOT_OWNER
```

```json
[
    {"op": "remove-by-id", "path": "/test", "id": "u6CvKyF0Db5"}
]
```
Odezva
```json
{
    "httpStatus": "Bad Request",
    "httpStatusCode": 400,
    "status": "ERROR",
    "message": "Invalid path /test"
}
```

### Metadata CSV export { #webapi_metadata_csv_export } 

Field filtering works almost the same for CSV (please note that using CSV on the `/api/metadata` endpoint is not supported), but not that
field fransformations are not yet supported.

For endpoints that support CSV (our metadata endpoints like `/api/dataElements` `/api/organisationUnits`) you can either use the `Accept` header with
value `text/csv` or you can use the extension `.csv`. Be aware that complex objects are not supported, and we only support id-object collections (so a list of UIDs
will be returned).

| Název | Možnosti | Popis |
|---|---|---|
| pole | Stejné jako filtr pole metadat (s výše uvedenými výhradami) | Výchozí filtr je `id,displayName` |
| skipHeader | false/true | Má nebo nemá být zahrnuto záhlaví (s názvy sloupců).
| oddělovač | Výchozí: `.` | Oddělovač sloupců
| arraySeparator | Výchozí: `;` | Pokud je jedno z polí kolekce id-objektů, tento oddělovač oddělí všechna UID

#### Příklady { #examples } 

#### Get all data elements including their group associations { #get-all-data-elements-including-their-group-associations } 

```
/api/dataElements.csv?fields=id,displayName,dataElementGroups
```

#### Get all org units including geometry (which will get ignored) { #get-all-org-units-including-geometry-which-will-get-ignored } 

```
/api/organisationUnits.csv?fields=id,displayName,organisationUnitGroups,geometry
```

## Export metadat { #webapi_metadata_export } 

This section explains the metatada API which is available at
`/api/metadata`. XML and JSON resource representations are supported.

    /api/metadata

The most common parameters are described below in the "Export Parameter"
table. You can also apply this to all available types by using
`type:fields=<filter>` and `type:filter=<filter>`. You can also
enable/disable the export of certain types by setting `type=true|false`.

Tabulka: Parametr exportu

| Název | Možnosti | Popis |
|---|---|---|
| pole | Stejné jako filtr metadatového pole | Výchozí filtr pole platí pro všechny typy, výchozí je `:owner`. |
| filtr | Stejné jako objektový filtr metadat | Výchozí objektový filtr platí pro všechny typy, výchozí je `none`. |
| řazení | Stejné jako pořadí metadat | Výchozí pořadí platí pro všechny typy, výchozí je `název`, pokud je k dispozici, nebo `vytvořeno`, pokud není. |
| přeložit | false/true | Povolit překlady. Uvědomte si, že toto je ve výchozím nastavení vypnuto (v jiných koncových bodech je ve výchozím nastavení zapnuto). |
| národní prostředí | <locale\> | Přepněte z národního prostředí uživatele na své vlastní národní prostředí. |
| výchozí | INCLUDE/EXCLUDE | Má nebo nemá být automaticky generovaný objekt kategorie zahrnut do datového obsahu. Pokud přesouváte metadata mezi 2 nesynchronizovanými instancemi, může mít smysl nastavit toto na EXCLUDE, aby se usnadnila manipulace s těmito generovanými objekty. |
| skipSharing | false/true | Enabling this will strip the sharing properties from the exported objects. This includes *user*, *publicAccess*, *userGroupAccesses*, *userAccesses*, and *externalAccess*. |
| stažení | false/true | Povolením této možnosti se přidá hlavička HTTP Content-Disposition, která určuje, že data by měla být zpracována jako příloha a budou nabízena webovými prohlížeči jako stahování. |

### Příklady exportu metadat { #webapi_metadata_export_examples } 

Export all metadata. Be careful as the response might be very large depending
on your metadata configuration:

    /api/metadata

Export všech metadat seřazených podle lastUpdated sestupně:

    /api/metadata?defaultOrder=lastUpdated:desc

Exportujte metadata pouze včetně indikátorů a skupin indikátorů:

    /api/metadata?indicators=true&indicatorGroups=true

Export id a displayName pro všechny datové prvky, seřazené podle displayName:

    /api/metadata?dataElements:fields=id,name&dataElements:order=displayName:desc

Export datových prvků a indikátorů, kde název začíná „ANC“:

    /api/metadata?filter=name:^like:ANC&dataElements=true&indicators=true

### Export metadat se závislostmi { #webapi_dataset_program_export_dependencies } 

When you want to exchange metadata for a data set, program, category combo,
dashboard, option set or data element group
from one DHIS2 instance to another instance there are six dedicated endpoints available:

```
/api/dataSets/{id}/metadata.json

/api/programs/{id}/metadata.json

/api/categoryCombos/{id}/metadata.json

/api/dashboards/{id}/metadata.json

/api/optionSets/{id}/metadata.json

/api/dataElementGroups/{id}/metadata.json
```

Tyto exporty lze poté importovat pomocí `/api/metadata`.

Tyto koncové body také podporují následující parametry:

Tabulka: Parametr exportu

| Název | Možnosti | Popis |
|---|---|---|
| skipSharing | false/true | Enabling this will strip the sharing properties from the exported objects. This includes *user*, *publicAccess*, *userGroupAccesses*, *userAccesses*, and *externalAccess*. |
| stažení | false/true | Povolením této možnosti se přidá hlavička HTTP Content-Disposition, která určuje, že data by měla být zpracována jako příloha a budou nabízena webovými prohlížeči jako stahování. |

## Import metadat { #webapi_metadata_import } 

This section explains the metadata import API. XML and JSON resource
representations are supported. Metadata can be imported using a *POST* request.

    /api/metadata

The importer allows you to import metadata payloads which may include many
different entities and any number of objects per entity. The metadata export
generated by the metadata export API can be imported directly.

The metadata import endpoint support a variety of parameters, which are
listed below.

Tabulka: Parametr importu

| Název | Možnosti (první je výchozí) | Popis |
|---|---|---|
| importMode | COMMIT, VALIDATE | Nastavuje celkový režim importu, rozhoduje, zda metadata pouze `VALIDATE` nebo také `COMMIT`, má podobnou funkci jako náš starý příznak dryRun. |
| identifikátor | UID, CODE, AUTO | Nastavuje schéma identifikátoru, které se má použít pro porovnávání referencí. `AUTO` znamená nejprve zkusit `UID`, potom `CODE`. |
| importReportMode | ERRORS, FULL, DEBUG | Sets the `ImportReport` mode, controls how much is reported back after the import is done. `ERRORS` only includes *ObjectReports* for object which has errors. `FULL` returns an *ObjectReport* for all objects imported, and `DEBUG` returns the same plus a name for the object (if available). |
| preheatMode | REFERENCE, ALL, NONE | Sets the preheater mode, used to signal if preheating should be done for `ALL` (as it was before with *preheatCache=true*) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to `NONE` is not recommended. |
| importStrategy | CREATE_AND_UPDATE, CREATE, UPDATE, DELETE | Nastaví strategii importu, `CREATE_AND_UPDATE` se pokusí najít shodu s identifikátorem, pokud neexistuje, vytvoří objekt. |
| atomicMode | ALL, NONE | Sets atomic mode, in the old importer we always did a *best effort* import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the `NONE` mode emulated the old behavior. |
| flushMode | AUTO, OBJECT | Sets the flush mode, which controls when to flush the internal cache. It is *strongly* recommended to keep this to `AUTO` (which is the default). Only use `OBJECT` for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues). | 
| skipSharing | false, true | Přeskočit vlastnosti sdílení, nesloučit sdílení při provádění aktualizací a nepřidávat přístup ke skupině uživatelů při vytváření nových objektů. |
| skipValidation | false, true | Přeskočit ověření pro import. `NOT RECOMMENDED`. |
| async | false, true | Asynchronous import, returns immediately with a *Location* header pointing to the location of the *importReport*. The payload also contains a json object of the job created. |
| inclusionStrategy | NON_NULL, ALWAYS, NON_EMPTY | *NON_NULL* includes properties which are not null, *ALWAYS* include all properties, *NON_EMPTY* includes non empty properties (will not include strings of 0 length, collections of size 0, etc.) |
| userOverrideMode | NONE, CURRENT, SELECTED | Umožňuje přepsat uživatelskou vlastnost každého objektu, který importujete, možnosti jsou NONE (nedělat nic), CURRENT (použít importovaného uživatele), SELECTED (vybrat konkrétního uživatele pomocí overrideUser=X) |
| overrideUser | User ID | Pokud je userOverrideMode SELECTED, použijte tento parametr k výběru uživatele, u kterého chcete přepsat. |

> **NOTE** When updating objects, all property values will be overwritten even if the new values are `null`. Please use [JSON Patch API](#webapi_partial_updates) in case you want do partial update to an object.


An example of a metadata payload to be imported looks like this. Note how
each entity type have their own property with an array of objects:

```json
{
  "dataElements": [
    {
      "name": "EPI - IPV 3 doses given",
      "shortName": "EPI - IPV 3 doses given",
      "aggregationType": "SUM",
      "domainType": "AGGREGATE",
      "valueType": "INTEGER_ZERO_OR_POSITIVE"
    },
    {
      "name": "EPI - IPV 4 doses given",
      "shortName": "EPI - IPV 4 doses given",
      "aggregationType": "SUM",
      "domainType": "AGGREGATE",
      "valueType": "INTEGER_ZERO_OR_POSITIVE"
    }
  ],
  "indicators": [
    {
      "name": "EPI - ADS stock used",
      "shortName": "ADS stock used",
      "numerator": "#{LTb8XeeqeqI}+#{Fs28ZQJET6V}-#{A3mHIZd2tPg}",
      "numeratorDescription": "ADS 0.05 ml used",
      "denominator": "1",
      "denominatorDescription": "1",
      "annualized": false,
      "indicatorType": {
        "id": "kHy61PbChXr"
      }
    }
  ]
}
```

When posting this payload to the metadata endpoint, the response will contain
information about the parameters used during the import and a summary per
entity type including how many objects were created, updated, deleted and
ignored:

```json
{
  "importParams": {
    "userOverrideMode": "NONE",
    "importMode": "COMMIT",
    "identifier": "UID",
    "preheatMode": "REFERENCE",
    "importStrategy": "CREATE_AND_UPDATE",
    "atomicMode": "ALL",
    "flushMode": "AUTO",
    "skipSharing": false,
    "skipTranslation": false,
    "skipValidation": false,
    "metadataSyncImport": false,
    "firstRowIsHeader": true,
    "username": "UNICEF_admin"
  },
  "status": "OK",
  "typeReports": [
    {
      "klass": "org.hisp.dhis.dataelement.DataElement",
      "stats": {
        "created": 2,
        "updated": 0,
        "deleted": 0,
        "ignored": 0,
        "total": 2
      }
    },
    {
      "klass": "org.hisp.dhis.indicator.Indicator",
      "stats": {
        "created": 1,
        "updated": 0,
        "deleted": 0,
        "ignored": 0,
        "total": 1
      }
    }
  ],
  "stats": {
    "created": 3,
    "updated": 0,
    "deleted": 0,
    "ignored": 0,
    "total": 3
  }
}
```

## GeoJSON import <!-- DHIS2-EDIT:https://github.com/dhis2/dhis2-docs/edit/master/src/developer/web-api/geo-json.md --> { #geojson-import } 

Import GeoJSON se používá k připojení geometrických dat k organizačním jednotkám.

For a bulk import a GeoJSON file with a feature collection is expected.
Each feature in the collection requires a reference to the organisation unit it
should be linked to.

By default, the geometry from the file is stored as the `geometry` property of
an organisation unit. To store additional geometries attributes of type
`GEOJSON` can be created. When attributes are use all geometries from a file
are stored for the same attribute which is provided with an additional 
parameter `attributeId`.

### Hromadný import dat GeoJSON { #webapi_geojson_bulk_import }

Tabulka: Parametry importu

| Název              | Typ                           | Výchozí | Popis                                                                                                                       |
|-------------------|--------------------------------|---|-----------------------------------------------------------------------------------------------------------------------------------|
| `geoJsonId`       | `boolean`                      | `true` | Když se očekává, že `true`, vlastnost `id` funkcí GeoJSON bude obsahovat identifikátor organizační jednotky                        |
| `geoJsonProperty` | `String`                       | _undefined_ | Pokud je `geoJsonId` `false`, tento parametr pojmenuje vlastnost ve vlastnostech `properties` funkce GeoJSON, která obsahuje identifikátor organizační jednotky. |
| `orgUnitProperty` | `enum`: [`id`, `code`, `name`] | `id` | Vlastnost organizační jednotky, na kterou odkazují identifikátory použité v souboru GeoJSON                             |
| `attributeId`     | `String` | _undefined_ | When set the geometry is stored as value of the attribute referenced  by ID                                                       |
| `dryRun`          | `boolean` | `false` | Když je `true`, import je zpracován bez skutečné aktualizace organizačních jednotek |
| `async`           | `boolean` | `false` | Když je `true`, import je zpracován asnychronně |

Uasge:

    POST /api/organisationUnits/geometry

The post body is the GeoJSON file. Content type should be `application/json` or
`application/geo+json`. The file may be `.zip` or `.gzip` compressed.

For example, a default file where `id` is used to refer to an organisation unit 
id has this structure:

```json
{ 
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "id": "O6uvpzGd5pu",
      "geometry": { ... }
    },
    ...
  ]
}
```

A file where a feature property is used to refer to the organisation unit code
would have this structure:

```json
{ 
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "properties": { "code": "OU1_CODE" },
      "geometry": { ... }
    },
    ...
  ]
}
```
The `coordinates` in a `geometry` may be pairs or triplets. 
If a third dimension is present it is stripped during the import.

A `geometry` may also be `null` to effectively clear or delete the geometry 
for specific organisation units. There is a special bulk deletion API that is
described in the next section.

When run synchronously an import report is returned directly.
The HTTP status code is always `OK`, the `status` in the message payload
indicates if all rows were imported successfully.
The import counts statistics contained in the report give further information:

* `imported`: number of organisation units that were successfully updated with a geometry that did not have one before for the updated property
* `updated`: number of organisation units that were successfully updated with a geometry that did have value for the updated property already
* `ignored`: number of organisation units that failed to update
* `deleted`: number of organisation units that where successfully update with a _empty_ geometry

When the import is run asynchronous the request returns immediately with status 
`OK` and job configuration response that contains a relative reference to 
the task endpoint that allows to track the status of the asynchronous import.
For example:

    /api/system/tasks/GEOJSON_IMPORT/{job-id}

Souhrn, který je vrácen přímo pro synchronní spuštění, je k dispozici na adrese

    /api/system/taskSummaries/GEOJSON_IMPORT/{job-id}

jakmile je import dokončen.

### Hromadné mazání dat GeoJSON { #webapi_geojson_bulk_deletion }
To clear or unset the `geometry` data for all organisation units use:

    DELETE /api/organisationUnits/geometry

To clear or unset the geometry data for a specific `GEOJSON` attribute for
all organisation units use:

    DELETE /api/organisationUnits/geometry?attributeId={attr-id}

Clearing is always synchronous and returns a similar report as the bulk import.
It does not support any other parameters. No `dry-run` can be performed.
Bulk clearing requires the `F_PERFORM_MAINTENANCE` authority.

### GeoJSON Single Data Import { #webapi_geojson_single_import }
Samostatný import umožňuje aktualizovat geometrii jedné organizační jednotky.

    POST /api/organisationUnits/{id}/geometry

The post body only contains the GeoJSON `geometry` value, for example:
```json
{
  "type": "Polygon",
  "coordinates": [...]
}
```
Single import only supports `attributeId` and `dryRun` parameters.

### GeoJSON Single Data Deletion { #webapi_geojson_single_deletion }
To clear the `geometry` GeoJSON data of an individual organisation unit use:

    DELETE /api/organisationUnits/{id}/geometry

Similarly to clear a `GEOJSON` attribute value for an individual organisation 
unit use:

    DELETE /api/organisationUnits/{id}/geometry?attributeId={attr-id}

Clearing is always synchronous returns a similar report as single import.
The `dry-run` parameter is supported as well. 
The performing user requires authority to modify the target organisation unit.



## Schéma { #webapi_schema } 

A resource which can be used to introspect all available DXF 2 objects
can be found on `/api/schemas`. For specific resources you can have a
look at `/api/schemas/<type>`.

Chcete-li získat všechna dostupná schémata v XML:

    GET /api/schemas.xml

Chcete-li získat všechna dostupná schémata v JSON:

    GET /api/schemas.json

Postup získání schématu JSON pro konkrétní třídu:

    GET /api/schemas/dataElement.json


## Ikony { #webapi_icons } 

DHIS2 includes a collection of icons that can be used to give visual
context to metadata. There are two different kind of icons:
  - Default icons: they are pre-installed in the application and are not possible to modify nor delete.
  - Custom icons: can be created, updated and deleted at will.

Both of them be accessed through the icons resource.

    GET /api/icons

This endpoint returns a list of information about the available default and custom icons.
By default key, description, keywords and href will be included in response. But fields parameter can be used to change this behaviour.

```json
{
  key: "mosquito_outline",
  description: "Mosquito outline",
  keywords: [
    "malaria",
    "mosquito",
    "dengue"
  ],
  "created": "2024-02-12T09:50:11.794",
  "lastUpdated": "2024-02-12T09:50:11.794",
  href: "<dhis server>/api/icons/mosquito_outline/icon.svg"
}
```

It's also possible to get a particular icon directly by filtering by its key, in the example below, the key is mosquito_outline.

    GET /api/icons/mosquito_outline

### Custom icon operations { #webapi_icons_custom }

A list of custom icons can be fetched retrieved certain request parameters

    GET /api/icons?type=CUSTOM

|Parametr požadavku|Typ|Povolené hodnoty|Popis|
|---|---|---|---|
|`type`|`Text`| DEFAULT,CUSTOM,ALL |What type of icons should be retrieved. Default is ALL|
|`keys`|`Text`| | List of keys custom icons should be retrieved for | 
|`keywords`|`Text`| | List of keywords custom icons should be retrieved for| 
|`search`|`Text`| | Search for a given text across icon keys and keywords, and retrieve all icons that contain this text in their key or keywords.| 
|`createdStartDate`|`Date`| | Starting point of created date|
|`createdEndDate`|`Date`| | End point of created date| 
|`lastUpdatedStartDate`|`Date`| | Starting point of last updated date| 
|`lastUpdatedEndDate`|`Date`| | End point of last updated date| 


#### Request parameters for pagination { #request-parameters-for-pagination } 

|Parametr požadavku|Typ|Povolené hodnoty|Popis|
|---|---|---|---|
|`page`|`Integer`| Any positive integer |Page number to return. Defaults to 1 if missing|
|`pageSize`|`Integer`| Any positive integer |Page size. Defaults to 50. |
|`paging`|`Boolean`| `true`&#124;`false` |Indicates whether paging should be ignored and all rows should be returned. Defaults to `true`, meaning that by default all requests are paginated, unless `paging=false`|

#### Request parameters for ordering { #request-parameters-for-ordering } 

|Parametr požadavku|Typ|Povolené hodnoty|Popis|
|---|---|---|---|
|`order`|`Text`| created:desc | Comma-separated list of property name and sort direction pairs in format propName:sortDirection. By default icons will be ordered based on key:asc|


#### Request parameter to filter responses { #request-parameter-to-filter-responses } 

The endpoints accept a `fields` parameter which controls which fields will be returned in the
JSON response. `fields` parameter accepts a comma separated list of field names. If nothing is specified, default fields will be used and those are 

`key,keywords,description,fileResourceUid,createdByUserUid,href`

A custom icon resource can be downloaded by providing the icon key:

    GET /api/icons/{key}/icon

Custom icons can be created, modified and deleted.
To create a custom icon, use the resource below.

    POST /api/icons

It expects a payload containing the icon key, description, list of keywords and the file resource uid to be linked to the data.

```json
{
    "key": "iconKey",
    "description": "description",
    "keywords": ["keyword 1","keyword 2"],
    "fileResourceUid": "ARsqBjfB2cf"
}
```

Only custom icons can be updated using below resource. 

    PUT /api/icons

With the following payload, the icon's description and keywords would be updated.

```json
{
    "key": "iconKey",
    "description": "new description",
    "keywords": ["new keyword 1", "new keyword 2"] 
}
```

Please notice that's also possible to just update one of the two. That means in case we would like to update the description while keeping the keywords, we would just need to provide the icon key and the descripton json field. Same would work the other way around, to update the keywords and leave the original description untouched.

Only custom icon can be deleted using below resource.

    DELETE /api/icons/{icon_key}


## Typ vykreslení { #webapi_render_type } 

Some metadata types have a property named *renderType*. The render type
property is a map between a *device* and a *renderingType*. Applications
can use this information as a hint on how the object should be rendered
on a specific device. For example, a mobile device might want to render
a data element differently than a desktop computer.

V současné době jsou k dispozici dva různé druhy typů vykreslování:

1.  Vykreslení typu hodnoty

2.  Vykreslování části programové fáze

K dispozici jsou také 2 typy zařízení:

1.  MOBILE

2.  PLOCHA

The following table lists the metadata and rendering types available.
The value type rendering has addition constraints based on the metadata
configuration, which will be shown in a second table.

Tabulka: Přehled metadat a RenderingType

| Typ metadat | Dostupné typy vykreslování RenderingTypes |
|---|---|
| Sekce fáze programu | * LISTING (default)<br> * SEQUENTIAL<br> * MATRIX |
| Datový prvek | * DEFAULT<br> * DROPDOWN<br> * VERTICAL_RADIOBUTTONS<br> * HORIZONTAL_RADIOBUTTONS<br> * VERTICAL_CHECKBOXES<br> * HORIZONTAL_CHECKBOXES<br> * SHARED_HEADER_RADIOBUTTONS<br> * ICONS_AS_BUTTONS<br> * SPINNER<br> * ICON<br> * TOGGLE<br> * VALUE<br> * SLIDER<br> * LINEAR_SCALE<br> * AUTOCOMPLETE<br> * QR_CODE<br> * BAR_CODE<br> * GS1_DATAMATRIX |

Since handling the default rendering of data elements and tracked entity
attributes are depending on the value type of the object, there is also
a DEFAULT type to tell the client it should be handled as normal.
Program Stage Section is LISTING as default.

Tabulka: RenderingTypes povoleny na základě typů hodnot

| Typ hodnoty               | Je objekt sadou možností? | Povoleny typy vykreslování RenderingTypes |
|--------------------------|---|---|
| TRUE_ONLY                | Ne | DEFAULT, VERTICAL_RADIOBUTTONS, HORIZONTAL_RADIOBUTTONS, VERTICAL_CHECKBOXES, HORIZONTAL_CHECKBOXES, TOGGLE |
| BOOLEAN                  | Ne ||
| -                        | Ano | DEFAULT, DROPDOWN, VERTICAL_RADIOBUTTONS, HORIZONTAL_RADIOBUTTONS, VERTICAL_CHECKBOXES, HORIZONTAL_CHECKBOXES, SHARED_HEADER_RADIOBUTTONS, ICONS_AS_BUTTONS, SPINNER, ICON |
| INTEGER                  | Ne | DEFAULT, VALUE, SLIDER, LINEAR_SCALE, SPINNER |
| TEXT                     | Ne | DEFAULT, VALUE, AUTOCOMPLETE, QR_CODE, BAR_CODE, GS1_DATAMATRIX |
| INTEGER_POSITIVE         | Ne ||
| INTEGER_NEGATIVE         | Ne ||
| INTEGER_ZERO_OR_POSITIVE | Ne ||
| NUMBER                   | Ne ||
| UNIT_INTERVAL            | Ne ||
| PERCENTAGE               | Ne ||

A complete reference of the previous table can also be retrieved using
the following endpoint:

    GET /api/staticConfiguration/renderingOptions

Value type rendering also has some additional properties that can be
set, which is usually needed when rendering some of the specific types:

Tabulka: vlastnosti objektu renderType

| Vlastnictví | Popis | Typ |
|---|---|---|
| typ | RenderingType objektu, jak je vidět v první tabulce. Tato vlastnost je stejná pro typ hodnoty i pro sekci fáze programu, ale je jedinou vlastností dostupnou pro sekci fáze programu. | Výčet (viz seznam v tabulce Metadata a typ vykreslení) |
| min | Pouze pro vykreslování typu hodnoty. Představuje minimální hodnotu, kterou může toto pole mít. | Celé číslo |
| max | Pouze pro vykreslování typu hodnoty. Představuje maximální hodnotu, kterou toto pole může mít. | Celé číslo |
| krok | Pouze pro vykreslování typu hodnoty. Představuje velikost kroků, o které by se měla hodnota zvýšit, například pro SLIDER nebo LINEAR_SCALE | Celé číslo |
| decimalPoints | Pouze pro vykreslování typu hodnoty. Představuje počet desetinných míst, který má hodnota použít. | Celé číslo |

Při vytváření nebo aktualizaci metadat uvedených v první tabulce lze nastavit *renderingType*. Příklad datového obsahu pro typ vykreslování pro sekci fáze programu vypadá takto:

```json
{
  "renderingType": {
    "type": "MATRIX"
  }
}
```

Pro datový prvek a atribut trasované entity:

```json
{
  "renderingType": {
    "type": "SLIDER",
    "min": 0,
    "max": 1000,
    "step": 50,
    "decimalPoints": 0
  }
}
```

## Styl objektu { #webapi_object_style } 

Most metadata have a property names "style". This property can be used
by clients to represent the object in a certain way. The properties
currently supported by style is as follows:

Tabulka: Vlastnosti stylu

| Vlastnictví | Popis | Typ |
|---|---|---|
| color | Barva reprezentovaná šestnáctkovou soustavou. | String (#000000) |
| icon | Ikona reprezentovaná názvem ikony. | Řetězec |

Currently, there is no official list or support for icon-libraries, so
this is currently up to the client to provide. The following list shows
all objects that support style:

  - Datový prvek

  - Možnost kategorie datových prvků

  - Datová sada

  - Indikátor

  - Možnost

  - Program

  - Indikátor programu

  - Sekce programu

  - Fáze programu

  - Sekce fáze programu

  - Vztah (Trasovač)

  - Atribut trasované entity

  - Typ trasované entity

When creating or updating any of these objects, you can include the
following payload to change the style:

```json
{
  "style": {
    "color": "#ffffff",
    "icon": "my-beautiful-icon"
  }
}
```
## Category Option { #category-option } 

### Merge category options { #category_option_merge }

The category option merge endpoint allows you to merge a number of category options (sources) into a target category option.

#### Authorisation { #authorisation } 

The main authority required to perform a category option merge is `F_CATEGORY_OPTION_MERGE`.  
Other authorities required relate to the general sharing and access of category options, `F_CATEGORY_OPTION_PUBLIC_ADD` and `F_CATEGORY_OPTION_DELETE`.

#### Request { #request } 

Merge category options with a POST request:

```
POST /api/categoryOptions/merge
```

Užitná zátěž ve formátu JSON vypadá takto:

```json
{
  "sources": [
    "FbLZS3ueWbQ",
    "dPSWsKeAZNw"
  ],
  "target": "rEq3Hkd3XXH",
  "deleteSources": true
}
```

Vlastnosti JSON jsou popsány v následující tabulce.

Tabulka: Sloučit pole datového obsahu

| Pole             | Požadované | Hodnota                                                                                                                                                                                   |
|-------------------|----------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| zdroje           | Ano      | Array of identifiers of the category options to merge (the source category options)                                                                                                     |
| cíl            | Ano      | Identifier of the category option to merge the sources into (the target category option)                                                                                                |
| deleteSources     | Ne       | Whether to delete the source category options after the operation. Default is false.                                                                                                    |

The merge operation will merge the source category options into the target category option. One or many source category options can be specified. Only one target should be specified.

The merge operation will transfer all source category option metadata associations to the target category option.
The following metadata get updated:


| Metadata            | Vlastnictví        | Action taken               |
|---------------------|-----------------|----------------------------|
| Kategorie            | categoryOptions | remove sources, add target |
| CategoryDimension   | items           | remove sources, add target |
| CategoryOptionCombo | categoryOptions | remove sources, add target |
| CategoryOptionGroup | members         | remove sources, add target |
| OrganisationUnit    | categoryOptions | remove sources, add target |


#### Validation { #validation } 

Platí následující omezení a chybové kódy.

Tabulka: Omezení a chybové kódy

| Chybový kód | Popis                                               |
|------------|-----------------------------------------------------------|
| E1650      | At least one source category option must be specified     |
| E1651      | Target category option must be specified                  |
| E1652      | Target category option cannot be a source category option |
| E1653      | Source/Target category option does not exist: `{uid}`     |


#### Odpověď { #response }
##### Success { #success } 
Sample success response looks like:

```json
{
    "httpStatus": "OK",
    "httpStatusCode": 200,
    "status": "OK",
    "response": {
        "mergeReport": {
            "mergeErrors": [],
            "mergeType": "CATEGORY_OPTION",
            "sourcesDeleted": [
                "FbLZS3ueWbQ", "dPSWsKeAZNw"
            ],
            "message": "CATEGORY_OPTION merge complete"
        }
    }
}
```

##### Failure { #failure } 
Sample error response looks like:

```json
{
    "httpStatus": "Conflict",
    "httpStatusCode": 409,
    "status": "WARNING",
    "message": "One or more errors occurred, please see full details in merge report.",
    "response": {
        "mergeReport": {
            "mergeErrors": [
                {
                    "message": "At least one source category options must be specified",
                    "errorCode": "E1650",
                    "args": []
                },
                {
                    "message": "Target category option does not exist: `abcdefg1221`",
                    "errorCode": "E1653",
                    "args": [
                        "Target",
                        "abcdefg1221"
                    ]
                }
            ],
            "mergeType": "CATEGORY_OPTION",
            "sourcesDeleted": [],
            "message": "CATEGORY_OPTION merge has errors"
        }
    }
}
```


## Datové prvky { #data-elements } 

### Merge data elements { #data_element_merge }

> **Caution**
>
> Merging DataElements should be carried out with the utmost care. Particular attention
> should be given to the merging of data values that have data element references involved in the
> merge. Knowing the potential side effects of a merge should be fully understood before performing
> the merge. The merging of DataElements has far-reaching effects. The information below
> will try to help show what's involved in a DataElement merge. A DataElement merge
> touches all the major parts of the system (metadata, data, tracker, analytics and audit).
> 
> System performance may be impacted if the source DataElements are linked to large amounts of Data/Audit records particularly.

The data element merge endpoint allows you to merge a number of data elements (sources) into a target data element.

#### Authorisation { #authorisation } 

The main authority required to perform a data element merge is `F_DATA_ELEMENT_MERGE`.  
Other authorities required relate to the general sharing and access of data elements, `F_DATAELEMENT_PUBLIC_ADD` and `F_DATAELEMENT_DELETE`.

#### Request { #request } 

Merge data elements with a POST request:

```
POST /api/dataElements/merge
```

Užitná zátěž ve formátu JSON vypadá takto:

```json
{
  "sources": [
    "jNb63DIHuwU",
    "WAjjFMDJKcx"
  ],
  "target": "V9rfpjwHbYg",
  "deleteSources": true,
  "dataMergeStrategy": "DISCARD"
}
```

Vlastnosti JSON jsou popsány v následující tabulce.

Tabulka: Sloučit pole datového obsahu

| Pole             | Požadované | Hodnota                                                                                                                                                                                   |
|-------------------|----------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| zdroje           | Ano      | Array of identifiers of the data elements to merge (the source data elements)                                                                                                           |
| cíl            | Ano      | Identifier of the data element to merge the sources into (the target data element)                                                                                                      |
| deleteSources     | Ne       | Whether to delete the source data elements after the operation. Default is false. If true is chosen, then all source audit records will also be deleted.                                |
| dataMergeStrategy | Ano      | How to handle merging of data values. Options are 'DISCARD' or 'LAST_UPDATED'. DISCARD will delete all source data values. LAST_UPDATED will use the data value which was last updated. |

The merge operation will merge the source data elements into the target data element. One or many source data elements can be specified. Only one target should be specified.

The merge operation will transfer all source data element metadata associations to the target data element.
The following metadata get updated:


| Metadata                          | Vlastnictví                  | Action taken               |
|-----------------------------------|---------------------------|----------------------------|
| DataDimensionItem                 | dataElement               | set to target              |
| EventVisualization                | dataElementValueDimension | set to target              |
| ProgramStageDataElement           | dataElement               | set to target              |
| ProgramNotificationTemplate       | recipientDataElement      | set to target              |
| ProgramRuleVariable               | dataElement               | set to target              |
| ProgramRuleAction                 | dataElement               | set to target              |
| TrackedEntityDataElementDimension | dataElement               | set to target              |
| MinMaxDataElement                 | dataElement               | set to target              |
| SMSCode                           | dataElement               | set to target              |
| SMSCode                           | dataElement               | set to target              |
| Prediktor                         | output                    | set to target              |
| DataSetElement                    | dataElement               | set to target              |
| DataElementOperand                | dataElement               | set to target              |
| ProgramStageDataElement           | dataElements              | remove sources, add target |
| Sekce                           | dataElements              | remove sources, add target |
| DataElementGroup                  | members                   | remove sources, add target |
| událost                             | eventDataValues           | remove sources, add target |
| Indikátor                         | čitatel                 | replace source with target |
| Indikátor                         | jmenovatel               | replace source with target |
| Prediktor                         | generator                 | replace source with target |
| Prediktor                         | sampleSkipTest            | replace source with target |
| DataEntryForm                     | htmlCode                  | replace source with target |
| ProgramIndicator                  | expression                | replace source with target |
| ProgramIndicator                  | filtr                    | replace source with target |
| DataValue                         | dataElement               |                            |


| Data                            | Vlastnictví        | Action taken                                                                                                                                                                                             |
|---------------------------------|-----------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| událost                           | eventDataValues | action based on merge strategy (DISCARD / LAST_UPDATED). DISCARD will delete all source event data values. LAST_UPDATED will use the event data value which was last updated, when more than one exists. |
| DataValue                       | dataElement     | action based on merge strategy (DISCARD / LAST_UPDATED). DISCARD will delete all source data values. LAST_UPDATED will use the data value which was last updated, when more than one exists.             |
| TrackedEntityDataValueChangeLog |                 | deleted if sources are being deleted, otherwise no action.                                                                                                                                               |
| DataValueAudit                  |                 | deleted if sources are being deleted, otherwise no action.                                                                                                                                               |


#### Validation { #validation } 

Platí následující omezení a chybové kódy.

Tabulka: Omezení a chybové kódy

| Chybový kód | Popis                                                                                                                                 |
|------------|---------------------------------------------------------------------------------------------------------------------------------------------|
| E1550      | At least one source data element must be specified                                                                                          |
| E1551      | Target data element must be specified                                                                                                       |
| E1552      | Target data element cannot be a source indicator                                                                                            |
| E1553      | Source/Target data element does not exist: `{uid}`                                                                                          |
| E1554      | All source ValueTypes must match target ValueType: `ValueType`. Other ValueTypes found: `ValueType`                                         |
| E1555      | All source DataElementDomains must match target DataElementDomain: `DataElementDomain`. Other DataElementDomains found: `DataElementDomain` |
| E1556      | dataMergeStrategy field must be specified. With value `DISCARD` or `LAST_UPDATED`                                                           |

#### Database constraints { #database-constraints } 
There are unique constraints in place that can prevent a successful merge. These constraints are set by DHIS2 in order to maintain a logical domain model.    
Below are a list of the known database unique key constraints at the time of writing. For example, you
can only have 1 data set element with the same dataset and data element.

Table: Database table unique key constraints

| Tabulka                   | Unique key constraint                     |
|-------------------------|-------------------------------------------|
| minmaxdataelement       | orgunit, dataelement, categoryoptioncombo |
| programstagedataelement | programstage, dataelement                 |
| datasetelement          | dataset, dataelement                      |


#### Odpověď { #response }
##### Success { #success } 
Sample success response looks like:

```json
{
    "httpStatus": "OK",
    "httpStatusCode": 200,
    "status": "OK",
    "response": {
        "mergeReport": {
            "mergeErrors": [],
            "mergeType": "DATA_ELEMENT",
            "sourcesDeleted": [
                "vQ0dGV9EDrw"
            ],
            "message": "DATA_ELEMENT merge complete"
        }
    }
}
```

##### Failure { #failure } 
Sample error response looks like:

```json
{
    "httpStatus": "Conflict",
    "httpStatusCode": 409,
    "status": "WARNING",
    "message": "One or more errors occurred, please see full details in merge report.",
    "response": {
        "mergeReport": {
            "mergeErrors": [
                {
                    "message": "At least one source data element must be specified",
                    "errorCode": "E1550",
                    "args": []
                },
                {
                    "message": "Target data element does not exist: `abcdefg1221`",
                    "errorCode": "E1553",
                    "args": [
                        "Target",
                        "abcdefg1221"
                    ]
                }
            ],
            "mergeType": "DATA_ELEMENT",
            "sourcesDeleted": [],
            "message": "DATA_ELEMENT merge has errors"
        }
    }
}
```

Another sample validation error response:

```json
{
    "httpStatus": "Conflict",
    "httpStatusCode": 409,
    "status": "WARNING",
    "message": "One or more errors occurred, please see full details in merge report.",
    "response": {
        "mergeReport": {
            "mergeErrors": [
                {
                    "message": "All source ValueTypes must match target ValueType: `TEXT`. Other ValueTypes found: `NUMBER`",
                    "errorCode": "E1554",
                    "args": []
                }
            ],
            "mergeType": "DATA_ELEMENT",
            "sourcesDeleted": [],
            "message": "DATA_ELEMENT merge has errors"
        }
    }
}
```

A database constraint sample error response:

```json
{
  "httpStatus": "Conflict",
  "httpStatusCode": 409,
  "status": "ERROR",
  "message": "ERROR: duplicate key value violates unique constraint \"minmaxdataelement_unique_key\"\n  Detail: Key (sourceid, dataelementid, categoryoptioncomboid)=(193236, 1148617, 167661) already exists."
}
```

## Indikátory { #webapi_indicators } 

Tato část popisuje indikátory a výrazy indikátorů.

### Agregované indikátory { #webapi_aggregate_indicators } 

To retrieve indicators you can make a GET request to the indicators
resource like this:

    /api/indicators

Indikátory představují výrazy, které lze vypočítat a prezentovat jako výsledek. Výrazy indikátorů se dělí na čitatele a jmenovatele. Čitatelé a jmenovatelé jsou matematické výrazy, které mohou obsahovat odkazy na datové prvky, jiné indikátory, konstanty a skupiny organizačních jednotek. Proměnné budou při použití např. ve výkazech nahrazeny hodnotami dat. Proměnné, které jsou ve výrazech povoleny, jsou popsány v následující tabulce.

Tabulka: Indikátorové proměnné

| Proměnná | Objekt | Popis |
|---|---|---|
| #{<data-element-id\>.<category-option-combo-id\>.<attribute-option-combo-id\>} | Operand datového prvku | Odkazuje na kombinaci agregovaného datového prvku a kombinace možností kategorie. Id kombinace možností kategorie i atributu jsou volitelné a k označení jakékoli hodnoty lze použít zástupný znak „\*“. |
| #{<dataelement-id\>.<category-option-group-id\>.<attribute-option-combo-id\>} | Skupina možností kategorií | Odkazuje na agregovaný datový prvek a skupinu možností kategorie obsahující více kombinací možností kategorie. |
| #{<data-element-id\>} | Agregovaný datový prvek | Odkazuje na celkovou hodnotu agregovaného datového prvku ve všech kombinacích možností kategorií. |
| D{<program-id\>.<data-element-id\>} | Datový prvek programu | Odkazuje na hodnotu datového prvku trasovače v programu. |
| A{<program-id\>.<attribute-id\>} | Atribut trasované entity programu | Odkazuje na hodnotu atributu trasované entity v rámci programu. |
| I{<program-indicator-id\>} | Indikátor programu | Odkazuje na hodnotu indikátoru programu. |
| R{<dataset-id\>.<metric\>} | četnost hlášení | Odkazuje na metriku rychlosti vykazování. Metrika může být REPORTING_RATE, REPORTING_RATE_ON_TIME, ACTUAL_REPORTS, ACTUAL_REPORTS_ON_TIME, EXPECTED_REPORTS. |
| C{<constant-id\>} | Konstantní | Odkazuje na konstantní hodnotu. |
| N{<indicator-id\>} | Indikátor | Odkazuje na existující indikátor. |
| OUG{<orgunitgroup-id\>} | Skupina organizační jednotky | Odkazuje na počet organizačních jednotek ve skupině organizačních jednotek. |

V rámci operandu datového prvku nebo agregovaného datového prvku lze provést následující substituce:

| Položka | Hodnota | Popis |
|---|---|---|
| data-element-id | data-element-id | Souhrnný datový prvek |
| data-element-id | deGroup:data-element-group-id | Všechny agregované datové prvky ve skupině datových prvků |
| category-option-combo-id | category-option-combo-id | Kombinace možností kategorie |
| category-option-combo-id | co:category-option-id | Všechny kombinace možností kategorie v možnosti kategorie |
| category-option-combo-id | coGroup:category-option-group-id | Všechny kombinace možností kategorie ve skupině možností kategorie |
| category-option-combo-id | coGroup:co-group-id1&co-group-id2... | Všechny kombinace možností kategorií, které jsou členy více skupin možností kategorií |

Syntaxe vypadá jako
    toto:

    #{<dataelement-id>.<catoptcombo-id>} + C{<constant-id>} + OUG{<orgunitgroup-id>}

Odpovídající příklad vypadá takto:

    #{P3jJH5Tu5VC.S34ULMcHMca} + C{Gfd3ppDfq8E} + OUG{CXw2yu5fodb}

Note that for data element variables the category option combo
identifier can be omitted. The variable will then represent the total
for the data element, e.g. across all category option combos. Example:

    #{P3jJH5Tu5VC} + 2

Data element operands can include any of category option combination and
attribute option combination, and use wildcards to indicate any
    value:

    #{P3jJH5Tu5VC.S34ULMcHMca} + #{P3jJH5Tu5VC.*.j8vBiBqGf6O} + #{P3jJH5Tu5VC.S34ULMcHMca.*}

Příklad použití skupiny datových prvků:

    #{deGroup:oDkJh5Ddh7d} + #{deGroup:GBHN1a1Jddh.j8vBiBqGf6O}

Příklad použití možností kategorie, skupiny datových prvků a skupiny možností kategorie:

    #{P3jJH5Tu5VC.co:FbLZS3ueWbQ} + #{deGroup:GBHN1a1Jddh.coGroup:OK2Nr4wdfrZ.j8vBiBqGf6O}

Příklad použití více skupin možností kategorií:

    #{P3jJH5Tu5VC.coGroup:OK2Nr4wdfrZ&j3C417uW6J7&ddAo6zmIHOk}

Příklad s použitím datového prvku programu a atributu programu:

    ( D{eBAyeGv0exc.vV9UWAZohSf} * A{IpHINAT79UW.cejWyOfXge6} ) / D{eBAyeGv0exc.GieVkTxp4HH}

Příklad kombinace programových indikátorů a souhrnných indikátorů:

    I{EMOt6Fwhs1n} * 1000 / #{WUg3MYWQ7pt}

Příklad použití četnosti hlášení zpráv:

    R{BfMAe6Itzgt.REPORTING_RATE} * #{P3jJH5Tu5VC.S34ULMcHMca}

Další příklad četnosti hlášení zpráv využívající skutečné hlášení zpráv datových souborů a očekávané hlášení zpráv:

    R{BfMAe6Itzgt.ACTUAL_REPORTS} / R{BfMAe6Itzgt.EXPECTED_REPORTS}

Příklad použití existujícího indikátoru:

    N{Rigf2d2Zbjp} * #{P3jJH5Tu5VC.S34ULMcHMca}

Expressions can be any kind of valid mathematical expression, as an
example:

    ( 2 * #{P3jJH5Tu5VC.S34ULMcHMca} ) / ( #{FQ2o8UBlcrS.S34ULMcHMca} - 200 ) * 25

### Indikátory programu { #webapi_program_indicators } 

To retrieve program indicators you can make a GET request to the program
indicators resource like this:

    /api/programIndicators

Program indicators can contain information collected in a program.
Indicators have an expression which can contain references to data
elements, attributes, constants and program variables. Variables which
are allowed in expressions are described in the following table.



Tabulka: proměnné Programového indikátoru

| Proměnná | Popis |
|---|---|
| #{<programstage-id\>.<dataelement-id\>} | Odkazuje na kombinaci fáze programu a id datového prvku. |
| A{<attribute-id\>} | Odkazuje na atribut trasované entity. |
| V{<variable-id\>} | Odkazuje na proměnnou programu. |
| C{<constant-id\>} | Odkazuje na konstantu. |

Syntaxe vypadá jako
    toto:

    #{<programstage-id>.<dataelement-id>} + #{<attribute-id>} + V{<varible-id>} + C{<constant-id>}

Odpovídající příklad vypadá takto:

    #{A03MvHHogjR.a3kGcGDCuk6} + A{OvY4VVhSDeJ} + V{incident_date} + C{bCqvfPR02Im}

### Výrazy { #webapi_expressions } 

Expressions are mathematical formulas which can contain references to
data elements, constants and organisation unit groups. To validate and
get the textual description of an expression, you can make a GET request
to the expressions resource:

    /api/expressions/description?expression=<expression-string>

The response follows the standard JSON web message format. The *status*
property indicates the outcome of the validation and will be "OK" if
successful and "ERROR" if failed. The *message* property will be "Valid"
if successful and provide a textual description of the reason why the
validation failed if not. The *description* provides a textual
description of the expression.

```json
{
  "httpStatus": "OK",
  "httpStatusCode": 200,
  "status": "OK",
  "message": "Valid",
  "description": "Acute Flaccid Paralysis"
}
```

### Merge indicators { #webapi_indicator_merge }

The indicator merge endpoint allows you to merge a number of indicators (sources) into a target indicator.

#### Authorisation { #authorisation } 

The authority `F_INDICATOR_MERGE` is required to perform indicator merges.

#### Request { #request } 

Merge indicators with a POST request:

```
POST /api/indicators/merge
```

Užitná zátěž ve formátu JSON vypadá takto:

```json
{
  "sources": [
    "jNb63DIHuwU",
    "WAjjFMDJKcx"
  ],
  "target": "V9rfpjwHbYg",
  "deleteSources": true
}
```

Vlastnosti JSON jsou popsány v následující tabulce.

Tabulka: Sloučit pole datového obsahu

| Pole         | Požadované | Hodnota                                                                         |
|---------------|----------|-------------------------------------------------------------------------------|
| zdroje       | Ano      | Array of identifiers of the indicators to merge (the source indicators)       |
| cíl        | Ano      | Identifier of the indicator to merge the sources into (the target indicator)  |
| deleteSources | Ne       | Whether to delete the source indicators after the operation. Default is false |

The merge operation will merge the source indicators into the target indicator. One or many source indicators can be specified. Only one target should be specified.

The merge operation will transfer all source indicator metadata associations to the target indicator. 
The following metadata get updated:


| Metadata            | Vlastnictví                                   | Action taken                                                                |
|---------------------|--------------------------------------------|-----------------------------------------------------------------------------|
| IndicatorGroup      | members                                    | Source indicator removed, target indicator added                            |
| DataSet             | indikátory                                 | Source indicator removed, target indicator added                            |
| DataDimensionalItem | n/a                                        | Any linked data items with sources will be linked with the target           |
| Sekce             | indikátory                                 | Source indicator removed, target indicator added                            |
| Konfigurace       | infrastructuralIndicators (IndicatorGroup) | Source indicator removed, target indicator added                            |
| Indikátor           | numerator / denominator                    | Replace any source reference with the target reference                      |
| DataEntryForm       | htmlCode                                   | Replace any source reference with the target reference                      |
| Vizualizace       | sorting                                    | Replace any source reference with the target reference as Sorting dimension |


#### Validation { #validation } 

Platí následující omezení a chybové kódy.

Tabulka: Omezení a chybové kódy

| Chybový kód | Popis                                     |
|------------|-------------------------------------------------|
| E1540      | At least one source indicator must be specified |
| E1541      | Target indicator must be specified              |
| E1542      | Target indicator cannot be a source indicator   |
| E1543      | Source/Target indicator does not exist: `{uid}` |

#### Odpověď { #response }
##### Success { #success } 
Sample success response looks like:

```json
{
    "httpStatus": "OK",
    "httpStatusCode": 200,
    "status": "OK",
    "response": {
        "mergeReport": {
            "mergeErrors": [],
            "mergeType": "INDICATOR",
            "sourcesDeleted": [
                "vQ0dGV9EDrw"
            ],
            "message": "INDICATOR merge complete"
        }
    }
}
```

Sample error response looks like:

```json
{
    "httpStatus": "Conflict",
    "httpStatusCode": 409,
    "status": "WARNING",
    "message": "One or more errors occurred, please see full details in merge report.",
    "response": {
        "mergeReport": {
            "mergeErrors": [
                {
                    "message": "At least one source indicator must be specified",
                    "errorCode": "E1540",
                    "args": []
                },
                {
                    "message": "Target indicator does not exist: `abcdefg1221`",
                    "errorCode": "E1543",
                    "args": [
                        "Target",
                        "abcdefg1221"
                    ]
                }
            ],
            "mergeType": "INDICATOR",
            "sourcesDeleted": [],
            "message": "INDICATOR merge has errors"
        }
    }
}
```

## Indicator Types { #webapi_indicator_types}

### Merge indicator types { #webapi_indicator_type_merge}

The indicator type merge endpoint allows you to merge a number of indicator types into a target indicator type.

#### Authorisation { #authorisation } 

The authority `F_INDICATOR_TYPE_MERGE` is required to perform indicator type merges.

#### Request { #request } 

Merge indicator types with a POST request:

```
POST /api/indicatorTypes/merge
```

Užitná zátěž ve formátu JSON vypadá takto:

```json
{
  "sources": [
    "jNb63DIHuwU",
    "WAjjFMDJKcx"
  ],
  "target": "V9rfpjwHbYg",
  "deleteSources": true
}
```

Vlastnosti JSON jsou popsány v následující tabulce.

Tabulka: Sloučit pole datového obsahu

| Pole         | Požadované | Hodnota                                                                                   |
|---------------|----------|-----------------------------------------------------------------------------------------|
| zdroje       | Ano      | Array of identifiers of the indicator types to merge (the source indicator types).      |
| cíl        | Ano      | Identifier of the indicator type to merge the sources into (the target indicator type). |
| deleteSources | Ne       | Whether to delete the source indicator types after the operation. Default is false.     |

The merge operation will merge the source indicator types into the target indicator type. One or many source indicator types can be specified. Only one target should be specified.

The merge operation will transfer all of the indicator metadata associations to the source indicator types over to the target indicator type.

#### Validation { #validation } 

Platí následující omezení a chybové kódy.

Tabulka: Omezení a chybové kódy

| Chybový kód | Popis                                             |
|------------|---------------------------------------------------------|
| E1530      | At least one source indicator type must be specified    |
| E1531      | Target indicator type must be specified                 |
| E1532      | Target indicator type cannot be a source indicator type |
| E1533      | Source/Target indicator type does not exist: `{uid}`    |

#### Odpověď { #response }
##### Success { #success } 
Sample success response looks like:

```json
{
    "httpStatus": "OK",
    "httpStatusCode": 200,
    "status": "OK",
    "response": {
        "mergeReport": {
            "mergeErrors": [],
            "mergeType": "INDICATOR_TYPE",
            "sourcesDeleted": [
                "vQ0dGV9EDrw"
            ],
            "message": "INDICATOR_TYPE merge complete"
        }
    }
}
```

Sample error response looks like:

```json
{
    "httpStatus": "Conflict",
    "httpStatusCode": 409,
    "status": "WARNING",
    "message": "One or more errors occurred, please see full details in merge report.",
    "response": {
        "mergeReport": {
            "mergeErrors": [
                {
                    "message": "At least one source indicator type must be specified",
                    "errorCode": "E1530",
                    "args": []
                },
                {
                    "message": "Target indicator type does not exist: `abcdefg1221`",
                    "errorCode": "E1533",
                    "args": [
                        "Target",
                        "abcdefg1221"
                    ]
                }
            ],
            "mergeType": "INDICATOR_TYPE",
            "sourcesDeleted": [],
            "message": "INDICATOR_TYPE merge has errors"
        }
    }
}
```

## Organizační jednotky { #webapi_organisation_units } 

The *organisationUnits* resource follows the standard conventions as
other metadata resources in DHIS2. This resource supports some
additional query parameters.

### Získejte seznam organizačních jednotek { #webapi_list_of_organisation_units } 

Chcete-li získat seznam organizačních jednotek, můžete použít následující zdroj.

    /api/33/organisationUnits

Tabulka: Parametry dotazu organizačních jednotek

| Parametr dotazu | Možnosti | Popis |
|---|---|---|
| userOnly | false &#124; true | Sběr dat Organizační jednotky spojené pouze s aktuálním uživatelem. |
| userDataViewOnly | false &#124; true | Zobrazení dat Organizační jednotky spojené pouze s aktuálním uživatelem. |
| userDataViewFallback | false &#124; true | Organizační jednotky zobrazení dat přidružené k aktuálnímu uživateli pouze se záložními organizačními jednotkami pro sběr dat. |
| query | řetězec | Dotaz na vlastnosti názvu, kódu a ID. |
| level | celé číslo | Organizační jednotky na dané úrovni v hierarchii. |
| maxLevel | celé číslo | Organizační jednotky na dané maximální úrovni nebo úrovních výše v hierarchii. |
| withinUserHierarchy | false &#124; true | Omezuje vyhledávání a načítání na organizační jednotky, které jsou v rámci rozsahu sběru dat uživatelů. |
| withinUserSearchHierarchy | false &#124; true | Omezuje vyhledávání a načítání na organizační jednotky, které jsou v rozsahu vyhledávání aktuálních uživatelů. Poznámka: "v rámciUserHierarchy", pokud je pravda, má vyšší prioritu. |
| memberCollection | řetězec | Pro zobrazení počtu členů v rámci kolekce odkazuje na název kolekce přidružené k organizačním jednotkám. |
| memberObject | UID | Pro zobrazení počtu členů v rámci kolekce odkazuje na identifikátor objektového člena kolekce. |

### Get organisation unit with sub-hierarchy { #webapi_organisation_units_with_sub_hierarchy } 

Chcete-li získat organizační jednotku včetně organizačních jednotek v její podhierarchii, můžete použít následující zdroj.

    /api/33/organisationUnits/{id}

Tabulka: Parametry organizační jednotky

| Parametr dotazu | Možnosti | Popis |
|---|---|---|
| includeChildren | false &#124; true | Zahrňte bezprostřední podřazené k zadané organizační jednotce, tj. Jednotky na bezprostřední úrovni níže v subhierarchii. |
| includeDescendants | false &#124; true | Zahrnout všechny podřízené objekty uvedené organizační jednotky, tj. Všechny jednotky v podhierarchii. |
| includeAncestors | false &#124; true | Zahrnout všechny nadřazené zadané organizační jednotky. |
| level | celé číslo | Zahrnout podřazené zadané organizační jednotky na dané úrovni podhierarchie. To se vztahuje k organizační jednotce, počínaje 1 pro úroveň bezprostředně pod organizační jednotkou. |

### Get organisation units by category option  { #webapi_organisation_units_by_category_options }

Účelově vytvořený koncový bod pro načtení přidružení mezi možnostmi kategorií a organizačními jednotkami. Tento koncový bod je preferovaným způsobem načítání přidružení organizačních jednotek programu.

    /api/33/categoryOptions/orgUnits?categoryOptions={categoryOptionIdA},{categoryOptionIdB}

odpovědi budou mít následující formát:

```json
{
  "<categoryOptionIdA>": [
    "<orgUnitUid>",
    "<orgUnitUid>"
  ],
  "<categoryOptionIdB>": [
    "<orgUnitUid>",
    "<orgUnitUid>"
  ],
  "<categoryOptionIdC>": []
}
```

Možnosti kategorií, které jsou přístupné všem organizačním jednotkám, jsou vráceny s prázdným polem (`[]`) organizačních jednotek.

### Get organisation units by programs { #webapi_organisation_units_by_programs } 

Účelově vytvořený koncový bod pro načtení přidružení mezi programy a organizačními jednotkami. Tento koncový bod je preferovaným způsobem načítání přidružení organizačních jednotek programu.

    /api/33/programs/orgUnits?programs={programIdA},{programIdB}

odpovědi budou mít následující formát:

```json
{
  "<programIdA>": [
    "<orgUnitUid>",
    "<orgUnitUid>"
  ],
  "<programIdB>": [
    "<orgUnitUid>",
    "<orgUnitUid>"
  ],
  "<programIdC>": []
}
```

Programy, které jsou přístupné všem organizačním jednotkám, jsou vráceny s prázdným polem (`[]`) organizačních jednotek.

### Rozdělená organizační jednotka { #webapi_organisation_unit_split }

The organisation unit split endpoint allows you to split organisation units into a number of target organisation units. 

#### Request { #request } 

Rozdělení organizačních jednotek pomocí požadavku POST:

```
POST /api/organisationUnits/split
```

Užitná zátěž ve formátu JSON vypadá takto:

```json
{
  "source": "rspjJHg4WY1",
  "targets": [
    "HT0w9YLMLyn",
    "rEpnzuNpRKM"
  ],
  "primaryTarget": "HT0w9YLMLyn",
  "deleteSource": true
}
```

Vlastnosti JSON jsou popsány v následující tabulce.

Tabulka: Rozdělit pole datového obsahu

| Pole         | Požadované | Hodnota |
| ------------- | -------- |------ |
| zdroj        | Ano      | Identifikátor organizační jednotky k rozdělení (zdrojová organizační jednotka). |
| cíle       | Ano      | Pole identifikátorů organizačních jednotek, na které se má zdroj rozdělit (cílové organizační jednotky). |
| primaryTarget | Ne       | Identifikátor organizační jednotky, do které se přenášejí souhrnná data, události a sledované entity spojené se zdrojem. Pokud není zadán, použije se první cíl. |
| deleteSource  | Ne       | Zda se má po operaci odstranit zdrojová organizační jednotka. Výchozí hodnota je `true`. |

Operace rozdělení rozdělí zdrojovou organizační jednotku na cílové organizační jednotky. Před rozdělením se doporučuje nejprve vytvořit nové cílové organizační jednotky a minimálně zajistit, že pro cílové organizační jednotky neexistují žádná agregovaná data. Lze zadat libovolný počet cílových organizačních jednotek.

Operace rozdělení přenese všechna přidružení metadat zdrojové organizační jednotky do cílových organizačních jednotek. To zahrnuje datové sady, programy, skupiny organizačních jednotek, možnosti kategorií, uživatele, vizualizace, mapy a zprávy o událostech.

Operace přenese všechny datové záznamy zdrojové organizační jednotky do organizační jednotky zadané jako primární cíl, nebo pokud není specifikována, do první zadané cílové organizační jednotky. To zahrnuje agregované hodnoty dat, záznamy o schválení dat, události, sledované entity a další.

#### Validation { #validation } 

Platí následující omezení a chybové kódy.

Tabulka: Omezení a chybové kódy

| Chybový kód | Popis                                     |
| ---------- | ----------------------------------------------- |
| E1510      | Musí být uvedena zdrojová organizační jednotka               |
| E1511      | Musí být zadány alespoň dvě cílové organizační jednotky |
| E1512      | Zdrojová organizační jednotka nemůže být cílová organizační jednotka     |
| E1513      | Primární cíl musí být specifikován                |
| E1514      | Primárním cílem musí být cílová organizační jednotka        |
| E1515      | Cílová organizační jednotka neexistuje                  |

### Sloučit organizační jednotky { #webapi_organisation_unit_merge}

Koncový bod sloučení organizačních jednotek vám umožňuje sloučit několik organizačních jednotek do cílové organizační jednotky.

#### Request { #request } 

Sloučení organizačních jednotek s požadavkem POST:

```
POST /api/organisationUnits/merge
```

Užitná zátěž ve formátu JSON vypadá takto:

```json
{
  "sources": [
    "jNb63DIHuwU",
    "WAjjFMDJKcx"
  ],
  "target": "V9rfpjwHbYg",
  "dataValueMergeStrategy": "LAST_UPDATED",
  "dataApprovalMergeStrategy": "LAST_UPDATED",
  "deleteSources": true
}
```

Vlastnosti JSON jsou popsány v následující tabulce.

Tabulka: Sloučit pole datového obsahu

| Pole                     | Požadované | Hodnota |
| ------------------------- | -------- | ----- |
| zdroje                   | Ano      | Pole identifikátorů organizačních jednotek ke sloučení (zdrojové organizační jednotky). |
| cíl                    | Ano      | Identifikátor organizační jednotky, do které se mají zdroje sloučit (cílová organizační jednotka). |
| dataValueMergeStrategy    | Ne       | Strategie pro slučování datových hodnot. Možnosti: `LAST_UPDATED` (výchozí), `DISCARD`. |
| dataApprovalMergeStrategy | Ne       | Strategie pro slučování záznamů schvalování dat. Možnosti: `LAST_UPDATED` (výchozí), `DISCARD`. |
| deleteSources             | Ne       | Zda po operaci odstranit zdrojové organizační jednotky. Výchozí hodnota je true. |

Operace sloučení sloučí zdrojové organizační jednotky do cílové organizační jednotky. Před provedením sloučení se doporučuje nejprve vytvořit novou cílovou organizační jednotku a minimálně zajistit, že pro cílovou organizační jednotku neexistují žádná agregovaná data. Lze zadat libovolný počet zdrojových organizačních jednotek.

Operace sloučení přenese všechna přidružení metadat zdrojových organizačních jednotek do cílové organizační jednotky. To zahrnuje datové sady, programy, skupiny organizačních jednotek, možnosti kategorií, uživatele, vizualizace, mapy a zprávy o událostech. Operace také přenese všechna data událostí a sledování, jako jsou události, registrace, historie vlastnictví, vlastnictví programu a sledované entity, do cílové organizační jednotky.

Zadaná strategie slučování datových hodnot definuje, jak se zachází s datovými hodnotami. U strategie `LAST_UPDATED` se datové hodnoty pro všechny zdrojové organizační jednotky přenesou do cílové organizační jednotky a v situaci, kdy pro stejné parametry existují datové hodnoty, bude použita poslední aktualizovaná nebo vytvořená datová hodnota. To se provádí, aby se zabránilo duplicitě dat. U strategie `DISCARD` se datové hodnoty nepřenesou do cílové organizační jednotky a jednoduše se smažou. Zadaná strategie slučování schvalování dat definuje, jak se zachází se záznamy schvalování dat, a řídí se stejnou logikou jako hodnoty dat.

#### Validation { #validation } 

Platí následující omezení a chybové kódy.

Tabulka: Omezení a chybové kódy

| Chybový kód | Popis                                     |
| ---------- | ----------------------------------------------- |
| E1500      | Musí být zadány alespoň dvě zdrojové organizační jednotky |
| E1501      | Musí být zadána cílová organizační jednotka               |
| E1502      | Cílová organizační jednotka nemůže být zdrojovou organizační jednotkou     |
| E1503      | Zdrojová organizační jednotka neexistuje                  |

## Datové sady { #webapi_data_sets } 

The *dataSets* resource follows the standard conventions as other
metadata resources in DHIS2. This resource supports some additional
query parameters.

    /api/33/dataSets

Chcete-li načíst verzi datové sady, můžete vystavit požadavek GET:

    GET /api/33/dataSets/<uid>/version

To bump (increase by one) the version of a data set you can issue a POST
request:

    POST /api/33/dataSets/<uid>/version

### Data set notification template { #webapi_dataset_notifications } 

The *dataset notification templates* resource follows the standard
conventions as other metadata resources in DHIS2.

    GET /api/33/dataSetNotficationTemplates

Chcete-li načíst šablonu oznámení sady dat, můžete vystavit požadavek GET:

    GET /api/33/dataSetNotficationTemplates/<uid>

Chcete-li přidat šablonu oznámení sady dat, můžete vystavit požadavek POST:

    POST /api/33/dataSetNotficationTemplates

Chcete-li odstranit šablonu oznámení datové sady, můžete zadat požadavek DELETE:

    DELETE /api/33/dataSetNotficationTemplates/<uid>

Ukázka datového obsahu JSON je uvedena níže:

```json
{
  "name": "dataSetNotificationTemplate1",
  "dataSetNotificationTrigger": "DATA_SET_COMPLETION",
  "relativeScheduledDays": 0,
  "notificationRecipient": "ORGANISATION_UNIT_CONTACT",
  "dataSets": [{
    "id": "eZDhcZi6FLP"
  }],
  "deliveryChannels": ["SMS","EMAIL"],
  "subjectTemplate": "V{data_set_name}",
  "messageTemplate": "V{data_set_name}V{registration_period}",
  "sendStrategy": "SINGLE_NOTIFICATION"
}

```

`notificationRecipient` can be one of:
- `USER_GROUP` for internal messages
- `ORGANISATION_UNIT_CONTACT` for external messages


## Naplněné úrovně organizační jednotky { #webapi_filled_organisation_unit_levels } 

The *filledOrganisationUnitLevels* resource provides an ordered list of
organisation unit levels, where generated levels are injected into the
list to fill positions for which it does not exist a persisted level.

    GET /api/33/filledOrganisationUnitLevels

To set the organisation unit levels you can issue a POST request with a
JSON payload and content type `application/json` looking like this:

```json
{
  "organisationUnitLevels": [{
    "name": "National",
    "level": 1,
    "offlineLevels": 3
  }, {
    "name": "District",
    "level": 2
  }, {
    "name": "Chiefdom",
    "level": 3
  }, {
    "name": "Facility",
    "level": 4
  }]
}
```

## Prediktory { #webapi_predictors } 

A predictor allows you to generate data values based on an expression.
This can be used for example to generate targets, thresholds,
or estimated values.

To retrieve predictors you can make a GET request to the predictors
resource like this:

    /api/predictors

### Vytvoření prediktoru { #webapi_create_predictor } 

You can create a predictor with a POST request to the predictors
resource:

    POST /api/predictors

Ukázkové užitečné zatížení vypadá takto:

```json
{
  "id": "AG10KUJCrRk",
  "name": "Malaria Outbreak Threshold Predictor",
  "shortName": "Malaria Outbreak Predictor",
  "description": "Computes the threshold for potential malaria outbreaks based on the mean plus 1.5x the std dev",
  "output": {
    "id": "nXJJZNVAy0Y"
  },
  "generator": {
    "expression": "AVG(#{r6nrJANOqMw})+1.5*STDDEV(#{r6nrJANOqMw})",
    "description": "Maximum normal malaria case count",
    "missingValueStrategy": "NEVER_SKIP",
    "slidingWindow": false
  },
  "periodType": "Monthly",
  "sequentialSampleCount": 4,
  "sequentialSkipCount": 1,
  "annualSampleCount": 3,
  "organisationUnitLevels": [4]
}
```

The output element refers to the identifier of the data element for
which to saved predicted data values. The generator element refers to the
expression to use when calculating the predicted values.

### Výrazy prediktoru { #webapi_predictor_expressions } 

A predictor always has a generator expression that describes how the
predicted value is calculated. A predictor may also have a skip test
expression returning a boolean value. When the skip test expression is
present, it is evaluated in each of the sampled periods to tell whether
values from that period should be skipped.

The following variables may be used in either a generator expression
or a skip test expression:

| Proměnná    | Objekt     | Popis |
| ----------- | ---------- | ----------- |
| #{<dataelement-id>} | Agregovaný datový prvek | Odkazuje na celkovou hodnotu agregovaného datového prvku ve všech kombinacích možností kategorií. |
| #{<dataelement-id>.<categoryoptcombo-id> | Operand datového prvku | Odkazuje na kombinaci agregovaného datového prvku a kombinace možnosti kategorie. |
| D{<program-id>.<dataelement-id>} | Datový prvek programu | Odkazuje na hodnotu datového prvku trasovače v programu. |
| A{<program-id>.<attribute-id>} | Atribut trasované entity programu | Odkazuje na hodnotu atributu trasované entity v rámci programu. |
| I{<program-indicator-id>} | Indikátor programu | Odkazuje na hodnotu indikátoru programu. |
| R{<dataset-id>.<metric>} | četnost hlášení | Odkazuje na metriku rychlosti vykazování. Metrika může být REPORTING_RATE, REPORTING_RATE_ON_TIME, ACTUAL_REPORTS, ACTUAL_REPORTS_ON_TIME, EXPECTED_REPORTS. |
| C{<constant-id>} | Konstantní | Odkazuje na konstantní hodnotu. |
| OUG{<orgunitgroup-id>} | Skupina organizační jednotky | Odkazuje na počet organizačních jednotek ve skupině organizačních jednotek. |
| [dny] | Počet dní | Počet dní v aktuálním období. |

### Generování předpokládaných hodnot { #webapi_generating_predicted_values } 

To run all predictors (generating predicted values) you can make a POST
request to the run resource:

    POST /api/predictors/run

To run a single predictor you can make a POST request to the run
resource for a predictor:

    POST /api/predictors/AG10KUJCrRk/run

## Pravidla programu { #webapi_program_rules } 

This section is about sending and reading program rules, and explains
the program rules data model. The program rules give functionality to
configure dynamic behaviour in the programs in DHIS2.

### Model pravidla programu { #webapi_program_rule_model } 

The program rules data model consists of programRuleVariables,
programRules and programRuleActions. The programRule contains an
expression - when this expression is true, the child programRuleActions
is triggered. The programRuleVariables is used to address data elements,
tracked entity data values and other data values needed to run the
expressions. All programRules in a program share the same library of
programRuleVariables, and one programRuleVariable can be used in several
programRules' expressions.

![](resources/images/program_rules/program-rule-model.jpg)

#### Podrobnosti modelu modelu programu { #program-rule-model-details } 

The following table gives a detailed overview over the programRule
model.

Tabulka: programRule

| název | popis | Povinný |
|---|---|---|
| program | Program, ve kterém se programRule provádí. | Povinný |
| název | Název, pod kterým se programové pravidlo zobrazí v konfigurátorech dhis2. Není viditelný pro koncového uživatele programu. | Povinný |
| popis | Popis programového pravidla může být použit konfigurátory k popisu pravidla. Není viditelný pro koncového uživatele programu. | Povinný |
| programStage | Je-li pro programové pravidlo nastaven programStage, bude pravidlo vyhodnoceno pouze v zadané fázi programu. | volitelný |
| condition | Výraz, který je třeba vyhodnotit jako true, aby programové pravidlo spustilo své podřízené akce. Výraz je zapsán pomocí operátorů, volání funkcí, pevně zakódovaných hodnot, konstant a proměnných programových pravidel. `d2:hasValue('hemoglobin') && #{hemoglobin} <= 7 `| Povinný |
| přednost | Priorita spuštění pravidla v případech, kdy na pořadí pravidel záleží. Ve většině případů pravidla nezávisí na spuštění před nebo po jiných pravidlech a v těchto případech lze prioritu vynechat. Pokud není nastavena žádná priorita, pravidlo se spustí po každém pravidle, které má definovanou prioritu. Pokud je nastavena priorita (celé číslo), bude pravidlo s nejnižší prioritou spuštěno před pravidly s vyšší prioritou. | volitelný |

#### Podrobnosti o akčním modelu pravidla programu { #program-rule-action-model-details } 

The following table gives a detailed overview over the programRuleAction
model.

Tabulka: programRuleAction

| název | popis | Povinný |
|---|---|---|
| programRule | ProgramRule, které je nadřazeným této akce. | Povinný |
| programRule- ActionType | The type of action that is to be performed.<br>  * `DISPLAYTEXT` - Displays a text in a given widget.<br> * `DISPLAYKEYVALUEPAIR` - Displays a key and value pair(like a program indicator) in a given widget.<br> * `HIDEFIELD` - Hide a specified dataElement or trackedEntityAttribute.<br>    -         *content* - if defined, the text in *content* will be displayed to the end user in the instance where a value is previously entered into a field that is now about to be hidden (and therefore blanked). If *content* is not defined, a standard message will be shown to the user in this instance.<br>   -         *dataElement* - if defined, the HIDEFIELD action will hide this dataElement when the rule is effective.<br>   -         *trackedEntityDataValue* - if defined, the HIDEFIELD action will hide this trackedEntityDataValue when the rule is effective.<br>  * `HIDESECTION` - Hide a specified section.<br>    -         *programStageSection* - must be defined. This is the programStageSection that will be hidden in case the parent rule is effective.<br>  * `ASSIGN` - Assign a dataElement a value(help the user calculate something or fill in an obvious value somewhere)<br>    -         *content* - if defined, the value in *data* is assigned to this variable. If content id defined, and thus a variable is assigned for use in other rules, it is important to also assign a *programRule.priority* to make sure the rule with an ASSIGN action runs before the rule that will in turn evaluate the assigned variable.<br>   -         *data* - must be defined, data forms an expression that is evaluated and assigned to either a variable(#{myVariable}), a dataElement, or both.<br>   -         *dataElement* - if defined, the value in *data* is assigned to this data element.<br>  Either the content or dataElement must be defined for the ASSIGN action to be effective.<br> * `SHOWWARNING` - Show a warning to the user, not blocking the user from completing the event or registration.<br>    -         *content* - if defined, content is a static part that is displayed at the end of the error message.<br>   -         *data* - if defined, data forms an expression that is evaluated and added to the end of the warning message.<br>   -         *dataElement* - if defined, the warning message is displayed next to this data element.<br>   -         *trackedEntityAttribute* - if defined, the warning message is displayed next to this tracked entity attribute.<br>  Either dataElement or trackedEntityAttribute must be specified.<br> * `SHOWERROR` - Show an error to the user, blocking the user from completing the event or registration.<br>    -         *content* - if defined, content is a static part that is displayed in the start of the error message.<br>   -         *data* - if defined, data forms an expression that is evaluated and added to the end of the error message.<br>   -         *dataElement* - if defined, the error message is linked to this data element.<br>   -         *trackedEntityAttribute* - if defined, the error message is linked to this tracked entity attribute.<br>  Either dataElement or trackedEntityAttribute must be specified.<br> * `WARNINGONCOMPLETE` - Show a warning to the user on the "Complete form" dialog, but allowing the user to complete the event.<br>    -         *content* - if defined, content is a static part that is displayed at the end of the error message.<br>   -         *data* - if defined, data forms an expression that is evaluated and added to the end of the warning message.<br>   -         *dataElement* - if defined, the warning message prefixed with the name/formName of the data element.<br>  * `ERRORONCOMPLETE` - Show an error to the user on in a modal window when the user tries to complete the event. The user is prevented from completing the event.<br>    -         *content* - if defined, content is a static part that is displayed in the start of the error message.<br>   -         *data* - if defined, data forms an expression that is evaluated and added to the end of the error message.<br>   -         *dataElement* - if defined, the error message is linked to this data element.<br>  * `CREATEEVENT` - Create an event within the same enrollment.<br>    -         *content*<br>   -         *data* - if defined, contains data values to assign the created event. The format is <uid\>:<data value\>. Where several values is specified, these are separated with comma.<br> AcMrnleqHqc:100,AqK1IHqCkEE:'Polyhydramnios'   -         *programStage* - must be defined, and designates the program stage that the rule shall create an event of.<br>  * `SETMANDATORYFIELD` - Set a field to be mandatory.<br>    -         *dataElement* - if defined, this data element will be set to be mandatory in the data entry form.<br>   -         *trackedEntityAttribute* - if defined, this tracked entity attribute will be set to mandatory in the registration form or profile.<br>  * `SENDMESSAGE` - To send message at completion of event/enrollment or at data value update.<br>    -         *messageTemplate* - if defined, this template will be delivered either as SMS or EMAIL depending upon DeliveryChannel value in message template.<br>  * `SCHEDULEMESSAGE` - To schedule message at completion of event/enrollment or at data value update.<br>    -         *messageTemplate* - if defined, this template will be delivered either as SMS or EMAIL depending upon DeliveryChannel value in message template.<br>   -         *Date to send message* - Expression which is going to be used for evaluation of scheduled date. This expression should result in Date, any other resultant will be discarded and notification will not get scheduled. | Povinný |
| umístění | Používá se pro actionType DISPLAYKEYVALUEPAIR a DISPLAYTEXT k určení, ve kterém widgetu se má zobrazit text nebo pár klíč-hodnota. Povinné pro DISPLAYKEYVALUEPAIR a DISPLAYTEXT. | Viz popis |
| obsah | Používá se pro uživatelské zprávy v různých akcích. Podrobné vysvětlení, jak se používá v jednotlivých typech akcí, najdete v přehledu actionType. Povinné pro SHOWWARNING, SHOWERROR, WARNINGONCOMPLETE, ERRORONCOMPLETE, DISPLAYTEXT a DISPLAYKEYVALUEPAIR. Volitelné pro HIDEFIELD a ASSIGN. | Viz popis |
| data | Používá se pro výrazy v různých akcích. Podrobné vysvětlení, jak se používá v jednotlivých typech akcí, najdete v přehledu actionType. Povinné pro ASSIGN. Volitelné pro SHOWVARNING, SHOWERROR, WARNINGONCOMPLETE, ERRORONCOMPLETE, DISPLAYTEXT, CREATEEVENT a DISPLAYKEYVALUEPAIR | Viz popis |
| dataElement | Používá se k propojení akcí pravidel s dataElements. Podrobné vysvětlení, jak se používá v jednotlivých typech akcí, najdete v přehledu actionType. Volitelné pro SHOWWARNING, SHOWERROR, WARNINGONCOMPLETE, ERRORONCOMPLETE, ASSIGN a HIDEFIELD | Viz popis |
| trackedEntity- Atribut | Používá se k propojení akcí pravidel s trackedEntityAttributes. Podrobné vysvětlení, jak se používá v jednotlivých typech akcí, najdete v přehledu actionType. Volitelně pro SHOWVARNING, SHOWERROR a HIDEFIELD. | Viz popis |
| možnost | Používá se k propojení akcí pravidel s možnostmi. Podrobné vysvětlení, jak se používá v jednotlivých typech akcí, najdete v přehledu actionType. Volitelné pro HIDEOPTION | Viz popis |
| optionGroup | Používá se k propojení akcí pravidel s optionGroups. Podrobné vysvětlení, jak se používá v jednotlivých typech akcí, najdete v přehledu actionType. Povinné pro SHOWOPTIONGROUP, HIDEOPTIONGROUP. | Viz popis |
| programStage | Používá se pouze pro akce pravidla CREATEEVENT. Povinné pro CREATEEEVENT. | Viz popis |
| programStage- Sekce | Používá se pouze pro akce pravidla HIDESECTION. Povinné pro HIDESECTION | Viz popis |

##### ProgramRuleAction Validation { #programruleaction-validation } 
There are certain validations added to ProgramRuleAction model in 2.37. Main purpose was to keep user from creating erroneous ProgramRules in order to keep the database consistent. These validations depends on program rule action type. Each action type has its own respective validation. 

Tabulka: Ověření ProgramRuleAction

| název | ověření ověření existence ID |
|---|---|
|SENDMESSAGE| ID šablony oznámení |
|SCHEDULEMESSAGE| ID šablony oznámení |
|HIDESECTION| ID sekce ProgramStage |
|HIDEPROGRAMSTAGE| ProgramStage id |
|HIDEFIELD| ID DataElement nebo TrackedEntityAttribute |
|HIDEOPTION| Option id |
|HIDEOPTIONGROUP| ID skupiny možností |
|SHOWOPTIONGROUP| ID skupiny možností |
|SETMANDATORYFIELD| ID DataElement nebo TrackedEntityAttribute |
|SHOWERROR| Vždy platné |
|SHOWWARNING| Vždy platné |
|DISPLAYTEXT| ID DataElement nebo TrackedEntityAttribute |
|DISPLAYKEYVALUEPAIR||
|ASSIGN| ID DataElement nebo TrackedEntityAttribute |
|WARNINGONCOMPLETE| ID DataElement nebo TrackedEntityAttribute |
|ERRORONCOMPLETE| ID DataElement nebo TrackedEntityAttribute |

Apart from above validations, `data` field in program rule action which normally contains expression can also be evaluated using below api endpoint.

    POST /api/programRuleActions/data/expression/description?programId=<uid>


```json
{
  "condition": "1 + 1"
}
```

#### Podrobnosti o variabilním modelu pravidla programu { #program-rule-variable-model-details } 

Následující tabulka poskytuje podrobný přehled 
o modelu programRuleVariable.

Tabulka: programRuleVariable

| název | popis | Povinný |
|---|---|---|
| název | název pro programRuleVariable - tento název se používá ve výrazech. #{myVariable} \> 5 | Povinný |
| sourceType | Defines how this variable is populated with data from the enrollment and events. <br> * DATAELEMENT_NEWEST_EVENT_PROGRAM_STAGE - In tracker capture, gets the newest value that exists for a data element, within the events of a given program stage in the current enrollment. In event capture, gets the newest value among the 10 newest events on the organisation unit.<br> * DATAELEMENT_NEWEST_EVENT_PROGRAM - In tracker capture, get the newest value that exists for a data element across the whole enrollment. In event capture, gets the newest value among the 10 newest events on the organisation unit.<br> * DATAELEMENT_CURRENT_EVENT - Gets the value of the given data element in the current event only.<br> * DATAELEMENT_PREVIOUS_EVENT - In tracker capture, gets the newest value that exists among events in the program that precedes the current event. In event capture, gets the newvest value among the 10 preceeding events registered on the organisation unit.<br> * CALCULATED_VALUE - Used to reserve a variable name that will be assigned by a ASSIGN program rule action<br> * TEI_ATTRIBUTE - Gets the value of a given tracked entity attribute | Povinný |
| valueType | Parametr valueType definuje typ hodnoty, kterou může tato proměnná ProgramRuleVariable obsahovat. Jeho hodnota je závislá na parametru sourceType. Pokud je zdrojem DataElement nebo TrackedEntityAttribute <br>, pak valueType bude odvozena z valueType zdroje. Když je sourceType CALCULATED_VALUE, měl by hodnotu valueType zadat uživatel, jinak bude výchozí <br> na ValueType.TEXT| Povinný
| dataElement | Used for linking the programRuleVariable to a dataElement. Compulsory for all sourceTypes that starts with DATAELEMENT_. | Viz popis |
| trackedEntity- Atribut | Používá se k propojení programRuleVariable s trackedEntityAttribute. Povinné pro sourceType TEI_ATTRIBUTE. | Viz popis |
| useCodeFor- OptionSet | Je-li zaškrtnuto, proměnná bude naplněna kódem – nikoli názvem – z libovolné propojené sady možností. Výchozí není zaškrtnuto, což znamená, že název volby je vyplněn. ||
| programStage | Používá se k určení konkrétní fáze programu, ze které se má načíst hodnota programRuleVariable. Povinné pro DATAELEMENT_NEWEST_EVENT_PROGRAM_STAGE. | Viz popis |

### Vytváření pravidel programu { #webapi_creating_program_rules } 

- K provádění hrubých operací je v rozhraní API k dispozici zdroj `programRules`.

Chcete-li načíst seznam programRules, můžete provést požadavek GET takto:

    /api/programRules

Chcete-li načíst jeden programRule, můžete provést požadavek GET takto:

    /api/programRules/<program_rule_uid>

Chcete-li uložit / přidat jeden programRule, můžete provést požadavek POST takto:

    /api/programRules/<program_rule_uid>

Chcete-li aktualizovat jeden programRule, můžete provést požadavek PUT takto:

    /api/programRules/<program_rule_uid>

Chcete-li odstranit jeden programRule, můžete provést požadavek VYMAZAT takto:

    /api/programRules/<program_rule_uid>

Chcete-li získat popis podmínky programRule, můžete použít POST a zadat řetězec podmínky v těle POST.

    /api/programRules/condition/description?<program_rule_uid>

## formuláře { #webapi_forms } 

To retrieve information about a form (which corresponds to a data set
and its sections) you can interact with the `form` resource. The form
response is accessible as XML and JSON and will provide information
about each section (group) in the form as well as each field in the
sections, including labels and identifiers. By supplying period and
organisation unit identifiers the form response will be populated with
data values.

Tabulka: Parametry dotazu formuláře

| Parametr | Možnost | Popis |
|---|---|---|
| pe | Období ISO | Období, pro které se mají vyplnit hodnoty dat formuláře. |
| ou | UID | Organizační jednotka, pro kterou se mají vyplnit hodnoty dat formuláře. |
| metaData | false &#124; true | Zda zahrnout metadata o každém datovém prvku částí formuláře. |

Chcete-li načíst formulář pro datovou sadu, můžete provést požadavek GET takto:

    /api/dataSets/<dataset-id>/form.json

Načíst formulář pro datovou sadu s identifikátorem "BfMAe6Itzgt" v XML:

    /api/dataSets/BfMAe6Itzgt/form

Načtení formuláře včetně metadat v JSON:

    /api/dataSets/BfMAe6Itzgt/form.json?metaData=true

To retrieve the form filled with data values for a specific period and
organisation unit in XML:

    /api/dataSets/BfMAe6Itzgt/form.xml?ou=DiszpKrYNg8&pe=201401

When it comes to custom data entry forms, this resource also allows for
creating such forms directly for a data set. This can be done through a
POST or PUT request with content type text/html where the payload is the
custom form markup such as:

```bash
curl -d @form.html "localhost/api/dataSets/BfMAe6Itzgt/form"
  -H "Content-Type:text/html" -u admin:district -X PUT
```

## Dokumenty { #webapi_documents } 

Odkazy na soubory lze uložit pomocí zdroje dokumentu.



Tabulka: Pole dokumentu

| Název pole | Popis |
|---|---|
| název | jedinečný název dokumentu |
| externí | příznak identifikující umístění dokumentu. TRUE pro externí soubory, FALSE pro ty interní  |
| url | umístění souboru. URL pro externí soubory. ID zdroje souboru pro interní zdroje (viz [Zdroje souboru](#webapi_file_resources)) |

Požadavek GET na koncový bod dokumentů vrátí všechny dokumenty:

    /api/documents

Požadavek POST na koncový bod dokumentů vytvoří nový dokument:

```bash
curl -X POST -d @document.json -H "Content-type: application/json"
  "http://dhis.domain/api/documents"
```

```json
{
  "name": "dhis home",
  "external": true,
  "url": "https://www.dhis2.org"
}
```

A GET request with the id of a document appended will return information
about the document. A PUT request to the same endpoint will update the
fields of the document:

    /api/documents/<documentId>

Appending */data* to the GET request will return the actual file content
of the document:

    /api/documents/<documentId>/data

## Import metadat CSV { #webapi_csv_metadata_import } 

DHIS2 podporuje import metadat ve formátu CSV, jako jsou datové prvky, organizační jednotky a ověřovací pravidla. Vlastnosti různých objektů metadat jsou identifikovány na základě pořadí sloupců / indexu sloupců (podrobnosti viz níže). Můžete vynechat nepožadované vlastnosti / sloupce objektu, ale protože pořadí sloupců je významné, musí být zahrnut prázdný sloupec. Jinými slovy, pokud byste chtěli určit vlastnosti / sloupce, které se objeví pozdě v pořadí sloupců, ale neurčit určité sloupce, které se objeví brzy v pořadí, můžete pro ně zahrnout prázdné / nevyplněné sloupce.

První řádek souboru CSV je považován za záhlaví a je během importu ignorován. Znak _comma_ by měl být použit jako oddělovač textu. Text, který obsahuje čárky, musí být uveden v _dvojitých uvozovkách_.

Chcete-li nahrát metadata ve formátu CSV, můžete odeslat požadavek POST do koncového bodu metadat:

    POST /api/metadata?classKey=CLASS-KEY

Jsou podporovány následující typy objektů. Parametr dotazu `classKey` je povinný a je uveden vedle každého typu objektu v tabulce níže.

Tabulka: Typy objektů a klíče

| Typ objektu | Klíč třídy |
|---|---|
| Datové prvky | DATA_ELEMENT |
| Skupiny datových prvků | DATA_ELEMENT_GROUP |
| Možnosti kategorie | CATEGORY_OPTION |
| Skupiny možností kategorie | CATEGORY_OPTION_GROUP |
| Organizační jednotky | ORGANISATION_UNIT |
| Skupiny organizačních jednotek | ORGANISATION_UNIT_GROUP |
| Pravidla ověřování | VALIDATION_RULE |
| Sady možností | OPTION_SET |
| Překlady | PŘEKLAD |

> **Tip**
>
> Pokud používáte *curl*, měla by být použita možnost `--data-binary`, protože zachovává konce řádků a nové řádky, což je pro data CSV zásadní.

Jako příklad můžete k nahrání souboru datových prvků ve formátu CSV pomocí `curl` použít následující příkaz:

```bash
curl --data-binary @data_elements.csv "http://localhost/api/metadata?classKey=DATA_ELEMENT"
  -H "Content-Type:application/csv" -u admin:district
```

Formáty aktuálně podporovaných typů objektů pro import CSV jsou uvedeny v následujících částech.

### Datové prvky { #webapi_csv_data_elements } 

Tabulka: Formát CSV datových prvků

| Index | Sloupec | Požadované | Hodnota (výchozí první) | Popis |
|---|---|---|---|---|
| 1 | Název | Ano || Název. Max. 230 znaků Unikátní. |
| 2 | UID | Ne | UID | Stabilní identifikátor. Přesně 11 alfanumerických znaků, začínajících písmenem. Pokud není uvedeno, bude generováno systémem. |
| 3 | Kód | Ne || Stabilní kód. Max. 50 znaků |
| 4 | Krátký název | Ne | 50 prvních znaků názvu | Pokud není uvedeno, vrátí se na prvních 50 znaků názvu. Max. 50 znaků Unikátní. |
| 5 | Popis | Ne || Libovolný textový popisek. |
| 6 | Název formuláře | Ne || Max. 230 znaků |
| 7 | Typ domény | Ne | AGGREGATE &#124; TRACKER | Typ domény pro datový prvek může být agregační nebo sledovací. Max. 16 znaků |
| 8 | Typ hodnoty | Ne | INTEGER &#124; NUMBER &#124; UNIT_INTERVAL &#124; PERCENTAGE &#124; INTEGER_POSITIVE &#124; INTEGER_NEGATIVE &#124; INTEGER_ZERO_OR_POSITIVE &#124; FILE_RESOURCE &#124; COORDINATE &#124;TEXT &#124; LONG_TEXT &#124; LETTER &#124; PHONE_NUMBER &#124; EMAIL &#124; BOOLEAN &#124; TRUE_ONLY &#124; DATE &#124; DATETIME | Typ hodnoty. Max. 16 znaků |
| 9 | Typ agregace | Ne | SUM &#124; AVERAGE &#124; AVERAGE_SUM_ORG_UNIT &#124; COUNT &#124; STDDEV &#124; VARIANCE &#124; MIN &#124; MAX &#124; NONE | Typ agregace udávající, jak agregovat data v různých dimenzích. Max. 16 znaků |
| 10 | Kombinace kategorií | Ne | UID | UID kombinace kategorií. Pokud není zadáno, provede se výchozí kombinace výchozích kategorií. |
| 11 | Url | Ne || Adresa URL zdroje datových prvků. Max. 255 znaků |
| 12 | Nulová hodnota je významná | Ne | false &#124; true | Udává, zda budou pro tento datový prvek uloženy nulové hodnoty. |
| 13 | Sada možností | Ne | UID | UID možnosti nastavené pro použití pro data. |
| 14 | Nastavena možnost komentáře | Ne | UID | UID možnosti nastavené pro použití pro komentáře. |

An example of a CSV file for data elements can be seen below. The first
row will always be ignored. Note how you can skip columns and rely on
default values to be used by the system. You can also skip columns which
you do not use which appear to the right of the ones

```csv
name,uid,code,shortname,description
"Women participated skill development training",,"D0001","Women participated in training"
"Women participated community organizations",,"D0002","Women participated in organizations"
```

### Organizační jednotky { #webapi_csv_org_units } 

Tabulka: Formát CSV organizační jednotky

| Index | Sloupec | Požadované | Hodnota (výchozí první) | Popis |
|---|---|---|---|---|
| 1 | Název | Ano || Název. Maximálně 230 znaků. Unikátní. |
| 2 | UID | Ne | UID | Stabilní identifikátor. Max. 11 znaků Pokud není specifikováno, bude generováno systémem. |
| 3 | Kód | Ne || Stabilní kód. Max. 50 znaků |
| 4 | Nadřazený | Ne | UID | UID nadřazené organizační jednotky. |
| 5 | Krátký název | Ne | 50 prvních znaků názvu | Pokud není zadáno, vrátí se zpět na prvních 50 znaků názvu. Maximálně 50 znaků. Unikátní. |
| 6 | Popis | Ne || Libovolný textový popisek. |
| 7 | Datum otevření | Ne | 1970-01-01 | Datum otevření organizační jednotky ve formátu RRRR-MM-DD. |
| 8 | Datum uzavření | Ne || Datum uzavření organizační jednotky ve formátu RRRR-MM-DD, přeskočte, pokud je aktuálně otevřeno. |
| 9 | Komentář | Ne || Volný textový komentář pro organizační jednotku. |
| 10 | Typ prvku | Ne | NONE &#124; MULTI_POLYGON &#124; POLYGON &#124; POINT &#124; SYMBOL | Typ geoprostorového prvku. |
| 11 | Souřadnice | Ne || Souřadnice používané pro geoprostorovou analýzu ve formátu Geo JSON. |
| 12 | URL | Ne || Adresa URL zdroje organizační jednotky. Max. 255 znaků |
| 13 | Kontaktní osoba | Ne || Kontaktní osoba pro organizační jednotku. Max. 255 znaků |
| 14 | Adresa | Ne || Adresa organizační jednotky. Max. 255 znaků |
| 15 | E-mail | Ne || E-mail pro organizační jednotku. Max. 150 znaků |
| 16 | Telefonní číslo | Ne || Telefonní číslo na organizační jednotku. Max. 150 znaků |

A minimal example for importing organisation units with a parent unit
looks like this:

```csv
name,uid,code,parent
"West province",,"WESTP","ImspTQPwCqd"
"East province",,"EASTP","ImspTQPwCqd"
```

### Pravidla ověřování { #webapi_csv_validation_rules } 

Tabulka: Formát CSV ověřovacího pravidla

| Index | Sloupec | Požadované | Hodnota (výchozí první) | Popis |
|---|---|---|---|---|
| 1 | Název | Ano || Název. Maximálně 230 znaků. Unikátní. |
| 2 | UID | Ne | UID | Stabilní identifikátor. Max. 11 znaků Pokud není specifikováno, bude generováno systémem. |
| 3 | Kód | Ne || Stabilní kód. Maximálně 50 |
| 4 | Popis | Ne || Libovolný textový popisek. |
| 5 | Návod | Ne || Volný textový pokyn. |
| 6 | Důležitost | Ne | MEDIUM &#124; HIGH &#124; LOW | Význam ověřovacího pravidla. |
| 7 | Typ pravidla (ignorováno) | Ne | VALIDATION &#124; SURVEILLANCE | Typ ověřovacího pravidla. |
| 8 | Operátor | Ne | equal_to &#124; not_equal_to &#124; greater_than &#124; greater_than_or_equal_to &#124; less_than &#124; less_than_or_equal_to &#124; compulsory_pair &#124; exclusive_pair | Operátor výrazu. |
| 9 | Typ období | Ne | měsíčně &#124; denně &#124; týdně &#124; čtvrtletně &#124; půlročně &#124; ročně | Typ období. |
| 10 | Výraz na levé straně | Ano || Matematický vzorec založený na UID datového prvku a kombinace možností. |
| 11 | Popis výrazu na levé straně | Ano || Volný text. |
| 12 | Na levé straně chybí hodnotová strategie | Ne | SKIP_IF_ANY_VALUE_MISSING &#124; SKIP_IF_ALL_VALUES_MISSING &#124; NEVER_SKIP | Chování v případě chybějících hodnot ve výrazu na levé straně. |
| 13 | Výraz na pravé straně | Ano || Matematický vzorec založený na UID datového prvku a kombinace možností. |
| 14 | Popis výrazu na pravé straně | Ano || Volný text. |
| 15 | Na pravé straně chybí hodnotová strategie | Ne | SKIP_IF_ANY_VALUE_MISSING &#124; SKIP_IF_ALL_VALUES_MISSING &#124; NEVER_SKIP | Chování v případě chybějících hodnot ve výrazu na pravé straně. |

### Sady možností { #webapi_csv_option_sets } 

Tabulka: Možnost Nastavit formát CSV

| Index | Sloupec | Požadované | Hodnota (výchozí první) | Popis |
|---|---|---|---|---|
| 1 | OptionSetName | Ano || Název. Maximálně 230 znaků. Unikátní. Mělo by se opakovat pro každou možnost. |
| 2 | OptionSetUID | Ne | UID | Stabilní identifikátor. Max. 11 znaků Pokud není uvedeno, bude generováno systémem. Mělo by se opakovat pro každou možnost. |
| 3 | OptionSetCode | Ne || Stabilní kód. Max. 50 znaků Mělo by se opakovat pro každou možnost. |
| 4 | OptionName | Ano || Název možnosti. Maximálně 230 znaků. |
| 5 | OptionUID | Ne | UID | Stabilní identifikátor. Max. 11 znaků Pokud není specifikováno, bude generováno systémem. |
| 6 | OptionCode | Ano || Stabilní kód. Max. 50 znaků |

The format for option sets is special. The three first values represent
an option set. The three last values represent an option. The first
three values representing the option set should be repeated for each
option.

```csv
optionsetname,optionsetuid,optionsetcode,optionname,optionuid,optioncode
"Color",,"COLOR","Blue",,"BLUE"
"Color",,"COLOR","Green",,"GREEN"
"Color",,"COLOR","Yellow",,"YELLOW"
"Sex",,,"Male",,"MALE"
"Sex",,,"Female",,"FEMALE"
"Sex",,,"Unknown",,"UNKNOWN"
"Result",,,"High",,"HIGH"
"Result",,,"Medium",,"MEDIUM"
"Result",,,"Low",,"LOW"
"Impact","cJ82jd8sd32","IMPACT","Great",,"GREAT"
"Impact","cJ82jd8sd32","IMPACT","Medium",,"MEDIUM"
"Impact","cJ82jd8sd32","IMPACT","Poor",,"POOR"
```

### Skupina možností { #option-group } 

Tabulka: Formát CSV skupiny možností

| Index | Sloupec | Požadované | Hodnota (výchozí první) | Popis |
|---|---|---|---|---|
| 1 | OptionGroupName | Ano || Název. Maximálně 230 znaků. Unikátní. Mělo by se opakovat pro každou možnost. |
| 2 | OptionGroupUid | Ne || Stabilní identifikátor. Max. 11 znaků Pokud není uvedeno, bude generováno systémem. Mělo by se opakovat pro každou možnost. |
| 3 | OptionGroupCode | Ne || Stabilní kód. Max. 50 znaků Mělo by se opakovat pro každou možnost. |
| 4 | OptionGroupShortName | Ano || Krátký název. Maximálně 50 znaků. Unikátní. Mělo by se opakovat pro každou možnost. |
| 5 | OptionSetUid | Ano || Stabilní identifikátor. Max. 11 znaků Mělo by se opakovat pro každou možnost. |
| 6 | OptionUid | Ne || Stabilní identifikátor. Max. 11 znaků |
| 7 | OptionCode | Ne || Stabilní kód. Max. 50 znaků |

Ukázkový datový obsah CSV OptionGroup

```csv
optionGroupName,optionGroupUid,optionGroupCode,optionGroupShortName,optionSetUid,optionUid,optionCode
optionGroupA,,,groupA,xmRubJIhmaK,,OptionA
optionGroupA,,,groupA,xmRubJIhmaK,,OptionB
optionGroupB,,,groupB,QYDAByFgTr1,,OptionC
```
### Sada skupin možností { #option-group-set } 



Tabulka: Skupina možností Nastavit formát CSV

| Index | Sloupec | Požadované | Hodnota (výchozí první) | Popis |
|---|---|---|---|---|
| 1 | OptionGroupSetName | Ano || Název. Maximálně 230 znaků. Unikátní. Mělo by se opakovat pro každou možnost. |
| 2 | OptionGroupSetUid | Ne || Stabilní identifikátor. Max. 11 znaků Pokud není uvedeno, bude generováno systémem. Mělo by se opakovat pro každou možnost. |
| 3 | OptionGroupSetCode | Ne || Stabilní kód. Max. 50 znaků Mělo by se opakovat pro každou možnost. |
| 4 | OptionGroupSetDescription | Ne || Popis. Mělo by se opakovat pro každou možnost. |
| 5 | DataDimension | Ne || TRUE, FALSE |
| 6 | OptionSetUid | Ne || OptionSet UID. Stabilní identifikátor. Max. 11 znaků |

Ukázkový datový obsah CSV OptionGroupSet

```csv
name,uid,code,description,datadimension,optionsetuid
optiongroupsetA,,,,,xmRubJIhmaK
optiongroupsetB,,,,false,QYDAByFgTr1
```
Chcete-li přidat OptionGroups do importované OptionGroupSet, postupujte podle pokynů jako import členství v kolekci

### Indicators { #webapi_csv_indicators } 

Table: Indicator CSV Format

| Index | Sloupec | Požadované | Hodnota (výchozí první) | Popis |
|---|---|---|---|---|
| 1 | Název | Ano || Název. Max. 230 znaků Unikátní. |
| 2 | UID | Ne | UID | Stabilní identifikátor. Přesně 11 alfanumerických znaků, začínajících písmenem. Pokud není uvedeno, bude generováno systémem. |
| 3 | Kód | Ne || Stabilní kód. Max. 50 znaků |
| 4 | Krátký název | Ano | 50 prvních znaků názvu | Pokud není uvedeno, vrátí se na prvních 50 znaků názvu. Max. 50 znaků Unikátní. |
| 5 | jmenovatel | Ano || Indicator expression. |
| 6 | denominatorDescription | Ne || Max. 230 znaků |
| 5 | čitatel | Ano || Indicator expression. |
| 6 | numeratorDescription | Ne || Max. 230 znaků |
| 6 | annualized | Ano ||  TRUE, FALSE |
| 6 | decimals | Ne || Number of decimals to use for indicator value, null implies default.
| 6 | Typ indikátoru | Ano || UID | UID of Indicator Type.

An example of a CSV file for Indicators can be seen below. The first
row will always be ignored. Note how you can skip columns and rely on
default values to be used by the system. You can also skip columns which
you do not use which appear to the right of the ones

```csv
Name,UID,Code,Description,shortName,denominator,denominatorDescription,numerator,numeratorDescription,annualized,decimals,indicatorType
Indicator A,yiAKjiZVoOU,CodeA,Indicator A description,Indicator A shortname,#{fbfJHSPpUQD},denominatorDescription,#{h0xKKjijTdI},numeratorDescription,false,2,sqGRzCziswD
Indicator B,Uvn6LCg7dVU,CodeB,Indicator B description,Indicator B shortname,#{fbfJHSPpUQD},denominatorDescription,#{h0xKKjijTdI},numeratorDescription,false,2,sqGRzCziswD
```

### Členství ve sbírce { #collection-membership } 

In addition to importing objects, you can also choose to only import the
group-member relationship between an object and a group. Currently, the
following group and object pairs are supported

  - Skupina organizační jednotky - organizační jednotka

  - Skupina datových prvků - datový prvek

  - Skupina indikátorů - indikátor

  - Sada skupin možností - Skupina možností

Formát CSV pro tyto importy je stejný



Tabulka: Formát CSV členství ve sbírce

| Index | Sloupec | Požadované | Hodnota (výchozí první) | Popis |
|---|---|---|---|---|
| 1 | UID | Ano | UID | UID kolekce, do které se má přidat objekt |
| 2 | UID | Ano | UID | UID objektu, který se má přidat do kolekce |

### Category Option Group { #category-option-group } 

| Index | Sloupec | Požadované | Hodnota (výchozí první) | Popis |
|---|---|---|---|---|
| 1 | Název | Ano || Název. Maximálně 230 znaků. Unikátní. |
| 2 | UID | Ne | UID | Stabilní identifikátor. Max. 11 znaků. Pokud není uvedeno, bude generováno systémem. |
| 3 | Kód | Ne || Stabilní kód. Max. 50 znaků |
| 4 | Krátký název | Ne || Krátký název. Maximálně 50 znaků. |
| 5 | Data Dimension Type | Ano || Data Dimension Type, can be either DISAGGREGATION or ATTRIBUTE |

### Ostatní objekty { #webapi_csv_other_objects } 

Table: Data Element Group, Category Option, Organisation Unit Group CSV Format

| Index | Sloupec | Požadované | Hodnota (výchozí první) | Popis |
|---|---|---|---|---|
| 1 | Název | Ano || Název. Maximálně 230 znaků. Unikátní. |
| 2 | UID | Ne | UID | Stabilní identifikátor. Max. 11 znaků. Pokud není uvedeno, bude generováno systémem. |
| 3 | Kód | Ne || Stabilní kód. Max. 50 znaků |
| 4 | Krátký název | Ne || Krátký název. Maximálně 50 znaků. |

Příklad možností kategorií vypadá takto:

```csv
name,uid,code,shortname
"Male",,"MALE"
"Female",,"FEMALE"
```

## Odstraněné objekty { #webapi_deleted_objects } 

Prostředek odstraněné objekty poskytuje protokol odstraněných objektů metadat.

    /api/deletedObjects

Whenever an object of type metadata is deleted, a log is being kept of
the uid, code, the type and the time of when it was deleted. This API is
available at `/api/deletedObjects` field filtering and object filtering
works similarly to other metadata resources.

Získejte odstraněné objekty datových prvků typu:

    GET /api/deletedObjects.json?klass=DataElement

Get deleted object of type indicator which was deleted in 2015 and
forward:

    GET /api/deletedObjects.json?klass=Indicator&deletedAt=2015-01-01

## Oblíbené { #webapi_favorites } 

Některé typy objektů metadat lze označit jako oblíbené pro
aktuálně přihlášeného uživatele. V současnosti to platí pro ovládací panely.

    /api/dashboards/<uid>/favorite

To make a dashboard a favorite you can make a *POST* request (no content
type required) to a URL like this:

    /api/dashboards/iMnYyBfSxmM/favorite

To remove a dashboard as a favorite you can make a *DELETE* request
using the same URL as above.

The favorite status will appear as a boolean *favorite* field on the
object (e.g. the dashboard) in the metadata response.

## Odběry { #webapi_subscription } 

A logged user can subscribe to certain types of objects. Currently
subscribable objects are those of type EventChart, EventReport,
Map, Visualization and EventVisualization.

> **Poznámka**
>
> Objekty EventChart a EventReport jsou zastaralé. Místo toho použijte EventVisualization.

To get the subscribers of an object (return an array of user IDs) you
can make a *GET* request:

    /api/<object-type>/<object-id>/subscribers

Viz příklad takto:

    /api/visualizations/DkPKc1EUmC2/subscribers

To check whether the current user is subscribed to an object (returns a
boolean) you can perform a *GET* call:

    /api/<object-type>/<object-id>/subscribed

Viz příklad takto:

    /api/visualizations/DkPKc1EUmC2/subscribed

Pro přihlášení/odhlášení k odběru objektu provedete *POST/DELETE*
požadavek (není vyžadován typ obsahu):

    /api/<object-type>/<object-id>/subscriber

## Zdroje souborů { #webapi_file_resources } 

*File resources* are objects used to represent and store binary content.
The *FileResource* object itself contains the file meta-data (name,
Content-Type, size, etc.) as well as a key allowing retrieval of the
contents from a database-external file store. The *FileResource* object
is stored in the database like any other but the content (file) is
stored elsewhere and is retrievable using the contained reference
*(storageKey)*.

    /api/fileResources

Obsah souborových prostředků není přímo přístupný, ale odkazuje se na ně z jiných objektů (například z datových hodnot) k ukládání binárního obsahu prakticky neomezené velikosti.

To create a file resource that does not require a corresponding data value,
POST to the endpoint `/api/fileResources` with a multipart upload:

```bash
curl "https://server/api/fileResources" -X POST
  -F "file=@/path/to/file/name-of-file.png"
```
The `uid` of a file resource can be provided when it is created, for example:
```bash
curl "https://server/api/fileResources?uid=0123456789x" -X POST
  -F "file=@/path/to/file/name-of-file.png"
```

To create both a file resource and a data value that references the file,
POST to the `/api/dataValues/file` endpoint in DHIS 2.36 or later:

```bash
curl "https://server/api/dataValues/file?de=xPTAT98T2Jd
  &pe=201301&ou=DiszpKrYNg8&co=Prlt0C1RF0s" -X POST
  -F "file=@/path/to/file/name-of-file.png"
```

For the `api/fileResources` endpoint, the only form parameter required is
*file*, which is the file to upload. For the `api/dataValues/file`
endpoint, the parameters required are the same as for a post to
`api/dataValues`, with the addition of *file*.

The filename and content-type should also be included in the request but
will be replaced with defaults when not supplied.

On successfully creating a file resource the returned data will contain
a `response` field which in turn contains the `fileResource` like this:

```json
{
  "httpStatus": "Accepted",
  "httpStatusCode": 202,
  "status": "OK",
  "response": {
    "responseType": "FileResource",
    "fileResource": {
      "name": "name-of-file.png",
      "created": "2015-10-16T16:34:20.654+0000",
      "lastUpdated": "2015-10-16T16:34:20.667+0000",
      "externalAccess": false,
      "publicAccess": "--------",
      "user": { ... },
      "displayName": "name-of-file.png",
      "contentType": "image/png",
      "contentLength": 512571,
      "contentMd5": "4e1fc1c3f999e5aa3228d531e4adde58",
      "storageStatus": "PENDING",
      "id": "xm4JwRwke0i"
    }
  }
}
```

Note that the response is a *202 Accepted*, indicating that the returned
resource has been submitted for background processing (persisting to the
external file store in this case). Also, note the `storageStatus` field
which indicates whether the contents have been stored or not. At this
point, the persistence to the external store is not yet finished (it is
likely being uploaded to a cloud-based store somewhere) as seen by the
`PENDING` status.

Even though the content has not been fully stored yet the file resource
can now be used, for example as referenced content in a data value (see
[Working with file data values](#datavalue_file)). If we need to check
the updated *storageStatus* or otherwise retrieve the metadata of the
file, the `fileResources` endpoint can be queried.

```bash
curl "https://server/api/fileResources/xm4JwRwke0i" -H "Accept: application/json"
```

This request will return the `FileResource` object as seen in the
response of the above example.

### Omezení souborových zdrojů { #webapi_file_resources_constraints } 

  - Souborové zdroje *musí* být odkazovány (přiřazeny) z jiného objektu
    in order to be persisted in the long term. A file resource which is
    created but not referenced by another object such as a data value is
    considered to be in *staging*. Any file resources which are in this
    state and are older than *two hours* will be marked for deletion
    and will eventually be purged from the system.

  - ID vrácené počátečním vytvořením souborového prostředku není
    retrievable from any other location unless the file resource has
    bylo odkazováno (ve kterém bude ID uloženo jako reference),
    takže jeho ztráta bude vyžadovat opakování požadavku POST a nové
    objekt, který má být vytvořen. Prostředek *osiřelého* souboru bude vyčištěn
    up automatically.

  - Objekty souborových prostředků jsou *neměnné*, což znamená, že modifikace nemají
    allowed and requires creating a completely new resource instead.

### Seznam blokovaných zdrojů souborů { #file-resource-blocklist } 

Nahrávání určitých typů souborů je z bezpečnostních důvodů blokováno.

Následující typy obsahu jsou blokovány.

| Typ obsahu | Typ obsahu |
| ------------------------------------- | ---- |
| text/html                             | application/x-ms-dos-executable |
| text/css                              | application/vnd.microsoft.portable-executable |
| text/javascript                       | application/vnd.apple.installer+xml |
| font/otf                              | application/vnd.mozilla.xul+xml |
| application/x-shockwave-flash         | application/x-httpd-php  |
| application/vnd.debian.binary-package | application/x-sh |
| application/x-rpm                     | application/x-csh |
| application/java-archive              |  |

Následující přípony souborů jsou blokovány.

| Přípona souboru | Přípona souboru | Přípona souboru |
| ---- | ---- | ---- |
| html | deb  | xul  |
| htm  | rpm  | php  |
| css  | jar  | bin  |
| js   | jsp  | sh   |
| mjs  | exe  | csh  |
| otf  | msi  | bat  |
| swf  | mpkg |      |

## Verze metadat { #webapi_metadata_versioning } 

Tato část vysvětluje rozhraní API pro správu verzí metadat.

  - `/api/metadata/version`: This endpoint will return the current metadata
    verzi systému, na kterém je vyvolána.



Tabulka: Parametry dotazu

| Název | Požadované | Popis |
|---|---|---|
| versionName | false | If this parameter is not specified, it will return the current version of the system or otherwise it will return the details of the versionName passed as parameter. (versionName is of the syntax "Version_<id\>" |

### Získejte příklady verzí metadat { #webapi_metadata_versioning_examples } 

**Příklad:** Získejte aktuální verzi metadat tohoto systému

Požadavek:

```
/api/metadata/version
```

Odezva:

```json
{
  "name": "Version_4",
  "created": "2016-06-30T06:01:28.684+0000",
  "lastUpdated": "2016-06-30T06:01:28.685+0000",
  "externalAccess": false,
  "displayName": "Version_4",
  "type": "BEST_EFFORT",
  "hashCode": "848bf6edbaf4faeb7d1a1169445357b0",
  "id": "Ayz2AEMB6ry"
}
```

**Příklad:** Získejte podrobnosti o verzi s názvem „Version_2“

Požadavek:

```
/api/metadata/version?versionName=Version_2
```

Odezva:

```json
{
  "name": "Version_2",
  "created": "2016-06-30T05:59:33.238+0000",
  "lastUpdated": "2016-06-30T05:59:33.239+0000",
  "externalAccess": false,
  "displayName": "Version_2",
  "type": "BEST_EFFORT",
  "hashCode": "8050fb1a604e29d5566675c86d02d10b",
  "id": "SaNyhusVxBG"
}
```

  - `/api/metadata/version/history`: This endpoint will return the list of all
    metadata versions of the system on which it is invoked.



Tabulka: Parametry dotazu

| Název | Požadované | Popis |
|---|---|---|
| základní linie | false | If this parameter is not specified, it will return list of all metadata versions. Otherwise we need to pass a versionName parameter of the form "Version_<id\>". It will then return the list of versions present in the system which were created after the version name supplied as the query parameter. |

### Získá seznam všech verzí metadat { #webapi_get_list_of_metadata_versions } 

**Příklad:** Získat seznam všech verzí v tomto systému

Požadavek:

```
/api/metadata/version/history
```

Odezva:

```json
{
  "metadataversions": [{
    "name": "Version_1",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T05:54:41.139+0000",
    "id": "SjnhUp6r4hG",
    "hashCode": "fd1398ff7ec9fcfd5b59d523c8680798"
  }, {
    "name": "Version_2",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T05:59:33.238+0000",
    "id": "SaNyhusVxBG",
    "hashCode": "8050fb1a604e29d5566675c86d02d10b"
  }, {
    "name": "Version_3",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T06:01:23.680+0000",
    "id": "FVkGzSjAAYg",
    "hashCode": "70b779ea448b0da23d8ae0bd59af6333"
  }]
}
```

**Příklad:** Získat seznam všech verzí v tomto systému vytvořených po verzi „Version_2“

Požadavek:

```
/api/metadata/version/history?baseline=Version_2
```

Odezva:

```json
{
  "metadataversions": [{
    "name": "Version_3",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T06:01:23.680+0000",
    "id": "FVkGzSjAAYg",
    "hashCode": "70b779ea448b0da23d8ae0bd59af6333"
  }, {
    "name": "Version_4",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T06:01:28.684+0000",
    "id": "Ayz2AEMB6ry",
    "hashCode": "848bf6edbaf4faeb7d1a1169445357b0"
  }]
 }
```

  - `/api/metadata/version/create`: Tento koncový bod vytvoří metadata
    version for the version type as specified in the parameter.



Tabulka: Parametry dotazu

| Název | Požadované | Popis |
|---|---|---|
| typ | true | The type of metadata version which needs to be created.<br>  * BEST_EFFORT<br> * ATOMIC |

Users can select the type of metadata which needs to be created.
Metadata Version type governs how the importer should treat the given
version. This type will be used while importing the metadata. There are
two types of metadata.

  - *BEST_EFFORT*: This type suggests that missing references can be
    ignored and the importer can continue importing the metadata (e.g.
    missing data elements on a data element group import).

  - *ATOMIC*: This type ensures a strict type checking of the metadata
    references and the metadata import will fail if any of the references
    do not exist.

> **Note**
>
> It's recommended to have an ATOMIC type of versions to ensure that all
> systems (central and local) have the same metadata. Any missing
> reference is caught in the validation phase itself. Please see the
> importer details for a full explanation.

### Vytvořte verzi metadat { #webapi_create_metadata_version } 

**Příklad:** Vytvořte verzi metadat typu `BEST_EFFORT`

Požadavek:

```bash
curl -X POST -u admin:district "https://play.dhis2.org/dev/api/metadata/version/create?type=BEST_EFFORT"
```

Odezva:

```json
{
  "name": "Version_1",
  "created": "2016-06-30T05:54:41.139+0000",
  "lastUpdated": "2016-06-30T05:54:41.333+0000",
  "externalAccess": false,
  "publicAccess": "--------",
  "user": {
    "name": "John Traore",
    "created": "2013-04-18T17:15:08.407+0000",
    "lastUpdated": "2016-04-06T00:06:06.571+0000",
    "externalAccess": false,
    "displayName": "John Traore",
    "id": "xE7jOejl9FI"
  },
  "displayName": "Version_1",
  "type": "BEST_EFFORT",
  "hashCode": "fd1398ff7ec9fcfd5b59d523c8680798",
  "id": "SjnhUp6r4hG"
}
```

  - `/api/metadata/version/{versionName}/data`: This endpoint will download
    the actual metadata specific to the version name passed as path
    parameter.

  - `/api/metadata/version/{versionName}/data.gz`: Tento koncový bod se stáhne
    the actual metadata specific to the version name passed as path
    parameter in a compressed format (gzipped).



Tabulka: Parametry cesty

| Název | Požadované | Popis |
|---|---|---|
| versionName | true | Path parameter of the form "Version_<id\>" so that the API downloads the specific version |

### Stažení metadat verze { #webapi_download_version_metadata } 

**Příklad:** Získejte aktuální metadata pro "Version 5"

Požadavek:

```bash
curl -u admin:district "https://play.dhis2.org/dev/api/metadata/version/Version_5/data"
```

Odezva:

```json
{
  "date": "2016-06-30T06:10:23.120+0000",
  "dataElements": [
    {
      "code": "ANC 5th Visit",
      "created": "2016-06-30T06:10:09.870+0000",
      "lastUpdated": "2016-06-30T06:10:09.870+0000",
      "name": "ANC 5th Visit",
      "id": "sCuZKDsix7Y",
      "shortName": "ANC 5th Visit ",
      "aggregationType": "SUM",
      "domainType": "AGGREGATE",
      "zeroIsSignificant": false,
      "valueType": "NUMBER",
      "categoryCombo": {
        "id": "p0KPaWEg3cf"
      },
      "user": {
        "id": "xE7jOejl9FI"
      }
    }
  ]
}
```

## Synchronizace metadat { #webapi_metadata_synchronization }

This section explains the Metadata Synchronization API available
starting 2.24

  - `/api/metadata/sync`: Tento koncový bod provádí synchronizaci metadat
    název verze předaný v parametru dotazu stažením a
    import zadané verze ze vzdáleného serveru, jak je definováno v
    the settings app.



Tabulka: Parametry databázového dotazu

| Název | Požadované | Popis |
|---|---|---|
| versionName | true | versionName query parameter of the form "Version_<id\>" . The api downloads this version from the remote server and imports it in the local system. |

  - Toto API by mělo být používáno s maximální opatrností. Upozorňujeme, že existuje
    alternativní způsob, jak dosáhnout synchronizace zcela automatizovaným způsobem
    využití úlohy synchronizace metadat ze „správy dat“
    app. See Chapter 22, Section 22.17 of User Manual for more details
    regarding Metadata Sync Task.

  - This sync API can alternatively be used to sync metadata for the
    verze, které selhaly z plánovače synchronizace metadat. Kvůli
    its dependence on the given metadata version number, care should be
    taken for the order in which this gets invoked. E.g. If this api is
    used to sync some higher version from the central instance, then the
    sync might fail as the metadata dependencies are not present in the
    local instance.

  - Assume the local instance is at `Version_12` and if this endpoint is used
    to sync `Version_15` (of type `BEST_EFFORT`) from the central
    instance, the scheduler will start syncing metadata from
    `Version_16`. Místní instance tedy nebude mít metadata
    verze mezi `Version_12` a `Version_15`. Musíte ručně
    sync the missing versions using these endpoints only.

### Synchronizovat verzi metadat { #webapi_metadata_synchronization_version } 

**Příklad:** Synchronizace Version_6 z centrálního systému do tohoto systému

Požadavek:

```bash
curl -u admin:district "https://play.dhis2.org/dev/api/metadata/sync?versionName=Version_6"
```

## Úložiště metadat { #webapi_metadata_repository } 

DHIS2 provides a metadata repository containing metadata packages with
various content. A metadata package is a DHIS2-compliant JSON document
which describes a set of metadata objects.

Chcete-li získat index dostupných balíčků metadat, můžete zadat požadavek GET na prostředek *metadataRepo*:

    GET /api/synchronization/metadataRepo

A metadata package entry contains information about the package and a
URL to the relevant package. An index could look like this:

```json
{
  "packages": [
    {
      "id": "sierre-leone-demo",
      "name": "Sierra Leone demo",
      "description": "Sierra Leone demo database",
      "version": "0.1",
      "href": "https://dhis2.org/metadata-repo/221/sierra-leone-demo/metadata.json"
    },
    {
      "id": "trainingland-org-units",
      "name": "Trainingland organisation units",
      "description": "Trainingland organisation units with four levels",
      "version": "0.1",
      "href": "https://dhis2.org/metadata-repo/221/trainingland-org-units/metadata.json"
    }
  ]
}
```

A client can follow the URLs and install a metadata package through a
POST request with content type *text/plain* with the metadata package
URL as the payload to the *metadataPull* resource:

    POST /api/synchronization/metadataPull

Příklad příkazu curl vypadá takto:

```bash
curl "localhost:8080/api/synchronization/metadataPull" -X POST
  -d "https://dhis2.org/metadata-repo/221/trainingland-org-units/metadata.json"
  -H "Content-Type:text/plain" -u admin:district
```


> **Note**
>
> The supplied URL will be checked against the config property `system.remote_servers_allowed` in the `dhis.conf` file.
> If the base URL is not one of the configured servers allowed then the operation will not be allowed. See failure example below.  
> Some examples where the config set is `system.remote_servers_allowed=https://server1.org/,https://server2.org/`
> - supply `https://server1.org/path/to/resource` -> this will be accepted
> - supply `https://server2.org/resource/path` -> this will be accepted
> - supply `https://oldserver.org/resource/path` -> this will be rejected
>
Sample failure response

```json
 {
  "httpStatus": "Conflict",
  "httpStatusCode": 409,
  "status": "ERROR",
  "message": "Provided URL is not in the remote servers allowed list",
  "errorCode": "E1004"
}
```


## Reference to created by user { #reference-to-created-by-user } 

Každý objekt vytvořený v DHIS2 bude mít vlastnost s názvem `user`, která je spojena s `User`, který objekt vytvořil.

Od verze 2.36 jsme změnili název této vlastnosti na `createdBy`, aby nedošlo k záměně.

Aby však byla zachována zpětná kompatibilita, je původní vlastnost `user` stále zahrnuta do datového obsahu a funguje normálně jako dříve.

```json
{
  "createdBy": {
      "displayName": "John Kamara",
      "name": "John Kamara",
      "id": "N3PZBUlN8vq",
      "username": "district"
  },
  "user": {
      "displayName": "John Kamara",
      "name": "John Kamara",
      "id": "N3PZBUlN8vq",
      "username": "district"
  }
}
```

## Pracovní postup návrhu metadat { #webapi_metadata_proposal_workflow }

Koncový bod pracovního postupu návrhu metadat umožňuje pracovní postup navrhování a přijímání změn metadat.

```
/api/metadata/proposals
```

### Navrhněte změnu metadat { #webapi_metadata_proposal_propose }

Nabídka vždy cílí na jeden objekt metadat pomocí:

    POST /api/metadata/proposals

V závislosti na datovém obsahu by návrh mohl:

* Přidat nový objekt metadat.
* Aktualizujte existující odkazy na objekt metadat podle ID.
* Odstraňte existující objekt metadat, na který odkazuje ID.

Chcete-li navrhnout přidání nového objektu metadat, odešlete datovou část JSON, jako je následující:

```json
{
  "type": "ADD",
  "target": "ORGANISATION_UNIT",
  "change": {"name":"My Unit", "shortName":"MyOU", "openingDate": "2020-01-01"}
}
```
Vlastnost `change` obsahuje stejný objekt JSON, který lze přímo odeslat do odpovídajícího koncového bodu za účelem vytvoření objektu.

Chcete-li navrhnout aktualizaci existujícího objektu metadat, odešlete datovou část JSON jako v níže uvedeném příkladu:

```json
{
  "type": "UPDATE",
  "target": "ORGANISATION_UNIT",
  "targetId": "<id>",
  "change": [
    {"op": "replace", "path": "/name", "value": "New name"}
  ]
}
```
The `targetId` refers to the object by its ID which should be updated. The `change` property here contains a JSON patch payload. This is the same
patch payload that could be posted to the corresponding endpoint to directly apply the update.

Chcete-li navrhnout odstranění existujícího objektu, odešlete datový obsah jako v posledním příkladu:

```json
{
  "type": "REMOVE",
  "target": "ORGANISATION_UNIT",
  "targetId": "<id>"
}
```
The `targetId` refers to the object  by its ID which should be removed. A free text `comment` can be added to any type of comment.

V současnosti je podporován pouze cílový `target` typ `ORGANISATION_UNIT`.

### Přijměte návrh na změnu metadat { #webapi_metadata_proposal_accept }
Chcete-li přijmout otevřenou nabídku, použijte příkaz `POST` ve zdroji nabídky

    POST /api/metadata/proposals/<uid>

Po úspěchu se stav návrhu změní na stav `ACCEPTED`. Jakmile je návrh přijat, již nelze odmítnout.

Should a proposal fail to apply it changes to status `NEEDS_UPDATE`. The `reason` field contains a summary of the failures when this information is 
available.

### Odmítněte návrh změny metadat { #webapi_metadata_proposal_oppose }
Pokud návrh není zcela v pořádku a potřebuje úpravu, lze to označit tak, že se proti návrhu postavíte zasláním `PATCH` pro zdroj návrhu.

    PATCH /api/metadata/proposals/<uid>

Volitelně lze k tomu přidat tělo ve formátu prostého textu, aby byl uveden `důvod`, proč byl návrh proti.

Oponovaný návrh musí být ve stavu `PROPOSED` a změní se na stav `NEEDS_UPDATE`.

### Upravte návrh změny metadat { #webapi_metadata_proposal_adjust }
A proposal in state `NEEDS_UPDATE` needs to be adjusted before it can be accepted. To adjust the proposal a `PUT` request is made for the proposal's 
resource

    PUT /api/metadata/proposals/<uid>

Such an adjustment can either be made without a body or with a JSON body containing an object with the updated `change` and `targetId` for the 
adjustment:

```json
{
  "targetId": "<id>",
  "change": ...
}
```
Typ JSON hodnoty `change` závisí na `type` nabídky, který je analogický tomu, kdy byla nabídka původně vytvořena.

### Odmítněte návrh změny metadat { #webapi_metadata_proposal_reject }
Chcete-li odmítnout otevřenou nabídku, použijte ve zdroji nabídky možnost `DELETE`

    DELETE /api/metadata/proposals/<uid>

Tím se definitivně změní stav návrhu na `REJECTED`. V tomto návrhu nelze provádět žádné další změny. Je vedena jako dokumentace událostí.

### Výpis návrhů změn metadat { #webapi_metadata_proposal_list }
Všechny návrhy mohou být uvedeny:

    GET /api/metadata/proposals/

The result list can be filtered using the `filter` parameter.
For example, to list only accepted proposals use:

    GET /api/metadata/proposals?filter=status:eq:ACCEPTED

Podobně jako k zobrazení pouze otevřených návrhů použijte:

    GET /api/metadata/proposals?filter=status:eq:PROPOSED

Filtry lze také použít na libovolné pole kromě pole `change`. Podporované operátory filtrů jsou popsány v Gist Metadata API. Patří sem také transformátory vlastností popsané pro Gist API.

Seznam dostupných polí je:

| Pole       | Popis |
| ----------- | -------------------------------------------------------------- |
| id          | jedinečný identifikátor nabídky |
| typ        | `ADD` nový objekt, `UPDATE` existující objekt, `REMOVE` existující objekt |
| status      | `PROPOSED` (otevřený návrh), `ACCEPTED` (úspěšný), `NEEDS_UPDATE` (přijetí způsobené chyby nebo proti), `REJECTED` |
| cíl      | typ objektu metadat, který se má přidat/aktualizovat/odebrat; aktuálně pouze `ORGANISATION_UNIT` |
| targetId    | UID aktualizovaného nebo odebraného objektu, není definováno pro `ADD` |
| createdBy   | uživatel, který návrh vytvořil |
| created     | datum a čas, kdy byl návrh vytvořen |
| finalisedBy | uživatel, který návrh přijal nebo odmítl |
| dokončeno   | datum a čas, kdy se návrh změnil na konečný stav buď přijat, nebo zamítnut |
| comment     | volitelný prostý textový komentář uvedený u původního návrhu |
| důvod      | nepovinný prostý text zadaný, když byl návrh vznesen proti, nebo chyby, které se vyskytly při neúspěšném přijetí návrhu | 
| změna      | Objekt JSON pro návrh `ADD`, pole JSON pro návrh `UPDATE`, nic pro návrh `REMOVE` |

### Zobrazení návrhů na změnu metadat { #webapi_metadata_proposal_show }
Individual change proposals can be viewed using 

    GET /api/metadata/proposals/<uid>

Parametr `fields` lze použít k zúžení polí zahrnutých pro zobrazený objekt. Například:

    GET /api/metadata/proposals/<uid>?fields=id,type,status,change

## Metadata Attribute Value Type and validations { #metadata-attribute-value-type-and-validations } 
| Typ | Ověření
|---| --- |
| TEXT | Žádný
| LONG_TEXT | Žádný
| LETTER | Value length = 1 AND is a letter
| PHONE_NUMBER  | Validation is based on this regex `^[0-9+\\(\\)#\\.\\s\\/ext-]{6,50}$`. Max length is 50.  <br /> Examples: +4733987937, (+47) 3398 7937, (47) 3398 7937.123
| EMAIL | Obecný e-mailový formát abc@email.com
| BOOLEAN | `true` nebo `false`
| TRUE_ONLY | Only accept `true`
| DATE | Use format `yyyy-MM-dd`
| DATETIME | Use format `yyyy-MM-dd HH:mm:ssZ` or `yyyy-MM-dd'T'HH:mm:ss`
| TIME | Use fornat `HH:mm`
| NUMBER | Value must be numberic with max length = 250
| UNIT_INTERVAL | Value is numeric and inclusive between 0 and 1
| PERCENTAGE | Value is a number in the inclusive range of 0 to 100
| INTEGER | Value is an integer
| INTEGER_POSITIVE | Value is a positive integer
| INTEGER_NEGATIVE | Value is a negative integer
| INTEGER_ZERO_OR_POSITIVE | Value is an positive or zero integer
| TRACKER_ASSOCIATE | Žádný
| USERNAME | Value is a username of an existing `User`
| COORDINATE | Žádný
| ORGANISATION_UNIT | Value is a valid UID of an existing `OrganisationUnit`
| REFERENCE | Žádný
| AGE | Value is date of birth. Use format as in DATE type.
| URL | Value is a valid URL
| FILE_RESOURCE | Value is a valid UID of existing `FileResource`
| IMAGE | Value is a valid UID of existing `FileResource`
| GEOJSON |Follow [GeoJson Specification](https://geojson.org)
| MULTI_TEXT | Žádný

## Copy Program { #copy-program } 

### Úvod { #introduction } 

A user will often want to create many `Program`s which share many of the same characteristics, and instead of having to create a new `Program` from scratch, it is efficient and beneficial to copy an existing `Program` and make modifications to it.  
A template `Program` could theoretically be setup as a base to copy from, which may help with the consistency of `Program` setups also.

### API info { #api-info } 

#### Endpoint  { #endpoint } 

    POST /api/programs/{uid}/copy

Example with a `Program` with a `UID` of `Program123a`

    POST /api/programs/Program123a/copy

Successful response will include the new `Program` `UID` and will look like this:

```json
{
    "httpStatus": "Created",
    "httpStatusCode": 201,
    "status": "OK",
    "message": "Program created: 'Program456b'"
}
```

The response will also contain a `Location` header with a link to the newly-created `Program`. e.g. when run locally the `Location` value would be `http://localhost:9090/api/programs/Program456b`

#### Copy options { #copy-options } 

The API does allow the optional supplying of a custom prefix, which will be prefixed to the following properties.

| Objekt           | Vlastnictví  | Info                                     |
|------------------|-----------|------------------------------------------|
| Program          | název      | Help identify the new Program            |
| ProgramIndicator | název      | Database constraint - needs to be unique |
| ProgramIndicator | shortName | Database constraint - needs to be unique |

In this example when a custom prefix is supplied, an original `Program` with a name of `My Simple Program` would be copied to a new `Program` with the name `my prefix My Simple Program` 

If no copy options are sent in the API call then the default `Copy of ` prefix will be used for the above properties.  
To send a custom prefix just add a HTTP request param `prefix` like so:  

     POST /api/programs/{uid}/copy?prefix=my prefix 

> **Note**
>
> The database does have limits for the number of characters allowed for properties. At the time of writing these limits are noted in the table below. Bear these in mind.

| Vlastnictví  | character limit |
|-----------|-----------------|
| název      | 230             |
| shortName | 50              |

If a property has exceeded its character limit, then an error will be returned like so:

```json
{
    "httpStatus": "Conflict",
    "httpStatusCode": 409,
    "status": "ERROR",
    "message": "ERROR: value too long for type character varying(230)",
    "errorCode": "E1004"
}
```

If trying to copy a Program that is not found, a response like this will be returned:
```json
{
    "httpStatus": "Not Found",
    "httpStatusCode": 404,
    "status": "ERROR",
    "message": "Program with id {uid} could not be found.",
    "errorCode": "E1005"
}
```

### Authorisation { #authorisation } 

#### Authorities { #authorities } 

A `User` will need the following authorities to be able to copy a `Program`:

- F_PROGRAM_PUBLIC_ADD
- F_PROGRAM_INDICATOR_PUBLIC_ADD

#### Přístup { #access } 

A `Program` needs one of the following states for it to be able to be copied:

- Public `read` & `write` access
- A specific `User` to have sharing `read` & `write` access
- A `User` is part of a `UserGroup` that has sharing `read` & `write` access

If a `User` does not have the correct permissions, a `Forbidden` response is returned like so:

```json
{
    "httpStatus": "Forbidden",
    "httpStatusCode": 403,
    "status": "ERROR",
    "message": "You don't have write permissions for Program Program123a",
    "errorCode": "E1006"
}
```

### Points to note { #points-to-note } 

#### Deep and shallow copy { #deep-and-shallow-copy } 

When a `Program` is copied, certain properties of the `Program` need different kinds of copying. It is important to be aware of what has been deep-copied and what has been shallow-copied.  
First of all let's explain the difference between deep and shallow copying in this context.  

##### Deep copy { #deep-copy } 

A deep copy in this context means that a completely new instance of a `Program` or `Program` property has been created with its own unique identifiers. These include amongst others:

- id
- uid  

Deep copies of `Program` properties will all belong to the newly-created `Program` copy.

##### Shallow copy { #shallow-copy } 

A shallow copy in this context means that an existing `Program` property will be reused by the newly-created `Program` or `Program` property.

#### Properties that get deep copied { #properties-that-get-deep-copied } 

All properties below have been deep copied. Anything not in included in this table means that it has been shallow copied.

| Objekt                         | Property of  |
|--------------------------------|--------------|
| Program                        |              |
| ProgramSection                 | Program      |
| ProgramIndicator               | Program      |
| ProgramRuleVariable            | Program      |
| Fáze programu                   | Program      |
| ProgramStageSection            | Fáze programu |
| ProgramStageSectionDataElement | Fáze programu |
| Zápis                     |              |

> **Note**
>
> The following properties have been set as empty as an initial approach. This approach should keep things simple to start off with.  

| Objekt                        | Vlastnictví          |
|-------------------------------|-------------------|
| ProgramIndicator              | groups            |
| ProgramStageSection           | programIndicators |
| Zápis                    | Události            |

