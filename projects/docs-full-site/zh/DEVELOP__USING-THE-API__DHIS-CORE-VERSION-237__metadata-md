---
edit_url: "https://github.com/dhis2/dhis2-docs/blob/2.37/src/developer/web-api/metadata.md"
revision_date: '2021-11-23'
tags:
- DHIS 核心 2.37 版
- Develop
---

# 元数据 { #metadata } 

## 标识符方案 { #webapi_identifier_schemes } 

本节提供标识符方案概念的解释。
标识符方案用于将元数据对象映射到其他元数据
在导入期间，并将元数据呈现为导出的一部分。请注意
并不是所有的方案都适用于所有的 API 调用，也不是所有的
方案可用于输入和输出。这在
部分解释了各种 Web API。

列出了可用的全套标识符方案对象类型
下面，使用在查询中使用的属性名称：

  - 方案

  - 数据元素标识方案

  - 类别选项组合IdScheme

  - orgUnitIdScheme

  - 程序标识方案

  - 程序阶段标识方案

  - 跟踪实体 ID 方案

  - 跟踪实体属性 IDScheme

通用 idScheme 适用于所有类型的对象。有可能
被特定的对象类型覆盖。

所有参数的默认方案是 UID（稳定的 DHIS2
身份标识）。支持的标识符方案在
下表。

表：计划值

| 计划 | 描述 |
|---|---|
| ID, UID | 与 DHIS2 稳定标识符匹配，这是默认标识方案。 |
| 代码 | 与 DHIS2 编码匹配，主要用于与外部系统交换数据。 |
| 名称 | 在 DHIS2 名称上匹配，请注意这使用的是可用的 *object.name*，而不是翻译后的名称。还请注意，名称并不总是唯一的，在这种情况下，不能使用它们。 |
| ATTRIBUTE:ID | 根据元数据属性进行匹配，需要将此属性分配给要匹配的类型，并将唯一属性设置为*true*。它的主要用途也是与外部系统交换数据，与 *CODE* 相比，它有一些优势，因为可以添加多个属性，所以可以用于与多个系统同步。 |

请注意，标识符方案不是一个独立的功能，但需要
与数据值导入、元数据导入等资源结合使用。

例如，指定 CODE 作为通用 id 方案并覆盖
使用 UID 作为组织单位 ID 方案，您可以使用这些查询
参数：

    ？idScheme = CODE＆orgUnitIdScheme = UID

再举一个例子，为组织单位 id 指定一个属性
方案，数据元素 id 方案的代码并使用默认 UID id
您可以使用这些参数的所有其他对象的方案：

    ？orgUnitIdScheme =属性：j38fk2dKFsG＆dataElementIdScheme = CODE

## 浏览Web API { #webapi_browsing_the_web_api } 

浏览 Web API 的入口点是 `/api`。这个资源
提供所有可用资源的链接。四种资源表示
格式始终适用于所有资源：HTML、XML、JSON、
和 JSONP。某些资源将具有其他可用格式，例如 MS
Excel、PDF、CSV 和 PNG。要从 Web 浏览器探索 API，请导航
到 `/api` 入口点并按照链接到您想要的
资源，例如`/api/dataElements`。对于所有资源
返回元素列表，某些查询参数可用于修改
响应：

表格查询参数

| 参数 | 选项值 | 默认选项 | 描述 |
|---|---|---|---|
| 分页 | true &#124; false | 真正 | 表示是否返回页面中的元素列表。 |
| 页码 | 编号 | 1 | 定义要返回的页码。 |
| 页面大小 | 编号 | 50 | 定义每页返回的元素数量。 |
| 订单 | property:asc/iasc/desc/idesc || iasc 和 idesc 是不区分大小写的排序。 |

如何使用这些参数获取完整列表的示例
XML 响应格式的数据元素组是：

    /api/dataElementGroups.xml?links=false&paging=false

您可以在 name 属性上查询元素而不是返回
使用 *query* 查询变量的完整元素列表。在这个例子中
我们查询名称中带有“贫血”一词的所有数据元素：

    / api / dataElements？query =贫血

您可以像这样获取特定页面和对象的页面大小：

    /api/dataElements.json?page=2&pageSize=20

您可以像这样完全禁用分页：

    /api/indicatorGroups.json?paging=false

要基于特定属性对结果进行排序：

    /api/indicators.json?order=shortName:desc

您可以通过以下方式在所有对象类型中根据对象的 ID 查找对象
*identifiableObjects* 资源：

    / api / identifiableObjects / <id>

### 翻译 { #webapi_translation } 

DHIS2 支持数据库内容的翻译，如数据元素、指标和计划、
指标和程序。网络应用程序接口中的所有元数据对象都有
属性，其中包括
*displayName*, *displayShortName*, *displayDescription* 和
*displayFormName*（用于数据元素和跟踪实体属性）。

表格翻译选项

| 参数 | 价值观 | 描述 |
|---|---|---|
| 译 | true &#124; false | 翻译元数据输出中的 display\* 属性（数据元素和跟踪实体属性的 displayName、displayShortName、displayDescription 和 displayFormName）。默认值为 true。 |
| 地点 | 使用的本地语言 | 使用指定的本地语言翻译元数据输出（要求 translate=true）。 |

### 翻译API { #webapi_translation_api } 

对象的翻译呈现为对象本身的一部分
在* translation *数组中。请注意，
JSON / XML有效负载的*翻译*数组通常为您预先过滤，这意味着它们不能直接用于导入/导出翻译（因为那样会
通常会覆盖当前用户以外的语言环境）。

在用户语言环境中过滤了转换数组的数据元素示例：

```json
{
  "id": "FTRrcoaog83",
  "displayName": "Accute French",
  "translations": [
    {
      "property": "SHORT_NAME",
      "locale": "fr",
      "value": "Accute French"
    },
    {
      "property": "NAME",
      "locale": "fr",
      "value": "Accute French"
    }
  ]
}
```

转换关闭的数据元素示例：

```json
{
  "id": "FTRrcoaog83",
  "displayName": "Accute Flaccid Paralysis (Deaths < 5 yrs)",
  "translations": [
    {
      "property": "FORM_NAME",
      "locale": "en_FK",
      "value": "aa"
    },
    {
      "property": "SHORT_NAME",
      "locale": "en_GB",
      "value": "Accute Flaccid Paral"
    },
    {
      "property": "SHORT_NAME",
      "locale": "fr",
      "value": "Accute French"
    },
    {
      "property": "NAME",
      "locale": "fr",
      "value": "Accute French"
    },
    {
      "property": "NAME",
      "locale": "en_FK",
      "value": "aa"
    },
    {
      "property": "DESCRIPTION",
      "locale": "en_FK",
      "value": "aa"
    }
  ]
}
```

请注意，即使您得到未过滤的结果，并且正在使用
适当的类型端点，即我们不允许的 `/api/dataElements` 
更新，因为这样做很容易犯错误并覆盖
其他可用的语言环境。

要阅读和更新翻译，您可以使用特殊翻译
每个对象资源的端点。可以通过*GET*或访问
在适当的`/ api / <object-type> / <object-id> / translations `端点上* PUT *。

As an example, for a data element with identifier `FTRrcoaog83`, you could use
`/api/dataElements/FTRrcoaog83/translations` to get and update
translations. The fields available are `property` with options *NAME*,
*SHORT_NAME*, *FORM_NAME*, *DESCRIPTION*, `locale` which supports any valid
locale ID and the translated property `value`.

法语语言环境的NAME属性示例：

```json
{
  "property": "NAME",
  "locale": "fr",
  "value": "Paralysie Flasque Aiguë (Décès <5 ans)"
}
```

然后将此有效负载添加到翻译数组中，并发回
到适当的端点：

```json
{
  "translations": [
    {
      "property": "NAME",
      "locale": "fr",
      "value": "Paralysie Flasque Aiguë (Décès <5 ans)"
    }
  ]
}
```

对于ID为* FTRrcoaog83 *的数据元素，您可以* PUT *此代码为
`/ api / dataElements / FTRrcoaog83 / translations`。确保发送全部
特定对象的翻译，而不仅仅是单个语言环境的翻译
（否则，您可能会覆盖其他区域的现有语言环境
语言环境）。

### Web API版本 { #webapi_api_versions } 

Web API的版本从DHIS 2.25开始。 API版本
遵循DHIS2主版本号。例如，API
DHIS 2.33的版本是`33`。

您可以通过包含版本号来访问特定的 API 版本
在`/api` 组件之后，作为这样的例子：

    / api / 33 / dataElements

如果省略 URL 的 version 部分，系统将使用当前的
API 版本。例如，对于 DHIS 2.25，在省略 API 部分时，
系统将使用 API 版本 25。在开发 API 客户端时，它是
建议使用显式 API 版本（而不是省略 API
版本），因为这将保护客户端免受不可预见的 API 更改。

将支持最后三个 API 版本。例如，DHIS
2.27 版本将支持 API 版本 27、26 和 25。

请注意，元数据模型没有版本控制，您可能
体验变化，例如在对象之间的关联中。这些变化
将记录在 DHIS2 主要版本发行说明中。

## 元数据对象过滤器 { #webapi_metadata_object_filter } 

要过滤元数据，可以使用多种过滤操作
应用于返回的元数据列表。过滤器的格式
本身是直截了当的并遵循模式
*property:operator:value*，其中 *property* 是
要过滤的元数据，*operator* 是比较运算符
您想要执行并且 *value* 是要检查的值（不是全部
运算符需要值）。请参阅 *schema* 部分以发现
哪些属性可用。递归过滤，即。过滤
也支持关联对象或对象集合。

表：可用操作符

| 操作员 | 类型 | 所需数值 | 描述 |
|---|---|---|---|
| 等式 | 字符串 | 布尔值 | 整数 | 浮点 | 枚举 | 集合（检查大小） | 日期 | 真正 | 平等 |
| !eq | 字符串 | 布尔值 | 整数 | 浮点 | 枚举 | 集合（检查大小） | 日期 | 真正 | 不平等 |
| 霓 | 字符串 | 布尔值 | 整数 | 浮点 | 枚举 | 集合（检查大小） | 日期 | 真正 | 不平等 |
| 喜欢 | 字符串 | 真正 | 区分大小写的字符串，任意匹配 |
| 喜欢 | 字符串 | 真正 | 区分大小写的字符串，任何地方都不匹配 |
| $like | 字符串 | 真正 | 区分大小写的字符串，匹配开始 |
| !$like | 字符串 | 真正 | 区分大小写的字符串，不匹配起始位置 |
| 喜欢$ | 字符串 | 真正 | 区分大小写的字符串，匹配末尾 |
| 喜欢$ | 字符串 | 真正 | 区分大小写的字符串，不匹配尾部 |
| 我喜欢 | 字符串 | 真正 | 不区分大小写的字符串，可在任意位置匹配 |
| 我喜欢 | 字符串 | 真正 | 不区分大小写的字符串，不匹配任何地方 |
| $ilike | 字符串 | 真正 | 不区分大小写字符串，匹配开始 |
| !$ilike | 字符串 | 真正 | 不区分大小写的字符串，不匹配起始位置 |
| 我喜欢$ | 字符串 | 真正 | 不区分大小写字符串，匹配末尾 |
| 我喜欢$ | 字符串 | 真正 | 不区分大小写的字符串，不匹配末尾 |
| gt | 字符串 | 布尔值 | 整数 | 浮点 | 集合（检查大小） | 日期 | 真正 | 大于 |
| ge | 字符串 | 布尔值 | 整数 | 浮点 | 集合（检查大小） | 日期 | 真正 | 大于或等于 |
| lt | 字符串 | 布尔值 | 整数 | 浮点 | 集合（检查大小） | 日期 | 真正 | 小于 |
| 勒 | 字符串 | 布尔值 | 整数 | 浮点 | 集合（检查大小） | 日期 | 真正 | 小于或等于 |
| 无效 | 一应俱全 | 假 | 属性为空 |
| 无效 | 一应俱全 | 假 | 属性不为空 |
| 空的 | 系列 | 假 | 藏品为空 |
| 象征性 | 字符串 | 真正 | 在搜索属性中对多个标记进行匹配 |
| 令牌 | 字符串 | 真正 | 搜索属性中的多个标记不匹配 |
| 在 | 字符串 | 布尔值 | 整数 | 浮点 | 日期 | 真正 | 查找匹配 1 个或多个值的对象 |
| 在 | 字符串 | 布尔值 | 整数 | 浮点 | 日期 | 真正 | 查找与 1 个或多个值不匹配的对象 |

运算符将作为逻辑 *and* 查询应用，如果您需要 *or*
查询，您可以查看我们的 *in* 过滤器（也可以查看
以下部分）。过滤机制允许递归。见下文
对于一些例子。

获取ID属性为ID1或ID2的数据元素：

    / api / dataElements？filter = id：eq：ID1＆filter = id：eq：ID2

获取具有ID为ID1的dataSet的所有数据元素：

    /api/dataElements?filter=dataSetElements.dataSet.id:eq:ID1

使用聚合运算符“sum”和值类型获取所有数据元素
“内部”：

    /api/dataElements.json?filter=aggregationOperator:eq:sum&filter=type:eq:int

您可以在集合中进行过滤，例如获取数据元素
是“ANC”数据元素组的成员，您可以使用以下内容
使用关联数据元素组的 id 属性查询：

    /api/dataElements.json?filter=dataElementGroups.id:eq:qfxEYY9xAl6

由于默认情况下所有运算符都是 *and*，因此您无法找到数据
匹配多个 id 的元素，为此您可以使用 *in*
操作员。

    /api/dataElements.json?filter=id:in:[fbfJHSPpUQD,cYeuwXTCPkU]。

### 逻辑运算符 { #webapi_metadata_logical_operator } 

如前一节所述，应用了默认逻辑运算符
过滤器是 *AND* 这意味着所有对象过滤器必须是
匹配。但是，在某些情况下，您希望匹配其中之一
几个过滤器（可能是 id 和 code 字段），在这些情况下，它是
可以将根逻辑运算符从 *AND* 切换为 *OR*
使用 *rootJunction* 参数。

示例：正常过滤，其中 id 和 code 必须匹配才能具有
结果返回

    /api/dataElements.json?filter=id:in:[id1,id2]&filter=code:eq:code1

示例：过滤逻辑运算符已切换为 OR 的位置
现在只有一个过滤器必须匹配才能产生结果
    回

    /api/dataElements.json?filter=id:in:[id1,id2]&filter=code:eq:code1&rootJunction=OR

### 可识别的令牌过滤器 { #identifiable-token-filter } 

除了上述基于特定属性的过滤之外，
我们还通过* token *基于* AND *过滤了一组
属性：ID，代码和名称（如果可用，还包括shortName）。这些
属性通常称为*可识别*。这个想法是为了
过滤ID，名称，代码或简称中包含某些内容的元数据。

示例：过滤所有包含 *2nd* 的数据元素
如下： id,name,code,shortName

    /api/dataElements.json?filter=identifiable:token:2nd

也可以指定多个过滤值。

示例：获取在任何 *identifiable* 属性中找到 *ANC visit* 的所有数据元素。系统返回所有数据元素，其中在可识别属性中的任何地方都可以找到令牌（ANC 和访问）。

    /api/dataElements.json?filter=identifiable:token:ANC访问

也可以将可识别过滤器与基于属性的过滤器结合起来，并期望应用 *rootJunction*。

    /api/dataElements.json?filter=identifiable:token:ANC visit＆filter = displayName：ilike：tt1

    /api/dataElements.json?filter=identifiable:token:ANC访问
      ＆filter = displayName：ilike：tt1＆rootJunction = OR

## 元数据字段过滤器 { #webapi_metadata_field_filter } 

在许多情况下，元数据的默认视图可能太
冗长。客户可能只需要每个对象的几个字段，并且想要
从响应中删除不必要的字段。发现哪些字段
可用于每个对象，请参阅 *schema* 部分。

包含/排除的格式允许无限递归。过滤
在“根”级别，您可以只使用字段的名称，
即`?fields=id,name`它只会显示`id`和
每个对象的`name` 字段。对于集合或
具有自身属性的复杂对象，您可以使用格式
`?fields=id,name,dataSets[id,name]` 将返回的 `id`、`name`
根，以及该对象上每个数据集的`id`和`name`。
否定可以用感叹号来完成，我们有一组
字段选择的预设。支持 XML 和 JSON。

**示例**：在指标资源上获取`id`和`name`：

    / api / indicators？fields = id，名称

**示例**：从dataElements中获取`id`和`name`，以及`id`和`name`。
从dataElements上的dataSets中：

    / api / dataElements？fields = id，name，dataSets [id，name]

要从输出中排除字段，可以使用感叹号`!`。
操作符。这是在查询中的任何地方都允许的，而根本不会
包括该属性，因为它可能已经插入了某些
预设。

一些预设（选定的字段组）可用并且可以应用
使用`:` 运算符。

表格属性操作符

| 操作员 | 描述 |
|---|---|
| <field-name\> | 如果存在，则包含带有名称的属性。 |
| <object\>[<field-name\>, ...] | 包含一个集合中的字段（将应用于该集合中的每个对象），或只包含一个对象上的字段。 |
| !<field-name\>,<object\>[！<field-name\> | 请勿包含此字段名，它也适用于对象/集合内部。在使用预设包含字段时非常有用。 |
| *,<object\>[\*] | 包括某个对象上的所有字段，如果应用于某个集合，则会包括该集合中所有对象上的所有字段。 |
| :<preset\> | 用于选择多个字段的别名。目前有三种预设，请参阅下表了解说明。 |

表格字段预设

| 预设 | 描述 |
|---|---|
| 一应俱全 | 对象的所有字段 |
| \* | 所有的别名 |
| 可识别 | 包括 id、名称、代码、创建和最后更新字段 |
| 可命名 | 包括 id、名称、简称、代码、描述、创建和最后更新字段 |
| 持续 | 返回对象的所有持久化属性，不考虑对象是否是关系的所有者。 |
| 所有者 | 返回对象上的所有持久化属性，其中该对象是所有属性的所有者，此有效负载可用于通过 API 进行更新。 |

**示例**：包括dataSet中的所有字段（organizationunits除外）：

    / api / dataSets？fields =：all，！organizationUnits

**示例**：仅包含ID，名称和数据集中的组织单位集合，但不包含组织单位中的ID：

    / api / dataSets / BfMAe6Itzgt？fields = id，name，organisationUnits [：all，！id]

**示例**：包括所有指标的可命名属性：

    /api/indicators.json?fields=:nameable

### 现场变压器 { #webapi_field_transformers } 

在 DHIS2.17 中我们引入了场变压器，其想法是允许
进一步定制服务器端的属性。

    /api/dataElements/ID?fields=id~rename(i),name~rename(n)

这会将 *id* 属性重命名为 *i*，将 *name* 属性重命名为 *n*。

可以通过重复变压器语法来使用多个变压器：

    /api/dataElementGroups.json?fields=id,displayName,dataElements~isNotEmpty~rename(haveDataElements）

表格：可用变压器

| 名称 | 论据 | 描述 |
|---|---|---|
| 尺寸 || 给出字符串（长度）和集合的大小 |
| isEmpty || 字符串或集合是否为空 |
| isNotEmpty || 字符串或集合是否为空 |
| 重命名 | 参数 1：名称 | 重命名属性名称 |
| 分页 | 参数 1：页面，参数 2：页面大小 | 页面集合，默认页面大小为 50。 |
| 采摘 | 可选参数 1：字段名 | 将对象数组转换为对象选定字段的数组。默认情况下，使用集合返回的第一个字段（通常是 ID）。 |

#### 例子 { #webapi_field_transformers_examples } 

变压器用法示例。

```
/api/dataElements?fields=dataSets~size

/api/dataElements?fields=dataSets~isEmpty

/api/dataElements?fields=dataSets~isNotEmpty

/api/dataElements/ID?fields=id~rename(i),name~rename(n)

/api/dataElementGroups?fields=id,displayName,dataElements~paging(1;20)

# Include array with IDs of organisation units:
/api/categoryOptions.json?fields=id,organisationUnits~pluck

# Include array with names of organisation units (collection only returns field name):
/api/categoryOptions.json?fields=id,organisationUnits~pluck[name]
```

## 元数据创建，读取，更新，删除，验证 { #webapi_metadata_crud } 

DHIS2 中的所有元数据实体都有自己的 API 端点，支持
*CRUD* 操作（创建、读取、更新和删除）。端点 URL
遵循以下格式：

    / api / <entityName>

_entityName_ 使用驼峰命名法。例如，端点
对于_数据元素_是：

    / api / dataElements

### 创建/更新参数 { #webapi_metadata_create_update } 

以下请求查询参数可用于所有元数据端点。

表：可用的查询过滤器

| 参数 | 类型 | 需要 | 选项（默认为默认） | 描述 |
|---|---|---|---|---|
| 预热缓存 | 布尔 | 假 | true &#124; false | 打开/关闭缓存映射预热。默认情况下该选项是打开的，关闭该选项将大大缩短导入程序的初始加载时间（但会使导入本身变慢）。这主要用于要导入一个小的 XML/JSON 文件，而不想等待缓存映射预热的情况。 |
| 导入策略 | 枚举 | 假 | CREATE_AND_UPDATE &#124; CREATE &#124; UPDATE &#124; DELETE | 使用的导入策略，更多信息请参阅下文。 |
| 合并模式 | 枚举 | 假 | 替换、合并 | 更新时合并对象的策略。REPLACE 只会用提供的新值覆盖属性，而 MERGE 只会在属性不为空的情况下设置属性（仅在提供了属性的情况下）。 |

### 创建和更新对象 { #webapi_creating_updating_objects } 

要创建新对象，您需要知道端点、类型
格式，并确保您拥有所需的权限。作为
例如，我们将创建和更新一个*常量*。为了弄清楚
格式，我们可以使用新的 *schema* 端点来获取格式
描述。因此，我们将从获取该信息开始：

    http：// <server> /api/schemas/constant.json

从输出中，您可以看到创建所需的权限
是`F_CONSTANT_ADD`，重要的属性是：*name* 和
*价值*。由此，我们可以创建一个 JSON 负载并将其保存为文件
称为constant.json：

```json
{
  "name": "PI",
  "value": "3.14159265359"
}
```

与XML有效内容相同的内容：

```xml
<constant name="PI" xmlns="http://dhis2.org/schema/dxf/2.0">
  <value>3.14159265359</value>
</constant>
```

我们现在准备通过发送 POST 请求来创建新的*常量*
使用curl 的带有JSON 有效负载的`constants`端点：

```bash
curl -d @constant.json "http://server/api/constants" -X POST
  -H "Content-Type: application/json" -u user:password
```

将常量发布到演示中的具体示例
    服务器：

```bash
curl -d @constant.json "https://play.dhis2.org/api/constants" -X POST
  -H "Content-Type: application/json" -u admin:district
```

如果一切顺利，您应该看到类似以下的输出：

```json
{
  "status": "SUCCESS",
  "importCount": {
    "imported": 1,
    "updated": 0,
    "ignored": 0,
    "deleted": 0
  },
  "type": "Constant"
}
```

更新过程将完全相同，您进行更改
到 JSON/XML 负载，找出常量的 *ID*，然后
向端点发送包含 ID 的 PUT 请求：

```bash
curl -X PUT -d @pi.json -H "Content-Type: application/json"
  -u user:password "http://server/api/constants/ID"
```

### 删除物件 { #webapi_deleting_objects } 

删除对象非常简单，您需要知道
*ID* 和你要删除的类型的端点，让我们继续我们的
上一节中的示例并使用*常量*。让我们假设
id 是 *abc123*，那么你需要做的就是发送 DELETE
对端点的请求 + id：

```bash
curl -X DELETE -u user:password "http://server/api/constants/ID"
```

成功删除应返回HTTP状态204（无内容）。

### 在集合中添加和删除对象 { #webapi_adding_removing_objects_collections } 

集合资源允许您修改集合
对象。

#### 添加或删除单个对象 { #webapi_collections_adding_removing_single_objects } 

为了在对象集合中添加或删除对象，您
可以使用以下
    图案：

    / api / {collection-object} / {collection-object-id} / {collection-name} / {object-id}

应该使用POST方法添加，使用DELETE方法删除
一个东西。当对象之间存在多对多关系时，
您必须首先确定哪个对象拥有该关系。如果不是
清除这是哪个对象，尝试两种方式调用以查看哪个有效。

模式的组成部分是：

  - 集合对象：拥有您的集合的对象类型
    想修改。

  - 集合对象 id：拥有该对象的对象的标识符
    要修改的集合。

  - 集合名称：您要修改的集合的名称。

  - object id：要添加或删除的对象的标识符
    从集合。

例如，为了删除标识符为 IDB 的数据元素
从具有标识符 IDA 的数据元素组中，您可以执行 DELETE
要求：

    删除/ api / dataElementGroups / IDA / dataElements / IDB

将带有标识符 IDB 的类别选项添加到带有
标识符 IDA 你可以做一个 POST
要求：

    POST / api / categories / IDA / categoryOptions / IDB

#### 添加或删除多个对象 { #webapi_collections_adding_removing_multiple_objects } 

您可以在一个请求中从集合中添加或删除多个对象
具有这样的有效载荷：

```json
{
  "identifiableObjects": [{
      "id": "IDA"
    }, {
      "id": "IDB"
    }, {
      "id": "IDC"
    }
  ]
}
```

使用此有效负载，您可以添加，替换或删除项目：

*添加项目：*

    POST / api / categories / IDA / categoryOptions

*更换物品：*

    PUT /api/categories/IDA/categoryOptions

*删除
项目：*

    删除/ api / categories / IDA / categoryOptions

#### 在单个请求中添加和删除对象 { #webapi_collections_adding_removing_objects_single_request } 

您可以在单个 POST 中从集合中添加和删除对象
请求到以下 URL：

    POST / api / categories / IDA / categoryOptions

有效负载格式为：

```json
{
  "additions": [{
      "id": "IDA"
    }, {
      "id": "IDB"
    }, {
      "id": "IDC"
    }
  ],
  "deletions": [{
      "id": "IDD"
    }, {
      "id": "IDE"
    }, {
      "id": "IDF"
    }
  ]
}
```

### 验证有效载荷 { #webapi_validating_payloads } 

DHIS 2 支持元数据有效载荷的系统范围验证，这意味着
将检查 API 端点上的创建和更新操作
允许进行更改之前的有效负载。找出哪些验证
为特定端点准备好了，看看`/api/schemas`
端点，即要找出数据元素具有哪些约束，您
会去`/api/schemas/dataElement`。

您还可以手动验证您的有效负载，方法是将其发送到适当的
架构端点。如果您想从创建中验证常量
之前的部分，您可以这样发送：

    POST / api / schemas / constant

一个简单的（非验证）示例为：

```bash
curl -X POST -d "{\"name\": \"some name\"}" -H "Content-Type: application/json"
  -u admin:district "https://play.dhis2.org/dev/api/schemas/dataElement"
```

这样就能得到结果：

```json
[
   {
      "message" : "Required property missing.",
      "property" : "type"
   },
   {
      "property" : "aggregationOperator",
      "message" : "Required property missing."
   },
   {
      "property" : "domainType",
      "message" : "Required property missing."
   },
   {
      "property" : "shortName",
      "message" : "Required property missing."
   }
]
```

### 部分更新 { #webapi_partial_updates } 

For our web api endpoints that deal with metadata, we support partial updates (PATCH) using the JSON Patch [standard](https://tools.ietf.org/html/rfc6902). The payload basically outlines a set of operation you want applied to a existing metadata object. For examples of JSON patch please see [jsonpatch.com](http://jsonpatch.com/), we support 3 operators: `add`, `remove` and `replace`.

下面是几个与 dhis2 相关的示例，请注意，对有效载荷的任何更新都应视为 HTTP PUT（即任何突变都必须产生有效的 PUT 元数据有效载荷）。

The default `importReportMode` for JSON Patch is `ERRORS_NOT_OWNER` which means that if you try and update any property that is not owned by that particular object (for example trying to add a indicator group directly to an indicator) you will get an error.

根据 JSON 补丁规范，发送补丁时必须始终使用 mimetype `application/json-patch+json`。

#### 例子 { #examples } 

##### 更新数据元素的名称和值类型{ #update-name-and-value-type-of-data-element } 

```
PATCH /api/dataElements/{id}
```

```json
[
  {"op": "add", "path": "/name", "value": "New Name"},
  {"op": "add", "path": "/valueType", "value": "INTEGER"}
] 
```

##### 在数据元素组中添加新数据元素{ #add-new-data-element-to-a-data-element-group } 

```
PATCH /api/dataElementGroups/{id}
```

```json
[
  {"op": "add", "path": "/dataElements/-", "value": {"id": "data-element-id"}}
]
```

##### 从数据元素组中删除所有数据元素关联{ #remove-all-data-element-associations-from-a-data-element-group } 

```
PATCH /api/dataElementGroups/{id}
```

```json
[
  {"op": "remove", "path": "/dataElements"}
]
```

##### 更改数据元素的域和值类型{ #change-domain-and-value-type-of-a-data-element } 

```
PATCH /api/dataElements/{id}
```

```json
[
    {"op": "add", "path": "/domainType", "value": "TRACKER"},
    {"op": "add", "path": "/valueType", "value": "INTEGER"}
]
```

##### 从 orgUnit 组中删除特定 orgUnit{ #remove-a-specific-orgunit-from-an-orgunit-group } 

```
PATCH /api/organisationUnitGroups/{id}
```

```json
[
  {"op": "remove", "path": "/organisationUnits/1"}
]
```


## 元数据导出 { #webapi_metadata_export } 

本节介绍了可在以下位置获得的元数据 API
`/api/元数据`。支持 XML 和 JSON 资源表示。

    / api /元数据

最常用的参数在下面的“导出参数”中描述
桌子。您还可以使用以下方法将其应用于所有可用类型
`type:fields=<filter>` 和 `type:filter=<filter>`。你也可以
通过设置 `type=true|false` 启用/禁用某些类型的导出。

表：导出参数

| 名称 | 选项 | 描述 |
|---|---|---|
| 领域 | 与元数据字段过滤器相同 | 适用于所有类型的默认字段过滤器，默认为 `:owner`。 |
| 过滤 | 与元数据对象过滤器相同 | 适用于所有类型的默认对象过滤器，默认为`无`。 |
| 订单 | 与元数据顺序相同 | 适用于所有类型的默认顺序，如果可用，则默认为 `name`；如果不可用，则默认为 `created`。 |
| 译 | 假/真 | 启用翻译。请注意，默认情况下这是关闭的（在其他端点，默认情况下是打开的）。 |
| 地点 | <locale\> | 从用户本地语言更改为自定义本地语言。 |
| 默认 | 包括/排除 | 是否应在有效载荷中包含自动生成的类别对象。如果您要在两个非同步实例之间移动元数据，可能需要将其设置为 EXCLUDE，以方便处理这些生成的对象。 |
| 跳过共享 | 假/真 | 启用此功能将从导出对象中剥离共享属性。这包括 *user*、*publicAccess*、*userGroupAccesses*、*userAccesses* 和 *externalAccess*。 |
| 下载 | 假/真 | 启用此功能将添加 HTTP 标头 Content-Disposition，指定数据应作为附件处理，并由网络浏览器提供下载。 |

### 元数据导出示例 { #webapi_metadata_export_examples } 

导出所有元数据。小心，因为响应可能非常大，具体取决于
关于您的元数据配置：

    / api /元数据

导出由lastUpdated降序排列的所有元数据：

    / api / metadata？defaultOrder = lastUpdated：desc

导出仅包括指标和指标组的元数据：

    / api / metadata？indicators = true＆indicatorGroups = true

导出所有数据元素的id和displayName，按displayName排序：

    / api / metadata？dataElements：fields = id，name＆dataElements：order = displayName：desc

导出名称以“ ANC”开头的数据元素和指示符：

    / api / metadata？filter = name：^ like：ANC＆dataElements = true＆indicators = true

### 具有依赖项的元数据导出 { #webapi_dataset_program_export_dependencies } 

当您想交换数据集、程序、类别组合、仪表盘、选项集或数据元素组的元数据时、
仪表板、选项集或数据元素组的元数据时
时，有六个专用端点可供使用：

```
/api/dataSets/{id}/metadata.json

/api/programs/{id}/metadata.json

/api/categoryCombos/{id}/metadata.json

/api/dashboards/{id}/metadata.json

/api/optionSets/{id}/metadata.json

/api/dataElementGroups/{id}/metadata.json
```

然后可以使用`/ api / metadata`导入这些导出。

这些端点还支持以下参数：

表：导出参数

| 名称 | 选项 | 描述 |
|---|---|---|
| 跳过共享 | 假/真 | 启用此功能将从导出对象中剥离共享属性。这包括 *user*、*publicAccess*、*userGroupAccesses*、*userAccesses* 和 *externalAccess*。 |
| 下载 | 假/真 | 启用此功能将添加 HTTP 标头 Content-Disposition，指定数据应作为附件处理，并由网络浏览器提供下载。 |

## 元数据导入 { #webapi_metadata_import } 

本节介绍元数据导入 API。 XML 和 JSON 资源
支持表示。可以使用 *POST* 请求导入元数据。

    / api /元数据

导入器允许您导入元数据有效负载，其中可能包括许多
不同的实体和每个实体的任意数量的对象。元数据导出
元数据导出API生成的可以直接导入。

元数据导入端点支持多种参数，分别是
下面列出。

表：导入参数

| 名称 | 选项（第一项为默认值） | 描述 |
|---|---|---|
| 导入模式 | 提交、验证 | 设置整体导入模式，决定是否仅 `VALIDATE` 或也 `COMMIT` 元数据，这与我们旧的 dryRun 标志具有相似的功能。 |
| 标识符 | uid、代码、自动 | Sets the identifier scheme to use for reference matching. `AUTO` means try `UID` first, then `CODE`. |
| 导入报告模式 | 错误、全部、调试 | Sets the `ImportReport` mode, controls how much is reported back after the import is done. `ERRORS` only includes *ObjectReports* for object which has errors. `FULL` returns an *ObjectReport* for all objects imported, and `DEBUG` returns the same plus a name for the object (if available). |
| 预热模式 | 参考、全部、无 | 设置预热器模式，用于指示是否应该对 `ALL` 进行预热（就像以前使用 *preheatCache=true* 一样）或对对象进行更智能的扫描以查看要预热的内容（现在是默认设置），将其设置为不推荐使用`无`。 |
| 导入策略 | CREATE_AND_UPDATE, CREATE, UPDATE, DELETE | Sets import strategy, `CREATE_AND_UPDATE` will try and match on identifier, if it doesn't exist, it will create the object. |
| 原子模式 | 全部，无 | 设置原子模式，在旧的导入器中，我们总是进行*best effort*导入，这意味着即使某些引用不存在，我们仍然会导入（即数据元素组导入时缺少数据元素）。新进口商的默认设置是不允许这样做，并且类似地拒绝任何验证错误。设置 `NONE` 模式模拟了旧的行为. |
| ~~mergeMode~~ | ~~ 替换、合并~~ | ~~Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, `MERGE` mode will only overwrite the old property if the new one is not-null, for `REPLACE` mode all properties are overwritten regardless of null or not.~~ (*) |
| 冲洗模式 | 自动，目标 | 设置刷新模式，控制何时刷新内部缓存。*强烈*建议_将其保留为`AUTO`（这是默认设置）。仅将 `OBJECT` 用于调试目的，您会看到休眠异常并想查明堆栈发生的确切位置（休眠只会在刷新时抛出，因此很难知道哪个对象有问题）。 | 
| 跳过共享 | 假，真 | 跳过共享属性，更新时不合并共享，创建新对象时不添加用户组访问权限。 |
| 跳过验证 | 假，真 | 跳过导入的验证。`不推荐`。 |
| 异步 | 假，真 | 异步导入时，会立即返回一个 *Location* 标头，指向 *importReport* 的位置。有效载荷还包含一个已创建任务的 json 对象。 |
| 包容策略 | NON_NULL, ALWAYS, NON_EMPTY | *NON_NULL* 包括非空属性，*ALLWAYS* 包括所有属性，*NON_EMPTY* 包括非空属性（不包括长度为 0 的字符串、大小为 0 的集合等）。 |
| 用户覆盖模式 | 无、当前、选定 | 允许你覆盖正在导入的每个对象的用户属性，选项包括 NONE（不做任何操作）、CURRENT（使用导入用户）、SELECTED（使用 overrideUser=X 选择特定用户）。 |
| 覆盖用户 | 用户 ID | 如果 userOverrideMode 为 SELECTED，则使用此参数选择要覆盖的用户。 |

> (*) Currently the `mergeMode=MERGE` option of the import service has limitations and doesn't support all objects. It doesn't work with some object types such as Embedded objects, or objects which are saved as JSONB format in database ( sharing, attributeValues, etc...). Fixing those issues are complicated and would just cause new issues. Therefore, this `mergedMode=MERGE` is deprecated and currently is not recommended to use. The update mode should always be mergedMode=REPLACE. We have developed a new [JSON Patch API](#webapi_partial_updates) which can be used as an alternative approach. This feature is introduced in 2.37 release.


要导入的元数据负载的示例如下所示。注意如何
每个实体类型都有自己的属性和一个对象数组：

```json
{
  "dataElements": [
    {
      "name": "EPI - IPV 3 doses given",
      "shortName": "EPI - IPV 3 doses given",
      "aggregationType": "SUM",
      "domainType": "AGGREGATE",
      "valueType": "INTEGER_ZERO_OR_POSITIVE"
    },
    {
      "name": "EPI - IPV 4 doses given",
      "shortName": "EPI - IPV 4 doses given",
      "aggregationType": "SUM",
      "domainType": "AGGREGATE",
      "valueType": "INTEGER_ZERO_OR_POSITIVE"
    }
  ],
  "indicators": [
    {
      "name": "EPI - ADS stock used",
      "shortName": "ADS stock used",
      "numerator": "#{LTb8XeeqeqI}+#{Fs28ZQJET6V}-#{A3mHIZd2tPg}",
      "numeratorDescription": "ADS 0.05 ml used",
      "denominator": "1",
      "denominatorDescription": "1",
      "annualized": false,
      "indicatorType": {
        "id": "kHy61PbChXr"
      }
    }
  ]
}
```

将此有效负载发布到元数据端点时，响应将包含
有关导入过程中使用的参数的信息和每个摘要
实体类型，包括创建、更新、删除和
忽略：

```json
{
  "importParams": {
    "userOverrideMode": "NONE",
    "importMode": "COMMIT",
    "identifier": "UID",
    "preheatMode": "REFERENCE",
    "importStrategy": "CREATE_AND_UPDATE",
    "atomicMode": "ALL",
    "mergeMode": "REPLACE",
    "flushMode": "AUTO",
    "skipSharing": false,
    "skipTranslation": false,
    "skipValidation": false,
    "metadataSyncImport": false,
    "firstRowIsHeader": true,
    "username": "UNICEF_admin"
  },
  "status": "OK",
  "typeReports": [
    {
      "klass": "org.hisp.dhis.dataelement.DataElement",
      "stats": {
        "created": 2,
        "updated": 0,
        "deleted": 0,
        "ignored": 0,
        "total": 2
      }
    },
    {
      "klass": "org.hisp.dhis.indicator.Indicator",
      "stats": {
        "created": 1,
        "updated": 0,
        "deleted": 0,
        "ignored": 0,
        "total": 1
      }
    }
  ],
  "stats": {
    "created": 3,
    "updated": 0,
    "deleted": 0,
    "ignored": 0,
    "total": 3
  }
}
```


## 架构图 { #webapi_schema } 

可用于内省所有可用 DXF 2 对象的资源
可以在`/api/schemas` 上找到。对于特定资源，您可以拥有
查看`/api/schemas/<type>`。

要获取XML中所有可用的模式：

    GET /api/schemas.xml

要获取JSON中所有可用的模式，请执行以下操作：

    GET /api/schemas.json

要获取特定类的JSON模式：

    GET /api/schemas/dataElement.json


## 图示 { #webapi_icons } 

DHIS2 包括一组可用于提供视觉效果的图标
元数据的上下文。这些图标可以通过图标访问
资源。

    GET /api/icons

此端点返回有关可用图标的信息列表。
每个条目都包含有关图标的信息，以及对图标的引用
实际图标。

```json
{
  key: "mosquito_outline",
  description: "Mosquito outline",
  keywords: [
    "malaria",
    "mosquito",
    "dengue"
  ],
  href: "<dhis server>/api/icons/mosquito_outline/icon.svg"
}
```

关键字可用于过滤要返回的图标。传递一个列表
带有请求的关键字将只返回与所有匹配的图标
关键词：

    GET /api/icons?keywords=shape,small

可以在关键字资源中找到所有唯一关键字的列表：

    GET /api/icons/keywords

## 渲染类型 { #webapi_render_type } 

某些元数据类型具有名为 *renderType* 的属性。渲染类型
属性是 *device* 和 *renderingType* 之间的映射。应用
可以使用此信息作为有关如何呈现对象的提示
在特定设备上。例如，移动设备可能想要渲染
与台式计算机不同的数据元素。

当前有两种不同的renderingTypes可用：

1.  值类型渲染

2.  程序阶段部分渲染

还提供2种设备类型：

1.  移动

2.  桌面

下表列出了可用的元数据和呈现类型。
值类型呈现具有基于元数据的附加约束
配置，这将显示在第二个表中。

表格元数据和渲染类型概览

| 元数据类型 | 可用的渲染类型 |
|---|---|
| 程序阶段部分 | * 列表（默认）<br> * 序列<br> * 矩阵 |
| 数据元素 | * DEFAULT<br> * DROPDOWN<br> * VERTICAL_RADIOBUTTONS<br> * HORIZONTAL_RADIOBUTTONS<br> * VERTICAL_CHECKBOXES<br> * HORIZONTAL_CHECKBOXES<br> * SHARED_HEADER_RADIOBUTTONS<br> * ICONS_AS_BUTTONS<br> * SPINNER<br> * ICON<br> * TOGGLE<br> * VALUE<br> * SLIDER<br> * LINEAR_SCALE |

由于处理数据元素和跟踪实体的默认呈现
属性取决于对象的值类型，还有
一个 DEFAULT 类型告诉客户端它应该被正常处理。
程序阶段部分默认为“列表”。

表：根据值类型允许的渲染类型

| 值类型 | 对象是一个选项集吗？ | 允许的渲染类型 |
|---|---|---|
| TRUE_ONLY | 不 | DEFAULT, VERTICAL_RADIOBUTTONS, HORIZONTAL_RADIOBUTTONS, VERTICAL_CHECKBOXES, HORIZONTAL_CHECKBOXES, TOGGLE |
| BOOLEAN | 不 ||
| -- | 是的 | DEFAULT, DROPDOWN, VERTICAL_RADIOBUTTONS, HORIZONTAL_RADIOBUTTONS, VERTICAL_CHECKBOXES, HORIZONTAL_CHECKBOXES, SHARED_HEADER_RADIOBUTTONS, ICONS_AS_BUTTONS, SPINNER, ICON |
| 整数 | 不 | DEFAULT, VALUE, SLIDER, LINEAR_SCALE, SPINNER |
| INTEGER_POSITIVE | 不 ||
| INTEGER_NEGATIVE | 不 ||
| INTEGER_ZERO_OR_POSITIVE | 不 ||
| 数字 | 不 ||
| UNIT_INTERVAL | 不 ||
| 百分比 | 不 ||

上表的完整参考也可以使用
以下端点：

    GET /api/staticConfiguration/renderingOptions

值类型渲染也有一些额外的属性，可以
设置，通常在渲染某些特定类型时需要：

表：renderType 对象属性

| 物业 | 描述 | 类型 |
|---|---|---|
| 类型 | 对象的渲染类型（RenderingType），如第一个表格所示。该属性对于值类型和程序阶段部分都是相同的，但对于程序阶段部分是唯一可用的属性。 | 枚举（参见元数据和渲染类型表中的列表） |
| 分钟 | 仅用于值类型渲染。表示该字段可以具有的最小值。 | 整数 |
| 最大 | 仅用于值类型渲染。表示此字段可具有的最大值。 | 整数 |
| 步骤 | 仅用于值类型渲染。代表数值应增加的步长，例如 SLIDER 或 LINEAR_SCALE 的步长 | 整数 |
| 小数点 | 仅用于数值类型渲染。表示数值应使用的小数点个数。 | 整数 |

*renderingType* 可以在创建或更新第一个表中列出的元数据时设置。程序阶段部分的渲染类型的示例负载如下所示：

```json
{
  "renderingType": {
    "type": "MATRIX"
  }
}
```

对于数据元素和跟踪的实体属性：

```json
{
  "renderingType": {
    "type": "SLIDER",
    "min": 0,
    "max": 1000,
    "step": 50,
    "decimalPoints": 0
  }
}
```

## 对象样式 { #webapi_object_style } 

大多数元数据都有一个属性名称“样式”。可以使用此属性
由客户以某种方式表示对象。属性
目前支持的样式如下：

表格样式属性

| 物业 | 描述 | 类型 |
|---|---|---|
| 颜色 | 一种颜色，用十六进制表示。 | 字符串 (#000000) |
| 图标 | 图标，由图标名称表示。 | 串 |

目前，没有官方列表或对图标库的支持，所以
这目前由客户提供。下面的列表显示
所有支持样式的对象：

  - 数据元素

  - 数据元素类别选项

  - 资料集

  - 指示符

  - 选项

  - 程序

  - 计划指标

  - 计划科

  - 程序阶段

  - 程序阶段部分

  - 关系（跟踪器）

  - 跟踪实体属性

  - 追踪实体类型

在创建或更新任何这些对象时，您可以包括
以下有效负载更改样式：

```json
{
  "style": {
    "color": "#ffffff",
    "icon": "my-beautiful-icon"
  }
}
```

## 指标 { #webapi_indicators } 

本节介绍指标和指标表达式。

### 综合指标 { #webapi_aggregate_indicators } 

要检索指标，您可以向指标发出 GET 请求
像这样的资源：

    / api /指标

指标表示可以计算和呈现的表达式
因此。指标表达式分为分子和
分母。分子和分母是数学的
可以包含对数据元素、其他指标、常量和
组织单位组。变量将替换为数据
使用时的值，例如在报告中。允许的变量
表达式在下表中描述。

表：指标变量

| 变量 | 目的 | 描述 |
|---|---|---|
| #{<data-element-id\>.<category-option-combo-id\>.<attribute-option-combo-id\>} | 数据元素操作数 | 指集合数据元素和类别选项组合的组合。类别和属性选项组合 id 都是可选的，可以使用通配符"\*"来表示任何值。 |
| #{<dataelement-id\>.<category-option-group-id\>.<attribute-option-combo-id\>} | 类别 选项组 | 指一个综合数据元素和一个类别选项组，包含多个类别选项组合。 |
| #{<data-element-id\>} | 汇总数据元素 | 指所有类别选项组合中的聚合数据元素的总值。 |
| D{<program-id\>.<data-element-id\>} | 程序数据元素 | 引用程序中跟踪器数据元素的值。 |
| A{<program-id\>.<attribute-id\>} | 程序跟踪的实体属性 | 指程序中被跟踪实体属性的值。 |
| I{<program-indicator-id\>} | 计划指标 | 指程序指示器的值。 |
| R{<dataset-id\>.<metric\>} | 报告率 | 指报告率指标。指标可以是REPORTING_RATE，REPORTING_RATE_ON_TIME，ACTUAL_REPORTS，ACTUAL_REPORTS_ON_TIME，EXPECTED_REPORTS。 |
| C{<constant-id\>} | 不变 | 指恒定值。 |
| N{<indicator-id\>} | 指示符 | 指现有指标。 |
| OUG{<orgunitgroup-id\>} | 组织单位组 | 指组织单位组内组织单位的数量。 |

在数据元素操作数或聚合数据元素内，可进行以下替换：

| 项目 | 值 | 描述 |
|---|---|---|
| data-element-id | data-element-id | 汇总数据元素 |
| data-element-id | deGroup:data-element-group-id | 数据元素组中的所有汇总数据元素 |
| 类别-选项-组合-id | 类别-选项-组合-id | 类别选项组合 |
| 类别-选项-组合-id | co:category-option-id | 类别选项中的所有类别选项组合 |
| 类别-选项-组合-id | coGroup:category-option-group-id | 类别选项组中的所有类别选项组合 |
| 类别-选项-组合-id | coGroup:co-group-id1&co-group-id2... | 属于多个类别选项组的所有类别选项组合 |

语法看起来像
    这：

＃

相应的示例如下所示：

＃

请注意，对于数据元素变量，类别选项组合
标识符可以省略。该变量将代表总数
对于数据元素，例如在所有类别选项组合中。例子：

＃

数据元素操作数可以包括任何类别选项组合和
属性选项组合，并使用通配符表示任何
    价值：

＃

使用数据元素组的示例

    #{deGroup:oDkJh5Ddh7d}+ #{deGroup:GBHN1a1Jddh.j8vBiBqGf6O}

使用类别选项、数据元素组和类别选项组的示例：

    #{P3jJH5Tu5VC.co:FbLZS3ueWbQ}+ #{deGroup:GBHN1a1Jddh.coGroup:OK2Nr4wdfrZ.j8vBiBqGf6O}

使用多个类别选项组的示例：

    #{P3jJH5Tu5VC.coGroup:OK2Nr4wdfrZ&j3C417uW6J7&ddAo6zmIHOk}

使用程序数据元素和程序属性的示例：

    （D {eBAyeGv0exc.vV9UWAZohSf} * A {IpHINAT79UW.cejWyOfXge6}）/ D {eBAyeGv0exc.GieVkTxp4HH}

结合计划指标和综合指标的示例：

    I {EMOt6Fwhs1n} * 1000 /＃{WUg3MYWQ7pt}

以报告率为例：

    R {BfMAe6Itzgt.REPORTING_RATE} *＃{P3jJH5Tu5VC.S34ULMcHMca}

另一个使用实际数据集报告和预期报告的报告率示例：

    R {BfMAe6Itzgt.ACTUAL_REPORTS} / R {BfMAe6Itzgt.EXPECTED_REPORTS}

使用现有指标的示例

    N {Rigf2d2Zbjp} *＃{P3jJH5Tu5VC.S34ULMcHMca}

表达式可以是任何类型的有效数学表达式，作为
例子：

    （2 *＃{P3jJH5Tu5VC.S34ULMcHMca}）/（＃{FQ2o8UBlcrS.S34ULMcHMca}-200）* 25

### 计划指标 { #webapi_program_indicators } 

要检索程序指标，您可以向程序发出 GET 请求
像这样的指标资源：

    / api / programIndicators

程序指示器可以包含在程序中收集的信息。
指标有一个表达式，可以包含对数据的引用
元素、属性、常量和程序变量。变量
下表中描述了允许在表达式中使用。



表：计划指标变量

| 变量 | 描述 |
|---|---|
| #{<programstage-id\>.<dataelement-id\>} | 指计划阶段和数据元素 ID 的组合。 |
| A{<attribute-id\>} | 指跟踪的实体属性。 |
| V{<variable-id\>} | 指程序变量。 |
| C{<constant-id\>} | 指一个常数。 |

语法看起来像
    这：

＃

一个相应的例子看起来像
    这：

＃

### 表达方式 { #webapi_expressions } 

表达式是数学公式，可以包含对
数据元素、常量和组织单元组。验证和
获取表达式的文本描述，您可以发出 GET 请求
到表达式资源：

    / api / expressions / description？expression = <expression-string>

响应遵循标准的 JSON Web 消息格式。 *状态*
属性表示验证的结果，如果
成功和“错误”如果失败。 *message* 属性将为“有效”
如果成功并提供原因的文字描述
如果不是，则验证失败。 *描述*提供了文字说明
表达式的描述。

```json
{
  "httpStatus": "OK",
  "httpStatusCode": 200,
  "status": "OK",
  "message": "Valid",
  "description": "Acute Flaccid Paralysis"
}
```

## 组织单位 { #webapi_organisation_units } 

*organisationUnits* 资源遵循标准约定，如
DHIS2 中的其他元数据资源。该资源支持一些
附加查询参数。

### 获取组织单位列表 { #webapi_list_of_organisation_units } 

要获取组织单位的列表，可以使用以下资源。

    / api / 33 / organisationUnits

表：组织单位查询参数

| 查询参数 | 选项 | 描述 |
|---|---|---|
| 仅限用户 | 假 | 真 | 数据采集组织单位只与当前用户相关。 |
| 仅 userDataView | 假 | 真 | 数据视图组织单位只与当前用户相关。 |
| userDataViewFallback | 假 | 真 | 仅与当前用户相关联的数据视图组织单位，可退回到数据采集组织单位。 |
| 询问 | 字符串 | 查询名称、代码和 ID 属性。 |
| 夷为平地 | 整数 | 层次结构中指定级别的组织单位。 |
| maxLevel | 整数 | 在给定的最大级别或更高级别上的组织单位。 |
| 用户层级内 | 假 | 真 | 将搜索和检索限制在用户数据采集范围内的组织单位。 |
| withinUserSearchHierarchy | 假 | 真 | 将搜索和检索限制在当前用户搜索范围内的组织单位。注意："in withinUserHierarchy"（如果为 true）优先级更高。 |
| 会员收藏 | 字符串 | 对于显示集合中成员的计数，指的是与组织单位相关联的集合名称。 |
| 成员对象 | 用户标识 | 用于显示集合中成员的计数，指集合对象成员的标识符。 |

### 获取带有子层次结构的组织单位{ #webapi_organisation_units_with_sub_hierarchy } 

要获得一个组织单位，包括其子层次结构中的组织单位，可以使用以下资源。

    / api / 33 / organisationUnits / {id}

表：组织单位参数

| 查询参数 | 选项 | 描述 |
|---|---|---|
| 包括儿童 | 假 | 真 | 包括指定组织单位的直属子单位，即子层次结构中下一级的直属单位。 |
| 包含后代 | 假 | 真 | 包括指定组织单位的所有子单位，即子层次结构中的所有单位。 |
| 包括祖先 | 假 | 真 | 包括指定组织单位的所有家长。 |
| 夷为平地 | 整数 | 包括子层次结构中指定级别的指定组织单位的子机构。这是相对于组织单位而言的，从 1 开始为紧接组织单位之下的层级。 |

### 按类别获取组织单位选项 { #webapi_organisation_units_by_category_options }

专门用于检索类别选项与组织单位之间关联的端点。该端点是检索程序组织单位关联的首选方式。

    /api/33/categoryOptions/orgUnits?categoryOptions={categoryOptionIdA} 、{categoryOptionIdB}

答复的格式如下

```json
{
  "<categoryOptionIdA>": [
    "<orgUnitUid>",
    "<orgUnitUid>"
  ],
  "<categoryOptionIdB>": [
    "<orgUnitUid>",
    "<orgUnitUid>"
  ],
  "<categoryOptionIdC>": []
}
```

所有组织单位都能访问的类别选项会以组织单位的空数组（`[]`）返回。

### 按程序获取组织单位{ #webapi_organisation_units_by_programs } 

专用端点，用于检索程序与组织单位之间的关联。该端点是检索程序与组织单位关联的首选方式。

    /api/33/programs/orgUnits?programs={programIdA} 、{programIdB}

答复的格式如下

```json
{
  "<programIdA>": [
    "<orgUnitUid>",
    "<orgUnitUid>"
  ],
  "<programIdB>": [
    "<orgUnitUid>",
    "<orgUnitUid>"
  ],
  "<programIdC>": []
}
```

所有组织单位都能访问的程序将以组织单位的空数组（`[]`）返回。

### 分体式组织单位{ #webapi_organisation_unit_split }

通过组织单位分割端点，可以将组织单位分割为多个目标组织单位。 

#### 请求{ #request } 

通过 POST 请求拆分组织单位：

```
POST /api/organisationUnits/split
```

JSON 格式的有效载荷如下所示：

```json
{
  "source": "rspjJHg4WY1",
  "targets": [
    "HT0w9YLMLyn",
    "rEpnzuNpRKM"
  ],
  "primaryTarget": "HT0w9YLMLyn",
  "deleteSource": true
}
```

下表描述了 JSON 属性。

表格分割有效载荷字段

| 领域         | 需要 | 值 |
| ------------- | -------- |------ |
| 消息来源        | 是的      | 要拆分的组织单位（源组织单位）的标识符。 |
| 目标       | 是的      | 要将源代码分割成的组织单位（目标组织单位）的标识符数组。 |
| 主要目标 | 不       | 要将与源相关的汇总数据、事件和跟踪实体转移到的组织单位的标识符。如果未指定，将使用第一个目标。 |
| 删除源  | 不       | 操作后是否删除源组织单位。默认为`真`。 |

拆分操作将把源组织单位拆分为目标组织单位。建议在执行拆分之前先创建新的目标组织单位，并至少确保目标组织单位不存在汇总数据。可以指定任意数量的目标组织单位。

拆分操作将把源组织单位的所有元数据关联转移到目标组织单位。这包括数据集、程序、组织单位组、类别选项、用户、可视化、地图和事件报告。

该操作将把源组织单位的所有数据记录转移到指定为主要目标的组织单位，如果没有指定，则转移到第一个指定的目标组织单位。这包括汇总数据值、数据批准记录、事件、跟踪实体等。

#### 验证{ #validation } 

适用以下限制条件和错误代码。

表：限制条件和错误代码

| 错误代码 | 描述                                     |
| ---------- | ----------------------------------------------- |
| E1510      | 必须指定来源网络单位               |
| E1511      | 必须指定至少两个目标组织单位 |
| E1512      | 源组织单位不能是目标组织单位     |
| E1513      | 必须指定主要目标                |
| E1514      | 主要目标必须是目标组织单位        |
| E1515      | 目标组织单位不存在                  |

### 合并组织单位 { #webapi_organisation_unit_merge}

通过组织单位合并端点，可以将多个组织单位合并为一个目标组织单位。

#### 请求{ #request } 

通过 POST 请求合并组织单位：

```
POST /api/organisationUnits/merge
```

JSON 格式的有效载荷如下所示：

```json
{
  "sources": [
    "jNb63DIHuwU",
    "WAjjFMDJKcx"
  ],
  "target": "V9rfpjwHbYg",
  "dataValueMergeStrategy": "LAST_UPDATED",
  "dataApprovalMergeStrategy": "LAST_UPDATED",
  "deleteSources": true
}
```

下表描述了 JSON 属性。

表格合并有效载荷字段

| 领域                     | 需要 | 值 |
| ------------------------- | -------- | ----- |
| 资源                   | 是的      | 要合并的组织单位（源组织单位）的标识符数组。 |
| 目标                    | 是的      | 要将数据源合并到的组织单位（目标组织单位）的标识符。 |
| 数据值合并策略    | 不       | Strategy for merging data values. Options: `LAST_UPDATED` (default), `DISCARD`. |
| 数据审批合并策略 | 不       | Strategy for merging data approval records. Options: `LAST_UPDATED` (default), `DISCARD`. |
| 删除资源             | 不       | 是否在操作后删除源组织单位。默认为 "true"。 |

合并操作将把源组织单位合并到目标组织单位中。建议在执行合并之前，先创建一个新的目标组织单位，并至少确保目标组织单位不存在汇总数据。可以指定任意数量的源组织单位。

合并操作将把源组织单位的所有元数据关联转移到目标组织单位。这包括数据集、程序、组织单位组、类别选项、用户、可视化、地图和事件报告。该操作还将把所有事件和跟踪器数据（如事件、注册、所有权历史、程序所有权和跟踪实体）转移到目标组织单位。

指定的数据值合并策略定义了如何处理数据值。对于`LAST_UPDATED`策略，所有源组织单位的数据值都将转移到目标组织单位，并且在相同参数存在数据值的情况下，将使用最后更新或创建的数据值。这样做是为了避免数据重复。对于`DISCARD`策略，数据值不会转移到目标组织单位，而是简单地删除。指定的数据审批合并策略定义了数据审批记录的处理方式，并遵循与数据值相同的逻辑。

#### 验证{ #validation } 

适用以下限制条件和错误代码。

表：限制条件和错误代码

| 错误代码 | 描述                                     |
| ---------- | ----------------------------------------------- |
| E1500      | 必须指定至少两个来源组织单位 |
| E1501      | 必须指定目标组织单位               |
| E1502      | 目标组织单位不能是源组织单位     |
| E1503      | 源机构单位不存在                  |

## 数据集 { #webapi_data_sets } 

*dataSets* 资源遵循标准约定作为其他
DHIS2 中的元数据资源。此资源支持一些额外的
查询参数。

    / api / 33 / dataSets

要检索数据集的版本，您可以发出GET请求：

    GET /api/33/dataSets/<uid>/version

要提高（增加一个）数据集的版本，您可以发出 POST
要求：

    POST / api / 33 / dataSets / <uid> / version

### 数据集通知模板{ #webapi_dataset_notifications } 

*数据集通知模板*资源遵循标准
DHIS2 中其他元数据资源的约定。

    GET /api/33/dataSetNotficationTemplate

要检索数据集通知模板，您可以发出GET请求：

    GET /api/33/dataSetNotficationTemplates/<uid>

要添加数据集通知模板，您可以发出POST请求：

    POST / api / 33 / dataSetNotficationTemplates

要删除数据集通知模板，您可以发出DELETE请求：

    删除/ api / 33 / dataSetNotficationTemplates / <uid>

JSON有效负载示例如下：

```json
{
  "name": "dataSetNotificationTemplate1",
  "notificationTrigger": "COMPLETION",
  "relativeScheduledDays": 0,
  "notificationRecipient": "ORGANISATION_UNIT_CONTACT",
  "dataSets": [{
    "id": "eZDhcZi6FLP"
  }],
  "deliveryChannels": ["SMS"],
  "subjectTemplate": "V{data_name}",
  "messageTemplate": "V{data_name}V{complete_registration_period}",
  "sendStrategy": "SINGLE_NOTIFICATION"
}

```

## 填充的组织单位级别 { #webapi_filled_organisation_unit_levels } 

*fillOrganisationUnitLevels* 资源提供了一个有序的列表
组织单元级别，其中生成的级别被注入到
列表以填充不存在持久级别的位置。

    GET /api/33/filledOrganisationUnitLevels

要设置组织单位级别，您可以发出一个 POST 请求，其中包含一个
内容类型为 `application/json` 的 POST 请求：

```json
{
  "organisationUnitLevels": [{
    "name": "National",
    "level": 1,
    "offlineLevels": 3
  }, {
    "name": "District",
    "level": 2
  }, {
    "name": "Chiefdom",
    "level": 3
  }, {
    "name": "Facility",
    "level": 4
  }]
}
```

## 预测变量 { #webapi_predictors } 

预测器允许您根据表达式生成数据值。
这可以用于例如生成目标、阈值、
或估计值。

要检索预测器，您可以向预测器发出 GET 请求
像这样的资源：

    / api / predictors

### 创建预测变量 { #webapi_create_predictor } 

您可以使用对预测器的 POST 请求创建预测器
资源：

    POST / api / predictors

有效负载样本如下所示：

```json
{
  "id": "AG10KUJCrRk",
  "name": "Malaria Outbreak Threshold Predictor",
  "shortName": "Malaria Outbreak Predictor",
  "description": "Computes the threshold for potential malaria outbreaks based on the mean plus 1.5x the std dev",
  "output": {
    "id": "nXJJZNVAy0Y"
  },
  "generator": {
    "expression": "AVG(#{r6nrJANOqMw})+1.5*STDDEV(#{r6nrJANOqMw})",
    "description": "Maximum normal malaria case count",
    "missingValueStrategy": "NEVER_SKIP",
    "slidingWindow": false
  },
  "periodType": "Monthly",
  "sequentialSampleCount": 4,
  "sequentialSkipCount": 1,
  "annualSampleCount": 3,
  "organisationUnitLevels": [4]
}
```

输出元素是指数据元素的标识符
其中保存预测数据值。生成器元素是指
计算预测值时使用的表达式。

### 预测表达式 { #webapi_predictor_expressions } 

预测器总是有一个生成器表达式来描述
计算出预测值。预测器也可能有跳过测试
表达式返回一个布尔值。当跳过测试表达式为
目前，在每个采样周期中对其进行评估，以判断是否
应该跳过那个时期的值。

以下变量可用于生成器表达式
或跳过测试表达式：

| 变量    | 目的     | 描述 |
| ----------- | ---------- | ----------- |
| #{<dataelement-id>} | 汇总数据元素 | 指所有类别选项组合中的聚合数据元素的总值。 |
| #{<dataelement-id>.<categoryoptcombo-id> | 数据元素操作数 | 指聚合数据元素和类别选项组合的组合。 |
| D{<program-id>.<dataelement-id>} | 程序数据元素 | 引用程序中跟踪器数据元素的值。 |
| A{<program-id>.<attribute-id>} | 程序跟踪的实体属性 | 指程序中被跟踪实体属性的值。 |
| I{<program-indicator-id>} | 计划指标 | 指程序指示器的值。 |
| R{<dataset-id>.<metric>} | 报告率 | 指报告率指标。指标可以是REPORTING_RATE，REPORTING_RATE_ON_TIME，ACTUAL_REPORTS，ACTUAL_REPORTS_ON_TIME，EXPECTED_REPORTS。 |
| C{<constant-id>} | 不变 | 指恒定值。 |
| OUG{<orgunitgroup-id>} | 组织单位组 | 指组织单位组内组织单位的数量。 |
| [天] | 天数 | 当前期间的天数。 |

### 生成预测值 { #webapi_generating_predicted_values } 

要运行所有预测器（生成预测值），您可以进行 POST
请求运行资源：

    POST / api / predictors / run

要运行单个预测器，您可以向运行发出 POST 请求
预测器的资源：

    POST / api / predictors / AG10KUJCrRk / run

## 计划规则 { #webapi_program_rules } 

本节是关于发送和读取程序规则，并解释
程序规则数据模型。程序规则赋予功能
在 DHIS2 程序中配置动态行为。

### 程序规则模型 { #webapi_program_rule_model } 

程序规则数据模型由 programRuleVariables、
程序规则和程序规则操作。 programRule 包含一个
表达式 - 当这个表达式为真时，子程序RuleActions
被触发。 programRuleVariables 用于寻址数据元素，
跟踪实体数据值和运行所需的其他数据值
表达式。一个程序中的所有程序规则共享同一个程序库
programRuleVariables，一个 programRuleVariable 可以用于多个
程序规则的表达式。

![](resources/images/program_rules/program-rule-model.jpg)

#### 程序规则模型详细信息 { #program-rule-model-details } 

下表给出了程序规则的详细概述
模型。

表：程序规则

| 名称 | 描述 | 强制性 |
|---|---|---|
| 程序 | 执行程序规则的程序。 | 强制性 |
| 名称 | 程序规则显示给 dhis2 配置器的名称。程序最终用户看不到。 | 强制性 |
| 描述 | 程序规则的描述，配置器可用于描述规则。程序的最终用户看不到。 | 强制性 |
| 程序阶段 | 如果为程序规则设置了程序阶段（programStage），则该规则只能在指定的程序阶段内进行评估。 | 可选的 |
| 健康）状况 | 为使程序规则触发其子操作，需要求值为 true 的表达式。表达式使用运算符、函数调用、硬编码值、常量和程序规则变量编写。`d2:hasValue('hemoglobin') && #{hemoglobin} <= 7 `.| 强制性 |
| 优先权 | 在规则顺序重要的情况下运行规则的优先级。在大多数情况下，规则并不取决于在其他规则之前或之后运行，在这种情况下，可以省略优先级。如果没有设置优先级，规则将在任何已定义优先级的规则之后运行。如果设置了优先级（整数），则优先级最低的规则将在优先级较高的规则之前运行。 | 可选的 |

#### 计划规则操作模型详细信息 { #program-rule-action-model-details } 

下表给出了对 programRuleAction 的详细概述
模型。

表：程序规则操作

| 名称 | 描述 | 强制性 |
|---|---|---|
| 程序规则 | 该操作的父程序规则。 | 强制性 |
| 程序规则--动作类型 | The type of action that is to be performed.<br>  * `DISPLAYTEXT` - Displays a text in a given widget.<br> * `DISPLAYKEYVALUEPAIR` - Displays a key and value pair(like a program indicator) in a given widget.<br> * `HIDEFIELD` - Hide a specified dataElement or trackedEntityAttribute.<br>    -         *content* - if defined, the text in *content* will be displayed to the end user in the instance where a value is previously entered into a field that is now about to be hidden (and therefore blanked). If *content* is not defined, a standard message will be shown to the user in this instance.<br>   -         *dataElement* - if defined, the HIDEFIELD action will hide this dataElement when the rule is effective.<br>   -         *trackedEntityDataValue* - if defined, the HIDEFIELD action will hide this trackedEntityDataValue when the rule is effective.<br>  * `HIDESECTION` - Hide a specified section.<br>    -         *programStageSection* - must be defined. This is the programStageSection that will be hidden in case the parent rule is effective.<br>  * `ASSIGN` - Assign a dataElement a value(help the user calculate something or fill in an obvious value somewhere)<br>    -         *content* - if defined, the value in *data* is assigned to this variable. If content id defined, and thus a variable is assigned for use in other rules, it is important to also assign a *programRule.priority* to make sure the rule with an ASSIGN action runs before the rule that will in turn evaluate the assigned variable.<br>   -         *data* - must be defined, data forms an expression that is evaluated and assigned to either a variable(#{myVariable}), a dataElement, or both.<br>   -         *dataElement* - if defined, the value in *data* is assigned to this data element.<br>  Either the content or dataElement must be defined for the ASSIGN action to be effective.<br> * `SHOWWARNING` - Show a warning to the user, not blocking the user from completing the event or registration.<br>    -         *content* - if defined, content is a static part that is displayed at the end of the error message.<br>   -         *data* - if defined, data forms an expression that is evaluated and added to the end of the warning message.<br>   -         *dataElement* - if defined, the warning message is displayed next to this data element.<br>   -         *trackedEntityAttribute* - if defined, the warning message is displayed next to this tracked entity attribute.<br>  Either dataElement or trackedEntityAttribute must be specified.<br> * `SHOWERROR` - Show an error to the user, blocking the user from completing the event or registration.<br>    -         *content* - if defined, content is a static part that is displayed in the start of the error message.<br>   -         *data* - if defined, data forms an expression that is evaluated and added to the end of the error message.<br>   -         *dataElement* - if defined, the error message is linked to this data element.<br>   -         *trackedEntityAttribute* - if defined, the error message is linked to this tracked entity attribute.<br>  Either dataElement or trackedEntityAttribute must be specified.<br> * `WARNINGONCOMPLETE` - Show a warning to the user on the "Complete form" dialog, but allowing the user to complete the event.<br>    -         *content* - if defined, content is a static part that is displayed at the end of the error message.<br>   -         *data* - if defined, data forms an expression that is evaluated and added to the end of the warning message.<br>   -         *dataElement* - if defined, the warning message prefixed with the name/formName of the data element.<br>  * `ERRORONCOMPLETE` - Show an error to the user on in a modal window when the user tries to complete the event. The user is prevented from completing the event.<br>    -         *content* - if defined, content is a static part that is displayed in the start of the error message.<br>   -         *data* - if defined, data forms an expression that is evaluated and added to the end of the error message.<br>   -         *dataElement* - if defined, the error message is linked to this data element.<br>  * `CREATEEVENT` - Create an event within the same enrollment.<br>    -         *content*<br>   -         *data* - if defined, contains data values to assign the created event. The format is <uid\>:<data value\>. Where several values is specified, these are separated with comma.<br> AcMrnleqHqc:100,AqK1IHqCkEE:'Polyhydramnios'   -         *programStage* - must be defined, and designates the program stage that the rule shall create an event of.<br>  * `SETMANDATORYFIELD` - Set a field to be mandatory.<br>    -         *dataElement* - if defined, this data element will be set to be mandatory in the data entry form.<br>   -         *trackedEntityAttribute* - if defined, this tracked entity attribute will be set to mandatory in the registration form or profile.<br>  * `SENDMESSAGE` - To send message at completion of event/enrollment or at data value update.<br>    -         *messageTemplate* - if defined, this template will be delivered either as SMS or EMAIL depending upon DeliveryChannel value in message template.<br>  * `SCHEDULEMESSAGE` - To schedule message at completion of event/enrollment or at data value update.<br>    -         *messageTemplate* - if defined, this template will be delivered either as SMS or EMAIL depending upon DeliveryChannel value in message template.<br>   -         *Date to send message* - Expression which is going to be used for evaluation of scheduled date. This expression should result in Date, any other resultant will be discarded and notification will not get scheduled. | 强制性 |
| 地点 | 用于动作类型 DISPLAYKEYVALUEPAIR 和 DISPLAYTEXT，以指定在哪个部件中显示文本或按键对。必须用于 DISPLAYKEYVALUEPAIR 和 DISPLAYTEXT。 | 参见说明 |
| 内容 | 用于不同操作中的用户信息。有关在每种操作类型中如何使用的详细说明，请参阅操作类型概述。SHOWWARNING、SHOWERROR、WARNINGONCOMPLETE、ERRORONCOMPLETE、DISPLAYTEXT 和 DISPLAYKEYVALUEPAIR 必须使用。HIDEFIELD 和 ASSIGN 可选。 | 参见说明 |
| 数据 | 用于不同操作中的表达式。有关在每种操作类型中如何使用的详细说明，请参阅操作类型概述。ASSIGN 必须使用。SHOWWARNING、SHOWERROR、WARNINGONCOMPLETE、ERRORONCOMPLETE、DISPLAYTEXT、CREATEEVENT 和 DISPLAYKEYVALUEPAIR 可选。 | 参见说明 |
| 数据元素 | 用于将规则操作链接到数据元素。有关在每种操作类型中如何使用的详细说明，请参阅操作类型概述。SHOWWARNING、SHOWERROR、WARNINGONCOMPLETE、ERRORONCOMPLETE、ASSIGN 和 HIDEFIELD 的可选项。 | 参见说明 |
| 跟踪属性 | 用于将规则操作链接到跟踪实体属性（trackedEntityAttributes）。有关在每种操作类型中如何使用的详细说明，请参阅操作类型概述。SHOWWARNING、SHOWERROR 和 HIDEFIELD 的可选项。 | 参见说明 |
| 选择权 | 用于将规则操作链接到选项。有关在每种操作类型中如何使用的详细说明，请参阅操作类型概述。HIDEOPTION 的可选项 | 参见说明 |
| 选项组 | 用于将规则操作链接到选项组。有关在每种操作类型中如何使用的详细说明，请参阅操作类型概述。SHOWOPTIONGROUP 和 HIDEOPTIONGROUP 必须使用。 | 参见说明 |
| 程序阶段 | 仅用于 CREATEEVENT 规则操作。必须用于 CREATEEEVENT。 | 参见说明 |
| 程序阶段-部分 | 仅用于 HIDESECTION 规则操作。必须用于 HIDESECTION | 参见说明 |

##### 程序规则行动验证{ #programruleaction-validation } 
2.37 中为 ProgramRuleAction 模型添加了一些验证。主要目的是防止用户创建错误的程序规则，以保持数据库的一致性。这些验证取决于程序规则动作类型。每种操作类型都有各自的验证。 

表：程序规则动作验证

| 名称 | 验证检查 ID 是否存在 |
|---|---|
|短信| 通知模板 ID |
|日程消息| 通知模板 ID |
|隐藏| ProgramStage 段落 ID |
|隐藏计划阶段| 节目阶段 id |
|希德菲尔德| 数据元素或跟踪实体属性 id |
|隐藏选项| 选项 id |
|隐藏选项组| 选项组 ID |
|显示选项组| 选项组 ID |
|设置必填字段| 数据元素或跟踪实体属性 id |
|淋浴器| 始终有效 |
|显示警告| 始终有效 |
|显示文本| DataElement 或 TrackedEntityAttribute id |
|显示键值对||
|分配| 数据元素或跟踪实体属性 id |
|完成警告| 数据元素或跟踪实体属性 id |
|erroroncomplete| 数据元素或跟踪实体属性 id |

除上述验证外，程序规则操作中通常包含表达式的 `data` 字段也可使用以下 api 端点进行评估。

    POST /api/programRuleActions/data/expression/description?programId=<uid>


```json
{
  "condition": "1 + 1"
}
```

#### 程序规则变量模型的详细信息 { #program-rule-variable-model-details } 

下表详细概述了
程序规则变量模型。

表：程序规则变量

| 名称 | 描述 | 强制性 |
|---|---|---|
| 名称 | programRuleVariable 的名称 - 该名称用于表达式中。#{myVariable} \> 5 | 强制性 |
| 源类型 | 定义如何用来自注册和事件的数据填充该变量。 <br> * DATAELEMENT_NEWEST_EVENT_PROGRAM_STAGE - 在跟踪捕获中，获取当前注册中给定计划阶段事件中数据元素的最新值。在事件捕获中，获取组织单元上 10 个最新事件中的最新值。<br> * DATAELEMENT_NEWEST_EVENT_PROGRAM - 在跟踪捕获中，获取一个数据元素在整个注册过程中的最新值。在事件捕获中，获取组织单位上 10 个最新事件中的最新值。<br> * DATAELEMENT_CURRENT_EVENT - 仅在当前事件中获取给定数据元素的值。<br> * DATAELEMENT_PREVIOUS_EVENT - 在跟踪捕获中，获取当前事件之前程序中事件的最新值。在事件捕获中，获取组织单元上登记的 10 个前置事件中的最新值。<br> * CALCULATED_VALUE - 用于保留变量名，该变量名将由 ASSIGN 程序规则操作分配<br> * TEI_ATTRIBUTE - 获取给定跟踪实体属性的值 | 强制性 |
| 数据元素 | 用于将程序规则变量链接到数据元素。必须用于所有以 DATAELEMENT_ 开头的源类型。 | 参见说明 |
| 跟踪属性 | 用于将 programRuleVariable（程序规则变量）链接到跟踪实体属性（trackedEntityAttribute）。必须用于源类型 TEI_ATTRIBUTE。 | 参见说明 |
| useCodeFor- 选项集 | 如果选中，变量将使用任何链接选项集的代码（而不是名称）。默认值为未选中，即输入选项名称。 ||
| 程序阶段 | 用于指定从哪个特定程序阶段获取 programRuleVariable 值。DATAELEMENT_NEWEST_EVENT_PROGRAM_STAGE 必须使用。 | 参见说明 |

### 创建程序规则 { #webapi_creating_program_rules } 

- To perform crud operations, `programRules` resource is available in API.

要检索programRules的列表，您可以执行GET请求，如下所示：

    / api / programRules

要检索单个programRule，您可以执行GET请求，如下所示：

    / api / programRules / <program_rule_uid>

要保存/添加单个programRule，您可以执行POST请求，如下所示：

    / api / programRules / <program_rule_uid>

要更新单个programRule，您可以执行如下PUT请求：

    / api / programRules / <program_rule_uid>

要删除单个programRule，您可以执行以下DELETE请求：

    / api / programRules / <program_rule_uid>

要检索programRule条件的描述，可以使用POST并在POST正文中提供条件字符串。

    / api / programRules / condition / description？ <program_rule_uid>

## 形式 { #webapi_forms } 

To retrieve information about a form (which corresponds to a data set
and its sections) you can interact with the `form` resource. The form
response is accessible as XML and JSON and will provide information
about each section (group) in the form as well as each field in the
sections, including labels and identifiers. By supplying period and
organisation unit identifiers the form response will be populated with
data values.

表格表单查询参数

| 参数 | 选项 | 描述 |
|---|---|---|
| 聚乙烯 | ISO 期 | 填入表格数据值的时间段。 |
| 欧 | 用户标识 | 用于填充表单数据值的组织单位。 |
| 元数据 | 假 | 真 | 是否包含表格各部分每个数据元素的元数据。 |

要检索数据集的表单，您可以执行GET请求，如下所示：

    / api / dataSets / <dataset-id> /form.json

检索具有标识符“BfMAe6Itzgt”的数据集的表单
XML：

    / api / dataSets / BfMAe6Itzgt / form

要检索包含JSON中的元数据的表单，请执行以下操作：

    /api/dataSets/BfMAe6Itzgt/form.json?metaData=true

检索填充了特定时期数据值的表单，并
XML 中的组织单位：

    /api/dataSets/BfMAe6Itzgt/form.xml?ou=DiszpKrYNg8&pe=201401

当涉及自定义数据输入表单时，此资源还允许
直接为数据集创建此类表单。这可以通过一个
内容类型为 text/html 的 POST 或 PUT 请求，其中有效负载是
自定义表单标记，例如：

```bash
curl -d @form.html "localhost/api/dataSets/BfMAe6Itzgt/form"
  -H "Content-Type:text/html" -u admin:district -X PUT
```

## 文件资料 { #webapi_documents } 

对文件的引用可以与文档资源一起存储。



表格文件字段

| 字段名称 | 描述 |
|---|---|
| 名称 | 文件唯一名称 |
| 外部 | 标识文件位置的标志。外部文件为 TRUE，内部文件为 FALSE |
| 网址 | 文件的位置。外部文件的 URL。内部文件的文件资源 ID（请参阅 [文件资源](#webapi_file_resources)）。 |

对文档端点的GET请求将返回所有文档：

    / api / documents

对文档端点的POST请求将创建一个新文档：

```bash
curl -X POST -d @document.json -H "Content-type: application/json"
  "http://dhis.domain/api/documents"
```

```json
{
  "name": "dhis home",
  "external": true,
  "url": "https://www.dhis2.org"
}
```

带有附加文档 ID 的 GET 请求将返回信息
关于文件。对同一端点的 PUT 请求将更新
文档的字段：

    / api / documents / <documentId>

将 */data* 附加到 GET 请求将返回实际文件内容
文件的：

    / api / documents / <documentId> / data

## CSV元数据导入 { #webapi_csv_metadata_import } 

DHIS2支持以CSV格式导入元数据，例如数据元素，组织单位和验证规则。根据列顺序/列索引来标识各种元数据对象的属性（有关详细信息，请参见下文）。您可以省略不需要的对象属性/列，但是由于列顺序很重要，因此必须包括一个空列。换句话说，如果您要指定在列顺序中排在后面的属性/列，但不指定在列顺序中排在较早的位置的某些列，则可以为它们添加空白/空白列。

CSV文件的第一行被视为标题，在导入期间将被忽略。 _comma_字符应用作文本定界符。包含逗号的文本必须放在_双引号_中。

要上传CSV格式的元数据，您可以向元数据端点发出POST请求：

    POST / api / metadata？classKey = CLASS-KEY

支持以下对象类型。 `classKey` 查询参数是强制性的，可以在下表中的每个对象类型旁边找到。

表格对象类型和关键字

| 对象类型 | 类键 |
|---|---|
| 资料元素 | DATA_ELEMENT |
| 数据元素组 | DATA_ELEMENT_GROUP |
| 类别选项 | CATEGORY_OPTION |
| 类别选项组 | CATEGORY_OPTION_GROUP |
| 组织单位 | ORGANISATION_UNIT |
| 组织单位组 | ORGANISATION_UNIT_GROUP |
| 验证规则 | VALIDATION_RULE |
| 选项集 | OPTION_SET |
| 翻译 | 翻译 |

> **提示**
>
> 如果使用 *curl*，应该使用 `--data-binary` 选项，因为它保留了换行符和换行符，这对于 CSV 数据是必不可少的。

例如，要使用`curl`上传CSV格式的数据元素文件，可以使用以下命令：

```bash
curl --data-binary @data_elements.csv "http://localhost/api/metadata?classKey=DATA_ELEMENT"
  -H "Content-Type:application/csv" -u admin:district
```

以下各节列出了CSV导入当前支持的对象类型的格式。

### 资料元素 { #webapi_csv_data_elements } 

表：数据元素 CSV 格式

| 索引 | 柱 | 需要 | 值（默认为第一位） | 描述 |
|---|---|---|---|---|
| 1 | 名称 | 是的 || 名称。最多 230 个字符。唯一。 |
| 2 | 用户标识 | 不 | 用户标识 | 稳定的标识符。正好 11 个字母数字字符，以字母开头。如果未指定，将由系统生成。 |
| 3 | 码 | 不 || 稳定代码。最多 50 个字符。 |
| 4 | 简称 | 不 | 50 名字的第一个字符 | 如果未指定，将返回姓名的前 50 个字符。最多 50 个字符。唯一。 |
| 5 | 描述 | 不 || 自由文本描述。 |
| 6 | 表格名称 | 不 || 最大 230 字符。 |
| 7 | 域名类型 | 不 | 汇总跟踪器 | 数据元素的域类型，可以是聚合或跟踪。最多 16 个字符。 |
| 8 | 值类型 | 不 | INTEGER &#124; NUMBER &#124; UNIT_INTERVAL &#124; PERCENTAGE &#124; INTEGER_POSITIVE &#124; INTEGER_NEGATIVE &#124; INTEGER_ZERO_OR_POSITIVE &#124; FILE_RESOURCE &#124; COORDINATE &#124;TEXT &#124; LONG_TEXT &#124; LETTER &#124; PHONE_NUMBER &#124; EMAIL &#124; BOOLEAN &#124; TRUE_ONLY &#124; DATE &#124; DATETIME | 数值类型。最多 16 个字符。 |
| 9 | 聚集类型 | 不 | SUM &#124; AVERAGE &#124; AVERAGE_SUM_ORG_UNIT &#124; COUNT &#124; STDDEV &#124; VARIANCE &#124; MIN &#124; MAX &#124; NONE | 聚合类型，表示如何按不同维度聚合数据。最多 16 个字符。 |
| 10 | 类别组合 | 不 | 用户标识 | 类别组合的 UID。如果未指定，将默认为默认类别组合。 |
| 11 | 网址 | 不 || 数据元素资源的 URL。最多 255 个字符。 |
| 12 | 零具有重要意义 | 不 | 假 | 真 | 表示该数据元素是否存储零值。 |
| 13 | 选项集 | 不 | 用户标识 | 要用于数据的选项集的 UID。 |
| 14 | 评论选项设置 | 不 | 用户标识 | 用于注释的选项集的 UID。 |

下面是数据元素的 CSV 文件示例。首先
行将始终被忽略。请注意如何跳过列并依赖
系统使用的默认值。您还可以跳过列
你不使用出现在右边的

```csv
名称，uid，代码，简称，描述
“妇女参加技能发展培训”，“ D0001”，“妇女参加培训”
“妇女参与社区组织”，“ D0002”，“妇女参与组织”
```

### 组织单位 { #webapi_csv_org_units } 

表：组织单位 CSV 格式

| 索引 | 柱 | 需要 | 值（默认为第一位） | 描述 |
|---|---|---|---|---|
| 1 | 名称 | 是的 || 姓名。最多 230 个字符。唯一。 |
| 2 | 用户标识 | 不 | 用户标识 | 稳定的标识符。最多 11 个字符。如果未指定，将由系统生成。 |
| 3 | 码 | 不 || 稳定代码。最多 50 个字符。 |
| 4 | 家长 | 不 | 用户标识 | 上级组织单位的 UID。 |
| 5 | 简称 | 不 | 50 名字的第一个字符 | 如果未指定，将返回姓名的前 50 个字符。最多 50 个字符。唯一。 |
| 6 | 描述 | 不 || 自由文本描述。 |
| 7 | 开幕日期 | 不 | 1970-01-01 | 以 YYYY-MM-DD 格式表示的组织单位成立日期。 |
| 8 | 关闭日期 | 不 || 组织单位的关闭日期，格式为 YYYY-MM-DD，如果当前开放，则跳过。 |
| 9 | 评论 | 不 || 组织单位的自由文本注释。 |
| 10 | 功能类型 | 不 | NONE &#124; MULTI_POLYGON &#124; POLYGON &#124; POINT &#124; SYMBOL | 地理空间特征类型。 |
| 11 | 坐标 | 不 || 用于地理空间分析的坐标，采用 Geo JSON 格式。 |
| 12 | 网址 | 不 || 组织单位资源的 URL。最多 255 个字符。 |
| 13 | 联系人 | 不 || 组织单位的联系人。最多 255 个字符。 |
| 14 | 地址 | 不 || 组织单位地址。最多 255 个字符。 |
| 15 | 电子邮件 | 不 || 组织单位的电子邮件。最多 150 个字符。 |
| 16 | 电话号码 | 不 || 组织单位的电话号码。最多 150 个字符。 |

使用父单位导入组织单位的最小示例
看起来像这样：

```csv
名称，uid，代码，父项
“西部省份”，“ WESTP”，“ ImspTQPwCqd”
“东部省”，“ EASTP”，“ ImspTQPwCqd”
```

### 验证规则 { #webapi_csv_validation_rules } 

表格验证规则 CSV 格式

| 索引 | 柱 | 需要 | 值（默认为第一位） | 描述 |
|---|---|---|---|---|
| 1 | 名称 | 是的 || 姓名。最多 230 个字符。唯一。 |
| 2 | 用户标识 | 不 | 用户标识 | 稳定的标识符。最多 11 个字符。如果未指定，将由系统生成。 |
| 3 | 码 | 不 || 稳定代码。最大 50 |
| 4 | 描述 | 不 || 自由文本描述。 |
| 5 | 教学 | 不 || 自由文本教学。 |
| 6 | 重要性 | 不 | 中 | 高 | 低 | 验证规则的重要性。 |
| 7 | 规则类型（忽略） | 不 | 验证 | 验证规则类型。 |
| 8 | 操作员 | 不 | equal_to &#124; not_equal_to &#124; greater_than &#124; greater_than_or_equal_to &#124; less_than &#124; less_than_or_equal_to &#124; compulsory_pair &#124; exclusive_pair | 表达运算符。 |
| 9 | 期间类型 | 不 | 月刊 | 日刊 | 周刊 | 季刊 | 半年刊 | 年刊 | 时期类型。 |
| 10 | 左侧表达 | 是的 || 基于数据元素和选项组合 UID 的数学公式。 |
| 11 | 左侧表情描述 | 是的 || 自由文本。 |
| 12 | 左侧缺失值策略 | 不 | skip_if_any_value_missing | skip_if_all_value_missing | never_skip | 左侧表达式中出现缺失值时的行为。 |
| 13 | 右侧表达 | 是的 || 基于数据元素和选项组合 UID 的数学公式。 |
| 14 | 右侧表达描述 | 是的 || 自由文本。 |
| 15 | 右侧缺失值策略 | 不 | skip_if_any_value_missing | skip_if_all_value_missing | never_skip | 右侧表达式中出现缺失值时的行为。 |

### 选项集 { #webapi_csv_option_sets } 

表：选项集 CSV 格式

| 索引 | 柱 | 需要 | 值（默认为第一位） | 描述 |
|---|---|---|---|---|
| 1 | 选项集名称 | 是的 || 姓名。最多 230 个字符。唯一。每个选项都应重复。 |
| 2 | 选项设置 UID | 不 | 用户标识 | 稳定的标识符。最多 11 个字符。如果未指定，将由系统生成。每个选项都应重复。 |
| 3 | 选项设置代码 | 不 || 稳定代码。最多 50 个字符。每个选项都应重复。 |
| 4 | 选项名称 | 是的 || 选项名称。最多 230 个字符。 |
| 5 | 选项 UID | 不 | 用户标识 | 稳定的标识符。最多 11 个字符。如果未指定，将由系统生成。 |
| 6 | 选项代码 | 是的 || 稳定代码。最多 50 个字符。 |

选项集的格式很特殊。前三个值代表
一个选项集。最后三个值代表一个选项。首先
代表选项集的三个值应该对每个值重复
选项。

```csv
optionsetname，optionsetuid，optionsetcode，optionname，optionuid，optioncode
“颜色”，“颜色”，“蓝色”，“蓝色”
“颜色”，“颜色”，“绿色”，“绿色”
“颜色”，“颜色”，“黄色”，“黄色”
“性别”，“男”，“男”
“性别”，“女性”，“女性”
“性别”，“未知”，“未知”
“结果”，“高”，“高”
“结果”，“中”，“中”
“结果”，“低”，“低”
“ Impact”，“ cJ82jd8sd32”，“ IMPACT”，“ Great”，“ GREAT”
“影响”，“ cJ82jd8sd32”，“影响”，“中等”，“中等”
“影响”，“ cJ82jd8sd32”，“影响”，“不良”，“不良”
```

### 选项组 { #option-group } 

表：选项组 CSV 格式

| 索引 | 柱 | 需要 | 值（默认为第一位） | 描述 |
|---|---|---|---|---|
| 1 | 选项组名称 | 是的 || 姓名。最多 230 个字符。唯一。每个选项都应重复。 |
| 2 | OptionGroupUid | 不 || 稳定的标识符。最多 11 个字符。如果未指定，将由系统生成。每个选项都应重复。 |
| 3 | 选项组代码 | 不 || 稳定代码。最多 50 个字符。每个选项都应重复。 |
| 4 | 选项组简称 | 是的 || 简称。最多 50 个字符。唯一。每个选项都应重复。 |
| 5 | OptionSetUid | 是的 || 稳定的标识符。最多 11 个字符。每个选项都应重复。 |
| 6 | OptionUid | 不 || 稳定的标识符。最多 11 个字符。 |
| 7 | 选项代码 | 不 || 稳定代码。最多 50 个字符。 |

OptionGroup CSV有效负载样本

```csv
optionGroupName，optionGroupUid，optionGroupCode，optionGroupShortName，optionSetUid，optionUid，optionCode
optionGroupA，groupA，xmRubJIhmaK，OptionA
optionGroupA，groupgroup，xmRubJIhmaK，OptionB
optionGroupB 、、 groupB，QYDAByFgTr1，OptionC
```
### 选项组集 { #option-group-set } 



表：选项组设置 CSV 格式

| 索引 | 柱 | 需要 | 值（默认为第一位） | 描述 |
|---|---|---|---|---|
| 1 | 选项组设置名称 | 是的 || 姓名。最多 230 个字符。唯一。每个选项都应重复。 |
| 2 | OptionGroupSetUid | 不 || 稳定的标识符。最多 11 个字符。如果未指定，将由系统生成。每个选项都应重复。 |
| 3 | 选项组设置代码 | 不 || 稳定代码。最多 50 个字符。每个选项都应重复。 |
| 4 | 选项组设置描述 | 不 || 说明每个选项都应重复。 |
| 5 | 数据维度 | 不 || 真，假 |
| 6 | OptionSetUid | 不 || OptionSet UID。稳定标识符。最多 11 个字符。 |

OptionGroupSet CSV有效负载样本

```csv
名称，uid，代码，描述，数据维度，选项
optiongroupsetA，...，xmRubJIhmaK
optiongroupsetB 、、、、 false，QYDAByFgTr1
```
要将OptionGroups添加到导入的OptionGroupSet中，请按照导入集合成员身份的步骤进行操作

### 收藏会员 { #collection-membership } 

除了导入对象，您还可以选择只导入对象
对象和组之间的组成员关系。目前，该
支持以下组和对象对

  - 组织单位组-组织单位

  - 数据元素组-数据元素

  - 指标组-指标

  - 选项组集-选项组

这些导入的CSV格式相同



表格：收集成员 CSV 格式

| 索引 | 柱 | 需要 | 值（默认为第一位） | 描述 |
|---|---|---|---|---|
| 1 | 用户标识 | 是的 | 用户标识 | 要添加对象的集合的 UID |
| 2 | 用户标识 | 是的 | 用户标识 | 要添加到集合中的对象的 UID |

### 其他物件 { #webapi_csv_other_objects } 



表格数据元素组、类别选项、类别选项组、组织单位组 CSV 格式

| 索引 | 柱 | 需要 | 值（默认为第一位） | 描述 |
|---|---|---|---|---|
| 1 | 名称 | 是的 || 姓名。最多 230 个字符。唯一。 |
| 2 | 用户标识 | 不 | 用户标识 | 稳定标识符。最多 11 个字符。如果未指定，将由系统生成。 |
| 3 | 码 | 不 || 稳定代码。最多 50 个字符。 |
| 4 | 简称 | 不 || 简称。最多 50 个字符。 |

类别选项的示例如下所示：

```csv
名称，uid，代码，简称
“男”，“男”
“女性”，“女性”
```

## 删除的对象 { #webapi_deleted_objects } 

删除的对象资源提供了元数据对象的日志
删除。

    / api / deletedObjects

每当删除元数据类型的对象时，都会保留日志
uid、代码、类型和删除时间。这个 API 是
在`/api/deletedObjects` 字段过滤和对象过滤中可用
与其他元数据资源类似。

获取类型为数据元素的已删除对象：

    GET /api/deletedObjects.json?klass=DataElement

获取在 2015 年删除的指标类型的已删除对象和
向前：

    GET /api/deletedObjects.json?klass=Indicator&deletedAt=2015-01-01

## 收藏夹 { #webapi_favorites } 

某些类型的元数据对象可以标记为收藏夹
当前登录的用户。这目前适用于仪表板。

    / api / dashboards / <uid> /收藏

要使仪表板成为收藏夹，您可以发出 *POST* 请求（无内容
type required) 到这样的 URL：

    / api /仪表板/ iMnYyBfSxmM /收藏

要将仪表板删除为收藏夹，您可以发出 *DELETE* 请求
使用与上面相同的 URL。

收藏夹状态将显示为布尔值 *收藏夹* 字段
元数据响应中的对象（例如仪表板）。

## 订阅内容 { #webapi_subscription } 

登录的用户可以订阅某些类型的对象。现在
可订阅对象是 Chart、EventChart、EventReport 类型的对象，
地图、报告表和可视化。

> **注意**
>
>不推荐使用Chart和ReportTable对象。改为使用可视化。

要获取对象的订阅者（返回用户 ID 数组），您
可以发出 *GET* 请求：

    / api / <object-type> / <object-id> /订阅者

请参见以下示例：

    / api / charts / DkPKc1EUmC2 / subscribers

检查当前用户是否订阅了一个对象（返回一个
boolean) 您可以执行 *GET* 调用：

    / api / <object-type> / <object-id> /已订阅

请参见以下示例：

    / api / charts / DkPKc1EUmC2 /已订阅

要订阅/取消订阅对象，请执行 *POST/DELETE*
请求（不需要内容类型）：

    / api / <object-type> / <object-id> / subscriber

## 文件资源 { #webapi_file_resources } 

*文件资源*是用于表示和存储二进制内容的对象。
*FileResource* 对象本身包含文件元数据（名称、
内容类型、大小等）以及允许检索
来自数据库外部文件存储的内容。 *FileResource* 对象
与其他数据库一样存储在数据库中，但内容（文件）是
存储在别处并可使用包含的引用检索
*（存储密钥）*。

    / api / fileResources

文件资源的内容不能直接访问，但可以
从其他对象（如数据值）引用来存储二进制
几乎无限大小的内容。

创建不需要相应数据值的文件资源、
以多部分上传方式 POST 到端点 `/api/fileResources`：

```bash
curl "https://server/api/fileResources" -X POST
  -F "file=@/path/to/file/name-of-file.png"
```

创建文件资源和引用该文件的数据值、
在 DHIS 2.36 或更高版本中，POST 到 `/api/dataValues/file` 端点：

```bash
curl "https://server/api/dataValues/file?de=xPTAT98T2Jd
  &pe=201301&ou=DiszpKrYNg8&co=Prlt0C1RF0s" -X POST
  -F "file=@/path/to/file/name-of-file.png"
```

For the `api/fileResources` endpoint, the only form parameter required is
*file*, which is the file to upload. For the `api/dataValues/file`
endpoint, the parameters required are the same as for a post to
`api/dataValues`, with the addition of *file*.

文件名和内容类型也应包含在请求中，但
如果没有提供，将用默认值代替。

成功创建文件资源后，返回的数据将包含
一个 `response` 字段，它又包含这样的 `fileResource`：

```json
{
  "httpStatus": "Accepted",
  "httpStatusCode": 202,
  "status": "OK",
  "response": {
    "responseType": "FileResource",
    "fileResource": {
      "name": "name-of-file.png",
      "created": "2015-10-16T16:34:20.654+0000",
      "lastUpdated": "2015-10-16T16:34:20.667+0000",
      "externalAccess": false,
      "publicAccess": "--------",
      "user": { ... },
      "displayName": "name-of-file.png",
      "contentType": "image/png",
      "contentLength": 512571,
      "contentMd5": "4e1fc1c3f999e5aa3228d531e4adde58",
      "storageStatus": "PENDING",
      "id": "xm4JwRwke0i"
    }
  }
}
```

注意响应是*202 Accepted*，表示返回的
资源已提交后台处理（持续到
在这种情况下是外部文件存储）。另外，请注意 `storageStatus` 字段
指示内容是否已存储。在这
点，到外部存储的持久化还没有完成（它是
可能会上传到某个地方的基于云的商店）
`PENDING` 状态。

即使内容尚未完全存储，文件资源
现在可以使用，例如作为数据值中的引用内容（参见
[使用文件数据值](#datavalue_file))。如果我们需要检查
更新的 *storageStatus* 或以其他方式检索
文件，可以查询`fileResources`端点。

```bash
curl "https://server/api/fileResources/xm4JwRwke0i" -H "Accept: application/json"
```

此请求将返回 `FileResource` 对象，如
上面例子的反应。

### 文件资源限制 { #webapi_file_resources_constraints } 

  - 文件资源*必须*从另一个对象引用（分配）
    以便长期坚持。一个文件资源是
    创建但未被其他对象（例如数据值）引用
    被认为处于*分期*。此中的任何文件资源
    状态并且超过*两个小时*将被标记为删除
    并将最终从系统中清除。

  - 文件资源初始创建返回的ID不是
    可从任何其他位置检索，除非文件资源具有
    已被引用（其中 ID 将被存储为引用），
    所以丢失它需要重复 POST 请求和一个新的
    要创建的对象。 *孤立*文件资源将被清理
    自动起来。

  - 文件资源对象是*不可变的*，意味着修改不是
    允许并需要创建一个全新的资源。

### 文件资源阻止列表 { #file-resource-blocklist } 

出于安全原因，某些类型的文件被阻止上传。

以下内容类型被阻止。

| 内容类型 | 内容类型 |
| ------------------------------------- | ---- |
| 文字/ HTML                             | 应用程序/ x-ms-dos-可执行 |
| 文字/ css                              | application / vnd.microsoft.portable-executable |
| 文字/ javascript                       | application / vnd.apple.installer + xml |
| 字体/ otf                              | application / vnd.mozilla.xul + xml |
| 应用程序/ x-shockwave-flash         | 应用程序/ x-httpd-php  |
| application / vnd.debian.binary-package | 应用程序/ x-sh |
| 应用/ x-rpm                     | 应用程序/ x-csh |
| 应用程序/ Java归档              |  |

以下文件扩展名被阻止。

| 文件扩展名 | 文件扩展名 | 文件扩展名 |
| ---- | ---- | ---- |
| 网页 | 黛比  | ul  |
| htm  | 转数  | 的PHP  |
| 的CSS  | 罐  | 箱子  |
| js   | jsp  | SH   |
| 微信  | 可执行程序  | csh  |
| OTF  | 微星  | 蝙蝠  |
| 瑞士法郎  | 每公斤 |      |

## 元数据版本控制 { #webapi_metadata_versioning } 

本节介绍元数据版本化 API。

  - `/api/metadata/version`：这个端点将返回当前的元数据
    调用它的系统的版本。



表格查询参数

| 名称 | 需要 | 描述 |
|---|---|---|
| 版本名称 | 假 | 如果未指定该参数，则将返回系统的当前版本，否则将返回作为参数传递的版本名称的详细信息。(版本名称的语法为 "Version_<id\>" |

### 获取元数据版本示例 { #webapi_metadata_versioning_examples } 

**示例：**获取此系统的当前元数据版本

请求：

```
/ api /元数据/版本
```

响应：

```json
{
  "name": "Version_4",
  "created": "2016-06-30T06:01:28.684+0000",
  "lastUpdated": "2016-06-30T06:01:28.685+0000",
  "externalAccess": false,
  "displayName": "Version_4",
  "type": "BEST_EFFORT",
  "hashCode": "848bf6edbaf4faeb7d1a1169445357b0",
  "id": "Ayz2AEMB6ry"
}
```

**示例：**获取名称为“ Version_2”的版本的详细信息

请求：

```
/ api / metadata / version？versionName = Version_2
```

响应：

```json
{
  "name": "Version_2",
  "created": "2016-06-30T05:59:33.238+0000",
  "lastUpdated": "2016-06-30T05:59:33.239+0000",
  "externalAccess": false,
  "displayName": "Version_2",
  "type": "BEST_EFFORT",
  "hashCode": "8050fb1a604e29d5566675c86d02d10b",
  "id": "SaNyhusVxBG"
}
```

  - `/api/metadata/version/history`：这个端点将返回所有
    调用它的系统的元数据版本。



表格查询参数

| 名称 | 需要 | 描述 |
|---|---|---|
| 底线 | 假 | 如果未指定该参数，将返回所有元数据版本的列表。否则，我们需要传递一个形式为 "Version_<id\>"的 versionName 参数。然后，它将返回系统中在作为查询参数提供的版本名称之后创建的版本列表。 |

### 获取所有元数据版本的列表 { #webapi_get_list_of_metadata_versions } 

**示例：**获取此系统中所有版本的列表

请求：

```
/ api /元数据/版本/历史记录
```

响应：

```json
{
  "metadataversions": [{
    "name": "Version_1",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T05:54:41.139+0000",
    "id": "SjnhUp6r4hG",
    "hashCode": "fd1398ff7ec9fcfd5b59d523c8680798"
  }, {
    "name": "Version_2",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T05:59:33.238+0000",
    "id": "SaNyhusVxBG",
    "hashCode": "8050fb1a604e29d5566675c86d02d10b"
  }, {
    "name": "Version_3",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T06:01:23.680+0000",
    "id": "FVkGzSjAAYg",
    "hashCode": "70b779ea448b0da23d8ae0bd59af6333"
  }]
}
```

**示例：**获取此系统在“ Version_2”之后创建的所有版本的列表

请求：

```
/ api / metadata / version / history？baseline = Version_2
```

响应：

```json
{
  "metadataversions": [{
    "name": "Version_3",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T06:01:23.680+0000",
    "id": "FVkGzSjAAYg",
    "hashCode": "70b779ea448b0da23d8ae0bd59af6333"
  }, {
    "name": "Version_4",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T06:01:28.684+0000",
    "id": "Ayz2AEMB6ry",
    "hashCode": "848bf6edbaf4faeb7d1a1169445357b0"
  }]
 }
```

  - `/api/metadata/version/create`：这个端点将创建元数据
    version 参数中指定的版本类型。



表格查询参数

| 名称 | 需要 | 描述 |
|---|---|---|
| 类型 | 真正 | The type of metadata version which needs to be created.<br>  * BEST_EFFORT<br> * ATOMIC |

用户可以选择需要创建的元数据类型。
元数据版本类型决定了进口商应该如何对待给定的
版本。导入元数据时将使用此类型。有
两种类型的元数据。

  - *BEST_EFFORT*：这种类型表明丢失的引用可以
    忽略，导入器可以继续导入元数据（例如
    数据元素组导入中缺少数据元素）。

  - *ATOMIC*：这种类型确保对元数据进行严格的类型检查
    如果有任何引用，则引用和元数据导入将失败
    不存在。

> **注意**
>
> 建议有一个 ATOMIC 类型的版本，以确保所有
> 系统（中央和本地）具有相同的元数据。任何遗漏
> 引用在验证阶段本身被捕获。请参阅
> 进口商详细信息的完整解释。

### 创建元数据版本 { #webapi_create_metadata_version } 

**示例：** 创建类型为 `BEST_EFFORT` 的元数据版本

请求：

```bash
curl -X POST -u admin:district "https://play.dhis2.org/dev/api/metadata/version/create?type=BEST_EFFORT"
```

响应：

```json
{
  "name": "Version_1",
  "created": "2016-06-30T05:54:41.139+0000",
  "lastUpdated": "2016-06-30T05:54:41.333+0000",
  "externalAccess": false,
  "publicAccess": "--------",
  "user": {
    "name": "John Traore",
    "created": "2013-04-18T17:15:08.407+0000",
    "lastUpdated": "2016-04-06T00:06:06.571+0000",
    "externalAccess": false,
    "displayName": "John Traore",
    "id": "xE7jOejl9FI"
  },
  "displayName": "Version_1",
  "type": "BEST_EFFORT",
  "hashCode": "fd1398ff7ec9fcfd5b59d523c8680798",
  "id": "SjnhUp6r4hG"
}
```

  - `/api/metadata/version/{versionName}/data`：这个端点将下载
    特定于作为路径传递的版本名称的实际元数据
    范围。

  - `/api/metadata/version/{versionName}/data.gz`：这个端点将下载
    特定于作为路径传递的版本名称的实际元数据
    压缩格式（gzipped）的参数。



表格路径参数

| 名称 | 需要 | 描述 |
|---|---|---|
| 版本名称 | 真正 | 格式为 "Version_<id\>"的路径参数，以便 API 下载特定版本 |

### 下载版本元数据 { #webapi_download_version_metadata } 

**示例：**获取“版本5”的实际元数据

请求：

```bash
curl -u admin:district "https://play.dhis2.org/dev/api/metadata/version/Version_5/data"
```

响应：

```json
{
  "date": "2016-06-30T06:10:23.120+0000",
  "dataElements": [
    {
      "code": "ANC 5th Visit",
      "created": "2016-06-30T06:10:09.870+0000",
      "lastUpdated": "2016-06-30T06:10:09.870+0000",
      "name": "ANC 5th Visit",
      "id": "sCuZKDsix7Y",
      "shortName": "ANC 5th Visit ",
      "aggregationType": "SUM",
      "domainType": "AGGREGATE",
      "zeroIsSignificant": false,
      "valueType": "NUMBER",
      "categoryCombo": {
        "id": "p0KPaWEg3cf"
      },
      "user": {
        "id": "xE7jOejl9FI"
      }
    }
  ]
}
```

## 元数据同步 { #webapi_metadata_synchronization } 

本节介绍了可用的元数据同步 API
2.24 开始

  - `/api/metadata/sync`：此端点执行元数据同步
    通过下载和在查询参数中传递的版本名称
    从远程服务器导入指定的版本，如定义
    设置应用程序。



表格查询参数

| 名称 | 需要 | 描述 |
|---|---|---|
| 版本名称 | 真正 | versionName 查询参数的形式为 "Version_<id\>" 。api 会从远程服务器下载该版本，并将其导入本地系统。 |

  - 使用此 API 时应格外小心。请注意，有
    以完全自动化的方式实现同步的另一种方法
    利用“数据管理”中的元数据同步任务
    应用程序。详见用户手册第 22 章 22.17 节
    关于元数据同步任务。

  - 此同步 API 也可用于同步元数据
    从元数据同步调度程序失败的版本。由于
    它依赖于给定的元数据版本号，应该注意
    为调用 this 的顺序而采用。例如。如果这个api是
    用于从中央实例同步一些更高版本，然后
    同步可能会失败，因为元数据依赖项不存在于
    本地实例。

  - 假设本地实例在 `Version_12` 并且如果使用这个端点
    从中央同步`Version_15`（类型`BEST_EFFORT`）
    例如，调度程序将从以下位置开始同步元数据
    `版本_16`。所以本地实例不会有元数据
    `Version_12` 和 `Version_15` 之间的版本。你需要手动
    仅使用这些端点同步丢失的版本。

### 同步元数据版本 { #webapi_metadata_synchronization_version } 

**示例：**将Version_6从中央系统同步到该系统

请求：

```bash
curl -u admin:district "https://play.dhis2.org/dev/api/metadata/sync?versionName=Version_6"
```

## 元数据存储库 { #webapi_metadata_repository } 

DHIS2 提供了一个包含元数据包的元数据存储库
各种内容。元数据包是符合 DHIS2 的 JSON 文档
它描述了一组元数据对象。

要检索可用元数据包的索引，您可以发出
对 *metadataRepo* 资源的 GET 请求：

    GET /api/synchronization/metadataRepo

元数据包条目包含有关包的信息和
相关包的 URL。索引可能如下所示：

```json
{
  "packages": [
    {
      "id": "sierre-leone-demo",
      "name": "Sierra Leone demo",
      "description": "Sierra Leone demo database",
      "version": "0.1",
      "href": "https://dhis2.org/metadata-repo/221/sierra-leone-demo/metadata.json"
    },
    {
      "id": "trainingland-org-units",
      "name": "Trainingland organisation units",
      "description": "Trainingland organisation units with four levels",
      "version": "0.1",
      "href": "https://dhis2.org/metadata-repo/221/trainingland-org-units/metadata.json"
    }
  ]
}
```

客户端可以通过 URL 安装元数据包
带有元数据包的内容类型 *text/plain* 的 POST 请求
URL 作为 *metadataPull* 资源的有效负载：

    POST / api / synchronization / metadataPull

curl命令示例如下所示：

```bash
curl "localhost:8080/api/synchronization/metadataPull" -X POST
  -d "https://dhis2.org/metadata-repo/221/trainingland-org-units/metadata.json"
  -H "Content-Type:text/plain" -u admin:district
```

## 引用 createdBy 用户{ #reference-to-createdby-user } 

Each object created in DHIS2 will have a property named `user` which is linked to `User` who created the object.

From version 2.36 we have changed the name of this property to `createdBy` to avoid confusion.

不过，为了保持向后兼容性，传统的 `user` 属性仍包含在有效载荷中，并像以前一样正常工作。

```json
{
  "createdBy": {
      "displayName": "John Kamara",
      "name": "John Kamara",
      "id": "N3PZBUlN8vq",
      "username": "district"
  },
  "user": {
      "displayName": "John Kamara",
      "name": "John Kamara",
      "id": "N3PZBUlN8vq",
      "username": "district"
  }
}
```

## 元数据提案工作流程{ #webapi_metadata_proposal_workflow }

元数据提议工作流程端点可实现提议和接受元数据更改的工作流程。

```
/api/metadata/proposals
```

### 提议更改元数据{ #webapi_metadata_proposal_propose }

一个提案总是针对一个元数据对象，使用

    POST /api/metadata/proposals

根据有效载荷的不同，该提案可以

* 添加一个新的元数据对象。
* 按 ID 更新现有元数据对象引用。
* 删除 ID 引用的现有元数据对象。

要提议添加新的元数据对象，请发送类似下面的 JSON 有效负载：

```json
{
  "type": "ADD",
  "target": "ORGANISATION_UNIT",
  "change": {"name":"My Unit", "shortName":"MyOU", "openingDate": "2020-01-01"}
}
```
`change` 属性包含相同的 JSON 对象，可直接发布到相应的端点以创建对象。

要提议更新现有元数据对象，请发送一个 JSON 有效载荷，如下例所示：

```json
{
  "type": "UPDATE",
  "target": "ORGANISATION_UNIT",
  "targetId": "<id>",
  "change": [
    { "op": "replace", "path": "/name", "value": "New name" }
  ]
}
```
The `targetId` refers to the object by its ID which should be updated. The `change` property here contains a JSON patch payload. This is the same
patch payload that could be posted to the corresponding endpoint to directly apply the update.

要提议删除现有对象，请发送一个有效载荷，如上一个示例：

```json
{
  "type": "REMOVE",
  "target": "ORGANISATION_UNIT",
  "targetId": "<id>"
}
```
The `targetId` refers to the object  by its ID which should be removed. A free text `comment` can be added to any type of comment.

Only `target` type `ORGANISATION_UNIT` is supported currently.

### 接受元数据更改建议{ #webapi_metadata_proposal_accept }
要接受一个开放的提案，请在提案资源上使用`POST`

    POST /api/metadata/proposals/<uid>

成功后，提案的状态变为`接受`状态。一旦被接受，提案就不能再被拒绝。

Should a proposal fail to apply it changes to status `NEEDS_UPDATE`. The `reason` field contains a summary of the failures when this information is 
available.

### 反对元数据变更提案{ #webapi_metadata_proposal_oppose }
如果提案不太正确并且需要调整，可以通过发送提案资源的`PATCH`来反对提案

    PATCH /api/metadata/proposals/<uid>

可选地，可以在其中添加纯文本正文，以给出提案遭到反对的`原因`。

反对的提案必须处于`PROPOSED`状态，并将更改为`NEEDS_UPDATE`状态。

### 调整元数据更改建议{ #webapi_metadata_proposal_adjust }
A proposal in state `NEEDS_UPDATE` needs to be adjusted before it can be accepted. To adjust the proposal a `PUT` request is made for the proposal's 
resource

    PUT /api/metadata/proposals/<uid>

这种调整可以不带正文，也可以使用 JSON 正文，其中包含一个对象，该对象包含更新后的 `change` 和 `targetId` 为 
调整：

```json
{
  "targetId": "<id>",
  "change": ...
}
```
The JSON type of the `change` value depends on the proposal `type` analogous to when a proposal is initially made.

### 拒绝元数据更改建议{ #webapi_metadata_proposal_reject }
要拒绝打开的提案，请在提案资源上使用`DELETE`

    DELETE /api/metadata/proposals/<uid>

这最终将提案的状态更改为`拒绝`。不能对此提案进行进一步的更改。它作为事件的文档保存。

### 元数据变更建议清单{ #webapi_metadata_proposal_list }
所有提案均可列入清单：

    GET /api/metadata/proposals/

可以使用`filter`参数过滤结果列表。
例如，要只列出已接受的提案，请使用

    GET /api/metadata/proposals?filter=status=ACCEPTED

同样，只显示公开提案的使用情况：

    GET /api/metadata/proposals?filter=status=PROPOSED

过滤器也可应用于除 `change` 以外的任何字段。支持的过滤器操作符是 Gist Metadata API 中描述的操作符。这也包括 Gist API 中描述的属性转换器。

可用字段列表如下

| 领域       | 描述 |
| ----------- | -------------------------------------------------------------- |
| 本我          | 提案的唯一标识符 |
| 类型        | `ADD` a new object, `UPDATE` an existing object, `REMOVE` an existing object |
| 地位      | `PROPOSED` (open proposal), `ACCEPTED` (successful), `NEEDS_UPDATE` (accepting caused error or opposed), `REJECTED` |
| 目标      | type of metadata object to add/update/remove; currently only `ORGANISATION_UNIT` |
| targetId    | 更新或删除对象的 UID，未为`添加`定义 |
| 创建人   | 创建提案的用户 |
| 创建     | 创建提案的日期时间 |
| 定稿于 | 接受或拒绝建议的用户 |
| 定稿   | 提案转为接受或拒绝的决定性状态的日期时间 |
| 评论     | 为初步建议提供可选的纯文本注释 |
| 理由      | 可选的纯文本，在提案被反对或接受提案失败时出现的错误时给出 | 
| 改变      | JSON object for `ADD` proposal, JSON array for `UPDATE` proposal, nothing for `REMOVE` proposal |

### 查看元数据更改建议{ #webapi_metadata_proposal_show }
单个变更建议可通过以下方式查看 

    GET /api/metadata/proposals/<uid>

参数 `fields` 可用来缩小显示对象所包含字段的范围。例如

    GET /api/metadata/proposals/<uid>?fields=id,type,status,change

