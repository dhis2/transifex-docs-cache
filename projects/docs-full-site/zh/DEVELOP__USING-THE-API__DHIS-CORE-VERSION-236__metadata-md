---
edit_url: "https://github.com/dhis2/dhis2-docs/blob/2.36/src/developer/web-api/metadata.md"
revision_date: "2022-01-17"
tags:
    - Develop
    - DHIS 核心版本 2.36
---

# 元数据 { #metadata }

## 标识符方案 { #webapi_identifier_schemes }

本节提供标识符方案概念的解释。
标识符方案用于将元数据对象映射到其他元数据
在导入期间，并将元数据呈现为导出的一部分。请注意
并不是所有的方案都适用于所有的 API 调用，也不是所有的
方案可用于输入和输出。这在
部分解释了各种 Web API。

列出了可用的全套标识符方案对象类型
下面，使用在查询中使用的属性名称：

-   方案

-   数据元素标识方案

-   类别选项组合 ID 方案

-   组织单位 ID 方案

-   程序标识方案

-   程序阶段标识方案

-   跟踪实体 ID 方案

-   trackedEntityAttributeIdScheme

通用 idScheme 适用于所有类型的对象。有可能
被特定的对象类型覆盖。

所有参数的默认方案是 UID（稳定的 DHIS2
身份标识）。支持的标识符方案在
下表。

 <table>
 <caption>方案值</caption>
 <colgroup>
 <col style="width: 14%" />
 <col style="width: 85%" />
 </colgroup>
 <thead>
 <tr class="header">
 <th>方案</th>
 <th>说明</th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td> ID，UID </td>
 <td>在DHIS2稳定标识符上匹配，这是默认的ID方案。 </td>
 </tr>
 <tr class="even">
 <td>代码</td>
 DHIS2代码上的<td>匹配，主要用于与外部系统交换数据。 </td>
 </tr>
 <tr class="odd">
 <td>名称</td>
 <td>与DHIS2名称匹配，请注意，这使用的是<em> object.name </em>而不是已翻译的名称。还要注意，名称并不总是唯一的，在这种情况下，不能使用它们。 </td>
 </tr>
 <tr class="even">
 <td>属性：ID </td>
 <td>匹配元数据属性，此属性需要分配给您要匹配的类型，并且unique属性设置为<em> true </em>。此方法的主要用途还在于与外部系统交换数据，与<em>代码</em>相比，它具有一些优点，因为可以添加多个属性，因此它可以用于与多个系统同步。 </td>
 </tr>
 </tbody>
 </table>

请注意，标识符方案不是一个独立的功能，但需要
与数据值导入、元数据导入等资源结合使用。

例如，指定 CODE 作为通用 id 方案并覆盖
使用 UID 作为组织单位 ID 方案，您可以使用这些查询
参数：

    ？idScheme = CODE＆orgUnitIdScheme = UID

再举一个例子，为组织单位 id 指定一个属性
方案，数据元素 id 方案的代码并使用默认 UID id
您可以使用这些参数的所有其他对象的方案：

    ？orgUnitIdScheme =属性：j38fk2dKFsG＆dataElementIdScheme = CODE

## 浏览Web API { #webapi_browsing_the_web_api }

浏览 Web API 的入口点是 `/api`。这个资源
提供所有可用资源的链接。四种资源表示
格式始终适用于所有资源：HTML、XML、JSON、
和 JSONP。某些资源将具有其他可用格式，例如 MS
Excel、PDF、CSV 和 PNG。要从 Web 浏览器探索 API，请导航
到 `/api` 入口点并按照链接到您想要的
资源，例如`/api/dataElements`。对于所有资源
返回元素列表，某些查询参数可用于修改
响应：

 <table style="width:100%;">
 <caption>查询参数 </caption>
 <colgroup>
 <col style="width: 11%" />
 <col style="width: 20%" />
 <col style="width: 12%" />
 <col style="width: 54%" />
 </colgroup>
 <thead>
 <tr class="header">
 <th>参数</th>
<th> 选项值</th>
<th> 默认选项</th>
 <th>说明</th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td>分页</td>
 <td>是|假</td>
 <td>是</td>
 <td>指示是否返回页面中的元素列表。 </td>
 </tr>
 <tr class="even">
 <td>页面</td>
 <td>编号</td>
 <td> 1 </td>
 <td>定义要返回的页码。 </td>
 </tr>
 <tr class="odd">
 <td>页面大小</td>
 <td>编号</td>
 <td> 50 </td>
 <td>定义每个页面要返回的元素数。 </td>
 </tr>
 <tr class="even">
 <td>订单</td>
 <td>property:asc/iasc/desc/ides</td>
  <td></td>
 <td>使用指定的顺序对输出进行排序，仅支持持久和简单的属性（不支持集合，idObjects等）。 iasc和idec是不区分大小写的排序。</td> 
 </tr>
 </tbody>
 </table>

如何使用这些参数获取完整列表的示例
XML 响应格式的数据元素组是：

    /api/dataElementGroups.xml?links=false&paging=false

您可以查询 name 属性上的元素，而不是使用 _query_ 查询变量返回完整的元素列表。在此示例中，我们查询名称中含有“anaemia”一词的所有数据元素：

    / api / dataElements？query =贫血

您可以像这样获取特定页面和对象的页面大小：

    /api/dataElements.json?page=2&pageSize=20

您可以像这样完全禁用分页：

    /api/indicatorGroups.json?paging=false

要基于特定属性对结果进行排序：

    /api/indicators.json?order=shortName:desc

您可以通过 _identifyingObjects_ 资源根据所有对象类型的 ID 查找对象：

    / api / identifiableObjects / <id>

### 翻译 { #webapi_translation }

DHIS2 支持数据库内容的翻译，例如数据元素、指标和程序。 Web API 中的所有元数据对象都具有用于显示/UI 目的的属性，其中包括 _displayName_、_displayShortName_ 和 _displayDescription_。

 <table>
 <caption>翻译选项</caption>
 <colgroup>
 <col style="width: 20%" />
 <col style="width: 16%" />
 <col style="width: 62%" />
 </colgroup>
 <thead>
 <tr class="header">
 <th>参数</th>
 <th>值</th>
 <th>说明</th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td>翻译</td>
 <td>是|假</td>
 <td>转换元数据输出中的display *属性（数据元素的displayName，displayShortName，displayDescription和displayFormName）。默认值为true。 </td>
 </tr>
 <tr class="even">
 <td>语言环境</td>
 <td>使用</td>的语言环境
 <td>使用指定的语言环境转换元数据输出（需要translate = true）。 </td>
 </tr>
 </tbody>
 </table>

### 翻译API { #webapi_translation_api }

对象的翻译在 _translations_ 数组中呈现为对象本身的一部分。请注意，JSON/XML 有效负载中的 _translations_ 数组通常已为您预先过滤，这意味着它们不能直接用于导入/导出翻译（因为这通常会覆盖当前用户以外的区域设置）。

在用户语言环境中过滤了转换数组的数据元素示例：

```json
{
    "id": "FTRrcoaog83",
    "displayName": "Accute French",
    "translations": [
        {
            "property": "SHORT_NAME",
            "locale": "fr",
            "value": "Accute French"
        },
        {
            "property": "NAME",
            "locale": "fr",
            "value": "Accute French"
        }
    ]
}
```

转换关闭的数据元素示例：

```json
{
    "id": "FTRrcoaog83",
    "displayName": "Accute Flaccid Paralysis (Deaths < 5 yrs)",
    "translations": [
        {
            "property": "FORM_NAME",
            "locale": "en_FK",
            "value": "aa"
        },
        {
            "property": "SHORT_NAME",
            "locale": "en_GB",
            "value": "Accute Flaccid Paral"
        },
        {
            "property": "SHORT_NAME",
            "locale": "fr",
            "value": "Accute French"
        },
        {
            "property": "NAME",
            "locale": "fr",
            "value": "Accute French"
        },
        {
            "property": "NAME",
            "locale": "en_FK",
            "value": "aa"
        },
        {
            "property": "DESCRIPTION",
            "locale": "en_FK",
            "value": "aa"
        }
    ]
}
```

请注意，即使您得到未过滤的结果，并且正在使用
适当的类型端点，即我们不允许的 `/api/dataElements` 
更新，因为这样做很容易犯错误并覆盖
其他可用的语言环境。

要读取和更新翻译，您可以使用每个对象资源的特殊翻译端点。这些可以通过适当的`/api/<object-type>/<object-id>/translations`端点上的_GET_或_PUT_来访问。

例如，对于标识符为`FTRrcoaog83`的数据元素，您可以使用`/api/dataElements/FTRrcoaog83/translations`来获取和更新翻译。可用的字段是带有选项 _NAME_、_SHORT_NAME_、_DESCRIPTION_、支持任何有效区域设置 ID 和翻译的属性`值`的`区域设置`的`属性`。

法语语言环境的NAME属性示例：

```json
{
    "property": "NAME",
    "locale": "fr",
    "value": "Paralysie Flasque Aiguë (Décès <5 ans)"
}
```

然后将此有效负载添加到翻译数组中，并发回
到适当的端点：

```json
{
    "translations": [
        {
            "property": "NAME",
            "locale": "fr",
            "value": "Paralysie Flasque Aiguë (Décès <5 ans)"
        }
    ]
}
```

对于 ID 为 _FTRrcoaog83_ 的数据元素，您可以将其 _PUT_ 到 `/api/dataElements/FTRrcoaog83/translations`。确保发送特定对象的所有翻译，而不仅仅是单个区域设置（如果不是，您可能会覆盖其他区域设置的现有区域设置）。

### Web API版本 { #webapi_api_versions }

Web API的版本从DHIS 2.25开始。 API版本
遵循DHIS2主版本号。例如，API
DHIS 2.33的版本是`33`。

您可以通过包含版本号来访问特定的 API 版本
在`/api` 组件之后，作为这样的例子：

    / api / 33 / dataElements

如果省略 URL 的 version 部分，系统将使用当前的
API 版本。例如，对于 DHIS 2.25，在省略 API 部分时，
系统将使用 API 版本 25。在开发 API 客户端时，它是
建议使用显式 API 版本（而不是省略 API
版本），因为这将保护客户端免受不可预见的 API 更改。

将支持最后三个 API 版本。例如，DHIS
2.27 版本将支持 API 版本 27、26 和 25。

请注意，元数据模型没有版本控制，您可能
体验变化，例如在对象之间的关联中。这些变化
将记录在 DHIS2 主要版本发行说明中。

## 元数据对象过滤器 { #webapi_metadata_object_filter }

要过滤元数据，可以将多种过滤操作应用于返回的元数据列表。过滤器本身的格式很简单，遵循 _property:operator:value_ 模式，其中 _property_ 是要过滤的元数据的属性，_operator_ 是要执行的比较运算符，_value_ 是要检查的值反对（并非所有运算符都需要值）。请参阅 _schema_ 部分以了解哪些属性可用。递归过滤，即。还支持对关联对象或对象集合进行过滤。

 <table>
 <caption> 可用运算符 </caption>
 <thead>
 <tr class="header">
 <th> 操作员 </th>
 <th> 类型 </th>
 <th> 需要值 </th>
 <th> 说明 </th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td> eq </td>
 <td> 字符串 |布尔值 |整数 |浮动|枚举 |集合（检查大小）|日期 </td>
 <td> 真 </td>
 <td> 相等 </td>
 </tr>
 <tr class="even">
 <td> !eq </td>
 <td> 字符串 |布尔值 |整数 |浮动|枚举 |集合（检查大小）|日期 </td>
 <td> 真 </td>
 <td> 不等式 </td>
 </tr>
 <tr class="odd">
 <td> ne </td>
 <td> 字符串 |布尔值 |整数 |浮动|枚举 |集合（检查大小）|日期 </td>
 <td> 真 </td>
 <td> 不等式 </td>
 </tr>
 <tr class="even">
 <td> 像 </td>
 <td> 字符串 </td>
 <td> 真 </td>
 <td> 区分大小写的字符串，匹配任何地方 </td>
 </tr>
 <tr class="odd">
 <td> !like </td>
 <td> 字符串 </td>
 <td> 真 </td>
 <td> 区分大小写的字符串，不匹配任何地方 </td>
 </tr>
 <tr class="even">
 <td> \$like </td>
 <td> 字符串 </td>
 <td> 真 </td>
 <td> 区分大小写的字符串，匹配开始 </td>
 </tr>
 <tr class="odd">
 <td> !\$like </td>
 <td> 字符串 </td>
 <td> 真 </td>
 <td> 区分大小写的字符串，不匹配开始 </td>
 </tr>
 <tr class="even">
 <td> 喜欢\$ </td>
 <td> 字符串 </td>
 <td> 真 </td>
 <td> 区分大小写的字符串，匹配结束 </td>
 </tr>
 <tr class="odd">
 <td> !like\$ </td>
 <td> 字符串 </td>
 <td> 真 </td>
 <td> 区分大小写的字符串，不匹配结束 </td>
 </tr>
 <tr class="even">
 <td> 喜欢 </td>
 <td> 字符串 </td>
 <td> 真 </td>
 <td> 不区分大小写的字符串，匹配任何地方 </td>
 </tr>
 <tr class="odd">
 <td> !ilike </td>
 <td> 字符串 </td>
 <td> 真 </td>
 <td> 不区分大小写的字符串，不匹配任何地方 </td>
 </tr>
 <tr class="even">
 <td> \$ilike </td>
 <td> 字符串 </td>
 <td> 真 </td>
 <td> 不区分大小写的字符串，匹配开始 </td>
 </tr>
 <tr class="odd">
 <td> !\$ilike </td>
 <td> 字符串 </td>
 <td> 真 </td>
 <td> 不区分大小写的字符串，不匹配开始 </td>
 </tr>
 <tr class="even">
 <td> ilike\$ </td>
 <td> 字符串 </td>
 <td> 真 </td>
 <td> 不区分大小写的字符串，匹配结束 </td>
 </tr>
 <tr class="odd">
 <td> !ilike\$ </td>
 <td> 字符串 </td>
 <td> 真 </td>
 <td> 不区分大小写的字符串，不匹配结束 </td>
 </tr>
 <tr class="even">
 <td> gt </td>
 <td> 字符串 |布尔值 |整数 |浮动|集合（检查大小）|日期 </td>
 <td> 真 </td>
 <td> 大于 </td>
 </tr>
 <tr class="odd">
 <td> ge </td>
 <td> 字符串 |布尔值 |整数 |浮动|集合（检查大小）|日期 </td>
 <td> 真 </td>
 <td> 大于或等于 </td>
 </tr>
 <tr class="even">
 <td> lt </td>
 <td> 字符串 |布尔值 |整数 |浮动|集合（检查大小）|日期 </td>
 <td> 真 </td>
 <td> 小于</td>
 </tr>
 <tr class="odd">
 <td> le </td>
 <td> 字符串 |布尔值 |整数 |浮动|集合（检查大小）|日期 </td>
 <td> 真 </td>
 <td> 小于或等于 </td>
 </tr>
 <tr class="even">
 <td> 空 </td>
 <td> 全部 </td>
 <td> 假 </td>
 <td> 属性为空 </td>
 </tr>
 <tr class="odd">
 <td> !null </td>
 <td> 全部 </td>
 <td> 假 </td>
 <td> 属性不为空 </td>
 </tr>
 <tr class="even">
 <td> 空 </td>
 <td> 集合 </td>
 <td> 假 </td>
 <td> 集合为空 </td>
 </tr>
 <tr class="odd">
 <td> 代币 </td>
 <td> 字符串 </td>
 <td> 真 </td>
 <td> 匹配搜索属性中的多个标记 </td>
 </tr>
 <tr class="even">
 <td> !token </td>
 <td> 字符串 </td>
 <td> 真 </td>
 <td> 与搜索属性中的多个标记不匹配 </td>
 </tr>
 <tr class="odd">
 <td> 在 </td>
 <td> 字符串 |布尔值 |整数 |浮动|日期 </td>
 <td> 真 </td>
 <td> 查找匹配 1 个或多个值的对象 </td>
 </tr>
 <tr class="even">
 <td> !in </td>
 <td> 字符串 |布尔值 |整数 |浮动|日期 </td>
 <td> 真 </td>
 <td> 查找与 1 个或多个值不匹配的对象 </td>
 </tr>
 </tbody>
 </table>

运算符将用作逻辑 _and_ 查询，如果您需要 _or_ 查询，您可以查看我们的 _in_ 过滤器（另请参阅下面的部分）。过滤机制允许递归。请参阅下面的一些示例。

获取具有 id 属性 ID1 和聚合运算符“sum”的数据元素：

    /api/dataElements?filter=id:eq:ID1&filter=aggregationOperator:eq:sum

获取具有ID为ID1的dataSet的所有数据元素：

    /api/dataElements?filter=dataSetElements.dataSet.id:eq:ID1

使用聚合运算符“sum”和值类型获取所有数据元素
“内部”：

    /api/dataElements.json?filter=aggregationOperator:eq:sum&filter=type:eq:int

您可以在集合中进行过滤，例如获取数据元素
是“ANC”数据元素组的成员，您可以使用以下内容
使用关联数据元素组的 id 属性查询：

    /api/dataElements.json?filter=dataElementGroups.id:eq:qfxEYY9xAl6

由于默认情况下所有运算符都是 _and_，因此您无法找到与多个 id 匹配的数据元素，为此，您可以使用 _in_ 运算符。

    /api/dataElements.json?filter=id:in:[fbfJHSPpUQD,cYeuwXTCPkU]

### 逻辑运算符 { #webapi_metadata_logical_operator }

如前一节所述，应用于过滤器的默认逻辑运算符是 _AND_，这意味着所有对象过滤器都必须匹配。然而，在某些情况下，您希望在多个过滤器之一（可能是 id 和代码字段）上进行匹配，在这些情况下，可以使用 _rootJunction_ 参数将根逻辑运算符从 _AND_ 切换到 _OR_。

示例：正常过滤，其中 id 和 code 必须匹配才能具有
结果返回

    /api/dataElements.json?filter=id:in:[id1,id2]&filter=code:eq:code1

示例：过滤逻辑运算符已切换为 OR 的位置
现在只有一个过滤器必须匹配才能产生结果
    回

    /api/dataElements.json?filter=id:in:[id1,id2]&filter=code:eq:code1&rootJunction=OR

### 可识别的令牌过滤器 { #identifiable-token-filter }

除了上面提到的基于特定属性的过滤之外，我们还对一组属性进行基于 _token_ 的 _AND_ 过滤：id、代码和名称（如果可用，还有短名称）。这些属性通常被称为_可识别_。这个想法是过滤 ID、名称、代码或短名称包含某些内容的元数据。

示例：过滤以下任意项中包含 _2nd_ 的所有数据元素：id、name、code、shortName

    /api/dataElements.json?filter=identific:token:2nd

也可以指定多个过滤值。

示例：获取在任何 _identabilible_ 属性中找到 _ANC Visit_ 的所有数据元素。系统返回在可识别属性中的任何位置找到两个令牌（ANC 和访问）的所有数据元素。

    /api/dataElements.json?filter=identifiable:token:ANC访问

还可以将可识别过滤器与基于属性的过滤器结合起来，并期望应用 _rootJunction_ 。

    /api/dataElements.json?filter=identifiable:token:ANC visit＆filter = displayName：ilike：tt1

    /api/dataElements.json?filter=identifiable:token:ANC访问
      ＆filter = displayName：ilike：tt1＆rootJunction = OR

## 元数据字段过滤器 { #webapi_metadata_field_filter }

在许多情况下，元数据的默认视图可能过于冗长。客户端可能只需要每个对象中的几个字段，并希望从响应中删除不必要的字段。要了解每个对象有哪些字段可用，请参阅 _schema_ 部分。

包含/排除的格式允许无限递归。过滤
在“根”级别，您可以只使用字段的名称，
即`?fields=id,name`它只会显示`id`和
每个对象的`name` 字段。对于集合或
具有自身属性的复杂对象，您可以使用格式
`?fields=id,name,dataSets[id,name]` 将返回的 `id`、`name`
根，以及该对象上每个数据集的`id`和`name`。
否定可以用感叹号来完成，我们有一组
字段选择的预设。支持 XML 和 JSON。

**示例**：在指标资源上获取`id`和`name`：

    / api / indicators？fields = id，名称

**示例**：从dataElements中获取`id`和`name`，以及`id`和`name`。
从dataElements上的dataSets中：

    / api / dataElements？fields = id，name，dataSets [id，name]

要从输出中排除字段，可以使用感叹号`!`。
操作符。这是在查询中的任何地方都允许的，而根本不会
包括该属性，因为它可能已经插入了某些
预设。

一些预设（选定的字段组）可用并且可以应用
使用`:` 运算符。

 <table>
 <caption>属性操作符  </caption>
 <colgroup>
 <col style="width: 25%" />
 <col style="width: 74%" />
 </colgroup>
 <thead>
 <tr class="header">
 <th> 操作符 </th>
 <th> 说明 </th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td> &lt;field-name&gt; </td>
 <td> 包含带有名称的属性（如果存在）。 </td>
 </tr>
 <tr class="even">
 <td> &lt;object&gt;[&lt;field-name&gt;, ...] </td>
 <td> 在集合中包含一个字段（将应用于该集合中的每个对象），或仅包含在单个对象上。 </td>
 </tr>
 <tr class="odd">
 <td> !&lt;field-name&gt;, &lt;object&gt;[!&lt;field-name&gt;</td>
 <td> 不包括此字段名称，它也适用于对象/集合。当您使用预设来包含字段时很有用。 </td>
 </tr>
 <tr class="even">
 <td> *, &lt;object&gt;[*] </td>
 <td> 包括某个对象上的所有字段，如果应用于一个集合，它将包括该集合上所有对象的所有字段。 </td>
 </tr>
 <tr class="odd">
 <td> :&lt;preset&gt; </td>
 <td> 选择多个字段的别名。目前有三种预设可用，请参阅下表了解说明。 </td>
 </tr>
 </tbody>
 </table>

 <table>
 <caption>字段预设</caption>
 <colgroup>
 <col style="width: 25%" />
 <col style="width: 74%" />
 </colgroup>
 <thead>
 <tr class="header">
 <th>预设</th>
 <th>说明</th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td>全部</td>
 <td>对象的所有字段</td>
 </tr>
 <tr class="even">
 <td> * </td>
 <td>所有</td>的别名
 </tr>
 <tr class="odd">
 <td>可识别</td>
 <td>包括ID，名称，代码，创建的和lastUpdated字段</td>
 </tr>
 <tr class="even">
 <td>可命名</td>
 <td>包括id，名称，shortName，代码，描述，创建的和lastUpdated字段</td>
 </tr>
 <tr class="odd">
 <td>持续了</td>
 <td>返回对象上的所有持久属性，如果对象是关系的所有者，则不考虑。 </td>
 </tr>
 <tr class="even">
 <td>所有者</td>
 <td>返回对象的所有持久属性，其中该对象是所有属性的所有者，此有效负载可用于通过API更新。 </td>
 </tr>
 </tbody>
 </table>

**示例**：包括dataSet中的所有字段（organizationunits除外）：

    / api / dataSets？fields =：all，！organizationUnits

**示例**：仅包含ID，名称和数据集中的组织单位集合，但不包含组织单位中的ID：

    / api / dataSets / BfMAe6Itzgt？fields = id，name，organisationUnits [：all，！id]

**示例**：包括所有指标的可命名属性：

    /api/indicators.json?fields=:nameable

### 现场变压器 { #webapi_field_transformers }

在 DHIS2.17 中我们引入了场变压器，其想法是允许
进一步定制服务器端的属性。

    /api/dataElements/ID?fields=id~rename(i),name~rename(n)

这会将 _id_ 属性重命名为 _i_，将 _name_ 属性重命名为 _n_。

可以通过重复变压器语法来使用多个变压器：

    /api/dataElementGroups.json?fields=id,displayName,dataElements~isNotEmpty~rename(haveDataElements）

 <table>
 <caption> 可用变压器 </caption>
 <colgroup>
 <col style="width: 33%" />
 <col style="width: 21%" />
 <col style="width: 44%" />
 </colgroup>
 <thead>
 <tr class="header">
 <th> 名称 </th>
 <th> 参数 </th>
 <th> 说明 </th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td> 尺寸 </td>
 <td> </td>
 <td> 给出字符串的大小（长度）和集合 </td>
 </tr>
 <tr class="even">
 <td> isEmpty </td>
 <td> </td>
 <td> 字符串或集合是否为空 </td>
 </tr>
 <tr class="odd">
 <td> isNotEmpty </td>
 <td> </td>
 <td> 字符串或集合是否为空 </td>
 </tr>
 <tr class="even">
 <td> 重命名 </td>
 <td> Arg1：名称 </td>
 <td> 重命名属性名称 </td>
 </tr>
 <tr class="odd">
 <td> 分页 </td>
 <td> Arg1：页面，Arg2：页面大小 </td>
 <td> Pages 一个集合，默认 pageSize 为 50。</td>
 </tr>
 <tr class="even">
 <td> 采摘 </td>
 <td> 可选参数 1：字段名称 </td>
 <td> 将对象数组转换为该对象选定字段的数组。默认情况下，使用集合返回的第一个字段（通常是 ID）。 </td>
 </tr>
 </tbody>
 </table>

#### 例子 { #webapi_field_transformers_examples }

变压器用法示例。

```
/api/dataElements?fields=dataSets~size

/api/dataElements?fields=dataSets~isEmpty

/api/dataElements?fields=dataSets~isNotEmpty

/api/dataElements/ID?fields=id~rename(i),name~rename(n)

/api/dataElementGroups?fields=id,displayName,dataElements~paging(1;20)

# Include array with IDs of organisation units:
/api/categoryOptions.json?fields=id,organisationUnits~pluck

# Include array with names of organisation units (collection only returns field name):
/api/categoryOptions.json?fields=id,organisationUnits~pluck[name]
```

## 元数据创建，读取，更新，删除，验证 { #webapi_metadata_crud }

DHIS2 中的所有元数据实体都有自己的 API 端点，支持 _CRUD_ 操作（创建、读取、更新和删除）。端点 URL 遵循以下格式：

    / api / <entityName>

_entityName_ 使用驼峰命名法。例如，端点
对于_数据元素_是：

    / api / dataElements

### 创建/更新参数 { #webapi_metadata_create_update }

以下请求查询参数可用于所有元数据端点。

 <table>
 <caption>可用的查询过滤器</caption>
 <thead>
 <tr class="header">
 <th>参数</th>
 <th>类型</th>
 <th>必需</th>
 <th>选项（默认为默认）</th>
 <th>说明</th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td> preheatCache </td>
 <td>布尔</td>
 <td>否</td>
 <td>是|假</td>
 <td>开启/关闭缓存地图预热。默认情况下处于启用状态，关闭此选项将使导入程序的初始加载时间短得多（但会使导入本身变慢）。这主要用于以下情况：您要导入的XML / JSON文件很小，并且不想等待缓存映射表预热。 </td>
 </tr>
 <tr class="even">
 <td>策略</td>
 <td>枚举</td>
 <td>否</td>
 <td> CREATE_AND_UPDATE |创建|更新|删除</td>
 <td>使用的导入策略，请参阅下面的更多信息。 </td>
 </tr>
 <tr class="odd">
 <td> mergeMode </td>
 <td>枚举</td>
 <td>否</td>
 替换，合并<td> </td>
 <td>执行更新时合并对象的策略。 REPLACE只会使用提供的新值覆盖属性，MERGE仅在属性不为null时设置属性（仅在提供了属性的情况下）。 </td>
 </tr>
 </tbody>
 </table>

### 创建和更新对象 { #webapi_creating_updating_objects }

为了创建新对象，您需要知道端点、类型格式，并确保您拥有所需的权限。例如，我们将创建并更新一个_constant_。为了弄清楚格式，我们可以使用新的 _schema_ 端点来获取格式描述。因此，我们将从获取该信息开始：

    http：// <server> /api/schemas/constant.json

从输出中可以看到create所需的权限是`F_CONSTANT_ADD`，重要的属性是：_name_和_value_。由此，我们可以创建一个 JSON 有效负载并将其保存为名为constant.json 的文件：

```json
{
    "name": "PI",
    "value": "3.14159265359"
}
```

与XML有效内容相同的内容：

```xml
<constant name="PI" xmlns="http://dhis2.org/schema/dxf/2.0">
  <value>3.14159265359</value>
</constant>
```

我们现在准备通过使用curl向*constants*端点发送带有JSON负载的POST请求来创建新的_constant_：

```bash
curl -d @constant.json "http://server/api/constants" -X POST
  -H "Content-Type: application/json" -u user:password
```

将常量发布到演示中的具体示例
    服务器：

```bash
curl -d @constant.json "https://play.dhis2.org/api/constants" -X POST
  -H "Content-Type: application/json" -u admin:district
```

如果一切顺利，您应该看到类似以下的输出：

```json
{
    "status": "SUCCESS",
    "importCount": {
        "imported": 1,
        "updated": 0,
        "ignored": 0,
        "deleted": 0
    },
    "type": "Constant"
}
```

更新过程与更新完全相同，您对 JSON/XML 有效负载进行更改，找出常量的 _ID_，然后向端点发送包含 ID 的 PUT 请求：

```bash
curl -X PUT -d @pi.json -H "Content-Type: application/json"
  -u user:password "http://server/api/constants/ID"
```

### 删除物件 { #webapi_deleting_objects }

删除对象非常简单，您需要知道要删除的类型的_ID_和端点，让我们继续上一节的示例并使用_constant_。假设 id 是 _abc123_，那么您需要做的就是向端点 + id 发送 DELETE 请求：

```bash
curl -X DELETE -u user:password "http://server/api/constants/ID"
```

成功删除应返回HTTP状态204（无内容）。

### 在集合中添加和删除对象 { #webapi_adding_removing_objects_collections }

集合资源允许您修改集合
对象。

#### 添加或删除单个对象 { #webapi_collections_adding_removing_single_objects }

为了在对象集合中添加或删除对象，您
可以使用以下
    图案：

    / api / {collection-object} / {collection-object-id} / {collection-name} / {object-id}

应该使用POST方法添加，使用DELETE方法删除
一个东西。当对象之间存在多对多关系时，
您必须首先确定哪个对象拥有该关系。如果不是
清除这是哪个对象，尝试两种方式调用以查看哪个有效。

模式的组成部分是：

-   集合对象：拥有要修改的集合的对象类型。

-   集合对象 ID：拥有要修改的集合的对象的标识符。

-   集合名称：您要修改的集合的名称。

-   对象 id：要从集合中添加或删除的对象的标识符。

例如，为了删除标识符为 IDB 的数据元素
从具有标识符 IDA 的数据元素组中，您可以执行 DELETE
要求：

    删除/ api / dataElementGroups / IDA / dataElements / IDB

将带有标识符 IDB 的类别选项添加到带有
标识符 IDA 你可以做一个 POST
要求：

    POST / api / categories / IDA / categoryOptions / IDB

#### 添加或删除多个对象 { #webapi_collections_adding_removing_multiple_objects }

您可以在一个请求中从集合中添加或删除多个对象
具有这样的有效载荷：

```json
{
    "identifiableObjects": [
        {
            "id": "IDA"
        },
        {
            "id": "IDB"
        },
        {
            "id": "IDC"
        }
    ]
}
```

使用此有效负载，您可以添加，替换或删除项目：

_添加项目：_

    POST / api / categories / IDA / categoryOptions

_更换物品：_

    PUT /api/categories/IDA/categoryOptions

_删除项目：_

    删除/ api / categories / IDA / categoryOptions

#### 在单个请求中添加和删除对象 { #webapi_collections_adding_removing_objects_single_request }

您可以在单个 POST 中从集合中添加和删除对象
请求到以下 URL：

    POST / api / categories / IDA / categoryOptions

有效负载格式为：

```json
{
    "additions": [
        {
            "id": "IDA"
        },
        {
            "id": "IDB"
        },
        {
            "id": "IDC"
        }
    ],
    "deletions": [
        {
            "id": "IDD"
        },
        {
            "id": "IDE"
        },
        {
            "id": "IDF"
        }
    ]
}
```

### 验证有效载荷 { #webapi_validating_payloads }

DHIS 2 支持元数据有效载荷的系统范围验证，这意味着
将检查 API 端点上的创建和更新操作
允许进行更改之前的有效负载。找出哪些验证
为特定端点准备好了，看看`/api/schemas`
端点，即要找出数据元素具有哪些约束，您
会去`/api/schemas/dataElement`。

您还可以手动验证您的有效负载，方法是将其发送到适当的
架构端点。如果您想从创建中验证常量
之前的部分，您可以这样发送：

    POST / api / schemas / constant

一个简单的（非验证）示例为：

```bash
curl -X POST -d "{\"name\": \"some name\"}" -H "Content-Type: application/json"
  -u admin:district "https://play.dhis2.org/dev/api/schemas/dataElement"
```

这将产生结果：

```json
[
    {
        "message": "Required property missing.",
        "property": "type"
    },
    {
        "property": "aggregationOperator",
        "message": "Required property missing."
    },
    {
        "property": "domainType",
        "message": "Required property missing."
    },
    {
        "property": "shortName",
        "message": "Required property missing."
    }
]
```

### 部分更新 { #webapi_partial_updates }

对于您不想或不需要更新所有属性的情况
对象（这意味着下载一个潜在的巨大有效负载，更改一个
属性，然后再次上传）我们现在支持部分更新，对于一个或
更多的属性。

进行部分更新的有效负载与您执行时相同
做一个完整的更新，唯一的区别是你只包括
您要更新的属性，即：

```json
{
    "name": "Updated Name",
    "zeroIsSignificant": true
}
```

curl命令示例如下所示：

```bash
curl -X PATCH -d @file.json -H "Content-Type: application/json"
  -u admin:district "https://play.dhis2.org/dev/api/dataElements/fbfJHSPpUQD"
```

## 元数据导出 { #webapi_metadata_export }

本节介绍了可在以下位置获得的元数据 API
`/api/元数据`。支持 XML 和 JSON 资源表示。

    / api /元数据

最常用的参数在下面的“导出参数”中描述
桌子。您还可以使用以下方法将其应用于所有可用类型
`type:fields=<filter>` 和 `type:filter=<filter>`。你也可以
通过设置 `type=true|false` 启用/禁用某些类型的导出。

 <table>
 <caption> 导出参数 </caption>
 <colgroup>
 <col style="width: 17%" />
 <col style="width: 21%" />
 <col style="width: 61%" />
 </colgroup>
 <thead>
 <tr class="header">
 <th> 名称 </th>
 <th> 选项 </th>
 <th> 说明 </th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td> 字段 </td>
 <td> 与元数据字段过滤器 </td> 相同
 <td> 适用于所有类型的默认字段过滤器，默认为`:owner`。 </td>
 </tr>
 <tr class="even">
 <td> 过滤器 </td>
 <td> 与元数据对象过滤器 </td> 相同
 <td> 适用于所有类型的默认对象过滤器，默认为`无`。 </td>
 </tr>
 <tr class="odd">
 <td> 订单 </td>
 <td> 与元数据顺序 </td> 相同
 <td> 适用于所有类型的默认顺序，如果可用，默认为`name`，否则为`created`。 </td>
 </tr>
 <tr class="even">
 <td> 翻译 </td>
 <td> 假/真 </td>
 <td> 启用翻译。请注意，默认情况下这是关闭的（在其他端点中，默认情况下是打开的）。 </td>
 </tr>
 <tr class="odd">
 <td> 区域设置 </td>
 <td> &lt;locale&gt; </td>
 <td> 从用户语言环境更改为您自己的自定义语言环境。 </td>
 </tr>
 <tr class="even">
 <td> 默认 </td>
 <td> 包括/排除 </td>
 <td> 自动生成的类别对象是否应包含在有效负载中。如果您在 2 个非同步实例之间移动元数据，将其设置为 EXCLUDE 以简化这些生成对象的处理可能是有意义的。 </td>
 </tr>
 <tr class="odd">
 <td> 跳过共享 </td>
 <td> 假/真 </td>
 <td> 启用此选项将从导出的对象中剥离共享属性。这包括用户<em> </em>，<em> publicAccess </em>，<em> userGroupAccesses </em>，<em> userAccesses </em>，和<em> externalAccess </em>。 </td>
 </tr>
 <tr class="odd">
 <td> 下载 </td>
 <td> 假/真 </td>
 <td> 启用此功能将添加 HTTP 标头 Content-Disposition，该标头指定数据应作为附件处理，并由 Web 浏览器作为下载提供。 </td>
 </tr>
 </tbody>
 </table>

### 元数据导出示例 { #webapi_metadata_export_examples }

导出所有元数据。小心，因为响应可能非常大，具体取决于
关于您的元数据配置：

    / api /元数据

导出由lastUpdated降序排列的所有元数据：

    / api / metadata？defaultOrder = lastUpdated：desc

导出仅包括指标和指标组的元数据：

    / api / metadata？indicators = true＆indicatorGroups = true

导出所有数据元素的id和displayName，按displayName排序：

    / api / metadata？dataElements：fields = id，name＆dataElements：order = displayName：desc

导出名称以“ ANC”开头的数据元素和指示符：

    / api / metadata？filter = name：^ like：ANC＆dataElements = true＆indicators = true

### 具有依赖项的元数据导出 { #webapi_dataset_program_export_dependencies }

当您想为数据集、程序或类别组合交换元数据时
从一个 DHIS2 实例到另一个实例，有三个专用端点可用：

```
/api/dataSets/{id}/metadata.json

/api/programs/{id}/metadata.json

/api/categoryCombos/{id}/metadata.json

/api/dashboards/{id}/metadata.json
```

然后可以使用`/ api / metadata`导入这些导出。

这些端点还支持以下参数：

 <table>
 <caption> 导出参数 </caption>
 <colgroup>
 <col style="width: 17%" />
 <col style="width: 21%" />
 <col style="width: 61%" />
 </colgroup>
 <thead>
 <tr class="header">
 <th> 名称 </th>
 <th> 选项 </th>
 <th> 说明 </th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td> 跳过共享 </td>
 <td> 假/真 </td>
 <td> 启用此选项将从导出的对象中剥离共享属性。这包括用户<em> </em>，<em> publicAccess </em>，<em> userGroupAccesses </em>，<em> userAccesses </em>，和<em> externalAccess </em>。 </td>
 </tr>
 <tr class="odd">
 <td> 下载 </td>
 <td> 假/真 </td>
 <td> 启用此功能将添加 HTTP 标头 Content-Disposition，该标头指定数据应作为附件处理，并由 Web 浏览器作为下载提供。 </td>
 </tr>
 </tbody>
 </table>

## 元数据导入 { #webapi_metadata_import }

本节介绍元数据导入 API。支持 XML 和 JSON 资源表示。可以使用 _POST_ 请求导入元数据。

    / api /元数据

导入器允许您导入元数据有效负载，其中可能包括许多
不同的实体和每个实体的任意数量的对象。元数据导出
元数据导出API生成的可以直接导入。

元数据导入端点支持多种参数，分别是
下面列出。

<table>
<caption>Import Parameter</caption>
<colgroup>
<col style="width: 17%" />
<col style="width: 21%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Options (first is default)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>importMode</td>
<td>COMMIT, VALIDATE</td>
<td>Sets overall import mode, decides whether or not to only `VALIDATE` or also `COMMIT` the metadata, this has similar functionality as our old dryRun flag.</td>
</tr>
<tr class="even">
<td>identifier</td>
<td>UID, CODE, AUTO</td>
<td>Sets the identifier scheme to use for reference matching. `AUTO` means try `UID` first, then `CODE`.</td>
</tr>
<tr class="odd">
<td>importReportMode</td>
<td>ERRORS, FULL, DEBUG</td>
<td>Sets the `ImportReport` mode, controls how much is reported back after the import is done. `ERRORS` only includes <em>ObjectReports</em> for object which has errors. `FULL` returns an <em>ObjectReport</em> for all objects imported, and `DEBUG` returns the same plus a name for the object (if available).</td>
</tr>
<tr class="even">
<td>preheatMode</td>
<td>REFERENCE, ALL, NONE</td>
<td>Sets the preheater mode, used to signal if preheating should be done for `ALL` (as it was before with <em>preheatCache=true</em>) or do a more intelligent scan of the objects to see what to preheat (now the default), setting this to `NONE` is not recommended.</td>
</tr>
<tr class="odd">
<td>importStrategy</td>
<td>CREATE_AND_UPDATE, CREATE, UPDATE, DELETE</td>
<td>Sets import strategy, `CREATE_AND_UPDATE` will try and match on identifier, if it doesn't exist, it will create the object.</td>
</tr>
<tr class="even">
<td>atomicMode</td>
<td>ALL, NONE</td>
<td>Sets atomic mode, in the old importer we always did a <em>best effort</em> import, which means that even if some references did not exist, we would still import (i.e. missing data elements on a data element group import). Default for new importer is to not allow this, and similar reject any validation errors. Setting the `NONE` mode emulated the old behavior.</td>
</tr>
<tr class="odd">
<td>mergeMode</td>
<td>REPLACE, MERGE</td>
<td>Sets the merge mode, when doing updates we have two ways of merging the old object with the new one, `MERGE` mode will only overwrite the old property if the new one is not-null, for `REPLACE` mode all properties are overwritten regardless of null or not.</td>
</tr>
<tr class="even">
<td>flushMode</td>
<td>AUTO, OBJECT</td>
<td>Sets the flush mode, which controls when to flush the internal cache. It is <em>strongly</em> recommended to keep this to `AUTO` (which is the default). Only use `OBJECT` for debugging purposes, where you are seeing hibernate exceptions and want to pinpoint the exact place where the stack happens (hibernate will only throw when flushing, so it can be hard to know which object had issues).</td>
</tr>
<tr class="odd">
<td>skipSharing</td>
<td>false, true</td>
<td>Skip sharing properties, does not merge sharing when doing updates, and does not add user group access when creating new objects.</td>
</tr>
<tr class="even">
<td>skipValidation</td>
<td>false, true</td>
<td>Skip validation for import. `NOT RECOMMENDED`.</td>
</tr>
<tr class="odd">
<td>async</td>
<td>false, true</td>
<td>Asynchronous import, returns immediately with a <em>Location</em> header pointing to the location of the <em>importReport</em>. The payload also contains a json object of the job created.</td>
</tr>
<tr class="even">
<td>inclusionStrategy</td>
<td>NON_NULL, ALWAYS, NON_EMPTY</td>
<td><em>NON_NULL</em> includes properties which are not null, <em>ALWAYS</em> include all properties, <em>NON_EMPTY</em> includes non empty properties (will not include strings of 0 length, collections of size 0, etc.)</td>
</tr>
<tr class="odd">
<td>userOverrideMode</td>
<td>NONE, CURRENT, SELECTED</td>
<td>Allows you to override the user property of every object you are importing, the options are NONE (do nothing), CURRENT (use import user), SELECTED (select a specific user using overrideUser=X)</td>
</tr>
<tr class="even">
<td>overrideUser</td>
<td>User ID</td>
<td>If userOverrideMode is SELECTED, use this parameter to select the user you want override with.</td>
</tr>
</tbody>
</table>

要导入的元数据负载的示例如下所示。注意如何
每个实体类型都有自己的属性和一个对象数组：

```json
{
    "dataElements": [
        {
            "name": "EPI - IPV 3 doses given",
            "shortName": "EPI - IPV 3 doses given",
            "aggregationType": "SUM",
            "domainType": "AGGREGATE",
            "valueType": "INTEGER_ZERO_OR_POSITIVE"
        },
        {
            "name": "EPI - IPV 4 doses given",
            "shortName": "EPI - IPV 4 doses given",
            "aggregationType": "SUM",
            "domainType": "AGGREGATE",
            "valueType": "INTEGER_ZERO_OR_POSITIVE"
        }
    ],
    "indicators": [
        {
            "name": "EPI - ADS stock used",
            "shortName": "ADS stock used",
            "numerator": "#{LTb8XeeqeqI}+#{Fs28ZQJET6V}-#{A3mHIZd2tPg}",
            "numeratorDescription": "ADS 0.05 ml used",
            "denominator": "1",
            "denominatorDescription": "1",
            "annualized": false,
            "indicatorType": {
                "id": "kHy61PbChXr"
            }
        }
    ]
}
```

将此有效负载发布到元数据端点时，响应将包含
有关导入过程中使用的参数的信息和每个摘要
实体类型，包括创建、更新、删除和
忽略：

```json
{
    "importParams": {
        "userOverrideMode": "NONE",
        "importMode": "COMMIT",
        "identifier": "UID",
        "preheatMode": "REFERENCE",
        "importStrategy": "CREATE_AND_UPDATE",
        "atomicMode": "ALL",
        "mergeMode": "REPLACE",
        "flushMode": "AUTO",
        "skipSharing": false,
        "skipTranslation": false,
        "skipValidation": false,
        "metadataSyncImport": false,
        "firstRowIsHeader": true,
        "username": "UNICEF_admin"
    },
    "status": "OK",
    "typeReports": [
        {
            "klass": "org.hisp.dhis.dataelement.DataElement",
            "stats": {
                "created": 2,
                "updated": 0,
                "deleted": 0,
                "ignored": 0,
                "total": 2
            }
        },
        {
            "klass": "org.hisp.dhis.indicator.Indicator",
            "stats": {
                "created": 1,
                "updated": 0,
                "deleted": 0,
                "ignored": 0,
                "total": 1
            }
        }
    ],
    "stats": {
        "created": 3,
        "updated": 0,
        "deleted": 0,
        "ignored": 0,
        "total": 3
    }
}
```

## 架构图 { #webapi_schema }

可用于内省所有可用 DXF 2 对象的资源
可以在`/api/schemas` 上找到。对于特定资源，您可以拥有
查看`/api/schemas/<type>`。

要获取XML中所有可用的模式：

    获取/api/schemas.xml

要获取JSON中所有可用的模式，请执行以下操作：

    获取/api/schemas.json

要获取特定类的JSON模式：

    获取 /api/schemas/dataElement.json

## 图示 { #webapi_icons }

DHIS2 包括一组可用于提供视觉效果的图标
元数据的上下文。这些图标可以通过图标访问
资源。

    获取/api/图标

此端点返回有关可用图标的信息列表。
每个条目都包含有关图标的信息，以及对图标的引用
实际图标。

```json
{
    "key": "mosquito_outline",
    "description": "Mosquito outline",
    "keywords": ["malaria", "mosquito", "dengue"],
    "href": "<dhis server>/api/icons/mosquito_outline/icon.svg"
}
```

关键字可用于过滤要返回的图标。传递一个列表
带有请求的关键字将只返回与所有匹配的图标
关键词：

    GET /api/icons?keywords=shape,小

可以在关键字资源中找到所有唯一关键字的列表：

    获取/api/图标/关键字

## 渲染类型 { #webapi_render_type }

某些元数据类型具有名为 _renderType_ 的属性。渲染类型属性是 _device_ 和 _renderingType_ 之间的映射。应用程序可以使用此信息作为有关如何在特定设备上呈现对象的提示。例如，移动设备可能希望以与台式计算机不同的方式呈现数据元素。

当前有两种不同的renderingTypes可用：

1.  值类型渲染

2.  程序阶段部分渲染

还提供2种设备类型：

1.  移动

2.  桌面

下表列出了可用的元数据和呈现类型。
值类型呈现具有基于元数据的附加约束
配置，这将显示在第二个表中。

 <table>
 <caption>元数据和渲染类型概述</caption>
 <colgroup>
 <col style="width: 50%" />
 <col style="width: 50%" />
 </colgroup>
 <thead>
 <tr class="header">
 <th>元数据类型</th>
 <th>可用的渲染类型</th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td>程序阶段段</td>
 <td> <ul>
 <li> <p>列表（默认）</p> </li>
 <li> <p>顺序</p> </li>
 矩阵<li> <p>矩阵</p> </li>
 </ul> </td>
 </tr>
 <tr class="even">
 <td>数据元素</td>
 <td> <ul>
 <li> <p>默认</p> </li>
 <li> <p>下拉菜单</p> </li>
 <li> <p> VERTICAL_RADIOBUTTONS </p> </li>
 <li> <p> HORIZONTAL_RADIOBUTTONS </p> </li>
 <li> <p> VERTICAL_CHECKBOXES </p> </li>
 <li> <p> HORIZONTAL_CHECKBOXES </p> </li>
 <li> <p> SHARED_HEADER_RADIOBUTTONS </p> </li>
 <li> <p> ICONS_AS_BUTTONS </p> </li>
 <li> <p>旋转器</p> </li>
 <li> <p> ICON </p> </li>
 <li> <p>切换</p> </li>
 <li> <p>值</p> </li>
 滑块<li> <p>滑块</p> </li>
 <li> <p> LINEAR_SCALE </p> </li>
 </ul> </td>
 </tr>
 </tbody>
 </table>

由于处理数据元素和跟踪实体的默认呈现
属性取决于对象的值类型，还有
一个 DEFAULT 类型告诉客户端它应该被正常处理。
程序阶段部分默认为“列表”。

<table>
<caption>RenderingTypes allowed based on value types</caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Value type</th>
<th>Is object an optionset?</th>
<th>RenderingTypes allowed</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>TRUE_ONLY</td>
<td>No</td>
<td>DEFAULT, VERTICAL_RADIOBUTTONS, HORIZONTAL_RADIOBUTTONS, VERTICAL_CHECKBOXES, HORIZONTAL_CHECKBOXES, TOGGLE</td>
</tr>
<tr class="even">
<td>BOOLEAN</td>
<td>No</td>
<td></td>
</tr>
<tr class="odd">
<td>-</td>
<td>Yes</td>
<td>DEFAULT, DROPDOWN, VERTICAL_RADIOBUTTONS, HORIZONTAL_RADIOBUTTONS, VERTICAL_CHECKBOXES, HORIZONTAL_CHECKBOXES, SHARED_HEADER_RADIOBUTTONS, ICONS_AS_BUTTONS, SPINNER, ICON</td>
</tr>
<tr class="even">
<td>INTEGER</td>
<td>No</td>
<td>DEFAULT, VALUE, SLIDER, LINEAR_SCALE, SPINNER</td>
</tr>
<tr class="odd">
<td>INTEGER_POSITIVE</td>
<td>No</td>
<td></td>
</tr>
<tr class="even">
<td>INTEGER_NEGATIVE</td>
<td>No</td>
<td></td>
</tr>
<tr class="odd">
<td>INTEGER_ZERO_OR_POSITIVE</td>
<td>No</td>
<td></td>
</tr>
<tr class="even">
<td>NUMBER</td>
<td>No</td>
<td></td>
</tr>
<tr class="odd">
<td>UNIT_INTERVAL</td>
<td>No</td>
<td></td>
</tr>
<tr class="even">
<td>PERCENTAGE</td>
<td>No</td>
<td></td>
</tr>
</tbody>
</table>

上表的完整参考也可以使用
以下端点：

    GET /api/staticConfiguration/renderingOptions

值类型渲染也有一些额外的属性，可以
设置，通常在渲染某些特定类型时需要：

 <table>
 <caption> renderType对象属性</caption>
 <colgroup>
 <col style="width: 33%" />
 <col style="width: 33%" />
 <col style="width: 33%" />
 </colgroup>
 <thead>
 <tr class="header">
 属性<th> </th>
 <th>说明</th>
 <th>类型</th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td>类型</td>
 <td>对象的RenderingType，如第一个表所示。值类型和程序阶段部分的此属性相同，但是是程序阶段部分可用的唯一属性。 </td>
 <td>枚举（请参见元数据和呈现类型表中的列表）</td>
 </tr>
 <tr class="even">
 min </td> <td>
 <td>仅用于值类型呈现。表示此字段可以具有的最小值。 </td>
 <td>整数</td>
 </tr>
 <tr class="odd">
 <td> max </td>
 <td>仅用于值类型呈现。表示此字段可以具有的最大值。 </td>
 <td>整数</td>
 </tr>
 <tr class="even">
 <td>步骤</td>
 <td>仅用于值类型呈现。表示值应增加的步长，例如对于SLIDER和LINEAR_SCALE </td>
 <td>整数</td>
 </tr>
 <tr class="odd">
 <td>小数点</td>
 <td>仅用于值类型呈现。表示该值应使用的小数点位数。 </td>
 <td>整数</td>
 </tr>
 </tbody>
 </table>

_renderingType_ 可以在创建或更新第一个表中列出的元数据时设置。程序阶段部分的渲染类型的示例有效负载如下所示：

```json
{
    "renderingType": {
        "type": "MATRIX"
    }
}
```

对于数据元素和跟踪的实体属性：

```json
{
    "renderingType": {
        "type": "SLIDER",
        "min": 0,
        "max": 1000,
        "step": 50,
        "decimalPoints": 0
    }
}
```

## 对象样式 { #webapi_object_style }

大多数元数据都有一个属性名称“样式”。可以使用此属性
由客户以某种方式表示对象。属性
目前支持的样式如下：

 <table>
 <caption>样式属性</caption>
 <colgroup>
 <col style="width: 33%" />
 <col style="width: 33%" />
 <col style="width: 33%" />
 </colgroup>
 <thead>
 <tr class="header">
 属性<th> </th>
 <th>说明</th>
 <th>类型</th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td>颜色</td>
 <td>一种颜色，以十六进制表示。 </td>
 <td>字符串（＃000000）</td>
 </tr>
 <tr class="even">
 <td>图标</td>
 <td>一个图标，由图标名称表示。 </td>
 <td>字符串</td>
 </tr>
 </tbody>
 </table>

目前，没有官方列表或对图标库的支持，所以
这目前由客户提供。下面的列表显示
所有支持样式的对象：

-   数据元素

-   数据元素类别选项

-   资料集

-   指示符

-   选项

-   程序

-   计划指标

-   计划科

-   程序阶段

-   程序阶段部分

-   关系（跟踪器）

-   跟踪实体属性

-   追踪实体类型

在创建或更新任何这些对象时，您可以包括
以下有效负载更改样式：

```json
{
    "style": {
        "color": "#ffffff",
        "icon": "my-beautiful-icon"
    }
}
```

## 指标 { #webapi_indicators }

本节介绍指标和指标表达式。

### 综合指标 { #webapi_aggregate_indicators }

要检索指标，您可以向指标发出 GET 请求
像这样的资源：

    / api /指标

指标表示可以计算和呈现的表达式
因此。指标表达式分为分子和
分母。分子和分母是数学的
可以包含对数据元素、其他指标、常量和
组织单位组。变量将替换为数据
使用时的值，例如在报告中。允许的变量
表达式在下表中描述。

<table>
<caption>Indicator variables</caption>
<colgroup>
<col style="width: 39%" />
<col style="width: 22%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="header">
<th>Variable</th>
<th>Object</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>#{&lt;dataelement-id&gt;.&lt;categoryoptcombo-id&gt;.&lt;attributeoptcombo-id&gt;}</td>
<td>Data element operand</td>
<td>Refers to a combination of an aggregate data element and a category option combination. Both category and attribute option combo ids are optional, and a wildcard &quot;*&quot; symbol can be used to indicate any value.</td>
</tr>
<tr class="even">
<td>#{&lt;dataelement-id&gt;.&lt;categoryoptiongroup-id&gt;.&lt;attributeoptcombo-id&gt;}</td>
<td>Category Option Group</td>
<td>Refers to an aggregate data element and a category option group, containing multiple category option combinations.</td>
</tr>
<tr class="odd">
<td>#{&lt;dataelement-id&gt;}</td>
<td>Aggregate data element</td>
<td>Refers to the total value of an aggregate data element across all category option combinations.</td>
</tr>
<tr class="even">
<td>D{&lt;program-id&gt;.&lt;dataelement-id&gt;}</td>
<td>Program data element</td>
<td>Refers to the value of a tracker data element within a program.</td>
</tr>
<tr class="odd">
<td>A{&lt;program-id&gt;.&lt;attribute-id&gt;}</td>
<td>Program tracked entity attribute</td>
<td>Refers to the value of a tracked entity attribute within a program.</td>
</tr>
<tr class="even">
<td>I{&lt;program-indicator-id&gt;}</td>
<td>Program indicator</td>
<td>Refers to the value of a program indicator.</td>
</tr>
<tr class="odd">
<td>R{&lt;dataset-id&gt;.&lt;metric&gt;}</td>
<td>Reporting rate</td>
<td>Refers to a reporting rate metric. The metric can be REPORTING_RATE, REPORTING_RATE_ON_TIME, ACTUAL_REPORTS, ACTUAL_REPORTS_ON_TIME, EXPECTED_REPORTS.</td>
</tr>
<tr class="even">
<td>C{&lt;constant-id&gt;}</td>
<td>Constant</td>
<td>Refers to a constant value.</td>
</tr>
<tr class="odd">
<td>N{&lt;indicator-id&gt;}</td>
<td>Indicator</td>
<td>Refers to an existing Indicator.</td>
</tr>
<tr class="even">
<td>OUG{&lt;orgunitgroup-id&gt;}</td>
<td>Organisation unit group</td>
<td>Refers to the count of organisation units within an organisation unit group.</td>
</tr>
</tbody>
</table>

语法看起来像
    这：

＃

相应的示例如下所示：

＃

请注意，对于数据元素变量，类别选项组合
标识符可以省略。该变量将代表总数
对于数据元素，例如在所有类别选项组合中。例子：

＃

数据元素操作数可以包括任何类别选项组合和
属性选项组合，并使用通配符表示任何
    价值：

＃

使用程序数据元素和程序的示例
    属性：

    （D {eBAyeGv0exc.vV9UWAZohSf} * A {IpHINAT79UW.cejWyOfXge6}）/ D {eBAyeGv0exc.GieVkTxp4HH}

结合了计划指标和汇总指标的示例：

    I {EMOt6Fwhs1n} * 1000 /＃{WUg3MYWQ7pt}

使用报告率的示例如下所示：

    R {BfMAe6Itzgt.REPORTING_RATE} *＃{P3jJH5Tu5VC.S34ULMcHMca}

使用实际数据集报告的另一个示例：

    R {BfMAe6Itzgt.ACTUAL_REPORTS} / R {BfMAe6Itzgt.EXPECTED_REPORTS}

使用现有指标的示例如下所示：

    N {Rigf2d2Zbjp} *＃{P3jJH5Tu5VC.S34ULMcHMca}

表达式可以是任何类型的有效数学表达式，作为
例子：

    （2 *＃{P3jJH5Tu5VC.S34ULMcHMca}）/（＃{FQ2o8UBlcrS.S34ULMcHMca}-200）* 25

### 计划指标 { #webapi_program_indicators }

要检索程序指标，您可以向程序发出 GET 请求
像这样的指标资源：

    / api / programIndicators

程序指示器可以包含在程序中收集的信息。
指标有一个表达式，可以包含对数据的引用
元素、属性、常量和程序变量。变量
下表中描述了允许在表达式中使用。

 <table>
 <caption> 程序指示变量 </caption>
 <colgroup>
 <col style="width: 31%" />
 <col style="width: 68%" />
 </colgroup>
 <thead>
 <tr class="header">
 <th> 变量 </th>
 <th> 说明 </th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td> #{&lt;programstage-id&gt;.&lt;dataelement-id&gt;} </td>
 <td> 指程序阶段和数据元素 id 的组合。 </td>
 </tr>
 <tr class="even">
 <td> A{&lt;attribute-id&gt;} </td>
 <td> 指的是被跟踪的实体属性。 </td>
 </tr>
 <tr class="odd">
 <td> V{&lt;variable-id&gt;} </td>
 <td> 指程序变量。 </td>
 </tr>
 <tr class="even">
 <td> C{&lt;constant-id&gt;} </td>
 <td> 指一个常数。 </td>
 </tr>
 </tbody>
 </table>

语法看起来像
    这：

＃

相应的示例如下所示：

＃

### 表达方式 { #webapi_expressions }

表达式是数学公式，可以包含对
数据元素、常量和组织单元组。验证和
获取表达式的文本描述，您可以发出 GET 请求
到表达式资源：

    / api / expressions / description？expression = <expression-string>

响应遵循标准 JSON Web 消息格式。 _status_ 属性指示验证的结果，如果成功则为“OK”，如果失败则为“ERROR”。如果成功，_message_ 属性将为“Valid”；如果失败，则提供验证失败原因的文本描述。 _description_ 提供表达式的文本描述。

```json
{
    "httpStatus": "OK",
    "httpStatusCode": 200,
    "status": "OK",
    "message": "Valid",
    "description": "Acute Flaccid Paralysis"
}
```

## 组织单位 { #webapi_organisation_units }

_organizationUnits_ 资源与 DHIS2 中的其他元数据资源一样遵循标准约定。该资源支持一些额外的查询参数。

### 获取组织单位列表 { #webapi_list_of_organisation_units }

要获取组织单位的列表，可以使用以下资源。

    / api / 33 / organisationUnits

 <table>
 <caption>组织单位查询参数</caption>
 <colgroup>
 <col style="width: 17%" />
 <col style="width: 17%" />
 <col style="width: 65%" />
 </colgroup>
 <thead>
 <tr class="header">
 <th>查询参数</th>
 <th>选项</th>
 <th>说明</th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td>用户仅</td>
 否| <td>假|真</td>
 <td>仅与当前用户关联的数据捕获组织单位。 </td>
 </tr>
 <tr class="even">
 <td> userDataViewOnly </td>
 否| <td>假|真</td>
 <td>仅与当前用户关联的数据视图组织单位。 </td>
 </tr>
 <tr class="odd">
 <td> userDataViewFallback </td>
 否| <td>假|真</td>
 <td>仅与当前用户相关联的数据视图组织单位，并回退到数据捕获组织单位。 </td>
 </tr>
 <tr class="even">
 查询<td> </td>
 <td>字符串</td>
 <td>查询名称，代码和ID属性。 </td>
 </tr>
 <tr class="odd">
 <td>级别</td>
 <td>整数</td>
 <td>层次结构中给定级别的组织单位。 </td>
 </tr>
 <tr class="even">
 <td> maxLevel </td>
 <td>整数</td>
 <td>给定的最高级别或更高层次结构中的级别的组织单位。 </td>
 </tr>
 <tr class="odd">
 用户层次结构内的<td> </td>
 否| <td>假|真</td>
 <td>将搜索和检索限制为用户数据捕获范围内的组织单位。 </td>
 </tr>
 <tr class="even">
 UserSearchHierarchy中的<td> </td>
 否| <td>假|真</td>
 <td>将搜索和检索限制为当前用户搜索范围内的组织单位。注意：如果为true，则“ withinUserHierarchy”具有更高的优先级。 </td>
 </tr>
 <tr class="odd">
 <td> memberCollection </td>
 <td>字符串</td>
 <td>要显示集合中的成员数，请参阅与组织单位关联的集合的名称。 </td>
 </tr>
 <tr class="even">
 <td> memberObject </td>
 <td> UID </td>
 <td>用于显示集合中成员的数量，是指集合中对象成员的标识符。 </td>
 </tr>
 </tbody>
 </table>

### 获取具有关系的组织单位 { #webapi_organisation_units_with_relations }

要获取具有相关组织单位的组织单位，您可以使用
以下资源。

    / api / 33 / organisationUnits / {id}

 <table>
 <caption>组织单位参数</caption>
 <colgroup>
 <col style="width: 20%" />
 <col style="width: 20%" />
 <col style="width: 58%" />
 </colgroup>
 <thead>
 <tr class="header">
 <th>查询参数</th>
 <th>选项</th>
 <th>说明</th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td> includeChild </td>
 否| <td>假|真</td>
 <td>包括指定组织单位的直接子级，即子层次结构中下方直接级别的单位。 </td>
 </tr>
 <tr class="even">
 <td>包括后代</td>
 否| <td>假|真</td>
 <td>包括指定组织单位的所有子级，即子层次结构中的所有单位。 </td>
 </tr>
 <tr class="odd">
 <td>包括祖先</td>
 否| <td>假|真</td>
 <td>包括指定组织单位的所有父母。 </td>
 </tr>
 <tr class="even">
 <td>级别</td>
 <td>整数</td>
 <td>在子层次结构的给定级别（相对于下面的直接级别为1的组织单位）包括指定组织单位的子级。 </td>
 </tr>
 </tbody>
 </table>

### 按计划获取组织单位 { #webapi_organisation_units_by_programs }

专门构建的端点，用于检索计划和组织单位之间的关联。此端点是检索计划组织单位关联的首选方式。

    /api/33/programs/orgUnits?programs=<programUid,anotherProgramUid,...>

响应将采用以下格式：

    {
        “<programUid>”：[
            “<orgUnitUid>”，
            “<orgUnitUid>”，
            ...,
            “<orgUnitUid>”
        ],
        “<programUid>”：[
            “<orgUnitUid>”，
            “<orgUnitUid>”，
            ...,
            “<orgUnitUid>”
        ],
        “...”：[
            ...,
            ...
        ],
        “<programUid>”：[]
    }

没有关联 uid 的程序（因此可以被所有 orgUnit 访问）将返回 orgUnit 的空数组 []。

## 数据集 { #webapi_data_sets }

_dataSets_ 资源与 DHIS2 中的其他元数据资源一样遵循标准约定。该资源支持一些额外的查询参数。

    / api / 33 / dataSets

要检索数据集的版本，您可以发出GET请求：

    GET /api/33/dataSets/<uid>/version

要提高（增加一个）数据集的版本，您可以发出 POST
要求：

    POST / api / 33 / dataSets / <uid> / version

### 数据集通知模板 { #webapi_dataset_notifications }

_数据集通知模板_资源与 DHIS2 中的其他元数据资源一样遵循标准约定。

    获取 /api/33/dataSetNotificationTemplates

要检索数据集通知模板，您可以发出GET请求：

    GET /api/33/dataSetNotficationTemplates/<uid>

要添加数据集通知模板，您可以发出POST请求：

    POST / api / 33 / dataSetNotficationTemplates

要删除数据集通知模板，您可以发出DELETE请求：

    删除/ api / 33 / dataSetNotficationTemplates / <uid>

JSON有效负载示例如下：

```json
{
    "name": "dataSetNotificationTemplate1",
    "notificationTrigger": "COMPLETION",
    "relativeScheduledDays": 0,
    "notificationRecipient": "ORGANISATION_UNIT_CONTACT",
    "dataSets": [
        {
            "id": "eZDhcZi6FLP"
        }
    ],
    "deliveryChannels": ["SMS"],
    "subjectTemplate": "V{data_name}",
    "messageTemplate": "V{data_name}V{complete_registration_period}",
    "sendStrategy": "SINGLE_NOTIFICATION"
}
```

## 填充的组织单位级别 { #webapi_filled_organisation_unit_levels }

_filledOrganizationUnitLevels_ 资源提供组织单位级别的有序列表，其中生成的级别将注入到列表中以填充不存在持久级别的职位。

    获取 /api/33/filledOrganizationUnitLevels

要设置组织单位级别，您可以使用
JSON 负载看起来像这样。

```json
{
    "organisationUnitLevels": [
        {
            "name": "National",
            "level": 1,
            "offlineLevels": 3
        },
        {
            "name": "District",
            "level": 2
        },
        {
            "name": "Chiefdom",
            "level": 3
        },
        {
            "name": "Facility",
            "level": 4
        }
    ]
}
```

要使用curl进行功能测试，您可以发出以下命令。

```bash
curl "http://localhost/api/33/filledOrganisationUnitLevels" -H "Content-Type:application/json"
  -d @levels.json -u admin:district
```

## 预测变量 { #webapi_predictors }

预测器允许您根据表达式生成数据值。
这可以用于例如生成目标、阈值、
或估计值。

要检索预测器，您可以向预测器发出 GET 请求
像这样的资源：

    / api / predictors

### 创建预测变量 { #webapi_create_predictor }

您可以使用对预测器的 POST 请求创建预测器
资源：

    POST / api / predictors

有效负载样本如下所示：

```json
{
    "id": "AG10KUJCrRk",
    "name": "Malaria Outbreak Threshold Predictor",
    "shortName": "Malaria Outbreak Predictor",
    "description": "Computes the threshold for potential malaria outbreaks based on the mean plus 1.5x the std dev",
    "output": {
        "id": "nXJJZNVAy0Y"
    },
    "generator": {
        "expression": "AVG(#{r6nrJANOqMw})+1.5*STDDEV(#{r6nrJANOqMw})",
        "description": "Maximum normal malaria case count",
        "missingValueStrategy": "NEVER_SKIP",
        "slidingWindow": false
    },
    "periodType": "Monthly",
    "sequentialSampleCount": 4,
    "sequentialSkipCount": 1,
    "annualSampleCount": 3,
    "organisationUnitLevels": [4]
}
```

输出元素是指数据元素的标识符
其中保存预测数据值。生成器元素是指
计算预测值时使用的表达式。

### 预测表达式 { #webapi_predictor_expressions }

预测器总是有一个生成器表达式来描述
计算出预测值。预测器也可能有跳过测试
表达式返回一个布尔值。当跳过测试表达式为
目前，在每个采样周期中对其进行评估，以判断是否
应该跳过那个时期的值。

以下变量可用于生成器表达式
或跳过测试表达式：

| 变量 | 目的 | 描述 |
| --- | --- | --- |
| #{\&lt;dataelement-id&gt;} | 汇总数据元素 | 指所有类别选项组合中的聚合数据元素的总值。 |
| #{\&lt;dataelement-id&gt;.\&lt;categoryoptcombo-id &gt;} | 数据元素操作数 | 指聚合数据元素和类别选项组合的组合。 |
| D{\&lt;程序 id&gt;.\&lt;数据元素-id &gt;} | 程序数据元素 | 引用程序中跟踪器数据元素的值。 |
| A{\&lt;程序 ID&gt;.\&lt;属性 ID &gt;} | 程序跟踪的实体属性 | 指程序中被跟踪实体属性的值。 |
| I{\&lt;program-indicator-id&gt;} | 计划指标 | 指程序指示器的值。 |
| R{\&lt;数据集-id&gt;.\&lt;指标<span类='notranslate'>&gt;</span>} | 报告率 | 指报告率指标。指标可以是REPORTING_RATE，REPORTING_RATE_ON_TIME，ACTUAL_REPORTS，ACTUAL_REPORTS_ON_TIME，EXPECTED_REPORTS。 |
| C{\&lt;常量 ID&gt;} | 不变 | 指恒定值。 |
| OUG{\&lt;orgunitgroup-id&gt;} | 组织单位组 | 指组织单位组内组织单位的数量。 |
| [天] | 天数 | 当前期间的天数。 |

### 生成预测值 { #webapi_generating_predicted_values }

要运行所有预测器（生成预测值），您可以进行 POST
请求运行资源：

    POST / api / predictors / run

要运行单个预测器，您可以向运行发出 POST 请求
预测器的资源：

    POST / api / predictors / AG10KUJCrRk / run

## 计划规则 { #webapi_program_rules }

本节是关于发送和读取程序规则，并解释
程序规则数据模型。程序规则赋予功能
在 DHIS2 程序中配置动态行为。

### 程序规则模型 { #webapi_program_rule_model }

程序规则数据模型由 programRuleVariables、
程序规则和程序规则操作。 programRule 包含一个
表达式 - 当这个表达式为真时，子程序RuleActions
被触发。 programRuleVariables 用于寻址数据元素，
跟踪实体数据值和运行所需的其他数据值
表达式。一个程序中的所有程序规则共享同一个程序库
programRuleVariables，一个 programRuleVariable 可以用于多个
程序规则的表达式。

![](resources/images/program_rules/program-rule-model.jpg)

#### 程序规则模型详细信息 { #program-rule-model-details }

下表给出了程序规则的详细概述
模型。

 <table style="width:100%;">
 <caption> 程序规则 </caption>
 <colgroup>
 <col style="width: 16%" />
 <col style="width: 66%" />
 <col style="width: 16%" />
 </colgroup>
 <thead>
 <tr class="header">
 <th> 名称 </th>
 <th> 描述 </th>
 <th> 强制性 </th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td> 程序 </td>
 <td> 执行programRule的程序。</td>
 <td> 强制性 </td>
 </tr>
 <tr class="even">
 <td> 名称 </td>
 <td> 程序规则将显示给 dhis2 配置器的名称。程序的最终用户不可见。 </td>
 <td> 强制性 </td>
 </tr>
 <tr class="odd">
 <td> 描述 </td>
 <td> 程序规则的描述，可供配置者用来描述规则。程序的最终用户不可见。 </td>
 <td> 强制性 </td>
 </tr>
 <tr class="even">
 <td> programStage </td>
 <td> 如果为程序规则设置了 programStage，则将仅在指定的程序阶段内评估该规则。 </td>
 <td> 可选 </td>
 </tr>
 <tr class="odd">
 <td> 条件 </td>
 <td> 需要评估为真以便程序规则触发其子操作的表达式。表达式是使用运算符、函数调用、硬编码值、常量和程序规则变量编写的。
 <pre> <code> D2：hasValue的（＆＃39;血红蛋白＆＃39;）&amp;&amp;＃{hemoglobin} &lt; = 7 </code> </pre> </td>
 <td> 强制性 </td>
 </tr>
 <tr class="even">
 <td> 优先级 </td>
 <td> 在规则顺序很重要的情况下运行规则的优先级。在大多数情况下，规则不依赖于在其他规则之前或之后运行，在这些情况下，可以省略优先级。如果未设置优先级，则规则将在定义了优先级的任何规则之后运行。如果设置了优先级（整数），则优先级最低的规则将在优先级较高的规则之前运行。 </td>
 <td> 可选 </td>
 </tr>
 </tbody>
 </table>

#### 计划规则操作模型详细信息 { #program-rule-action-model-details }

下表给出了对 programRuleAction 的详细概述
模型。

<table style="width:100%;">
<caption>programRuleAction</caption>
<colgroup>
<col style="width: 16%" />
<col style="width: 66%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="header">
<th>name</th>
<th>description</th>
<th>Compulsory</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>programRule</td>
<td>The programRule that is the parent of this action.</td>
<td>Compulsory</td>
</tr>
<tr class="even">
<td>programRule- ActionType</td>
<td>The type of action that is to be performed.
<ul>
<li><p>`DISPLAYTEXT` - Displays a text in a given widget.</p></li>
<li><p>`DISPLAYKEYVALUEPAIR` - Displays a key and value pair(like a program indicator) in a given widget.</p></li>
<li><p>`HIDEFIELD` - Hide a specified dataElement or trackedEntityAttribute.</p>
<ul>
<li><p><em>content</em> - if defined, the text in <em>content</em> will be displayed to the end user in the instance where a value is previously entered into a field that is now about to be hidden (and therefore blanked). If <em>content</em> is not defined, a standard message will be shown to the user in this instance.</p></li>
<li><p><em>dataElement</em> - if defined, the HIDEFIELD action will hide this dataElement when the rule is effective.</p></li>
<li><p><em>trackedEntityDataValue</em> - if defined, the HIDEFIELD action will hide this trackedEntityDataValue when the rule is effective.</p></li>
</ul></li>
<li><p>`HIDESECTION` - Hide a specified section.</p>
<ul>
<li><p><em>programStageSection</em> - must be defined. This is the programStageSection that will be hidden in case the parent rule is effective.</p></li>
</ul></li>
<li><p>`ASSIGN` - Assign a dataElement a value(help the user calculate something or fill in an obvious value somewhere)</p>
<ul>
<li><p><em>content</em> - if defined, the value in <em>data</em> is assigned to this variable. If content id defined, and thus a variable is assigned for use in other rules, it is important to also assign a <em>programRule.priority</em> to make sure the rule with an ASSIGN action runs before the rule that will in turn evaluate the assigned variable.</p></li>
<li><p><em>data</em> - must be defined, data forms an expression that is evaluated and assigned to either a variable(#{myVariable}), a dataElement, or both.</p></li>
<li><p><em>dataElement</em> - if defined, the value in <em>data</em> is assigned to this data element.</p></li>
</ul>
<p>Either the content or dataElement must be defined for the ASSIGN action to be effective.</p></li>
<li><p>`SHOWWARNING` - Show a warning to the user, not blocking the user from completing the event or registration.</p>
<ul>
<li><p><em>content</em> - if defined, content is a static part that is displayed at the end of the error message.</p></li>
<li><p><em>data</em> - if defined, data forms an expression that is evaluated and added to the end of the warning message.</p></li>
<li><p><em>dataElement</em> - if defined, the warning message is displayed next to this data element.</p></li>
<li><p><em>trackedEntityAttribute</em> - if defined, the warning message is displayed next to this tracked entity attribute.</p></li>
</ul>
<p>Either dataElement or trackedEntityAttribute must be specified.</p></li>
<li><p>`SHOWERROR` - Show an error to the user, blocking the user from completing the event or registration.</p>
<ul>
<li><p><em>content</em> - if defined, content is a static part that is displayed in the start of the error message.</p></li>
<li><p><em>data</em> - if defined, data forms an expression that is evaluated and added to the end of the error message.</p></li>
<li><p><em>dataElement</em> - if defined, the error message is linked to this data element.</p></li>
<li><p><em>trackedEntityAttribute</em> - if defined, the error message is linked to this tracked entity attribute.</p></li>
</ul>
<p>Either dataElement or trackedEntityAttribute must be specified.</p></li>
<li><p>`WARNINGONCOMPLETINON` - Show a warning to the user on the &quot;Complete form&quot; dialog, but allowing the user to complete the event.</p>
<ul>
<li><p><em>content</em> - if defined, content is a static part that is displayed at the end of the error message.</p></li>
<li><p><em>data</em> - if defined, data forms an expression that is evaluated and added to the end of the warning message.</p></li>
<li><p><em>dataElement</em> - if defined, the warning message prefixed with the name/formName of the data element.</p></li>
</ul></li>
<li><p>`ERRORONCOMPLETION` - Show an error to the user on in a modal window when the user tries to complete the event. The user is prevented from completing the event.</p>
<ul>
<li><p><em>content</em> - if defined, content is a static part that is displayed in the start of the error message.</p></li>
<li><p><em>data</em> - if defined, data forms an expression that is evaluated and added to the end of the error message.</p></li>
<li><p><em>dataElement</em> - if defined, the error message is linked to this data element.</p></li>
</ul></li>
<li><p>`CREATEEVENT` - Create an event within the same enrollment.</p>
<ul>
<li><p><em>content</em></p></li>
<li><p><em>data</em> - if defined, contains data values to assign the created event. The format is &lt;uid&gt;:&lt;data value&gt;. Where several values is specified, these are separated with comma.</p>
<pre><code>AcMrnleqHqc:100,AqK1IHqCkEE:&#39;Polyhydramnios&#39;</code></pre></li>
<li><p><em>programStage</em> - must be defined, and designates the program stage that the rule shall create an event of.</p></li>
</ul></li>
<li><p>`SETMANDATORYFIELD` - Set a field to be mandatory.</p>
<ul>
<li><p><em>dataElement</em> - if defined, this data element will be set to be mandatory in the data entry form.</p></li>
<li><p><em>trackedEntityAttribute</em> - if defined, this tracked entity attribute will be set to mandatory in the registration form or profile.</p></li>
</ul></li>
<li><p>`SENDMESSAGE` - To send message at completion of event/enrollment or at data value update.</p>
<ul>
<li><p><em>messageTemplate</em> - if defined, this template will be delivered either as SMS or EMAIL depending upon DeliveryChannel value in message template.</p></li>
</ul></li>
<li><p>`SCHEDULEMESSAGE` - To schedule message at completion of event/enrollment or at data value update.</p>
<ul>
<li><p><em>messageTemplate</em> - if defined, this template will be delivered either as SMS or EMAIL depending upon DeliveryChannel value in message template.</p></li>
<li><p><em>Date to send message</em> - Expression which is going to be used for evaluation of scheduled date. This expression should result in Date, any other resultant will be discarded and notification will not get scheduled.</p></li>
</ul></li>
</ul></td>
<td>Compulsory</td>
</tr>
<tr class="odd">
<td>location</td>
<td>Used for actionType DISPLAYKEYVALUEPAIR and DISPLAYTEXT to designate which widget to display the text or keyvaluepair in. Compulsory for DISPLAYKEYVALUEPAIR and DISPLAYTEXT.</td>
<td>See description</td>
</tr>
<tr class="even">
<td>content</td>
<td>Used for user messages in the different actions. See the actionType overview for a detailed explanation for how it is used in each of the action types. Compulsory for SHOWWARNING, SHOWERROR, WARNINGONCOMPLETION, ERRORONCOMPLETION, DISPLAYTEXT and DISPLAYKEYVALUEPAIR. Optional for HIDEFIELD and ASSIGN.</td>
<td>See description</td>
</tr>
<tr class="odd">
<td>data</td>
<td>Used for expressions in the different actions. See the actionType overview for a detailed explanation for how it is used in each of the action types. Compulsory for ASSIGN. Optional for SHOWWARNING, SHOWERROR, WARNINGONCOMPLETION, ERRORONCOMPLETION, DISPLAYTEXT, CREATEEVENT and DISPLAYKEYVALUEPAIR</td>
<td>See description</td>
</tr>
<tr class="even">
<td>dataElement</td>
<td>Used for linking rule actions to dataElements. See the actionType overview for a detailed explanation for how it is used in each of the action types. Optional for SHOWWARNING, SHOWERROR, WARNINGONCOMPLETION, ERRORONCOMPLETION, ASSIGN and HIDEFIELD</td>
<td>See description</td>
</tr>
<tr class="odd">
<td>trackedEntity- Attribute</td>
<td>Used for linking rule actions to trackedEntityAttributes. See the actionType overview for a detailed explanation for how it is used in each of the action types. Optional for SHOWWARNING, SHOWERROR and HIDEFIELD.</td>
<td>See description</td>
</tr>
<tr class="even">
<td>option</td>
<td>Used for linking rule actions to options. See the actionType overview for a detailed explanation for how it is used in each of the action types. Optional for HIDEOPTION</td>
<td>See description</td>
</tr>
<tr class="odd">
<td>optionGroup</td>
<td>Used for linking rule actions to optionGroups. See the actionType overview for a detailed explanation for how it is used in each of the action types. Compulsory for SHOWOPTIONGROUP, HIDEOPTIONGROUP.</td>
<td>See description</td>
</tr>
<tr class="even">
<td>programStage</td>
<td>Only used for CREATEEVENT rule actions. Compulsory for CREATEEEVENT.</td>
<td>See description</td>
</tr>
<tr class="odd">
<td>programStage- Section</td>
<td>Only used for HIDESECTION rule actions. Compulsory for HIDESECTION</td>
<td>See description</td>
</tr>
</tbody>
</table>

#### 程序规则变量模型的详细信息 { #program-rule-variable-model-details }

下表详细概述了
程序规则变量模型。

<table style="width:100%;">
<caption>programRuleVariable</caption>
<colgroup>
<col style="width: 16%" />
<col style="width: 66%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="header">
<th>name</th>
<th>description</th>
<th>Compulsory</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>name</td>
<td>the name for the programRuleVariable - this name is used in expressions.
<pre><code>#{myVariable} &gt; 5</code></pre></td>
<td>Compulsory</td>
</tr>
<tr class="even">
<td>sourceType</td>
<td>Defines how this variable is populated with data from the enrollment and events.
<ul>
<li><p>DATAELEMENT_NEWEST_EVENT_PROGRAM_STAGE - In tracker capture, gets the newest value that exists for a data element, within the events of a given program stage in the current enrollment. In event capture, gets the newest value among the 10 newest events on the organisation unit.</p></li>
<li><p>DATAELEMENT_NEWEST_EVENT_PROGRAM - In tracker capture, get the newest value that exists for a data element across the whole enrollment. In event capture, gets the newest value among the 10 newest events on the organisation unit.</p></li>
<li><p>DATAELEMENT_CURRENT_EVENT - Gets the value of the given data element in the current event only.</p></li>
<li><p>DATAELEMENT_PREVIOUS_EVENT - In tracker capture, gets the newest value that exists among events in the program that precedes the current event. In event capture, gets the newvest value among the 10 preceeding events registered on the organisation unit.</p></li>
<li><p>CALCULATED_VALUE - Used to reserve a variable name that will be assigned by a ASSIGN program rule action</p></li>
<li><p>TEI_ATTRIBUTE - Gets the value of a given tracked entity attribute</p></li>
</ul></td>
<td>Compulsory</td>
</tr>
<tr class="odd">
<td>dataElement</td>
<td>Used for linking the programRuleVariable to a dataElement. Compulsory for all sourceTypes that starts with DATAELEMENT_.</td>
<td>See description</td>
</tr>
<tr class="even">
<td>trackedEntity- Attribute</td>
<td>Used for linking the programRuleVariable to a trackedEntityAttribute. Compulsory for sourceType TEI_ATTRIBUTE.</td>
<td>See description</td>
</tr>
<tr class="odd">
<td>useCodeFor- OptionSet</td>
<td>If checked, the variable will be populated with the code - not the name - from any linked option set. Default is unchecked, meaning that the name of the option is populated.</td>
<td></td>
</tr>
<tr class="even">
<td>programStage</td>
<td>Used for specifying a specific program stage to retreive the programRuleVariable value from. Compulsory for DATAELEMENT_NEWEST_EVENT_PROGRAM_STAGE.</td>
<td>See description</td>
</tr>
</tbody>
</table>

### 创建程序规则 { #webapi_creating_program_rules }

-   To perform crud operations, `programRules` resource is available in API.

要检索programRules的列表，您可以执行GET请求，如下所示：

    / api / programRules

要检索单个programRule，您可以执行GET请求，如下所示：

    / api / programRules / <program_rule_uid>

要保存/添加单个programRule，您可以执行POST请求，如下所示：

    / api / programRules / <program_rule_uid>

要更新单个programRule，您可以执行如下PUT请求：

    / api / programRules / <program_rule_uid>

要删除单个programRule，您可以执行以下DELETE请求：

    / api / programRules / <program_rule_uid>

要检索programRule条件的描述，可以使用POST并在POST正文中提供条件字符串。

    / api / programRules / condition / description？ <program_rule_uid>

## 形式 { #webapi_forms }

To retrieve information about a form (which corresponds to a data set
and its sections) you can interact with the `form` resource. The form
response is accessible as XML and JSON and will provide information
about each section (group) in the form as well as each field in the
sections, including labels and identifiers. By supplying period and
organisation unit identifiers the form response will be populated with
data values.

 <table>
 <caption>表单查询参数</caption>
 <colgroup>
 <col style="width: 12%" />
 <col style="width: 12%" />
 <col style="width: 74%" />
 </colgroup>
 <thead>
 <tr class="header">
 <th>参数</th>
 <th>选项</th>
 <th>说明</th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td> pe </td>
 <td> ISO周期</td>
 <td>填充表单数据值的时间段。 </td>
 </tr>
 <tr class="even">
 <td> ou </td>
 <td> UID </td>
 <td>要为其填充表单数据值的组织单位。 </td>
 </tr>
 <tr class="odd">
 <td>元数据</td>
 否| <td>假|真</td>
 <td>是否包括有关表单节每个数据元素的元数据。 </td>
 </tr>
 </tbody>
 </table>

要检索数据集的表单，您可以执行GET请求，如下所示：

    / api / dataSets / <dataset-id> /form.json

检索具有标识符“BfMAe6Itzgt”的数据集的表单
XML：

    / api / dataSets / BfMAe6Itzgt / form

要检索包含JSON中的元数据的表单，请执行以下操作：

    /api/dataSets/BfMAe6Itzgt/form.json?metaData=true

检索填充了特定时期数据值的表单，并
XML 中的组织单位：

    /api/dataSets/BfMAe6Itzgt/form.xml?ou=DiszpKrYNg8&pe=201401

当涉及自定义数据输入表单时，此资源还允许
直接为数据集创建此类表单。这可以通过一个
内容类型为 text/html 的 POST 或 PUT 请求，其中有效负载是
自定义表单标记，例如：

```bash
curl -d @form.html "localhost/api/dataSets/BfMAe6Itzgt/form"
  -H "Content-Type:text/html" -u admin:district -X PUT
```

## 文件资料 { #webapi_documents }

对文件的引用可以与文档资源一起存储。

 <table>
 <caption>文档字段</caption>
 <colgroup>
 <col style="width: 50%" />
 <col style="width: 50%" />
 </colgroup>
 <thead>
 <tr class="header">
 <th>字段名称</th>
 <th>说明</th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td>名称</td>
 <td>文档的唯一名称</td>
 </tr>
 <tr class="even">
 <td>外部</td>
 <td>标志，用于标识文档的位置。外部文件为TRUE，内部文件为FALSE </td>
 </tr>
 <tr class="odd">
 <td>网址</td>
 <td>文件的位置。外部文件的URL。内部资源的文件资源ID（请参阅<a href="#webapi_file_resources">文件资源</a>）</td>
 </tr>
 </tbody>
 </table>

对文档端点的GET请求将返回所有文档：

    / api / documents

对文档端点的POST请求将创建一个新文档：

```bash
curl -X POST -d @document.json -H "Content-type: application/json"
  "http://dhis.domain/api/documents"
```

```json
{
    "name": "dhis home",
    "external": true,
    "url": "https://www.dhis2.org"
}
```

带有附加文档 ID 的 GET 请求将返回信息
关于文件。对同一端点的 PUT 请求将更新
文档的字段：

    / api / documents / <documentId>

将 _/data_ 附加到 GET 请求将返回文档的实际文件内容：

    / api / documents / <documentId> / data

## CSV元数据导入 { #webapi_csv_metadata_import }

DHIS2支持以CSV格式导入元数据，例如数据元素，组织单位和验证规则。根据列顺序/列索引来标识各种元数据对象的属性（有关详细信息，请参见下文）。您可以省略不需要的对象属性/列，但是由于列顺序很重要，因此必须包括一个空列。换句话说，如果您要指定在列顺序中排在后面的属性/列，但不指定在列顺序中排在较早的位置的某些列，则可以为它们添加空白/空白列。

CSV文件的第一行被视为标题，在导入期间将被忽略。 _comma_字符应用作文本定界符。包含逗号的文本必须放在_双引号_中。

要上传CSV格式的元数据，您可以向元数据端点发出POST请求：

    POST / api / metadata？classKey = CLASS-KEY

支持以下对象类型。 `classKey` 查询参数是强制性的，可以在下表中的每个对象类型旁边找到。

 <table>
 <caption> 对象类型和键 </caption>
 <tr>
 <th> 对象类型 </th>
 <th> 类密钥 </th>
 </tr>
 <tr>
 <td> 数据元素 </td>
 <td> DATA_ELEMENT </td>
 </tr>
 <tr>
 <td> 数据元素组 </td>
 <td> DATA_ELEMENT_GROUP
 </tr>
 <tr>
 <td> 类别选项 </td>
 <td> CATEGORY_OPTION </td>
 </tr>
 <tr>
 <td> 类别选项组 </td>
 <td> CATEGORY_OPTION_GROUP </td>
 </tr>
 <tr>
 <td> 组织单位 </td>
 <td> ORGANISATION_UNIT </td>
 </tr>
 <tr>
 <td> 组织单位组 </td>
 <td> ORGANISATION_UNIT_GROUP </td>
 </tr>
 <tr>
 <td> 验证规则 </td>
 <td> VALIDATION_RULE </td>
 </tr>
 <tr>
 <td> 选项集 </td>
 <td> OPTION_SET </td>
 </tr>
 <tr>
 <td> 翻译 </td>
 <td> 翻译 </td>
 </tr>
 </table>

> **提示**
>
> 如果使用 _curl_，则应使用 `--data-binary` 选项，因为它保留换行符和换行符，这对于 CSV 数据至关重要。

例如，要使用`curl`上传CSV格式的数据元素文件，可以使用以下命令：

```bash
curl --data-binary @data_elements.csv "http://localhost/api/metadata?classKey=DATA_ELEMENT"
  -H "Content-Type:application/csv" -u admin:district
```

以下各节列出了CSV导入当前支持的对象类型的格式。

### 资料元素 { #webapi_csv_data_elements }

 <table>
 <caption> 数据元素 CSV 格式 </caption>
 <colgroup>
 <col />
 <col style="width: 13%" />
 <col style="width: 7%" />
 <col style="width: 27%" />
 <col style="width: 50%" />
 </colgroup>
 <thead>
 <tr class="header">
 <th> 索引 </th>
 <th> 列 </th>
 <th> 需要 </th>
 <th> 值（默认第一个） </th>
 <th> 说明 </th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td> 1 </td>
 <td> 名称 </td>
 <td> 是 </td>
 <td> </td>
 <td> 名称。最多 230 个字符。独特。 </td>
 </tr>
 <tr class="even">
 <td> 2 </td>
 <td> UID </td>
 <td> 否 </td>
 <td> UID </td>
 <td> 稳定标识符。正好 11 个字母数字字符，以字符开头。如果未指定，将由系统生成。 </td>
 </tr>
 <tr class="odd">
 <td> 3 </td>
 <td> 代码 </td>
 <td> 否 </td>
 <td> </td>
 <td> 稳定代码。最多 50 个字符。 </td>
 </tr>
 <tr class="even">
 <td> 4 </td>
 <td> 简称 </td>
 <td> 否 </td>
 <td> 50 名称的第一个字符 </td>
 <td> 如果未指定，将回退到名称的前 50 个字符。最多 50 个字符。独特。 </td>
 </tr>
 <tr class="odd">
 <td> 5 </td>
 <td> 说明 </td>
 <td> 否 </td>
 <td> </td>
 <td> 自由文本描述。 </td>
 </tr>
 <tr class="even">
 <td> 6 </td>
 <td> 表格名称 </td>
 <td> 否 </td>
 <td> </td>
 <td> 最多 230 个字符。 </td>
 </tr>
 <tr class="odd">
 <td> 7 </td>
 <td> 域类型 </td>
 <td> 否 </td>
 <td> 聚合 |跟踪器 </td>
 <td> 数据元素的域类型，可以是聚合或跟踪器。最多 16 个字符。 </td>
 </tr>
 <tr class="even">
 <td> 8 </td>
 <td> 值类型 </td>
 <td> 否 </td>
 <td> 整数 |数量 | UNIT_INTERVAL |百分比 | INTEGER_POSITIVE | INTEGER_NEGATIVE | INTEGER_ZERO_OR_POSITIVE | FILE_RESOURCE |坐标 |文本 | LONG_TEXT |信 | PHONE_NUMBER |电子邮件 |布尔值 | TRUE_ONLY |日期 |日期时间 </td>
 <td> 值类型。最多 16 个字符。 </td>
 </tr>
 <tr class="odd">
 <td> 9 </td>
 <td> 聚合类型 </td>
 <td> 否 </td>
 <td> 总和 |平均| AVERAGE_SUM_ORG_UNIT |计数 | STDDEV |方差|最小 |最大 |无 </td>
 <td> 聚合类型，指示如何聚合各个维度的数据。最多 16 个字符。 </td>
 </tr>
 <tr class="even">
 <td> 10 </td>
 <td> 类别组合 </td>
 <td> 否 </td>
 <td> UID </td>
 <td> 类别组合的 UID。如果未指定，将默认为默认类别组合。 </td>
 </tr>
 <tr class="odd">
 <td> 11 </td>
 <td> 网址 </td>
 <td> 否 </td>
 <td> </td>
 <td> 数据元素资源的 URL。最多 255 个字符。 </td>
 </tr>
 <tr class="even">
 <td> 12 </td>
 <td> 零是重要的 </td>
 <td> 否 </td>
 <td> 假 |真 </td>
 <td> 指示是否将为该数据元素存储零值。 </td>
 </tr>
 <tr class="odd">
 <td> 13 </td>
 <td> 选项集 </td>
 <td> 否 </td>
 <td> UID </td>
 <td> 设置为用于数据的选项的 UID。 </td>
 </tr>
 <tr class="even">
 <td> 14 </td>
 <td> 注释选项集 </td>
 <td> 否 </td>
 <td> UID </td>
 <td> 设置为用于注释的选项的 UID。 </td>
 </tr>
 </tbody>
 </table>

下面是数据元素的 CSV 文件示例。首先
行将始终被忽略。请注意如何跳过列并依赖
系统使用的默认值。您还可以跳过列
你不使用出现在右边的

```csv
名称，uid，代码，简称，描述
“妇女参加技能发展培训”，“ D0001”，“妇女参加培训”
“妇女参与社区组织”，“ D0002”，“妇女参与组织”
```

### 组织单位 { #webapi_csv_org_units }

 <table>
 <caption> 组织单位 CSV 格式 </caption>
 <colgroup>
 <col />
 <col style="width: 14%" />
 <col style="width: 10%" />
 <col style="width: 21%" />
 <col style="width: 53%" />
 </colgroup>
 <thead>
 <tr class="header">
 <th> 索引 </th>
 <th> 列 </th>
 <th> 需要 </th>
 <th> 值（默认第一个） </th>
 <th> 说明 </th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td> 1 </td>
 <td> 名称 </td>
 <td> 是 </td>
 <td> </td>
 <td> 名称。最多 230 个字符。独特。 </td>
 </tr>
 <tr class="even">
 <td> 2 </td>
 <td> UID </td>
 <td> 否 </td>
 <td> UID </td>
 <td> 稳定标识符。最多 11 个字符。如果未指定，将由系统生成。 </td>
 </tr>
 <tr class="odd">
 <td> 3 </td>
 <td> 代码 </td>
 <td> 否 </td>
 <td> </td>
 <td> 稳定代码。最多 50 个字符。 </td>
 </tr>
 <tr class="even">
 <td> 4 </td>
 <td> 父级 </td>
 <td> 否 </td>
 <td> UID </td>
 <td> 上级组织单位的 UID。 </td>
 </tr>
 <tr class="odd">
 <td> 5 </td>
 <td> 简称 </td>
 <td> 否 </td>
 <td> 50 名称的第一个字符 </td>
 <td> 如果未指定，将回退到名称的前 50 个字符。最多 50 个字符。独特。 </td>
 </tr>
 <tr class="even">
 <td> 6 </td>
 <td> 说明 </td>
 <td> 否 </td>
 <td> </td>
 <td> 自由文本描述。 </td>
 </tr>
 <tr class="odd">
 <td> 7 </td>
 <td> 开业日期 </td>
 <td> 否 </td>
 <td> 1970-01-01 </td>
 <td> YYYY-MM-DD 格式的组织单元开始日期。 </td>
 </tr>
 <tr class="even">
 <td> 8 </td>
 <td> 关闭日期 </td>
 <td> 否 </td>
 <td> </td>
 <td> YYYY-MM-DD 格式的组织单元关闭日期，如果当前打开则跳过。 </td>
 </tr>
 <tr class="odd">
 <td> 9 </td>
 <td> 评论 </td>
 <td> 否 </td>
 <td> </td>
 <td> 组织单位的自由文本注释。 </td>
 </tr>
 <tr class="even">
 <td> 10 </td>
 <td> 特征类型 </td>
 <td> 否 </td>
 <td> 无 | MULTI_POLYGON |多边形 |点 |符号 </td>
 <td> 地理空间要素类型。 </td>
 </tr>
 <tr class="odd">
 <td> 11 </td>
 <td> 坐标 </td>
 <td> 否 </td>
 <td> </td>
 <td> 用于以 Geo JSON 格式进行地理空间分析的坐标。 </td>
 </tr>
 <tr class="even">
 <td> 12 </td>
 <td> 网址 </td>
 <td> 否 </td>
 <td> </td>
 <td> 组织单位资源的 URL。最多 255 个字符。 </td>
 </tr>
 <tr class="odd">
 <td> 13 </td>
 <td> 联系人 </td>
 <td> 否 </td>
 <td> </td>
 <td> 组织单位联系人。最多 255 个字符。 </td>
 </tr>
 <tr class="even">
 <td> 14 </td>
 <td> 地址 </td>
 <td> 否 </td>
 <td> </td>
 <td> 组织单位地址。最多 255 个字符。 </td>
 </tr>
 <tr class="odd">
 <td> 15 </td>
 <td> 电子邮件 </td>
 <td> 否 </td>
 <td> </td>
 <td> 组织单位的电子邮件。最多 150 个字符。 </td>
 </tr>
 <tr class="even">
 <td> 16 </td>
 <td> 电话号码 </td>
 <td> 否 </td>
 <td> </td>
 <td> 组织单位的电话号码。最多 150 个字符。 </td>
 </tr>
 </tbody>
 </table>

使用父单位导入组织单位的最小示例
看起来像这样：

```csv
名称，uid，代码，父项
“西部省份”，“ WESTP”，“ ImspTQPwCqd”
“东部省”，“ EASTP”，“ ImspTQPwCqd”
```

### 验证规则 { #webapi_csv_validation_rules }

<table>
<caption>Validation Rule CSV Format</caption>
<colgroup>
<col />
<col style="width: 17%" />
<col style="width: 7%" />
<col style="width: 28%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th>Index</th>
<th>Column</th>
<th>Required</th>
<th>Value (default first)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Name</td>
<td>Yes</td>
<td></td>
<td>Name. Max 230 characters. Unique.</td>
</tr>
<tr class="even">
<td>2</td>
<td>UID</td>
<td>No</td>
<td>UID</td>
<td>Stable identifier. Max 11 char. Will be generated by system if not specified.</td>
</tr>
<tr class="odd">
<td>3</td>
<td>Code</td>
<td>No</td>
<td></td>
<td>Stable code. Max 50</td>
</tr>
<tr class="even">
<td>4</td>
<td>Description</td>
<td>No</td>
<td></td>
<td>Free text description.</td>
</tr>
<tr class="odd">
<td>5</td>
<td>Instruction</td>
<td>No</td>
<td></td>
<td>Free text instruction.</td>
</tr>
<tr class="even">
<td>6</td>
<td>Importance</td>
<td>No</td>
<td>MEDIUM | HIGH | LOW</td>
<td>Importance of validation rule.</td>
</tr>
<tr class="odd">
<td>7</td>
<td>Rule type (ignored)</td>
<td>No</td>
<td>VALIDATION | SURVEILLANCE</td>
<td>Type of validation rule.</td>
</tr>
<tr class="even">
<td>8</td>
<td>Operator</td>
<td>No</td>
<td>equal_to | not_equal_to | greater_than | greater_than_or_equal_to | less_than | less_than_or_equal_to | compulsory_pair | exclusive_pair</td>
<td>Expression operator.</td>
</tr>
<tr class="odd">
<td>9</td>
<td>Period type</td>
<td>No</td>
<td>Monthly | Daily | Weekly | Quarterly | SixMontly | Yearly</td>
<td>Period type.</td>
</tr>
<tr class="even">
<td>10</td>
<td>Left side expression</td>
<td>Yes</td>
<td></td>
<td>Mathematical formula based on data element and option combo UIDs.</td>
</tr>
<tr class="odd">
<td>11</td>
<td>Left side expression description</td>
<td>Yes</td>
<td></td>
<td>Free text.</td>
</tr>
<tr class="even">
<td>12</td>
<td>Left side missing value strategy</td>
<td>No</td>
<td>SKIP_IF_ANY_VALUE_MISSING | SKIP_IF_ALL_VALUES_MISSING | NEVER_SKIP</td>
<td>Behavior in case of missing values in left side expression.</td>
</tr>
<tr class="odd">
<td>13</td>
<td>Right side expression</td>
<td>Yes</td>
<td></td>
<td>Mathematical formula based on data element and option combo UIDs.</td>
</tr>
<tr class="even">
<td>14</td>
<td>Right side expression description</td>
<td>Yes</td>
<td></td>
<td>Free text.</td>
</tr>
<tr class="odd">
<td>15</td>
<td>Right side missing value strategy</td>
<td>No</td>
<td>SKIP_IF_ANY_VALUE_MISSING | SKIP_IF_ALL_VALUES_MISSING | NEVER_SKIP</td>
<td>Behavior in case of missing values in right side expression.</td>
</tr>
</tbody>
</table>

### 选项集 { #webapi_csv_option_sets }

 <table style="width:100%;">
 <caption> 选项集 CSV 格式 </caption>
 <colgroup>
 <col />
 <col style="width: 14%" />
 <col style="width: 11%" />
 <col style="width: 15%" />
 <col style="width: 59%" />
 </colgroup>
 <thead>
 <tr class="header">
 <th> 索引 </th>
 <th> 列 </th>
 <th> 需要 </th>
 <th> 值（默认第一个） </th>
 <th> 说明 </th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td> 1 </td>
 <td> OptionSetName </td>
 <td> 是 </td>
 <td> </td>
 <td> 名称。最多 230 个字符。独特。每个选项都应该重复。 </td>
 </tr>
 <tr class="even">
 <td> 2 </td>
 <td> OptionSetUID </td>
 <td> 否 </td>
 <td> UID </td>
 <td> 稳定标识符。最多 11 个字符。如果未指定，将由系统生成。每个选项都应该重复。 </td>
 </tr>
 <tr class="odd">
 <td> 3 </td>
 <td> OptionSetCode </td>
 <td> 否 </td>
 <td> </td>
 <td> 稳定代码。最多 50 个字符。每个选项都应该重复。 </td>
 </tr>
 <tr class="even">
 <td> 4 </td>
 <td> 选项名称 </td>
 <td> 是 </td>
 <td> </td>
 <td> 选项名称。最多 230 个字符。 </td>
 </tr>
 <tr class="odd">
 <td> 5 </td>
 <td> OptionUID </td>
 <td> 否 </td>
 <td> UID </td>
 <td> 稳定标识符。最多 11 个字符。如果未指定，将由系统生成。 </td>
 </tr>
 <tr class="even">
 <td> 6 </td>
 <td> OptionCode </td>
 <td> 是 </td>
 <td> </td>
 <td> 稳定代码。最多 50 个字符。 </td>
 </tr>
 </tbody>
 </table>

选项集的格式很特殊。前三个值代表
一个选项集。最后三个值代表一个选项。首先
代表选项集的三个值应该对每个值重复
选项。

```csv
optionsetname，optionsetuid，optionsetcode，optionname，optionuid，optioncode
“颜色”，“颜色”，“蓝色”，“蓝色”
“颜色”，“颜色”，“绿色”，“绿色”
“颜色”，“颜色”，“黄色”，“黄色”
“性别”，“男”，“男”
“性别”，“女性”，“女性”
“性别”，“未知”，“未知”
“结果”，“高”，“高”
“结果”，“中”，“中”
“结果”，“低”，“低”
“ Impact”，“ cJ82jd8sd32”，“ IMPACT”，“ Great”，“ GREAT”
“影响”，“ cJ82jd8sd32”，“影响”，“中等”，“中等”
“影响”，“ cJ82jd8sd32”，“影响”，“不良”，“不良”
```

### 选项组 { #option-group }

 <table style="width:100%;">
 <caption>选项组CSV格式</caption>
 <colgroup>
 <col />
 <col style="width: 14%" />
 <col style="width: 11%" />
 <col style="width: 15%" />
 <col style="width: 59%" />
 </colgroup>
 <thead>
 <tr class="header">
 <th>索引</th>
 <th>栏</th>
 <th>必需</th>
 <th>值（默认为默认值）</th>
 <th>说明</th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td> 1 </td>
 <td> OptionGroupName </td>
 <td>是</td>
 <td>名称。最多230个字符。独特。每个选项都应重复。 </td>
 </tr>
 <tr class="even">
 <td> 2 </td>
 <td> OptionGroupUid </td>
 <td>否</td>
 <td>稳定的标识符。最多11个字符。如果未指定，将由系统生成。每个选项都应重复。 </td>
 </tr>
 <tr class="odd">
 <td> 3 </td>
 <td> OptionGroupCode </td>
 <td>否</td>
 <td>稳定的代码。最多50个字符。每个选项都应重复。 </td>
 </tr>
 <tr class="even">
 <td> 4 </td>
 <td> OptionGroupShortName </td>
 <td>是</td>
 <td>简称。最多50个字符。独特。每个选项都应重复。 </td>
 </tr>
 <tr class="odd">
 <td> 5 </td>
 <td> OptionSetUid </td>
 <td>是</td>
 <td>稳定的标识符。最多11个字符。每个选项都应重复。 </td>
 </tr>
 <tr class="even">
 <td> 6 </td>
 <td> OptionUid </td>
 <td>否</td>
 <td>稳定的标识符。最多11个字符。 </td>
 </tr>
 <tr class="odd">
 <td> 7 </td>
 <td>选项代码</td>
 <td>否</td>
 <td>稳定的代码。最多50个字符。 </td>
 </tr>
 </tbody>
 </table>

OptionGroup CSV有效负载样本

```csv
optionGroupName，optionGroupUid，optionGroupCode，optionGroupShortName，optionSetUid，optionUid，optionCode
optionGroupA，groupA，xmRubJIhmaK，OptionA
optionGroupA，groupgroup，xmRubJIhmaK，OptionB
optionGroupB 、、 groupB，QYDAByFgTr1，OptionC
```

### 选项组集 { #option-group-set }

 <table style="width:100%;">
 <caption>选项组设置CSV格式</caption>
 <colgroup>
 <col />
 <col style="width: 14%" />
 <col style="width: 11%" />
 <col style="width: 15%" />
 <col style="width: 59%" />
 </colgroup>
 <thead>
 <tr class="header">
 <th>索引</th>
 <th>栏</th>
 <th>必需</th>
 <th>值（默认为默认值）</th>
 <th>说明</th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td> 1 </td>
 <td> OptionGroupSetName </td>
 <td>是</td>
 <td>名称。最多230个字符。独特。每个选项都应重复。 </td>
 </tr>
 <tr class="even">
 <td> 2 </td>
 <td> OptionGroupSetUid </td>
 <td>否</td>
 <td>稳定的标识符。最多11个字符。如果未指定，将由系统生成。每个选项都应重复。 </td>
 </tr>
 <tr class="odd">
 <td> 3 </td>
 <td> OptionGroupSetCode </td>
 <td>否</td>
 <td>稳定的代码。最多50个字符。每个选项都应重复。 </td>
 </tr>
 <tr class="even">
 <td> 4 </td>
 <td> OptionGroupSetDescription </td>
 <td>否</td>
 <td>说明。每个选项都应重复。 </td>
 </tr>
 <tr class="odd">
 <td> 5 </td>
 <td> DataDimension </td>
 <td>否</td>
 <td>是，否</td>
 </tr>
 <tr class="even">
 <td> 6 </td>
 <td> OptionSetUid </td>
 <td>否</td>
 <td> OptionSet UID。稳定的标识符。最多11个字符。 </td>
 </tr>
 </tbody>
 </table>

OptionGroupSet CSV有效负载样本

```csv
名称，uid，代码，描述，数据维度，选项
optiongroupsetA，...，xmRubJIhmaK
optiongroupsetB 、、、、 false，QYDAByFgTr1
```

要将OptionGroups添加到导入的OptionGroupSet中，请按照导入集合成员身份的步骤进行操作

### 收藏会员 { #collection-membership }

除了导入对象，您还可以选择只导入对象
对象和组之间的组成员关系。目前，该
支持以下组和对象对

-   组织单位组-组织单位

-   数据元素组-数据元素

-   指标组-指标

-   选项组集-选项组

这些导入的CSV格式相同

 <table>
 <caption>集合成员资格CSV格式</caption>
 <colgroup>
 <col />
 <col style="width: 25%" />
 <col style="width: 25%" />
 <col style="width: 25%" />
 <col style="width: 25%" />
 </colgroup>
 <thead>
 <tr class="header">
 <th>索引</th>
 <th>栏</th>
 <th>必需</th>
 <th>值（默认为默认值）</th>
 <th>说明</th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td> 1 </td>
 <td> UID </td>
 <td>是</td>
 <td> UID </td>
 <td>要将对象添加到</td>的集合的UID
 </tr>
 <tr class="even">
 <td> 2 </td>
 <td> UID </td>
 <td>是</td>
 <td> UID </td>
 <td>要添加到集合</td>中的对象的UID
 </tr>
 </tbody>
 </table>

### 其他物件 { #webapi_csv_other_objects }

 <table>
 <caption> 数据元素组、类别选项、类别选项组、组织单元组 CSV 格式 </caption>
 <colgroup>
 <col />
 <col style="width: 17%" />
 <col style="width: 12%" />
 <col style="width: 14%" />
 <col style="width: 55%" />
 </colgroup>
 <thead>
 <tr class="header">
 <th> 索引 </th>
 <th> 列 </th>
 <th> 需要 </th>
 <th> 值（默认第一个） </th>
 <th> 说明 </th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td> 1 </td>
 <td> 名称 </td>
 <td> 是 </td>
 <td> </td>
 <td> 名称。最多 230 个字符。独特。 </td>
 </tr>
 <tr class="even">
 <td> 2 </td>
 <td> UID </td>
 <td> 否 </td>
 <td> UID </td>
 <td> 稳定标识符。最多 11 个字符。如果未指定，将由系统生成。 </td>
 </tr>
 <tr class="odd">
 <td> 3 </td>
 <td> 代码 </td>
 <td> 否 </td>
 <td> </td>
 <td> 稳定代码。最多 50 个字符。 </td>
 </tr>
 <tr class="even">
 <td> 4 </td>
 <td> 简称 </td>
 <td> 否 </td>
 <td> </td>
 <td> 简称。最多 50 个字符。 </td>
 </tr>
 </tbody>
 </table>

类别选项的示例如下所示：

```csv
名称，uid，代码，简称
“男”，“男”
“女性”，“女性”
```

## 删除的对象 { #webapi_deleted_objects }

删除的对象资源提供了元数据对象的日志
删除。

    / api / deletedObjects

每当删除元数据类型的对象时，都会保留日志
uid、代码、类型和删除时间。这个 API 是
在`/api/deletedObjects` 字段过滤和对象过滤中可用
与其他元数据资源类似。

获取类型为数据元素的已删除对象：

    GET /api/deletedObjects.json?klass=DataElement

获取在 2015 年删除的指标类型的已删除对象和
向前：

    GET /api/deletedObjects.json?klass=指示器&deletedAt=2015-01-01

## 收藏夹 { #webapi_favorites }

某些类型的元数据对象可以标记为收藏夹
当前登录的用户。这目前适用于仪表板。

    / api / dashboards / <uid> /收藏

要使仪表板成为收藏夹，您可以向如下 URL 发出 _POST_ 请求（无需内容类型）：

    / api /仪表板/ iMnYyBfSxmM /收藏

要将仪表板从收藏夹中删除，您可以使用与上述相同的 URL 发出 _DELETE_ 请求。

收藏夹状态将在元数据响应中的对象（例如仪表板）上显示为布尔值 _favorite_ 字段。

## 订阅内容 { #webapi_subscription }

登录的用户可以订阅某些类型的对象。现在
可订阅对象是 Chart、EventChart、EventReport 类型的对象，
地图、报告表和可视化。

> **注意**
>
>不推荐使用Chart和ReportTable对象。改为使用可视化。

要获取对象的订阅者（返回用户 ID 数组），您可以发出 _GET_ 请求：

    / api / <object-type> / <object-id> /订阅者

请参见以下示例：

    / api / charts / DkPKc1EUmC2 / subscribers

要检查当前用户是否订阅了对象（返回布尔值），您可以执行 _GET_ 调用：

    / api / <object-type> / <object-id> /已订阅

请参见以下示例：

    / api / charts / DkPKc1EUmC2 /已订阅

要订阅/取消订阅对象，您可以执行 _POST/DELETE_ 请求（不需要内容类型）：

    / api / <object-type> / <object-id> / subscriber

## 文件资源 { #webapi_file_resources }

_文件资源_是用于表示和存储二进制内容的对象。 _FileResource_ 对象本身包含文件元数据（名称、内容类型、大小等）以及允许从数据库外部文件存储检索内容的密钥。 _FileResource_ 对象与其他任何对象一样存储在数据库中，但内容（文件）存储在其他位置，并且可以使用包含的引用 _(storageKey)_ 进行检索。

    / api / fileResources

文件资源的内容不能直接访问，但可以
从其他对象（如数据值）引用来存储二进制
几乎无限大小的内容。

要创建不需要相应数据值的文件资源，可通过多部分上传向端点 `/api/fileResources` 发送 POST：

```bash
curl "https://server/api/fileResources" -X POST
  -F "file=@/path/to/file/name-of-file.png"
```

要创建文件资源和引用该文件的数据值，请在 DHIS 2.36 或更高版本中 POST 到 `/api/dataValues/file` 端点：

```bash
curl "https://server/api/dataValues/file?de=xPTAT98T2Jd
  &pe=201301&ou=DiszpKrYNg8&co=Prlt0C1RF0s" -X POST
  -F "file=@/path/to/file/name-of-file.png"
```

对于 `api/fileResources` 端点，唯一需要的表单参数是 _file_，即要上传的文件。对于 `api/dataValues/file` 端点，所需的参数与发布到 `api/dataValues` 的参数相同，只是多了 _file_。

文件名和内容类型也应包含在请求中，但在未提供时将替换为默认值。

成功创建文件资源后，返回的数据将包含
一个 `response` 字段，它又包含这样的 `fileResource`：

```json
{
  "httpStatus": "Accepted",
  "httpStatusCode": 202,
  "status": "OK",
  "response": {
    "responseType": "FileResource",
    "fileResource": {
      "name": "name-of-file.png",
      "created": "2015-10-16T16:34:20.654+0000",
      "lastUpdated": "2015-10-16T16:34:20.667+0000",
      "externalAccess": false,
      "publicAccess": "--------",
      "user": { ... },
      "displayName": "name-of-file.png",
      "contentType": "image/png",
      "contentLength": 512571,
      "contentMd5": "4e1fc1c3f999e5aa3228d531e4adde58",
      "storageStatus": "PENDING",
      "id": "xm4JwRwke0i"
    }
  }
}
```

请注意，响应是 _202 Accepted_，表明返回的资源已提交进行后台处理（在这种情况下会持续到外部文件存储）。另外，请注意`storageStatus`字段，该字段指示内容是否已存储。此时，如`PENDING`状态所示，对外部存储的持久化尚未完成（它可能被上传到某处基于云的存储）。

即使内容尚未完全存储，文件资源现在也可以使用，例如作为数据值中的引用内容（请参阅[使用文件数据值](#datavalue_file)）。如果我们需要检查更新后的 _storageStatus_ 或检索文件的元数据，可以查询 `fileResources` 端点。

```bash
curl "https://server/api/fileResources/xm4JwRwke0i" -H "Accept: application/json"
```

此请求将返回 `FileResource` 对象，如
上面例子的反应。

### 文件资源限制 { #webapi_file_resources_constraints }

-   文件资源_必须_被另一个对象引用（分配），才能被长期持久化。已创建但未被其他对象（如数据值）引用的文件资源被视为处于_暂存_状态。任何处于这种状态且时间超过_2 小时_的文件资源都将被标记为删除，并最终从系统中清除。

-   初始创建文件资源时返回的 ID 无法从任何其他位置检索，除非该文件资源已被引用（其中 ID 将作为引用存储），因此丢失它需要重复 POST 请求，并且要创建的新对象。 _孤立_文件资源将被自动清理。

-   文件资源对象是_不可变的_，这意味着不允许修改，需要创建一个全新的资源。

### 文件资源阻止列表 { #file-resource-blocklist }

出于安全原因，某些类型的文件被阻止上传。

以下内容类型被阻止。

| 内容类型 | 内容类型 |
| --- | --- |
| 文字/ HTML | 应用程序/ x-ms-dos-可执行 |
| 文字/ css | application / vnd.microsoft.portable-executable |
| 文字/ javascript | application / vnd.apple.installer + xml |
| 字体/ otf | application / vnd.mozilla.xul + xml |
| 应用程序/ x-shockwave-flash | 应用程序/ x-httpd-php |
| application / vnd.debian.binary-package | 应用程序/ x-sh |
| 应用/ x-rpm | 应用程序/ x-csh |
| 应用程序/ Java归档 |  |

以下文件扩展名被阻止。

| 文件扩展名 | 文件扩展名 | 文件扩展名 |
| -------------- | -------------- | -------------- |
| html           | 黛比            | ul            |
| 哈特姆            | 转数            | 的PHP            |
| 的CSS            | 罐            | 箱子            |
| js             | jsp            | SH             |
| 微信            | 可执行程序            | 西施            |
| OTF            | 微星            | 蝙蝠            |
| 瑞士法郎            | 每公斤           |                |

## 元数据版本控制 { #webapi_metadata_versioning }

本节介绍了可用的元数据版本控制 API
2.24

-   `/api/metadata/version`：此端点将返回调用它的系统的当前元数据版本。

<table>
<caption>Query Parameters</caption>
<colgroup>
<col style="width: 19%" />
<col style="width: 23%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>versionName</td>
<td>false</td>
<td>If this parameter is not specified, it will return the current version of the system or otherwise it will return the details of the versionName passed as parameter. (versionName is of the syntax &quot;Version_&lt;id&gt;&quot;</td>
</tr>
</tbody>
</table>

### 获取元数据版本示例 { #webapi_metadata_versioning_examples }

**示例：**获取此系统的当前元数据版本

请求：

```
/ api /元数据/版本
```

响应：

```json
{
    "name": "Version_4",
    "created": "2016-06-30T06:01:28.684+0000",
    "lastUpdated": "2016-06-30T06:01:28.685+0000",
    "externalAccess": false,
    "displayName": "Version_4",
    "type": "BEST_EFFORT",
    "hashCode": "848bf6edbaf4faeb7d1a1169445357b0",
    "id": "Ayz2AEMB6ry"
}
```

**示例：**获取名称为“ Version_2”的版本的详细信息

请求：

```
/ api / metadata / version？versionName = Version_2
```

响应：

```json
{
    "name": "Version_2",
    "created": "2016-06-30T05:59:33.238+0000",
    "lastUpdated": "2016-06-30T05:59:33.239+0000",
    "externalAccess": false,
    "displayName": "Version_2",
    "type": "BEST_EFFORT",
    "hashCode": "8050fb1a604e29d5566675c86d02d10b",
    "id": "SaNyhusVxBG"
}
```

-   `/api/metadata/version/history`：此端点将返回调用它的系统的所有元数据版本的列表。

 <table>
 查询参数<caption> </caption>
 <colgroup>
 <col style="width: 19%" />
 <col style="width: 23%" />
 <col style="width: 57%" />
 </colgroup>
 <thead>
 <tr class="header">
 名称<th> <p>名称</p> </th>
 <th> <p>必需</p> </th>
 <th> <p>说明</p> </th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 基线<td> <p>基线</p> </td>
 <td> <p>否</p> </td>
 <td> <p>如果未指定此参数，它将返回所有元数据版本的列表。否则，我们需要传递形式为&quot;Version_&lt;id&gt;&quot;的versionName参数。然后，它将返回系统中存在的版本列表，这些版本是在作为查询参数提供的版本名称之后创建的。 </p> </td>
 </tr>
 </tbody>
 </table>

### 获取所有元数据版本的列表 { #webapi_get_list_of_metadata_versions }

**示例：**获取此系统中所有版本的列表

请求：

```
/ api /元数据/版本/历史记录
```

响应：

```json
{
    "metadataversions": [
        {
            "name": "Version_1",
            "type": "BEST_EFFORT",
            "created": "2016-06-30T05:54:41.139+0000",
            "id": "SjnhUp6r4hG",
            "hashCode": "fd1398ff7ec9fcfd5b59d523c8680798"
        },
        {
            "name": "Version_2",
            "type": "BEST_EFFORT",
            "created": "2016-06-30T05:59:33.238+0000",
            "id": "SaNyhusVxBG",
            "hashCode": "8050fb1a604e29d5566675c86d02d10b"
        },
        {
            "name": "Version_3",
            "type": "BEST_EFFORT",
            "created": "2016-06-30T06:01:23.680+0000",
            "id": "FVkGzSjAAYg",
            "hashCode": "70b779ea448b0da23d8ae0bd59af6333"
        }
    ]
}
```

**示例：**获取此系统在“ Version_2”之后创建的所有版本的列表

请求：

```
/ api / metadata / version / history？baseline = Version_2
```

响应：

```json
{
    "metadataversions": [
        {
            "name": "Version_3",
            "type": "BEST_EFFORT",
            "created": "2016-06-30T06:01:23.680+0000",
            "id": "FVkGzSjAAYg",
            "hashCode": "70b779ea448b0da23d8ae0bd59af6333"
        },
        {
            "name": "Version_4",
            "type": "BEST_EFFORT",
            "created": "2016-06-30T06:01:28.684+0000",
            "id": "Ayz2AEMB6ry",
            "hashCode": "848bf6edbaf4faeb7d1a1169445357b0"
        }
    ]
}
```

-   `/api/metadata/version/create`：此端点将为参数中指定的版本类型创建元数据版本。

 <table>
 查询参数<caption> </caption>
 <colgroup>
 <col style="width: 19%" />
 <col style="width: 23%" />
 <col style="width: 57%" />
 </colgroup>
 <thead>
 <tr class="header">
 名称<th> <p>名称</p> </th>
 <th> <p>必需</p> </th>
 <th> <p>说明</p> </th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td> <p>类型</p> </td>
 <td> <p>是</p> </td>
 <td> <p>需要创建的元数据版本的类型。 </p>
 <ul>
 <li> <p> BEST_EFFORT </p> </li>
 <li> <p> ATOMIC </p> </li>
 </ul> </td>
 </tr>
 </tbody>
 </table>

用户可以选择需要创建的元数据类型。
元数据版本类型决定了进口商应该如何对待给定的
版本。导入元数据时将使用此类型。有
两种类型的元数据。

-   _BEST_EFFORT_：此类型表明可以忽略丢失的引用，并且导入器可以继续导入元数据（例如，数据元素组导入中丢失的数据元素）。

-   _ATOMIC_：此类型确保对元数据引用进行严格的类型检查，如果任何引用不存在，则元数据导入将失败。

> **注意**
>
> 建议使用 ATOMIC 类型的版本，以确保所有系统（中央和本地）具有相同的元数据。任何缺失的引用都会在验证阶段本身被捕获。请参阅进口商详细信息以获取完整说明。

### 创建元数据版本 { #webapi_create_metadata_version }

**示例：** 创建类型为 `BEST_EFFORT` 的元数据版本

请求：

```bash
curl -X POST -u admin:district "https://play.dhis2.org/dev/api/metadata/version/create?type=BEST_EFFORT"
```

响应：

```json
{
    "name": "Version_1",
    "created": "2016-06-30T05:54:41.139+0000",
    "lastUpdated": "2016-06-30T05:54:41.333+0000",
    "externalAccess": false,
    "publicAccess": "--------",
    "user": {
        "name": "John Traore",
        "created": "2013-04-18T17:15:08.407+0000",
        "lastUpdated": "2016-04-06T00:06:06.571+0000",
        "externalAccess": false,
        "displayName": "John Traore",
        "id": "xE7jOejl9FI"
    },
    "displayName": "Version_1",
    "type": "BEST_EFFORT",
    "hashCode": "fd1398ff7ec9fcfd5b59d523c8680798",
    "id": "SjnhUp6r4hG"
}
```

-   `/api/metadata/version/{versionName}/data`：此端点将下载特定于作为路径参数传递的版本名称的实际元数据。

-   `/api/metadata/version/{versionName}/data.gz`：此端点将以压缩格式（gzipped）下载特定于作为路径参数传递的版本名称的实际元数据。

 <table>
 <caption> 路径参数 </caption>
 <colgroup>
 <col style="width: 33%" />
 <col style="width: 33%" />
 <col style="width: 33%" />
 </colgroup>
 <thead>
 <tr class="header">
 <th> <p> 名称 </p> </th>
 <th> <p> 需要 </p> </th>
 <th> <p> 说明 </p> </th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td> <p> 版本名称 </p> </td>
 <td> <p> true </p> </td>
 <td>形式的<p> Path参数&quot;Version_&lt;id&gt;&quot;从而使API下载特定版本</p> </td>
 </tr>
 </tbody>
 </table>

### 下载版本元数据 { #webapi_download_version_metadata }

**示例：**获取“版本5”的实际元数据

请求：

```bash
curl -u admin:district "https://play.dhis2.org/dev/api/metadata/version/Version_5/data"
```

响应：

```json
{
    "date": "2016-06-30T06:10:23.120+0000",
    "dataElements": [
        {
            "code": "ANC 5th Visit",
            "created": "2016-06-30T06:10:09.870+0000",
            "lastUpdated": "2016-06-30T06:10:09.870+0000",
            "name": "ANC 5th Visit",
            "id": "sCuZKDsix7Y",
            "shortName": "ANC 5th Visit ",
            "aggregationType": "SUM",
            "domainType": "AGGREGATE",
            "zeroIsSignificant": false,
            "valueType": "NUMBER",
            "categoryCombo": {
                "id": "p0KPaWEg3cf"
            },
            "user": {
                "id": "xE7jOejl9FI"
            }
        }
    ]
}
```

## 元数据同步 { #webapi_metadata_synchronization }

本节介绍了可用的元数据同步 API
2.24 开始

-   `/api/metadata/sync`：此端点通过从远程服务器下载并导入设置应用程序中定义的指定版本，对查询参数中传递的版本名称执行元数据同步。

 <table>
 查询参数<caption> </caption>
 <colgroup>
 <col style="width: 33%" />
 <col style="width: 33%" />
 <col style="width: 33%" />
 </colgroup>
 <thead>
 <tr class="header">
 名称<th> <p>名称</p> </th>
 <th> <p>必需</p> </th>
 <th> <p>说明</p> </th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td> <p>版本名称</p> </td>
 <td> <p>是</p> </td>
 <td> <p> versionName查询参数，格式为&quot;Version_&lt;id&gt;&quot;。 api从远程服务器下载此版本，并将其导入本地系统。 </p> </td>
 </tr>
 </tbody>
 </table>

-   使用此 API 时应格外小心。请注意，还有另一种方法可以通过利用“数据管理”应用程序中的元数据同步任务以完全自动化的方式实现同步。有关元数据同步任务的更多详细信息，请参阅用户手册第 22 章第 22.17 节。

-   该同步 API 也可以用于同步元数据同步调度程序失败的版本的元数据。由于它依赖于给定的元数据版本号，因此应注意调用的顺序。例如。如果此 api 用于从中央实例同步某些更高版本，则同步可能会失败，因为本地实例中不存在元数据依赖项。

-   假设本地实例处于`Version_12`，并且如果此端点用于从中央实例同步`Version_15`（类型为`BEST_EFFORT`），则调度程序将从`Version_16`开始同步元数据。所以本地实例不会有 `Version_12` 和 `Version_15` 之间的元数据版本。您只需要使用这些端点手动同步丢失的版本。

### 同步元数据版本 { #webapi_metadata_synchronization_version }

**示例：**将Version_6从中央系统同步到该系统

请求：

```bash
curl -u admin:district "https://play.dhis2.org/dev/api/metadata/sync?versionName=Version_6"
```

## 元数据存储库 { #webapi_metadata_repository }

DHIS2 提供了一个包含元数据包的元数据存储库
各种内容。元数据包是符合 DHIS2 的 JSON 文档
它描述了一组元数据对象。

要检索可用元数据包的索引，您可以向 _metadataRepo_ 资源发出 GET 请求：

    GET /api/synchronization/metadataRepo

元数据包条目包含有关包的信息和
相关包的 URL。索引可能如下所示：

```json
{
    "packages": [
        {
            "id": "sierre-leone-demo",
            "name": "Sierra Leone demo",
            "description": "Sierra Leone demo database",
            "version": "0.1",
            "href": "https://dhis2.org/metadata-repo/221/sierra-leone-demo/metadata.json"
        },
        {
            "id": "trainingland-org-units",
            "name": "Trainingland organisation units",
            "description": "Trainingland organisation units with four levels",
            "version": "0.1",
            "href": "https://dhis2.org/metadata-repo/221/trainingland-org-units/metadata.json"
        }
    ]
}
```

客户端可以按照 URL 并通过内容类型为 _text/plain_ 的 POST 请求安装元数据包，并将元数据包 URL 作为 _metadataPull_ 资源的负载：

    POST / api / synchronization / metadataPull

curl命令示例如下所示：

```bash
curl "localhost:8080/api/synchronization/metadataPull" -X POST
  -d "https://dhis2.org/metadata-repo/221/trainingland-org-units/metadata.json"
  -H "Content-Type:text/plain" -u admin:district
```
