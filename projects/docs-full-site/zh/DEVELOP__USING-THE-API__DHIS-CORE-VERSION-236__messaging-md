---
edit_url: "https://github.com/dhis2/dhis2-docs/blob/2.36/src/developer/web-api/messaging.md"
revision_date: "2021-06-14"
tags:
    - Develop
    - DHIS 核心版本 2.36
---

# 讯息传递 { #messaging }

## 讯息对话 { #webapi_message_conversations }

DHIS2 具有一种发送消息的机制，用于向用户发送用户反馈、通知和一般信息等目的。消息被分组为对话。要与消息对话交互，您可以向 _messageConversations_ 资源发送 POST 和 GET 请求。

    / api / 33 / messageConversations

消息会发送到 DHIS2 消息收件箱，但也可以通过 SMS 发送到用户的电子邮件地址和手机。在此示例中，我们将了解如何利用 Web API 发送、读取和管理消息。我们将假装是 _DHIS2 Administrator_ 用户并向 _Mobile_ 用户发送消息。然后我们将假装是移动用户并阅读我们的新消息。接下来，我们将通过标记和删除邮件来管理管理员用户收件箱。

### 撰写和阅读邮件 { #webapi_writing_messages }

发送和读取消息时我们需要交互的资源是 _messageConversations_ 资源。我们首先访问位于 <http://play.dhis2.org/demo/api> 的 Web API 入口点，在其中找到并点击位于 <http://play.dhis2.org/demo/api/messageConversations> 的 _messageConversations_ 资源的链接。描述告诉我们，我们可以使用 POST 请求来创建一条使用以下 XML 格式的新消息，以便发送给多个用户：

```xml
<message xmlns="http://dhis2.org/schema/dxf/2.0">
  <subject>This is the subject</subject>
  <text>This is the text</text>
  <users>
    <user id="user1ID" />
    <user id="user2ID" />
    <user id="user3ID" />
  </users>
</message>
```

为了发送给一个或多个用户组中的所有用户，我们可以
用：

```xml
<message xmlns="http://dhis2.org/schema/dxf/2.0">
  <subject>This is the subject</subject>
  <text>This is the text</text>
  <userGroups>
    <userGroup id="userGroup1ID" />
    <userGroup id="userGroup2ID" />
    <userGroup id="userGroup3ID" />
  </userGroups>
</message>
```

为了发送给连接到一个或多个组织单位的所有用户，我们
可以使用：

```xml
<message xmlns="http://dhis2.org/schema/dxf/2.0">
  <subject>This is the subject</subject>
  <text>This is the text</text>
  <organisationUnits>
    <organisationUnit id="ou1ID" />
    <organisationUnit id="ou2ID" />
    <organisationUnit id="ou3ID" />
  </organisationUnits>
</message>
```

由于我们想向我们的朋友移动用户发送消息，我们需要查找她的标识符。我们通过转到 Web API 入口点并按照链接到 `/api/users` 中的 _users_ 资源来实现。我们继续点击位于`/api/users/PhzytPW3g2J`的移动用户的链接，在那里我们了解到她的标识符是 _PhzytPW3g2J_。我们现在准备将我们的 XML 消息放在一起形成一条消息，我们想询问移动用户她是否报告了 2014 年 1 月的数据：

```xml
<message xmlns="http://dhis2.org/schema/dxf/2.0">
  <subject>Mortality data reporting</subject>
  <text>Have you reported data for the Mortality data set for January 2014?</text>
  <users>
    <user id="PhzytPW3g2J" />
  </users>
</message>
```

为了测试这一点，我们将 XML 内容保存到名为 _message.xml_ 的文件中。我们使用 cURL 将消息分派到 DHIS2 演示实例，其中我们指示内容类型为 XML 并以 _admin_ 用户身份进行身份验证：

```bash
curl -d @message.xml "https://play.dhis2.org/demo/api/messageConversations"
  -H "Content-Type:application/xml" -u admin:district -X POST
```

JSON和POST命令中的相应有效负载如下所示：

```json
{
    "subject": "Hey",
    "text": "How are you?",
    "users": [
        {
            "id": "OYLGMiazHtW"
        },
        {
            "id": "N3PZBUlN8vq"
        }
    ],
    "userGroups": [
        {
            "id": "ZoHNWQajIoe"
        }
    ],
    "organisationUnits": [
        {
            "id": "DiszpKrYNg8"
        }
    ]
}
```

```bash
curl -d @message.json "https://play.dhis2.org/demo/api/33/messageConversations"
  -H "Content-Type:application/json" -u admin:district -X POST
```

如果一切顺利，我们会收到 _201 Created_ HTTP 状态代码。另请注意，我们收到一个 _Location_ HTTP 标头，该标头的值告知我们新创建的消息对话资源的 URL - 消费者可以使用它来执行进一步的操作。

现在，我们将假装是移动用户，并通过向 _messageConversations_ 资源发送 GET 请求来读取刚刚发送的消息。我们提供一个带有 _application/xml_ 值的 _Accept_ 标头，以表明我们对 XML 资源表示感兴趣，并且我们以 _mobile_ 用户身份进行身份验证：

```bash
curl "https://play.dhis2.org/demo/api/33/messageConversations"
  -H "Accept:application/xml" -u mobile:district
```

作为响应，我们得到以下XML：

```xml
<messageConversations xmlns="http://dhis2.org/schema/dxf/2.0"
  link="https://play.dhis2.org/demo/api/messageConversations">
  <messageConversation name="Mortality data reporting" id="ZjHHSjyyeJ2"
    link="https://play.dhis2.org/demo/api/messageConversations/ZjHHSjyyeJ2"/>
  <messageConversation name="DHIS2 version 2.7 is deployed" id="GDBqVfkmnp2"
    link="https://play.dhis2.org/demo/api/messageConversations/GDBqVfkmnp2"/>
</messageConversations>
```

从响应中，我们可以读取新发送消息的标识符，即_ZjHHSjyyeJ2_。请注意，特定资源的链接是嵌入的，可以通过点击链接来阅读完整的消息。一旦我们知道 URL，我们就可以通过将消息文本作为请求负载来直接回复现有的消息对话。现在我们可以构建一个 URL 来发送回复：

```bash
curl -d "Yes the Mortality data set has been reported"
  "https://play.dhis2.org/demo/api/messageConversations/ZjHHSjyyeJ2"
  -H "Content-Type:text/plain" -u mobile:district -X POST
```

如果一切按计划进行，您将收到 _200 OK_ 状态代码。

在2.30中，我们添加了URL搜索参数：

    queryString =？＆queryOperator =？

过滤器搜索消息对话的主题、文本和发件人中的匹配项。默认查询运算符是 _token_，但是可以在查询中定义其他运算符。

### 管理讯息 { #webapi_managing_messages }

随着用户接收和发送消息，对话将开始堆积
在他们的收件箱中，最终变得难以跟踪。我们现在将
看看通过删除和标记来管理用户的消息收件箱
通过 Web-API 进行对话。我们将通过执行一些
在“DHIS 管理员”用户的收件箱中维护。

首先，让我们看看从收件箱中删除一些邮件。是
一定要注意这里描述的所有删除操作只删除
用户和消息对话之间的关系。实际上
这意味着我们不会删除消息本身（或任何
内容），但只是从
用户使其不再列在
`/api/messageConversations` 资源。

要从用户收件箱中删除消息对话，我们需要向由消息对话的 id 和参与用户标识的资源发出 _DELETE_ 请求。例如，要从 ID 为`jMe43trzrdi`的对话中删除 ID 为`xE7jOejl9FI`的用户：

```bash
curl "https://play.dhis2.org/demo/api/33/messageConversations/jMe43trzrdi
```

如果请求成功，服务器将回复_200 OK_。响应正文包含一个 XML 或 JSON 对象（根据请求的接受标头），其中包含已删除用户的 ID。

```json
{
    "removed": ["xE7jOejl9FI"]
}
```

失败时，返回的对象将包含一个消息有效负载
描述错误。

```json
{
    "message": "No user with uid: dMV6G0tPAEa"
}
```

细心的读者可能已经注意到，在我们的示例中成功返回的对象实际上是一个 id 列表（包含单个条目）。这是因为端点也支持批量删除。该请求是向相同的 _messageConversations_ 资源发出的，但遵循的语义略有不同。对于批处理操作，会话 ID 作为查询字符串参数给出。以下示例删除当前用户的两个单独的消息对话：

```bash
curl "https://play.dhis2.org/demo/api/messageConversations?mc=WzMRrCosqc0&mc=lxCjiigqrJm"
  -X DELETE -u admin:district
```

如果您有足够的权限，可以删除对话
通过提供可选的用户 ID 参数代表另一个用户。

```bash
curl "https://play.dhis2.org/demo/api/messageConversations?mc=WzMRrCosqc0&mc=lxCjiigqrJm&user=PhzytPW3g2J"
  -X DELETE -u admin:district
```

如上所述，批量删除将返回与
单一操作。删除的对象列表将反映成功
执行的移除。部分错误的请求（即不存在的 ID）
因此不会取消整个批处理操作。

消息带有布尔_read_属性。这允许跟踪用户是否已看到（打开）消息。在典型的应用场景（例如 DHIS2 门户网站）中，用户第一次打开消息时，该消息将被标记为已读。但是，用户可能希望管理其消息的已读或未读状态，以便跟踪某些对话。

标记消息已读或未读与批量删除的语义相似，也支持批量操作。要将消息标记为已读，我们会向 `messageConversations/read` 资源发出一个 _POST_，请求体包含一个或多个消息 ID。要将消息标记为未读，我们会向 `messageConversations/unread` 资源发出一个相同的请求。与删除一样，也可以给出一个可选的 _user_ 请求参数。

让我们将几条消息标记为当前用户已读：

```bash
curl "https://play.dhis2.org/dev/api/messageConversations/read"
  -d '["ZrKML5WiyFm","Gc03smoTm6q"]' -X POST
  -H "Content-Type: application/json" -u admin:district
```

响应是 _200 OK_，具有以下 JSON 正文：

```json
{
    "markedRead": ["ZrKML5WiyFm", "Gc03smoTm6q"]
}
```

您可以将收件人添加到现有的消息对话中。该资源位于：

    / api / 33 / messageConversations / id /收件人

此资源的选项是用户、用户组和
组织单位。请求应如下所示：

```json
{
    "users": [
        {
            "id": "OYLGMiazHtW"
        },
        {
            "id": "N3PZBUlN8vq"
        }
    ],
    "userGroups": [
        {
            "id": "DiszpKrYNg8"
        }
    ],
    "organisationUnits": [
        {
            "id": "DiszpKrYNg8"
        }
    ]
}
```

### 邮件附件 { #webapi_message_attachments }

创建带附件的消息分为两步：将文件上传到 _attachments_ 资源，然后在创建新消息时包含一个或多个附件 ID。

对 _attachments_ 资源的 POST 请求会将文件上传到服务器。

```
curl -F file=@attachment.png“ https://play.dhis2.org/demo/api/messageConversations/attachments”
  -u管理员：区
```

该请求返回一个表示附件的对象。的标识
创建消息时必须使用此对象以链接
邮件附件。

```json
{
    "created": "2018-07-20T16:54:18.210",
    "lastUpdated": "2018-07-20T16:54:18.212",
    "externalAccess": false,
    "publicAccess": "--------",
    "user": {
        "name": "John Traore",
        "created": "2013-04-18T17:15:08.407",
        "lastUpdated": "2018-03-09T23:06:54.512",
        "externalAccess": false,
        "displayName": "John Traore",
        "favorite": false,
        "id": "xE7jOejl9FI"
    },
    "lastUpdatedBy": {
        "id": "xE7jOejl9FI",
        "name": "John Traore"
    },
    "favorite": false,
    "id": "fTpI4GOmujz"
}
```

创建新消息时，可以在请求正文中传递 id
将上传的文件链接到正在创建的消息。

```json
{
    "subject": "Hey",
    "text": "How are you?",
    "users": [
        {
            "id": "OYLGMiazHtW"
        },
        {
            "id": "N3PZBUlN8vq"
        }
    ],
    "userGroups": [
        {
            "id": "ZoHNWQajIoe"
        }
    ],
    "organisationUnits": [
        {
            "id": "DiszpKrYNg8"
        }
    ],
    "attachments": ["fTpI4GOmujz", "h2ZsOxMFMfq"]
}
```

回复消息时，可以将 id 作为请求传递
范围。

```bash
curl -d "Yes the Mortality data set has been reported"
  "https://play.dhis2.org/demo/api/33/messageConversations/ZjHHSjyyeJ2?attachments=fTpI4GOmujz,h2ZsOxMFMfq"
  -H "Content-Type:text/plain" -u mobile:district -X POST
```

创建带有附件的邮件后，附加文件
可以通过对以下 URL 的 GET 请求访问：

    / api / messageConversations / <mcv-id> / <msg-id> / attachments / <attachment-id>

其中 <mcv-id> 是 _message Conversation_ ID，<msg-id> 是包含附件的 _message_ ID，<attachment-id> 是特定_消息附件_的 ID。

### 票证和验证结果通知 { #webapi_messaging_tickets }

您可以使用“写反馈”工具来创建工单和消息。
一张票和一条消息的唯一区别是你可以给
票证的状态和优先级。设置状态：

    POST / api / messageConversations / <uid> / status

设置优先级：

    POST / api / messageConversations / <uid> / priority

在 2.29 中，验证分析生成的消息现在也用于
状态和优先级属性。默认情况下，消息由
验证分析将继承验证规则的优先级
问题，或者如果消息包含多个最重要的
规则。

在 2.30 中，可以将验证规则分配给任何用户，同时工单
仍然需要分配给系统反馈接收者中的一个用户
团体。

 <table>
 <caption> 有效状态和优先级值的列表 </caption>
 <colgroup>
 <col style="width: 50%" />
 <col style="width: 50%" />
 </colgroup>
 <thead>
 <tr class="header">
 <th> 状态 </th>
 <th> 优先级 </th>
 </tr>
 </thead>
 <tbody>
 <tr class="odd">
 <td> 打开 </td>
 <td> 低 </td>
 </tr>
 <tr class="even">
 <td> 待定 </td>
 <td> 中等 </td>
 </tr>
 <tr class="odd">
 <td> 无效 </td>
 <td> 高 </td>
 </tr>
 <tr class="even">
 <td> 已解决 </td>
 <td> </td>
 </tr>
 </tbody>
 </table>

也可以给工单添加内部消息，只能看到
拥有“管理票证”权限的用户。创建一个内部
回复，包括“内部”参数，并将其设置为

```bash
curl -d "This is an internal message"
  "https://play.dhis2.org/demo/api/33/messageConversations/ZjHHSjyyeJ2?internal=true"
  -H "Content-Type:text/plain" -u admin:district -X POST
```
