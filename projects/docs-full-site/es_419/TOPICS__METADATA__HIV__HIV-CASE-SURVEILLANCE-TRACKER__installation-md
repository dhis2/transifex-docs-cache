---
edit_url: "https://github.com/dhis2-metadata/HIV_CS-TRK-HIV_Case_Surveillance/blob/master/docs/hiv_case_surveillance_installation.md"
revision_date: "2021-10-05"
---

# VIH Guía de instalación de Case Surveillance { #hiv_cs_installation }

Versión del paquete b1.0.0

Compatibilidad con DHIS2 Versión 2.33.5 y superior

## Visión general { #overview }

El paquete VIH Case Surveillance Captura de datos individuales se desarrolló utilizando DHIS2.33.5. Esto se hizo con el fin de soportar algunas de las últimas características de DHIS2. Para poder utilizar el paquete, se recomienda instalarlo en una instancia de DHIS2 que utilice DHIS2 2.33.5 o superior. Si va a instalarlo en una nueva instancia, consulte la [Guía de instalación de DHIS2](https://docs.dhis2.org/master/en/dhis2_system_administration_guide/installation.html). Este documento cubre la instalación de los siguientes paquetes:

1. Programa de vigilancia de casos Captura de datos individuales 

Tendrás que seguir las instrucciones para asegurarte de que el paquete se instala y configura correctamente.

## Instalación { #installation }

La instalación del módulo consta de varios pasos:

1. [Preparar](#preparing-the-metadata-file) el archivo de metadatos.
2. [Importar](#importing-metadata) el archivo de metadatos en DHIS2.
3. [Configuración](#configuración-adicional) los metadatos importados.
4. [Adaptar](#adapting-the-tracker-program) el programa después de ser importado

Se recomienda leer primero cada sección antes de comenzar el proceso de instalación y configuración en DHIS2. Se han identificado las secciones que no son aplicables, dependiendo de si se está importando a una nueva instancia de DHIS2 o a una instancia de DHIS2 con metadatos ya presentes. El procedimiento descrito en este documento debe probarse en un entorno de prueba antes de repetirlo o transferirlo a una instancia de producción de DHIS2.

## Requisitos { #requirements }

Para instalar el módulo, se requiere una cuenta de usuario administrador en DHIS2. El procedimiento descrito en este documento debe probarse en un entorno de prueba/preparación antes de realizarse en una instancia de producción de DHIS2.

Se debe tener mucho cuidado para garantizar que el servidor en sí y la aplicación DHIS2 estén bien protegidos, para restringir el acceso a los datos que se recopilan. Los detalles sobre cómo proteger un sistema DHIS2 están fuera del alcance de este documento, por lo que remitimos a la [documentación de DHIS2](http://dhis2.org/documentation).

## Preparación del archivo de metadatos { #preparing-the-metadata-file }

**NOTA:** Si está instalando el paquete en una nueva instancia de DHIS2, puede omitir la sección "Preparación del archivo de metadatos" y pasar inmediatamente a la sección [Importar un archivo de metadatos a DHIS2](#importing-metadata)

Si bien no siempre es necesario, a menudo puede resultar ventajoso realizar ciertas modificaciones en el archivo de metadatos antes de importarlo a DHIS2.

### por defecto dimensión de los datos (si procede) { #default-data-dimension-if-applicable }

En las primeras versiones de DHIS2, el UID de la dimensión de datos predeterminada se generaba automáticamente. Por lo tanto, si bien todas las instancias de DHIS2 tienen una opción de categoría predeterminada, una categoría de elemento de datos, una combinación de categoría y una combinación de opciones de categoría, los UID de estos valores predeterminados pueden ser diferentes. Las versiones posteriores de DHIS2 tienen UID codificados para la dimensión predeterminada y estos UID se utilizan en los paquetes de configuración.

Para evitar conflictos al importar los metadatos, es recomendable buscar y  reemplazar en todo el archivo .json todas las apariciones de estos objetos predeterminados, reemplazando los UID del archivo .json con los UID de la base de datos en la que se importará el archivo. La Tabla 1 muestra los UID que deben reemplazarse, así como los API endpoints para identificar los UID existentes.

| Objeto | UID | API endpoint |
| :-- | :-- | :-- |
| Categoría  | GLevLNI9wkl | `../api/categories.json?filter=name:eq:default` |
| Opción de categoría | xYerKDKCefk | `../api/categoryOptions.json?filter=name:eq:default` |
| Combinación de categoría | bjDvmb4bfuf | `../api/categoryCombos.json?filter=name:eq:default` |
| Combinación de opciones de categoría | HllvX50cXC0 | `../api/categoryOptionCombos.json?filter=name:eq:default` |

Por ejemplo, si importa un paquete de configuración a <https://play.dhis2.org/demo>, el UID de la combinación de opciones de categoría predeterminada podría identificarse a través de <https://play.dhis2.org/demo/api/categoryOptionCombos.json?filter=name:eq:default> as bRowv6yZOF2.

Luego, puede buscar y reemplazar todas las apariciones de HllvX50cXC0 con bRowv6yZOF2 en el archivo .json, ya que ese es el ID predeterminado en el sistema al que está importando. **_Tenga en cuenta que esta operación de búsqueda y reemplazo debe realizarse con un editor de texto plano_**, no con un procesador de textos como Microsoft Word.

### Tipos de indicadores { #indicator-types }

El tipo de indicador es otro tipo de objeto que puede crear conflictos de importación porque ciertos nombres se utilizan en diferentes bases de datos DHIS2 (por ejemplo, "Porcentaje"). Dado que los tipos de indicadores se definen simplemente por su factor y si son o no números simples sin denominador, no son ambiguos y pueden reemplazarse mediante una búsqueda y reemplazo de los UID. Esto evita posibles conflictos de importación y evita la creación de tipos de indicadores duplicados. La Tabla 2 muestra los UID que podrían reemplazarse, así como los API endpoints para identificar los UID existentes.

| Objeto | UID | API endpoint |
| :-- | :-- | :-- |
| Porcentaje | hmSnCXmLYwt | `../api/indicatorTypes.json?filter=number:eq:false&filter=factor:eq:100` |

### Tipo de entidad rastreada { #tracked-entity-type }

Al igual que los tipos de indicadores, es posible que ya existan tipos de entidades tracker en su base de datos DHIS2. Las referencias al tipo de entidad tracker deben cambiarse para reflejar lo que hay en su sistema para no crear duplicados. La Tabla 3 muestra los UID que podrían reemplazarse, así como los API endpoints para identificar los UID existentes

| Objeto | UID | API endpoint |
| :-- | :-- | :-- |
| Persona | MCPQUTHX1Ze | `../api/trackedEntityTypes.json?filter=name:eq:Person` |

## Importar metadatos { #importing-metadata }

El archivo de metadatos .json se importa a través de la aplicación [Importar/Exportar] (https://docs.dhis2.org/master/en/user/html/import_export.html) de DHIS2. Es recomendable utilizar la función de proceso de prueba "dry run" para identificar problemas antes de intentar realizar una importación real de los metadatos. Si el "dry run" informa algún problema o conflicto, consulte la sección [conflictos de importación](#handling-import-conflicts) más abajo.

Si la importación "en seco"/"validar" funciona sin errores, intente importar los metadatos. Si la importación funciona sin errores, puede proceder a [configurar](#configuración-adicional) el módulo. En algunos casos, los conflictos o problemas de importación no se muestran durante la "ejecución en seco", pero aparecen cuando se intenta la importación real. En este caso, el resumen de importación listará cualquier error que necesite ser resuelto.

### Gestión de conflictos de importación { #handling-import-conflicts }

**NOTA:** Si está importando a una nueva instancia de DHIS2, no tendrá que preocuparse por conflictos de importación, ya que no hay nada en la base de datos a la que está importando con la que pueda entrar en conflicto. Siga las instrucciones para importar los metadatos y luego pase a la sección "[Configuración adicional](#additional-configuration)".

Pueden ocurrir varios conflictos diferentes, aunque el más común es que haya objetos de metadatos en el paquete de configuración con un nombre, nombre corto y/o código que ya existe en la base de datos de destino. Hay un par de soluciones alternativas a estos problemas, con diferentes ventajas y desventajas. Cuál sea la más adecuada dependerá, por ejemplo, del tipo de objeto para el que se produce un conflicto.

**_Alternativa 1_**

Cambiar el nombre del objeto existente en su base de datos DHIS2 para el cual existe un conflicto. La ventaja de este enfoque es que no es necesario modificar el archivo .json, ya que los cambios se realizan a través de la interfaz de usuario de DHIS2. Es probable que esto sea menos propenso a errores. También significa que el paquete de configuración se deja como está, lo que puede ser una ventaja, por ejemplo, cuando se vaya a utilizar material de formación y documentación basados en el paquete de configuración.

**_Alternativa 2_**

Cambiar el nombre del objeto para el que existe un conflicto en el archivo .json. La ventaja de este enfoque es que los metadatos DHIS2 existentes se dejan como están. Este puede ser un factor cuando existe material de formación o documentación como SOPs de diccionarios de datos vinculados al objeto en cuestión, y no implica ningún riesgo de confundir a los usuarios al modificar los metadatos con los que están familiarizados.

Tenga en cuenta que, tanto para la alternativa 1 como para la 2, la modificación puede ser tan simple como agregar un pequeño pre/post-fijo al nombre, para minimizar el riesgo de confusión.

**_Alternativa 3_**

Un tercer enfoque, más complicado, es modificar el archivo .json para reutilizar los metadatos existentes. Por ejemplo, en los casos en los que ya existe un set de opciones para un determinado concepto (por ejemplo, "sexo"), ese set de opciones podría eliminarse del archivo .json y todas las referencias a su UID podrían reemplazarse con el set de opciones correspondiente que ya se esté en la base de datos. La gran ventaja de esto (que no se limita a los casos en los que existe un conflicto de importación directo) es evitar la creación de metadatos duplicados en la base de datos. Hay algunas consideraciones clave que se deben tener en cuenta al realizar este tipo de modificación:

-   requiere conocimiento especializado de la estructura detallada de metadatos de DHIS2
-   el enfoque no funciona para todos los tipos de objetos. En particular, ciertos tipos de objetos tienen dependencias que son complicadas de resolver de esta manera, por ejemplo relacionadas con desagregaciones.
-   las futuras actualizaciones del paquete de configuración serán complicadas.

### Configuración adicional { #additional-configuration }

Una vez que todos los metadatos se hayan importado correctamente, hay algunos pasos que deben seguirse antes de que el módulo sea funcional.

### Compartir { #sharing }

Primero, tendrá que usar la funcionalidad _Compartir_ de DHIS2 para configurar qué usuarios (grupos de usuarios) deben ver los metadatos y los datos asociados con el programa, así como quién puede registrar/introducir datos en el programa. De forma predeterminada, el uso compartido se ha configurado para lo siguiente:

-   Tipo de entidad Tracked
-   Programa
-   Etapas del programa
-   Tableros

El paquete incluye cuatro grupos de usuarios:

-   VIH VC- Admin
-   VIH VC- Captura de datos
-   VIH VC- Análisis de datos

En por defecto se asigna lo siguiente a estos grupos de usuarios

| Objeto | Grupos de usuarios |  |  |  |
| --- | --- | --- | --- | --- |
|  | VIH - VC Admin | VIH VC- Captura de datos | VIH VC - Análisis de datos |  |
| Tipo de entidad Tracked | XXX | Metadatos: se pueden editar y visualizar Datos: se pueden visualizar | Metadatos: se pueden visualizar Datos: se pueden capturar y visualizar | Metadatos: se pueden ver Datos: se pueden ver |
| Programa | XXX | Metadatos: se pueden editar y visualizar Datos: se pueden visualizar | Metadatos: se pueden visualizar Datos: se pueden capturar y visualizar | Metadatos: se pueden ver Datos: se pueden ver |
| Tableros | XXX | Metadatos: se pueden editar y visualizar Datos: se pueden visualizar | Metadatos: se pueden ver Datos: se pueden ver | Metadatos: se pueden ver Datos: se pueden ver |
|  |  |  |  |  |

Querrá asignar sus usuarios al grupo de usuarios apropiado según su rol dentro del sistema. Es posible que desee habilitar 'compartir' para otros objetos en el paquete en función de su configuración. Consulte la [Documentación de DHIS2](https://docs.dhis2.org/master/en/dhis2_user_manual_en/about-sharing-of-objects.html) para obtener más información sobre cómo configurar compartir.

### Funciones de los usuarios { #user-roles }

Los usuarios necesitarán roles de usuario para poder interactuar con las diversas aplicaciones dentro de DHIS2. Se recomiendan los siguientes roles mínimos:

1. Análisis de datos Tracker: puede ver análisis de eventos y acceder a tableros, informes de eventos, visualizador de eventos, visualizador de datos, tablas dinámicas, informes y mapas.
2. Captura de datos Tracker: puede agregar valores de datos, actualizar entidades de tracker, buscar entidades de tracker en unidades organizativas y acceder a la captura de tracker

Consulte la [Documentación DHIS2](http://dhis2.org/documentation) para obtener más información sobre la configuración de roles de usuario.

### Unidades de organización { #organisation-units }

Debe asignar el programa a unidades organizativas dentro de su propia jerarquía para poder ver el programa en Tracker - captura de datos.

### Metadatos duplicados { #duplicated-metadata }

**NOTA:** Esta sección sólo se aplica si está importando a una base de datos DHIS2 en la que ya hay metadatos presentes. Si está trabajando con una nueva instancia de DHIS2, puede omitir esta sección.

Incluso cuando los metadatos se han importado exitosamente sin ningún conflicto de importación, puede haber duplicados en los metadatos: elementos de datos, atributos de entidad tracker o set de opciones que ya existen. Como se señaló en la sección anterior sobre resolución de conflictos, una cuestión importante a tener en cuenta es que las decisiones sobre la realización de cambios en los metadatos en DHIS2 también deben tener en cuenta otros documentos y recursos que están asociados de diferentes maneras tanto con los metadatos existentes, como con los metadatos que se han importado a través del paquete de configuración. Por lo tanto, resolver duplicados no es sólo una cuestión de "limpiar la base de datos", sino también de asegurarse de que esto se haga sin, por ejemplo, romper la posible integración con otros sistemas, la posibilidad de utilizar material de capacitación, romper los SOP, etc. Esto dependerá en gran medida del contexto.

Algo importante a tener en cuenta es que DHIS2 dispone de herramientas que pueden ocultar algunas de las complejidades de las posibles duplicaciones en los metadatos. Por ejemplo, cuando existen conjuntos de opciones duplicados, pueden ocultarse para grupos de usuarios a través de [compartir](https://docs.dhis2.org/master/en/user/html/sharing.html).

#### Formularios de introducción de datos { #data-entry-forms }

-   Tras registrar el primer caso (de prueba), acceda al menú **Configuración** del formulario de captura Captura de datos individuales y seleccione **Mostrar/Ocultar widgets**.
-   Pasar de **Introducción de datos cronológicos** a **Introducción de datos tabulares**
-   Asegúrese de que los widgets **Inscripción**, **Comentarios** y **Perfil** están seleccionados. Haga clic en **Cerrar**.
-   Ajuste los widgets en la pantalla como se muestra a continuación:

Captura de Pantalla

#### Barra superior { #top-bar }

-   Acceda al menú **Configuración** y seleccione **Configuración de la barra superior**.
-   Seleccione **Activar barra superior**
-   Seleccione los campos de información requeridos y asígneles su **Orden de clasificación**.

|                                    | Campos recomendados | Orden de clasificación |
| ---------------------------------- | ------------------ | ---------- |
| Apellido                            | 1                  |
| Fecha de nacimiento                      | 2                  |
| Esta persona está en supresión viral | 3                  |
| Carga vírica más reciente                  | 4                  |
| Días sin medicamentos              | 5                  |

-   Haga clic en **Guardar**.
-   Vuelva al menú **Configuración**. Haga clic en **Guardar diseño tablero como por defecto**. Bloquear diseño para todos los usuarios.

## Adaptación del programa Captura de datos individuales { #adapting-the-tracker-program }

Una vez que se haya importado el programa, es posible que desee realizar ciertas modificaciones en él. Algunos ejemplos de adaptaciones locales que _podrían_ realizarse son:

-   Añadir variables adicionales al formulario.
-   Adaptar los nombres de los elementos de datos/opciones según las convenciones nacionales.
-   Añadir traducciones a las variables y/o al formulario de entrada de datos.
-   Modificación de los indicadores del programa basados en definiciones de casos locales.

Sin embargo, se recomienda fuertemente tener mucho cuidado si decide cambiar o eliminar cualquiera de los formularios/metadatos incluidos. Existe el peligro de que las modificaciones puedan alterar la funcionalidad, por ejemplo las reglas y los indicadores de programa.

## Informes de eventos { #event-reports }

Actualmente (08/03/2021) existe un error que impide la importación de informes de eventos (JIRA-DHIS2-10163). Esto significa que algunos de los cuadros de mando de informes de eventos deben volver a crearse manualmente después de la importación.

### 6.1.2VIH - Visita por género y estado del tratamiento { #612hiv-visit-by-gender-and-treatment-status }

![Visit by gender and Treatment status](resources/images/image23.png)

Para recrear esta tabla dinámica, vaya a la aplicación "informes de eventos" y configure lo siguiente:

Estilo de tabla: Tabla dinámica Tipo de salida: Evento Programa: VIH Vigilancia de casos Etapa: Visita

Elementos de datos seleccionados: Atributo del programa "género, M,F,TG" Elemento de datos "VIH - Estado del tratamiento"

Períodos: Este mes Últimos tres meses

Unidad de organización: Seleccione la unidad o nivel org correspondiente(Actualmente está configurado a nivel nacional)

### VIH - Visita por estado de tratamiento y distrito { #hiv-visit-by-treatment-status-and-district }

![Visit by Treatment Status and District](resources/images/image20.png)

Para recrear esta tabla dinámica, vaya a la aplicación "informes de eventos" y configure lo siguiente:

Estilo de tabla: Tabla dinámica Tipo de salida: Evento Programa: VIH Vigilancia de casos Etapa: Visita

Elementos de datos seleccionados: Elemento de datos "VIH - Estado del tratamiento"

Periodos: Último mes

Unidad de organización: Seleccione la unidad o nivel org correspondiente (Actualmente está configurado a nivel nacional)

Disposición: Filtro del informe: Periodos Dimensiones de columna: Elemento de datos "VIH - Estado del tratamiento" Dimensiones de fila: Unidades de organización

### Regímenes TPT { #tpt-regimes }

![TB PReventive therapy regimes](resources/images/image17.png) In order to recreate this pivot table, go to the app “event reports” and configure the following:

Estilo de tabla: Tabla dinámica Tipo de salida: Evento Programa: VIH Vigilancia de casos Etapa: Visita

Elementos de datos seleccionados: Elemento de datos "VIH - Elegibilidad TPT" Elemento de datos "VIH - Régimen TPT"

Periodos: Este mes,Último mes, Últimos tres meses

Unidad org: Seleccione la unidad org correspondiente (Actualmente está configurada como "User org unit")

Disposición: Dimensiones de columna: Unidades de organización, Periodos Dimensiones de fila: DE VIH Elegibilidad TPT, DE VIH - Régimen TPT

## Anexo del guión { #script-annex }

Para permitir el análisis en el punto de servicio cuando los clientes cambian el lugar donde reciben tratamiento, hemos creado un script que deberá instalarse en la instancia.

### Paso 1: Crear una tabla { #step-1-create-a-table }

El primer paso es crear una nueva tabla en la base de datos donde registraremos el UO seleccionado cuando el usuario se inscriba en un nuevo TEI. Tenga en cuenta que sólo son necesarias las columnas programinstanceid y organisationunitid. En este caso se ha añadido la columna uid para mayor claridad. Podríamos añadir cualquier columna necesaria a efectos de auditoría (por ejemplo una marca de tiempo con la fecha de creación, etc...)

```SQL
CREAR TABLA public.enrollmentou (
    programinstanceid bigint NOT NULL,
    uid character varying(11),
    organisationunitid bigint
);

ALTER TABLE public.enrollmentou OWNER TO postgres;

ALTER TABLE ONLY public.enrollmentou
    ADD CONSTRAINT enrollmentou_pkey PRIMARY KEY (programinstanceid);

ALTER TABLE ONLY public.enrollmentou
    ADD CONSTRAINT uk_d3lsa2h8me94ksyp53l6rpe4g UNIQUE (uid);

CREATE INDEX index_enrollmentou ON public.enrollmentou USING btree (programinstanceid);

ALTER TABLE ONLY public.enrollmentou
    ADD CONSTRAINT fk_enrollmentou_programinstanceid FOREIGN KEY (programinstanceid) REFERENCES public.programinstance(programinstanceid);

ALTER TABLE ONLY public.enrollmentou
    ADD CONSTRAINT fk_enrollmentou_organisationunitid FOREIGN KEY (organisationunitid) REFERENCES public.organisationunit(organisationunitid);
```

A continuación, definimos una función que será ejecutada por un trigger. Esta función simplemente toma el(los) valor(es) NUEVO(S) INSERTADO(S) o ACTUALIZADO(S) en la tabla programinstance (correspondiente a una inscripción) almacenada en la variable NEW y rellena la tabla enrollementou con ellos. También se asegura de que la nueva inscripción corresponde al programa uid 'Xh88p1nyefp', VIH VC.

```SQL
@CREATE OR REPLACE FUNCTION log_enrollment_ou_changes()
  DEVUELVE TRIGGER
  LENGUAJE PLPGSQL
  COMO
$$
BEGIN
    IF NEW.programid = (SELECT programid FROM program WHERE uid = 'Xh88p1nyefp')
    THEN
        INSERT INTO enrollmentou (programinstanceid, uid, organisationunitid)
        VALUES(NEW.programinstanceid,NEW.uid,NEW.organisationunitid)
        ON CONFLICT (programinstanceid) DO NOTHING;
    END IF;

    RETURN NEW;
END;
$$;
```

El último paso que queda es crear un trigger que ejecute esta función después de que se produzca una operación de inserción o actualización en la tabla programinstance.

```SQL
CREATE TRIGGER enrollment_ou_changes
  AFTER INSERT OR UPDATE
  ON programinstance
  FOR EACH ROW
  EXECUTE PROCEDURE log_enrollment_ou_changes();
```

Comprobamos la tabla en la actualidad y verificamos que está vacía:

![tabla](resources/images/image15.png)

Tras acceder a la instancia, procedemos a inscribir un nuevo caso en el programa VIH VC. El resultado es el siguiente:

![Visit by Treatment Status and District](resources/images/image22.png)

Tenga en cuenta que el UID de este nuevo TEI es qFdfVhUGFZ8.

Comprobando la tabla enrollou, podemos ver que se ha creado una nueva fila.

![Visit by Treatment Status and District](resources/images/image1.png)

Es posible crear una vista SQL para proporcionar el contenido de la tabla enrollmentou de una manera más fácil de usar, para que el usuario pueda comprobar fácilmente cuál fue la inscripción UO para cada TEI en el programa. La vista SQL es la siguiente:

```SQL
SELECT tei.uid as tei_uid, eou.uid as enrollment_uid, UO.name as enrollment_ou
FROM enrollmentou eou
INNER JOIN programinstance pi ON eou.programinstanceid = pi.programinstanceid
INNER JOIN trackedentityinstance tei ON pi.trackedentityinstanceid = tei.trackedentityinstanceid
INNER JOIN organisationunit UO ON eou.organisationunitid = UO.organisationunitid;
```

Y el resultado es:

![Visit by Treatment Status and District](resources/images/image27.png)

Ahora podemos verificar que la inscripción actual UO y la propiedad UO son las mismas para este TEI:

![Visit by Treatment Status and District](resources/images/image13.png)

También en la IU:

![Visit by Treatment Status and District](resources/images/image19.png)

### Paso 2: Crear una función y un disparador en trackedentityprogramowner { #step-2-create-a-function-and-trigger-on-trackedentityprogramowner }

Creamos la siguiente función y trigger sobre la tabla trackedentityprogramowner:

```SQL
CREATE OR REPLACE FUNCTION log_ownership_ou_changes()
  DEVUELVE TRIGGER
  LENGUAJE PLPGSQL
  COMO
$$
BEGIN
    IF NEW.programid = (SELECT programid FROM program WHERE uid = 'Xh88p1nyefp') AND
       NEW.lasttupdated != NEW.created
    THEN
        UPDATE programinstance SET organisationunitid = NEW.organisationunitid
        FROM trackedentityprogramowner
        WHERE trackedentityprogramowner.trackedentityinstanceid = NEW.trackedentityinstanceid AND
            trackedentityprogramowner.trackedentityinstanceid = programinstance.trackedentityinstanceid;

    END IF;

    RETURN NEW;
END;
$$;

CREAR TRIGGER ownership_ou_changes
  DESPUÉS DE INSERTAR O ACTUALIZAR
  ON trackedentityprogramowner
  PARA CADA FILA
  EJECUTAR PROCEDIMIENTO log_ownership_ou_changes();
```

La función log_ownership_ou_changes se activará cuando se produzca un INSERT o UPDATE en trackedentityprogramowner. Si la fila afectada corresponde al programa VIH y la marca de tiempo de la actualización difiere de la almacenada en create (por lo que se trata de una actualización de la propiedad), la inscripción UO en la tabla programinstance se actualiza en consecuencia.

Procedemos a derivar al paciente, haciendo un traslado permanente:

![Visit by Treatment Status and District](resources/images/image16.png)

Podemos comprobar que la propiedad ha cambiado al Centro de Salud Crow:

También comprobamos la tabla en la base de datos:

![Visit by Treatment Status and District](resources/images/image24.png)

La titularidad de UO es "Crow Health Centre" pero también es la nueva inscripción UO, por lo que el disparador ha realizado correctamente la actualización en la tabla de instancias del programa. Si actualizamos el navegador, vemos esto:

![Visit by Treatment Status and District](resources/images/image7.png)

La titularidad y la inscripción son las mismas.

Por último, comprobamos que no ha cambiado nada en la tabla enrollou:

![Visit by Treatment Status and District](resources/images/image13.png)

Así que todavía tenemos la información sobre la unidad de organización de la inscripción.
