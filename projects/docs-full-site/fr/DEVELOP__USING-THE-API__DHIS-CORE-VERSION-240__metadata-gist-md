---
edit_url: "https://github.com/dhis2/dhis2-docs/blob/2.40/src/developer/web-api/metadata-gist.md"
revision_date: '2022-05-12'
tags:
- DHIS Version 2.40
- Développement
---

# Métadonnées Gist API { #gist_api } 
<!--DHIS2-SECTION-ID:gist_api-->

L'API Gist des métadonnées est une API JSON RESTful en lecture uniquement qui permet de récupérer et de parcourir 
des métadonnées. Les éléments de cette API contiennent la gist du même élément dans l'API Métadonnées.

L'API est spécifiquement conçue pour éviter :

* des réponses volumineuses en raison de l'inclusion de graphes d'objets partiels 
  imbriqués.
* Traitement des demandes en mémoire, à forte intensité de ressources 
  (par exemple, le filtrage en mémoire ou la navigation dans le graphe d'objets).
* _n + 1_ requêtes de base de données à la suite de la navigation dans le graphe d'objets lors de la restitution de 
  la réponse.

## Comparaison avec l'API des métadonnées { #gist_vs_metadata_api } 
<!--DHIS2-SECTION-ID:gist_vs_metadata_api-->

L'API standard des métadonnées est une API flexible et puissante, conçue pour répondre à 
tous les cas d'utilisation. 
L'inconvénient est que toutes les fonctionnalités et combinaisons ne peuvent pas être mises à l'échelle tout en 
conservant de bonnes performances en présence d'un grand nombre d'éléments. 
En particulier, les listes d'éléments où chaque élément possède une propriété qui est une 
grande collection d'objets complexes se sont avérées problématiques car elles font 
rapidement référence à une grande partie du graphe d'objets entier.

L'API `/gist` a été ajoutée pour fournir une API de métadonnées où la mise à l'échelle est 
notre première priorité. L'inconvénient est qu'il y a des limites plus distinctes à ce qui est 
techniquement raisonnable, ce qui signifie que toutes les fonctionnalités de l'API standard 
de métadonnées n'existent pas pour l'API Gist.

L'API Gist utilise une stratégie de division et de conquête pour éviter les réponses avec de grands 
graphes d'objets partiels. Au lieu d'inclure des objets ou des listes imbriqués, elle fournit
un URI de point de terminaison `/gist` où cet objet ou cette liste peut être visualisé de manière isolée.

**L'API `/gist` se réfère aux données imbriquées en utilisant les URI plutôt que de les inclure.** 
Cela signifie que si un client est intéressé par ces informations imbriquées, il faudra plus de 
requêtes, mais chacune d'entre elles reste raisonnablement petite et s'adaptera 
bien dans le contexte d'un grand nombre d'éléments potentiels.

Les différences connues :

* les éléments n'incluent que les champs des objets identifiables référencés si ceux-ci n'ont 
  pas de point de terminaison propre 
* ils n'incluent jamais directement les collections d'objets identifiables 
* les éléments par défaut n'incluent pas tous les champs disponibles, mais un sous-ensemble qui dépend 
  du contexte et des paramètres 
* les listes ne peuvent pas être utilisées sans pagination (il n'y a donc pas de paramètre `pagination`) 
* les champs avec les collections ne sont pas paginés en utilisant le transformateur `pagination` mais à travers 
  un point de terminaison API paginé pour la propriété particulière de la collection 
* les éléments d'une liste, la taille d'une propriété de collection ou le résultat d'un transformateur booléen prennent
  toujours en compte le partage d'objets (l'ensemble des éléments pris en compte est toujours l'ensemble 
  visible par l'utilisateur)
* Gist propose les transformateurs de champs de collection  `membre(<id>)` et  `non-membre(<id>)`
* Gist propose un filtre de vérification d'accès de type `peutLire` et `peuModifier` au lieu de filtrer 
  selon la propriété `accès`
* La Gist propose d'utiliser les UID des attributs comme noms de champs et de propriétés de filtrage pour permettre 
  l'établissement de listes ou le filtrage en fonction de valeurs d'attributs personnalisées
* Gist propose le regroupement de filtres

Les limites connues :

* par défaut, seuls les champs persistants sont inclus ; une poignée de champs spéciaux 
  non persistants (champs synthétiques) peuvent être ajoutés explicitement ; d'autres 
  les champs non persistants peuvent être extraits à l'aide de la transformation `de`
* les filtres ne peuvent être appliqués qu'aux champs persistants
* les commandes ne peuvent être appliquées qu'aux champs persistants
* les filtres de jeton ne sont pas disponibles
* l'ordre est toujours sensible à la casse
* Le transformateur `pluck` limité aux propriétés de texte
* Les champs contenant des collections d'éléments simples (non identifiables) ne peuvent pas toujours 
  être inclus en fonction de la manière dont ils sont stockés

Lorsque cela est possible, l'utilisation de l'API `/gist` doit être considérée comme la meilleure façon 
d'obtenir des informations sur les métadonnées.


## Points de terminaison { #gist_endpoints } 
<!--DHIS2-SECTION-ID:gist_Points de terminaison-->

L'API `/gist` a 3 types de points de terminaison :

* <code>/api/&lt;object-type><b>/gist </b></code>: liste paginée de tous les objets connus et visibles du type (implicite `auto=S`)
* <code>/api/&lt;object-type&gt;/&lt;object-id&gt;<b>/gist</b></code> : affichage d'un seul objet par identifiant (implicite `auto=L`)
* <code>/api/&lt;object-type&gt;/&lt;object-id&gt;/&lt;field-name&gt;<b>/gist</b></code> : liste paginée de tous les éléments connus et visibles dans la collection du champ de l'objet propriétaire (implicite `auto=M` ; dans le cas d'un champ simple, juste la valeur du champ).

Ces points de terminaison correspondent aux points de terminaison de l'API standard de métadonnées sans 
le suffixe `/gist` et partagent la majorité des paramètres et de leurs options avec 
cette API.


## Données de navigation { #gist_browse } 
<!--DHIS2-SECTION-ID:gist_browse-->

Puisque l'API `/gist` évite les structures de données profondément intégrées dans la réponse, les 
détails des objets complexes ou des listes d'objets référencés sont plutôt fournis 
sous la forme d'un URI vers le point de terminaison gist qui renvoie uniquement l'objet complexe ou 
la liste d'objets. Ces URI sont fournies par le champ `pointsdeterminaisonsdel'api` d'un élément qui est 
automatiquement ajouté à un élément lorsque de telles références existent. 
La propriété item elle-même peut contenir un résultat de transformation sur l'objet 
ou la collection tel que sa taille, sa contenance, sa non contenance, son (ses) identifiant(s) 
ou une propriété extraite telle que son nom.

Pour parcourir manuellement les données, il peut être pratique d'utiliser le paramètre `absoluteUrls=true`. 
Les liens entre les parties de la liste peuvent maintenant être suivis directement dans les navigateurs qui 
affichent les réponses JSON.


## Paramètres { #gist_parameters } 
<!--DHIS2-SECTION-ID:gist_paramètres-->

Tous les points de terminaison de l'API `/gist` acceptent le même ensemble de paramètres.
Les paramètres et leurs options qui n'ont pas de sens dans le contexte du point de terminaison sont 
ignorés.


### Aperçu { #overview } 
Les paramètres par ordre alphabétique :

| Paramètre      | Options               |  Par défaut     | Description          |
| -------------- | --------------------- | ------------ | ---------------------|
| `Urls absolus` | `vrai` or `faux`     | `faux`      | `vrai` utilise les chemins relatifs dans les liens, `faux` utilise les URL absolues dans les liens |
| `automatique`         | `XS`, `S`, `M`, `L`, `XL` | (en fonction du contexte) | étendue des champs sélectionnés par `*` le sélecteur de champ  |
| `champs`       | (en fonction du point de terminaison) | `*`          | liste de champs ou de préréglages séparés par des virgules à inclure |
| `filtre`       | `<field>:<operator>` ou `<field>:<operator>:<value>` |   | liste de filtres de champs de requête séparés par des virgules (peut être utilisée plus d'une fois) |
| `sans titre`     | `vrai` or `faux`     | `faux`      | `true` skip wrapping result in a pager (ignores `total`), `false` use a pager wrapper object around the result list |
| `inversé`      | `vrai` or `faux`     | `faux`      | La valeur `vrai` renvoie les éléments **pas** dans la liste, la valeur `faux` renvoie les éléments dans la liste. |
| `locale`       |                       | (langue configurée du compte utilisateur) | remplacement de la langue de traduction |
| `ordre`        | `<field>` or  `<field>:asc` or `<field>:desc` | `:asc` | comma separated list of query order fields (can be used more than once) |
| `page`         | 1-n                   | 1            | numéro de page |
| `taille de la page`     | 1-1000                | 50           | nombre d'éléments sur une page |
| `jonction de racines` | `ET` or `OU`         | `ET`        | combinaison logique de `filtres`, `ET`= tous doivent correspondre, `OU`= au moins un doit correspondre |
| `total`        | `vrai` or `faux`     | `faux`      | `vrai` ajoute le nombre total de correspondances à la pagination, `faux` ne compte pas le nombre total de correspondances |
| `traduire`    | `vrai` or `faux`     | `vrai`       | `vrai` traduit toutes les propriétés traduisibles, `faux` saute la traduction des propriétés traduisibles (pas d'effet sur les noms d'affichage synthétiques) |


### Le paramètre `absoluteUrls` { #gist_parameters_absoluteUrls } 
<!--DHIS2-SECTION-ID:gist_les paramètres_absoluteUrls-->

Par défaut, les URIs dans les `points de terminaison api`, `href` et les membres `précedent` et `suivant` de la`pagination` 
sont relatifs, et commencent par le chemin `/<object-type>/`.

Les URI peuvent être changés en URL absolues en utilisant le paramètre `absoluteUrls`.

Par exemple, `/api/users/rWLrZL8rP3K/gist?fields=id,href` renvoie :

```json
{
  "id": "rWLrZL8rP3K",
  "href": "/users/rWLrZL8rP3K/gist"
}
```

tandis que `/api/users/rWLrZL8rP3K/gist?fields=id,href&absoluteUrls=true` 
renvoie :

```json
{
  "id": "rWLrZL8rP3K",
  "href": "http://localhost:8080/api/users/rWLrZL8rP3K/gist?absoluteUrls=true"
}
```

Comme le montre l'exemple, le paramètre `absoluteUrls` est également transmis ou reporté 
dans les URLs incluses, ce qui permet de parcourir les réponses en suivant les 
URLs fournies.


### Le Paramètre `auto` { #the-auto-parameter } 
Chaque point d'accès définit implicitement une valeur par défaut pour l'étendue des champs correspondant 
au sélecteur de champs`*` / `:tout` :

* `/api/<object-type>/gist` : implique que `auto=S`
* `/api/<object-type>/<object-id>/gist`: implique que `auto=L`
* `/api/<object-type>/<object-id>/<field-name>/gist`: implique que `auto=M`

Le paramètre `auto` est utilisé pour surcharger manuellement la valeur par défaut afin que les éléments 
de la liste incluent plus ou moins de champs. Ce paramètre agit à nouveau comme une valeur par défaut qui peut 
être modifiée pour chaque champ à l'aide d'une transformation explicite.

Les options possibles pour `auto` sont (" les tailles de t-shirt ") :

* `XS` : inclut uniquement les identifiants et les propriétés textuelles
* `S` : exclut les propriétés complexes (objets), les collections sont uniquement liées (non comptabilisées)
* `M` : complexe inclus en tant qu'URL de référence, les références et les collections en tant qu'URL de comptage et de référence
* `L` : comme `M` mais les références et les collections sont incluses en tant qu'identifiants (OBS ! non consolidé en taille)
* `XL` : comme `L` mais les références et les collections sont incluses en tant qu'objets de l'identifiant : `{ "id" : <id>}`

Par exemple, `/api/users/gist` listerait les éléments avec les champs `identifiant`, `nom`, 
`prénom`, `numéro de téléphone`, `email`, `dernière mise à jour` alors que 
`/api/users/gist?auto=XS` ne liste que l' `identifiant`, le `nom`,
le `prénom`, le `numéro de téléphone`, l'`email`. L'utilisation de `/api/users/gist?auto=L` inclurait également `unités d'organisation`, `unités d'organisation de visualisation des données`, 
`Unités d'organisation de recherche d'instances d'entités suivis` et `groupes d'utilisateurs`, chacun avec la liste des identifiants des
membres des listes/ensembles.


### Le paramètre `champs` { #gist_parameters_fields } 
<!--DHIS2-SECTION-ID:gist_les paramètres_champs-->

Spécifie la liste des champs à inclure pour chaque élément de la liste.

Les champs sont inclus dans les résultats des objets JSON pour un élément dans l'ordre indiqué. 
Un preset dans la liste des champs est étendu aux champs qu'il contient en fonction de la 
position qu'il occupe dans la liste `fields`. 
Les champs de la présélection sont classés de simple à complexe.

Si aucun paramètre `fields` n'est fourni, `fields=*` est pris en compte.
Notez que les champs du `*`preset dépendent également du paramètre `auto`.

Pour supprimer un champ, utilisez `!<name>` ou `-<name>` dans la liste des champs.
Par exemple, pour supprimer les groupes d'utilisateurs d'un utilisateur, utilisez :

    /api/users/gist?fields=*,!groupes d'utilisateurs

Le même principe peut être utilisé pour spécifier le transformateur à utiliser pour un 
champ. Par exemple, pour inclure les identifiants des groupes d'utilisateurs de l'utilisateur, utilisez :

    /api/users/gist?fields=*,groupes d'utilisateurs:identifiants

Le paramètre `champs` permet de lister les champs des objets imbriqués. 
Par exemple, pour ajouter `références de l'utilisateur` avec `identifiant` et `nom` d'un utilisateur, utilisez :

    /api/users/gist?fields=*,références de l'utilisateur[identifiant,Nom d'utilisateur]

Cela crée des éléments du genre :

```json
{
  ...
  "références de l'utilisateur": {
    "identifiant": "Z9oOHPi3FHB",
    "Nom d'utilisateur": "invité"
  }
}
```

Lors de l'inclusion de champs imbriqués de collections, le champ imbriqué doit être une 
propriété textuelle.

Par exemple pour inclure tous les `nom`s des `groupes d'utilisateurs` d'un utilisateur par :

    /api/users/gist?fields=*,groupes d'utilisateurs[nom]

La liste des `groupes d'utilisateurs` est la suivante:

```json
{
  "groupes d'utilisateurs ": {
    "nom": [
      "_PROGRAMME_Programme pour les patients hospitalisés",
      "_PROGRAMME_Programme TB",
      "_ENSEMBLE DE DONNÉES_Superutilisateur",
      "_PROGRAMME_Superutilisateur",
      "_ENSEMBLE DE DONNÉES_Agent de saisie des données",
      "_ENSEMBLE DE DONNÉES_Agent M et E"
    ]
  }
}
```
Ce qui précède est fonctionnellement identique à :

    /api/users/gist?fields=*,groupe d'utilisateurs::pluck( nom)~renommer(groupe d'utilisateurs.nom)

Lorsque l'on demande un seul champ, comme `/api/users/gist?fields=nom`, la réponse est une liste (toujours paginée) de valeurs simples :

```json
{
  "pager": {
    "page": 1,
    "taille de la page": 50
  },
  "utilisateurs": [
    "Kamara",
    "Wakiki",
    "Nana",
    "Malai",
    ...
  ]
}
```

Lorsque l'on demande un champ unique de l'objet d'un propriétaire spécifique qui a une valeur simple 
(sans collection), comme par exemple 
`/api/users/rWLrZL8rP3K/gist fields=surname`, la réponse comprend uniquement la valeur 
JSON simple:

```json
"Wakiki"
```

Pour plus de détails sur les préréglages de champs, voir la section [Champs](#gist_fields).

### Le paramètre `filtre` { #gist_parameters_filter } 
<!--DHIS2-SECTION-ID:gist_paramètres_filtre-->

Pour filtrer la liste des éléments renvoyés, ajoutez un ou plusieurs paramètres `filtre`.

Plusieurs filtres peuvent être spécifiés sous la forme d'une liste séparée par des virgules d'un seul paramètre 
ou comme de multiples paramètres `filtre`, chacun avec un seul `filtre`.

Il existe deux types de filtres :

* unitaire: `<field>:<operator>`
* binaire: `<field>:<operator>:<value>`

Un champ peut être : 

* un champ persistant du type d'élément énuméré
* un champ maintenu d'un objet directement référencé (relation 1:1)
* l'UID d'un attribut

Les opérateurs unitaires disponibles sont les suivants :

| Opérateur unitaire | Description                                                 |
| -------- | ----------------------------------------------------------------- |
| `nul`   | le champ est _nul_ (non défini)                                       |
| `!nul`  | le champ est _non nul_ (défini)                                     |
| `vide`  | Le champ est une collection ou une chaîne _vide_                           |
| `!vide` | le champ est une collection ou une chaîne de caractères _non vide_                       |

Les opérateurs binaires disponibles sont les suivants :

| Opérateur binaire   | Description                                              |
| ----------------- | -------------------------------------------------------- |
| `eq`              | champ _égal_ valeur                                     |
| `ieq`             | champ _égal_ valeur (insensible à la casse)                  |
| `!eq`, `neq`, `ne`| champ _non égal_ valeur                               |
| `lt`              | champ _inférieur à_ valeur                               |
| `le`, `lte`       | champ _inférieur ou égal à_ valeur                   |
| `gt`              | champ _supérieur à_ valeur                            |
| `ge`, `gte`       | champ _supérieur ou égal à_ valeur                |
| `in`              | le champ est une collection et la valeur est un élément _contenu dans_ la collection |
| `!in`             | le champ est une collection et la valeur est un élément _non contenu dans_ la collection |

Si la `<value>` d'un filtre `in` ou `!in` est une liste, il est donné sous la forme suivante
`[valeur1,valeur2,...]`, par exemple: `groupes d'utilisateurs:dans:[fbfJHSPpUQD,cYeuwXTCPkU]`.

Toute comparaison `>`, `>=`, `<` `<=`, `==` ou `!=` appliquée à un champ de collection 
avec une valeur numérique comparera la taille de la collection à la valeur, par 
exemple : `groupes d'utilisateurs:gt:0`.

Toute comparaison `>`, `>=`, `<` `<=`, `==` ou `!=` appliquée à un champ de texte 
avec une valeur numérique entière comparera la longueur du texte à la valeur, par 
exemple : `nom:eq:4` (nom a une longueur de 4).


Les opérateurs de recherche de motifs binaires disponibles sont les suivants :

| Opérateur binaire                   | Description                              |
| --------------------------------- | ---------------------------------------- |
| `like`, `ilike`                   | le champ _contient_ `<value>` ou le champ _correspond_ au motif `<value>` (lorsque les caractères génériques `*` ou `?` sont présents dans la valeur) |
| `!like`, `!ilike`                 | le champ ne _contient pas_ `<value>` ou le champ ne _correspond pas_ au motif `<value>` (lorsque les caractères génériques `*` ou `?` sont présents dans la valeur) |
| `$like`, `$ilike`, `commence avec`   | le champ _commence avec_ `<value>`            |
| `!$like`, `!$ilike`, `!commence avec`| le champ ne_commence pas avec_ `<value>`    |
| `like$`, `ilike$`, `se termine par`     | le champ _se termine par_ `<value>`              |
| `!like$`, `!ilike$`, `!se termine avec`  | le champ ne_se termine pas par_ `<value>`      |

Les opérateurs `like` et `!like` peuvent être utilisés soit en fournissant un terme de recherche, 
et dans ce cas la correspondance est toute valeur où le terme apparaît à tout endroit, soit 
en fournissant le motif de recherche en utilisant `*` comme _nombre quelconque de caractères_ 
et `?` comme _caractère unique_.

Tous les opérateurs de recherche de motifs nommés `like` sont sensibles à la casse. Tous les autres 
sont insensibles à la casse. 

Notez que les filtres sur les valeurs d'attributs utilisent une comparaison basée sur le texte, ce qui signifie que 
tous les filtres textuels sont pris en charge.

Par exemple, pour ne répertorier que les organisations de deuxième niveau, utilisez

    /api/organisationUnits/gist?filter=level:eq:2

De même, lorsqu'il s'agit de lister les `enfants` d'une unité d'organisation particulière, la 
collection peut être filtrée. Pour ne lister que les enfants qui sont connectés à
à un programme, on peut utiliser:

    /api/organisationUnits/rZxk3S0qN63/children/gist?filter=programs:gt:0

Opérateurs binaires pour le filtrage basé sur l'accès (le partage) :

| Opérateur binaire   | Description                                              |
| ----------------- | -------------------------------------------------------- |
| `peutLire`         | L'utilisateur `<value>` de métadonnées a t'il le droit de consulter l'objet |
| `peutModifier`        | L'utilisateur `<value>` de métadonnées a t-il le droit de modifier l'objet ? |
| `peut Lire les données`     | L'utilisateur `<value>` des données a t'il le droit de consulter l'objet    |
| `peutModifier les données`    | L'utilisateur `<value>` des données a t-il le droit de modifier l'objet ?   |
| `peutAccéder`       | L'utilisateur a t'il la `<value0>` permission `<value1>` d'accéder à l'objet   |

Lorsque l'identifiant de l'utilisateur `<value>` est omis, la vérification est effectuée pour 
l'utilisateur actuellement connecté. De même, si `<value0>` est omis pour le filtre `peutAccéder`, 
la vérification est effectuée pour l'utilisateur actuellement connecté.

Lorsqu'il est appliqué à une propriété de valeur simple, ici `code`, le filtre limite la réponse à 
ces  éléments de données (propriétaire de l'objet) que l'utilisateur peut lire/modifier :

    /api/dataElements/gist?filter=code:canWrite:OYLGMiazHtW

Lorsqu'il est appliqué à une propriété de référence, ici `combinaison de catégories`, le filtre limite la réponse 
à ces éléments de données ayant une combinaison de catégories que l'utilisateur peut lire/modifier:

    /api/dataElements/gist?filter=categoryCombo:canWrite:OYLGMiazHtW

Lorsqu'il est appliqué à une propriété de collection de référence, ici `groupe d'éléments de données`, le 
filtre limite la réponse à ces éléments de données pour lesquels un groupe d'éléments de données existe dans la 
propriété de collection et que l'utilisateur peut lire/modifier :

    /api/dataElements/gist?filter=dataElementGroups:canWrite:OYLGMiazHtW

La fonction `peutAccéder` demande deux arguments, le premier est l'identifiant de l'utilisateur, le second le modèle d'accès,
par exemple, pour vérifier l'accès en lecture et en modification des métadonnées, le motif est `rw%` :

    /api/dataElements/gist?filter=code:canAccess:[OYLGMiazHtW,rw%]


En outre, les filtres peuvent être regroupés pour permettre de combiner les filtres sélectionnés avec 
un OU logique lorsque le combinateur de filtre général est un ET logique, ou inversement 
avec un ET logique lorsque le combinateur général est un OU logique.

Pour les groupes, le modèle de filtre est élargi comme suit :

* unary: `<group>:<field>:<operator>`
* binary: `<group>:<field>:<operator>:<value>`

The group is an arbitrary number between `0` and `9` (when omitted `0` is 
assumed). 

The behaviour is best explained with a small example for an imaginary object
type with an `age` and `name` property.

    ?filter=1:age:eq:50&filter=2:name:eq:foo&filter=2:name:eq:bar

The above filter has two groups `1` and `2`, and the `2` group has 2 members.
This is equivalent to the SQL (note the `and` and `or` as well as the 
grouping braces):

    e.age = 50 and (e.name = 'foo' or e.name = 'bar')

Now, if the same `filter`s would be used in combination with `rootJunction=OR`

    ?filter=1:age:eq:50&filter=2:name:eq:foo&filter=2:name:eq:bar&rootJunction=OR

the effect would be equivalent to the following SQL instead:

    e.age = 50 or (e.name = 'foo' and e.name = 'bar')


### The `headless` Parameter { #gist_parameters_headless } 
<!--DHIS2-SECTION-ID:gist_parameters_headless-->

Endpoints returning a list by default wrap the items with an envelope containing 
the `pager` and the list, which is named according to the type of object listed.

For example `/api/organisationUnits/gist` returns:

```json
{
  "pager": {
    "page": 1,
    "pageSize": 50,
    "nextPage": "/organisationUnits/gist?page=2"
  },
  "organisationUnits": [
    ...
  ]
}
```

With `headless=true` the response to `/api/organisationUnits/gist?headless=true` 
is just the `[...]` list part in above example.


### The `inverse` Parameter { #the-inverse-parameter } 
The `inverse` can be used in context of a collection field gist of the form 
`/api/<object-type>/<object-id>/<field-name>/gist` to not list all items that
are contained in the member collection but all items that are **not** contained
in the member collection.

For example, while 

    /api/organisationUnits/rZxk3S0qN63/children/gist

would list all organisation units that are children of `rZxk3S0qN63` the inverse

    /api/organisationUnits/rZxk3S0qN63/children/gist?inverse=true

would list all organisation units that are not children of `rZxk3S0qN63`. 
This would e.g. be used to compose a list of all units that can be made a child 
of a particular unit.

Filters and orders do apply normally, meaning they filter or order the items
not contained in the member collection.


### The `locale` Parameter { #gist_parameters_locale } 
<!--DHIS2-SECTION-ID:gist_parameters_locale-->
The `locale` parameter is usually used for testing purposes to ad-hoc switch 
translation language of display names. 

If not specified the translation language is the one configured in the users
account settings.

Examples:

    /api/organisationUnits/gist?locale=en
    /api/organisationUnits/gist?locale=en_GB

### The `order` Parameter { #gist_parameters_order } 
<!--DHIS2-SECTION-ID:gist_parameters_order-->

To sort the list of items one or more order expressions can be given.

An order expression is either just a field name of a persisted field, or a field
name followed by `:asc` (ascending order - the default) or `:desc` 
(descending order).

For example, to sort organisation units alphabetically by name use:

    /api/organisationUnits/gist?order=name

Reverse alphabetical order would use:

    /api/organisationUnits/gist?order=name:desc

To sort organisation units first by level, then by name use:

    /api/organisationUnits/gist?order=level,name

This would start with root(s) at level 1. To start with the leaf units use:

    /api/organisationUnits/gist?order=level:desc,name

If no order is specified the result list will have a stable order based on 
internal data organisation.


### The `page` Parameter { #gist_parameters_page } 
<!--DHIS2-SECTION-ID:gist_parameters_page-->

Refers to the viewed page in paged list starting with `1` for the first page.

If no `page` parameter is present this is equal to `page=1`.

The `page` is always in relation to the `pageSize`.
If a `page` is given beyond the number of existing matches an empty item list
is returned.


### The `pageSize` Parameter { #gist_parameters_pageSize } 
<!--DHIS2-SECTION-ID:gist_parameters_pageSize-->

Refers to the number of items on a `page`. Maximum is 1000 items.

If no `pageSize` parameter is present this is equal to `pageSize=50`.


### The `rootJunction` Parameter { #gist_parameters_rootJunction } 
<!--DHIS2-SECTION-ID:gist_parameters_rootJunction-->

The `rootJunction` parameter can be used to explicitly set the logic junction
used between filters. Possible are:

* `AND`: all filters have to match an entry for it to be included in the results
* `OR`: any of the filters matches an entry for it to be included in the results

Default is `AND`.


### The `total` Parameter { #gist_parameters_total } 
<!--DHIS2-SECTION-ID:gist_parameters_total-->

By default, a gist query will **not** count the total number of matches should 
those exceed the `pageSize` limit. Instead, we opt-in to the additional costs
the total count implicates.

When not counting the total matches (`total=false`) the response `pager` will
assume that there is a `next` page in case `pageSize` items were found. This
could however turn out to be false when browsing to the page. Also, the `total`
field stating the number of total matches is not included in the `pager`.

For example, `/api/organisationUnits/gist` returns a `pager`:

```json
{
  "pager": {
    "page": 1,
    "pageSize": 50,
    "nextPage": "/organisationUnits/gist?page=2"
  }
}
```

When counting the total matches (`total=true`) the response `pager` will 
contain the `total` field with the actual number of total matches at the cost
of an additional database operation.

The response to `/api/organisationUnits/gist?total=true` now returns this `pager`:

```json
{
  "pager": {
    "page": 1,
    "pageSize": 50,
    "total": 1332,
    "nextPage": "/organisationUnits/gist?total=true&page=2",
    "pageCount": 27
  }
}
```


### The `translate` Parameter { #gist_parameters_translate } 
<!--DHIS2-SECTION-ID:gist_parameters_translate-->

Fields like `name` or `shortName` can be translated (internationalised).

By default, any translatable field that has a translation is returned translated
given that the user requesting the gist has an interface language configured.

To return the plain non-translated field use `translate=false`.

For example, `/api/organisationUnits/gist` returns items like this:

```json
{
  "name": "A translated name",
  ...
}
```

Whereas `/api/organisationUnits/gist?translate=false` would return items like:

```json
{
  "name"
  "Plain field name",
  ...
}
```

Note that synthetic fields `displayName` and `displayShortName` are always
returning the translated value independent of the `translate` parameter.


## Fields { #gist_fields } 
<!--DHIS2-SECTION-ID:gist_fields-->

The fields included by default (without `fields` parameter) correspond to 
`fields=*`. 
This means the list of fields shown depends on object type, endpoint context as 
well as the `auto` parameter.

Note that the `/gist` API always excludes certain fields that usually are of no 
interest to clients, like for example the `translations` or `sharing` fields. 
These can be added explicitly.

When not explicitly provided by name in the `fields` parameters the list of 
fields is computed from a preset.
A preset can be used in the list of fields like a field name. 
It expands to zero, one or many fields depending on the object type, used 
endpoint and selector.


### Field Presets { #field-presets } 

* `*` / `:all`: default fields depend on the context and `auto` parameter
* `:identifiable`: all persisted fields of the `IdentifiableObject` interface
* `:owner`: all persisted fields where the listed type is the owner
* `:nameable`: all persisted fields of the `NameableObject` interface
* `:persisted`: literally all persisted fields


### Field Transformers { #field-transformers } 
A transformer or transformation can be applied to a field by appending 
any of the indicators `::`, `~` or `@` followed by the transformer expression.

Available transformer expressions are:

| Transformer        | JSON Result Type    | Description                       |
| ------------------ | ------------------- | --------------------------------- |
| `rename(<name>)`   | -                   | renames the field in the response to `<name>` |
| `size`             | `number`            | number of items in the collection field |
| `isEmpty`          | `boolean`           | emptiness of a collection field   |
| `isNotEmpty`       | `boolean`           | non-emptiness of a collection field |
| `identifiants`              | `string` or `[string]` | ID of an object or IDs of collection items |
| `id-objects`       | `[{ "identifiant": <id> }]`  | IDs of collection items as object |
| `member(<id>)`     | `boolean`           | has member with `<id>` for collection field |
| `not-member(<id>)` | `boolean`           | not has member with `<id>` for collection field |
| `pluck(<field>)`   | `string` or `[string]` | extract single text property of the object or of each collection item |
| `de(<field>,...)`| depends on bean type | extracts a non-persistent field from one or more persistent ones |

A field can receive both the `rename` transformer and one of the other 
transformers, for example:

    /api/organisationUnits/gist?fields=*,children::size~rename(child-count)

The returned items now no longer have a `children` member but a `child-count`
member instead. Note that `rename` also affects the member name of the URI
reference given in `apiEndpoints`.

The `from` transformation can be used with one or more persistent fields as
parameter. These will be loaded from the database, set in an instance of the 
listed element object before the non-persistent property transformed with 
`from` is extracted from that instance by calling the getter. This allows to 
extract derived fields while using the same logic that is used in usual metadata API.

For example, a user's (non-persistent property) `name` is composed of the 
persistent property `firstName` and `surname`. It can be fetched like this:

    /api/users/gist?fields=id,name~from(firstName,surname)

Since a user's name is such a common case an auto-detection was added so that in
this special case the `from` transformation is added automatically to `name`.
We are allowed to just use the following which internally adds the `from` 
transformation:

    /api/users/gist?fields=id,name

While this makes non-persistent properties accessible in general these always 
have to be included in the `fields` explicitly. For a user this could be 
done using the following:

    /api/users/gist?fields=*,name


## Synthetic Fields { #gist_syntheticFields } 
<!--DHIS2-SECTION-ID:gist_syntheticFields-->

The `/gist` API is tightly coupled to properties that exist the database.
This means properties that aren't stored in the database usually aren't 
available.
The exception to this are the "synthetic" properties which are dynamically 
computed on the basis of one or more database stored properties.

Synthetic properties are available for all endpoints where the persisted 
properties needed to compute the synthetic property exist.

Except for the `apiEndpoints` property which is automatically added when needed 
all other synthetic properties are not included by default and have to be 
requested explicitly in the list of `fields`.


### Aperçu { #overview } 
Synthetic fields in alphabetical order:

| Champ              | Description                                             |
| ------------------ | ------------------------------------------------------- |
| `apiEndpoints`     | contains links to browse nested complex objects or collections |
| `href`             | link to the list item itself (single item view)         |
| `displayName`      | translated `name` (always translated)                   |
| `displayShortName` | translated `shortName` (always translated)              |
| `accès`           | summary on ability of current user to read/write/modify the entry |


### The `href` Field { #gist_syntheticFields_href } 
<!--DHIS2-SECTION-ID:gist_syntheticFields_href-->

Each item in a `/gist` response can link to itself. This link is given in the 
`href` property.

To add the `href` field use (for example):

    /api/<object-type>/gist?fields=*,href

### The `displayName` and `displayShortName` Field { #gist_syntheticFields_displayName } 
<!--DHIS2-SECTION-ID:gist_syntheticFields_displayName-->

By definition the `displayName` is the translated `name` and the 
`displayShortName` is the translated `shortName`. 

To add `displayName` or `displayShortName` add it to the list use (for example):

    /api/<object-type>/gist?fields=*,displayName
    /api/<object-type>/gist?fields=*,displayShortName

Note that by default all translatable properties like `name` and `shortName` 
would also be translated. When `translate=false` is used to disable this 
`displayName` and `displayShortName` stay translated.


### The `apiEndpoints` Field { #gist_syntheticFields_apiEndpoints } 
<!--DHIS2-SECTION-ID:gist_syntheticFields_apiEndpoints-->

This property provides the links to further browse complex objects or list of 
items that are included in the `/gist` response in form of a transformed simple 
value like an item count.

The `apiEndpoints` object will have a member of the same name for every member 
in the item that was transformed to a simple value.

Par exemple, 

    /api/users/gist?fields=id,userGroups::size,organisationUnits::size 

returns items in the form:

```json
{
  "id": "rWLrZL8rP3K",
  "userGroups": 0,
  "organisationUnits": 1,
  "apiEndpoints": {
    "organisationUnits": "/users/rWLrZL8rP3K/organisationUnits/gist",
    "userGroups": "/users/rWLrZL8rP3K/userGroups/gist"
  }
}
```

The list of `userGroups` and `organisationUnits` are included as their `size`. 
Each has a corresponding member in `apiEndpoints` with the path to browse the 
list.

The paths can be changed to URLs by using the `absoluteUrls` parameter. 

    /api/users/gist?fields=id,userGroups::size,organisationUnits::size&absoluteUrls=true

returns items in the form:

```json
{
  "id": "rWLrZL8rP3K",
  "userGroups": 0,
  "organisationUnits": 1,
  "apiEndpoints": {
    "organisationUnits": "http://{host}/api/users/rWLrZL8rP3K/organisationUnits/gist?absoluteUrls=true",
    "userGroups": "http://{host}/api/users/rWLrZL8rP3K/userGroups/gist?absoluteUrls=true"
  }
}
```

### The `access` Field { #the-access-field } 
The `access` summary is based on the `sharing` and the current user.
This means it is only applicable for objects that have a `sharing` property.

For example, when listing data elements with `access` field

    /api/dataElements/gist?fields=*,access

the returned data element items contain a `"access"` member like the one below:

```json
"access": {
  "manage": false,
  "externalize": false,
  "write": false,
  "read": true,
  "update": false,
  "delete": false
}
```

### Attributes as Fields { #gist_attributeFields }
DHIS2 allows creating and adding custom attributes to metadata objects.
Their values are contained in the `attributeValues` property of a metadata 
object in form of a map with the attribute UID as the map's key.

To directly list one or more specific attribute values from this map as if they
were usual fields of the metadata object the attribute UID can be used as if it
was a name of a usual field.

For example, to include the value of the attribute with UID `Y1LUDU8sWBR` as 
the property `unit-of-measure` in the list use:

    /api/dataElements/gist?fields=id,name,Y1LUDU8sWBR::rename(unit-of-measure)

This results in list items of the form:
```json
{
  "id": "qrur9Dvnyt5",
  "name": "Age in years",
  "unit-of-measure": "years"
}
```

By default, the values are fetched as JSON and extracted from the map of 
attribute values. This means the listing will contain the proper JSON type for
the type of attribute value. This comes at the overhead of fetching all 
attribute values. To single out the value within the database the `PLUCK` 
transformation can be used.

    /api/dataElements/gist?fields=id,name,Y1LUDU8sWBR::rename(unit-of-measure)~pluck

The result will look the same but now the value is extracted as text in the 
database turning any JSON value to a string in the property output. 

## Exemples { #gist_examples } 
<!--DHIS2-SECTION-ID:gist_examples-->
A few examples starting from simple listings moving on to very specific use cases. 

It is preferable to always supply an explicit list of `fields` so this section 
will do so. 

List organisation units with id and name:

    /api/organisationUnits/gist?fields=id,name

List organisation units with id and name and total count:

    /api/organisationUnits/gist?fields=id,name&total=true

List users with id and username:

    /api/users/gist?fields=id,userCredentials.username

List users with id, username and last login date:

    /api/users/gist?fields=id,userCredentials[username,lastLogin]

List only organisation units on second level with id, name and level:

    /api/organisationUnits/gist?fields=id,name,level&filter=level:eq:2

List only organisation units that have more than 1 child with id, name and
number of children:

    /api/organisationUnits/gist?fields=id,name,children::size&filter=children:gt:1

List only organisation units that are not yet a children of another unit
`zFDYIgyGmXG`:

    /api/organisationUnits/zFDYIgyGmXG/children/gist?fields=id,name&inverse=true

List users and flag whether they are a member of a specific user group 
`NTC8GjJ7p8P` and name that field `is-member` in the response:

    /api/users/gist?fields=id,userCredentials.username,userGroups::member(NTC8GjJ7p8P)~rename(is-member)

List links to all users in pages of 10 items:

    /api/users/gist?fields=href&absoluteUrls&pageSize=10

