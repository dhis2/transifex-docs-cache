---
edit_url: "https://github.com/dhis2/dhis2-docs/blob/2.37/src/developer/web-api/metadata.md"
revision_date: '2021-11-23'
tags:
- DHIS core version 2.37
- Développement
---

# Métadonnées { #metadata } 

## Schémas d'identification { #webapi_identifier_schemes } 

This section provides an explanation of the identifier scheme concept.
Identifier schemes are used to map metadata objects to other metadata
during import, and to render metadata as part of exports. Please note
that not all schemes work for all API calls, and not all
schemes can be used for both input and output. This is outlined in the
sections explaining the various Web APIs.

Tous les types d'objets disponibles pour le schéma d'identification sont énumérés ci-dessous. Sont fournis les noms des propriétés à utiliser dans les requêtes :

  - idScheme

  - dataElementIdScheme (Schéma d'identifiant d'élément de données)

  - categoryOptionComboIdScheme (Schéma de l'identifiant de la combinaison d'options de catégorie)

  - orgUnitIdScheme (Schéma de l'identifiant de l'unité d'organisation)

  - programIdScheme (Schéma d'identification du programme)

  - programmeStageIdScheme (Schéma d'identification de l'étape de programme)

  - trackedEntityIdScheme (schéma d'identification de l'entité suivie)

  - trackedEntityAttributeIdScheme (schéma d'identification de l'attribut d'entité suivie)

Le schéma d'identification général (idScheme) s'applique à tous les types d'objets. Il peut être remplacé par des types d'objets spécifiques.

Le schéma par défaut pour tous les paramètres est UID (identifiants stables de DHIS2). Les schémas d'identification pris en charge sont décrits dans le tableau ci-dessous.

Tableau : Valeurs du schéma

| Schéma | Description |
|---|---|
| ID, UID | Correspondance avec l'identifiant permanent DHIS2. il s'agit du schéma d'identification par défaut. |
| CODE | Correspondre avec le code DHIS2, principalement utilisé pour échanger des données avec un système externe. |
| NOM | Correspondre avec le nom DHIS2. Notez que c'est l'élément disponible en tant que *object.name* (nom de l'objet) qui est utilisé, et non le nom traduit. Notez également que les noms ne sont pas toujours uniques et que, dans ce cas, ils ne peuvent pas être utilisés. |
| ATTRIBUT:ID | Correspondre avec l'attribut de métadonnées. Cet attribut doit être assigné au type avec lequel vous établissez la correspondance, d'autant plus que la propriété unique est définie sur  *true*. Cette fonctionnalité permet principalement d'échanger des données avec des systèmes externes. Il présente certains avantages par rapport à *CODE* puisque plusieurs attributs peuvent être ajoutés. Il peut donc se synchroniser avec plus d'un système. |

Note that identifier schemes is not an independent feature but needs to
be used in combination with resources such as data value import and metadata import.

Par exemple, pour spécifier CODE comme schéma d'identification général et le remplacer par UID pour le schéma d'identification de l'unité d'organisation, vous pouvez utiliser les requêtes suivantes : 

    ?idScheme=CODE&orgUnitIdScheme=UID

Autre exemple, pour spécifier un attribut pour le schéma d'identification de l'unité d'organisation, un code pour le schéma d'identification de l'élément de données et utiliser le schéma d'identification par défaut UID pour tous les autres objets, vous pouvez utiliser les paramètres suivants :

    ?orgUnitIdScheme=ATTRIBUTE:j38fk2dKFsG&dataElementIdScheme=CODE

## Navigation dans l'API Web { #webapi_browsing_the_web_api } 

Le point d'entrée pour naviguer dans l'API Web est `/api`. Cette ressource fournit des liens vers toutes les ressources disponibles. Quatre formats de représentation sont systématiquement disponibles pour toutes les ressources : HTML, XML, JSON et JSONP. D'autres formats sont disponibles pour des ressources comme MS Excel, PDF, CSV et PNG. Pour explorer l'API à partir d'un navigateur web, accédez au point d'entrée `/api` et suivez les liens vers la ressource que vous recherchez, par exemple `/api/dataElements`. Pour toutes les ressources qui renvoient une liste d'éléments, certains paramètres de requête peuvent être utilisés pour modifier la réponse :

Tableau : Paramètres de requête

| Param | Valeurs des options | Option par défaut | Description |
|---|---|---|---|
| pagination | vrai &#124; faux | vrai | Indique s'il faut renvoyer les listes d'éléments sous forme de pages. |
| page | nombre | 1 | Définit le numéro de page à renvoyer. |
| taille de la page | nombre | 50 | Définit le nombre d'éléments à renvoyer pour chaque page. |
| Ordre | property:asc/iasc/desc/idesc || Permet d'ordonner la sortie dans un ordre précis. Seules les propriétés conservées et simples (pas de collections, objets d'identification, etc.) sont prises en charge. iasc et idesc sont insensibles à la casse. |

Voici un exemple de comment ces paramètres peuvent être utilisés pour obtenir une liste complète de groupes d'éléments de données dans un format de réponse XML :

    /api/dataElementGroups.xml?links=false&paging=false

Vous pouvez rechercher des éléments à partir de la propriété "nom" au lieu de renvoyer toute une liste d'éléments à l'aide de la variable de requête *query*. Dans cet exemple, nous recherchons tous les éléments de données dont le nom contient le mot "anémie" :

    /api/dataElements?query=anaemia

Vous pouvez obtenir des pages spécifiques et des tailles de page pour des objets en utilisant la requête suivante :

    /api/dataElements.json?page=2&pageSize=20

Vous pouvez désactiver complètement la pagination à l'aide de cette requête :

    /api/indicatorGroups.json?paging=false

Pour que le résultat soit ordonné selon une propriété spécifique :

    /api/indicators.json?order=shortName:desc

La ressource *identifiableObjects* vous permet de rechercher tout objet à partir de son identifiant, quel que soit son type :

    /api/identifiableObjects/<id>

### Traduction { #webapi_translation } 

DHIS2 propose des traductions pour le contenu de la base de données, notamment les éléments de données, les indicateurs et les programmes. Tous les objets de métadonnées qui figurent dans l'API Web ont des propriétés destinées à être utilisées pour l'affichage et l'interface utilisateur. Il s'agit entre autres de *displayName* (nom d'affichage), *displayShortName* (nom d'affichage court), *displayDescription* (description de l'affichage) et *displayFormName* (nom du formulaire d'affichage). Ces propriétés sont utilisées pour les éléments de données et les attributs d'entités suivies.

Tableau : Options de traduction

| Paramètre | Valeurs | Description |
|---|---|---|
| traduction | vrai &#124; faux | Traduire les propriétés display\* dans les sorties de métadonnée (displayName, displayShortName, displayDescription, et displayFormName pour les éléments de données et les attributs d'entités suivies). La valeur par défaut est "true". |
| emplacement | Emplacement à utiliser | Traduire les métadonnées dans une langue donnée (nécessite que la traduction soit définie sur 'vrai'). |

### API de traduction { #webapi_translation_api } 

Les traductions d'un objet sont rendues comme faisant partie de l'objet lui-même dans le tableau *traductions*. Le tableau *traductions* qui figure dans les charges JSON/XML est normalement préfiltré pour vous, ce qui signifie qu'il ne peut pas être utilisé directement pour importer/exporter des traductions (car cela aurait pour effet de remplacer les langues autres que celles des utilisateurs actuellement connectés).

Exemple d'élément de données dont le tableau de traduction est filtré sur la langue de l'utilisateur :

```json
{
  "id": "FTRrcoaog83",
  "displayName": "Accute French",
  "translations": [
    {
      "property": "SHORT_NAME",
      "locale": "fr",
      "value": "Accute French"
    },
    {
      "property": "NAME",
      "locale": "fr",
      "value": "Accute French"
    }
  ]
}
```

Exemple d'élément de données dont les traductions sont désactivées :

```json
{
  "id": "FTRrcoaog83",
  "displayName": "Accute Flaccid Paralysis (Deaths < 5 yrs)",
  "translations": [
    {
      "property": "FORM_NAME",
      "locale": "en_FK",
      "value": "aa"
    },
    {
      "property": "SHORT_NAME",
      "locale": "en_GB",
      "value": "Accute Flaccid Paral"
    },
    {
      "property": "SHORT_NAME",
      "locale": "fr",
      "value": "Accute French"
    },
    {
      "property": "NAME",
      "locale": "fr",
      "value": "Accute French"
    },
    {
      "property": "NAME",
      "locale": "en_FK",
      "value": "aa"
    },
    {
      "property": "DESCRIPTION",
      "locale": "en_FK",
      "value": "aa"
    }
  ]
}
```

Notez que même si vous obtenez un résultat non filtré, et que vous utilisez le type de point d'extrémité approprié, c'est-à-dire `/api/dataElements`, nous n'autorisons pas les mises à jour, car cela pourrait facilement entraîner des erreurs et remplacer les autres langues disponibles.

Pour lire et mettre à jour les traductions, vous pouvez utiliser le point d'extrémité spécial "traductions" pour chaque ressource d'objet. Vous pouvez y accéder en utilisant *GET* ou *PUT* sur le point d'extrémité `/api/<object-type>/<object-id>/translations` approprié.

Par exemple, pour un élément de données dont l'identifiant est  `FTRrcoaog83`, vous pouvez utiliser `/api/dataElements/FTRrcoaog83/translations` pour obtenir les traductions et les mettre à jour. Les champs disponibles sont `property` avec les options *NOM*, *NOM_COURT*, *NOM DU_FORMULAIRE*, *DESCRIPTION*, `locale` qui prend en charge tout ID de langue valide et la propriété traduite `value`.

Exemple de propriété NOM pour la langue française :

```json
{
  "property": "NAME",
  "locale": "fr",
  "value": "Paralysie Flasque Aiguë (Décès <5 ans)"
}
```

Cette charge est ensuite ajoutée à un tableau de traduction et renvoyée au point d'extrémité approprié :

```json
{
  "translations": [
    {
      "property": "NAME",
      "locale": "fr",
      "value": "Paralysie Flasque Aiguë (Décès <5 ans)"
    }
  ]
}
```

Pour un élément de données dont l'ID est *FTRrcoaog83*, vous pouvez effectuer une requête *PUT* comme suit : `/api/dataElements/FTRrcoaog83/translations`. Assurez-vous d'envoyer toutes les traductions disponibles pour cet objet et pas seulement pour une langue (sinon vous risquez de remplacer les langues existantes par d'autres langues).

### Versions de l'API Web { #webapi_api_versions } 

L'API Web est versionnée à partir de DHIS 2.25. La version de l'API suit la numérotation des versions majeures de DHIS2. Par exemple, la version de l'API pour DHIS 2.33 est `33`.

Vous pouvez accéder à une version spécifique de l'API en incluant le numéro de version après `/api`, comme dans l'exemple suivant :

    /api/33/dataElements

Si vous omettez la partie version de l'URL, le système utilisera la version actuelle de l'API. Par exemple, pour DHIS 2.25, si vous omettez la partie de l'API, le système utilisera la version 25 de l'API. Lors du développement de clients API, il est recommandé d'utiliser des versions API explicites (plutôt que d'omettre la version de l'API), car cela protégera le client contre les modifications imprévues de l'API.

Les trois dernières versions de l'API seront prises en charge. Par exemple, la version 2.27 de DHIS va prendre en charge les versions 27, 26 et 25 de l'API.

Notez que le modèle de métadonnées n'est pas versionné et que des changements peuvent survenir, par exemple dans les associations entre objets. Ces changements seront documentés dans les notes de mise à jour de la version principale de DHIS2.

## Filtre sur les objets de métadonnées { #webapi_metadata_object_filter } 

To filter the metadata there are several filter operations that can be
applied to the returned list of metadata. The format of the filter
itself is straight-forward and follows the pattern
*property:operator:value*, where *property* is the property on the
metadata you want to filter on, *operator* is the comparison operator
you want to perform and *value* is the value to check against (not all
operators require value). Please see the *schema* section to discover
which properties are available. Recursive filtering, ie. filtering on
associated objects or collection of objects, is supported as well.

Tableau : Opérateurs disponibles

| Opérateur | Les types | Valeur requise | Description |
|---|---|---|---|
| eq | chaîne | booléen | entier | flottant | énumération | collection (vérification de la taille) | date | vrai | Égalité |
| !eq | chaîne | booléen | entier | flottant | énumération | collection (vérification de la taille) | date | vrai | Inégalité |
| ne | chaîne | booléen | entier | flottant | énumération | collection (vérification de la taille) | date | vrai | Inégalité |
| like | chaîne | vrai | Chaîne sensible à la casse ; peut correspondre avec tout élément |
| !like | chaîne | vrai | Chaîne sensible à la casse ; ne peut pas correspondre avec tous les éléments |
| $like | chaîne | vrai | Chaîne sensible à la casse ; début de la correspondance |
| !$like | chaîne | vrai | Chaîne sensible à la casse, pas de début de correspondance |
| like$ | chaîne | vrai | Chaîne sensible à la casse ; fin de la correspondance |
| !like$ | chaîne | vrai | Case sensitive string, not match end |
| ilike | chaîne | vrai | Chaîne insensible à la casse ; peut correspondre avec tout élément |
| !ilike | chaîne | vrai | Chaîne insensible à la casse ; ne peut pas correspondre avec tous les éléments |
| $ilike | chaîne | vrai | Chaîne insensible à la casse ; début de la correspondance |
| !$ilike | chaîne | vrai | Chaîne insensible à la casse, pas de début de correspondance |
| ilike$ | chaîne | vrai | Case insensitive string, match end |
| !ilike$ | chaîne | vrai | Case insensitive string, not match end |
| gt | chaîne | booléen | entier | flottant | collection (vérification de la taille) | date | vrai | Supérieure à |
| ge | chaîne | booléen | entier | flottant | collection (vérification de la taille) | date | vrai | Supérieur ou égal |
| lt | chaîne | booléen | entier | flottant | collection (vérification de la taille) | date | vrai | Inférieur à |
| le | chaîne | booléen | entier | flottant | collection (vérification de la taille) | date | vrai | inférieur ou égal |
| nulle | tous | faux | La propriété est nulle |
| !null | tous | faux | La propriété n'est pas nulle |
| vide | collection | faux | La collection est vide |
| jeton | chaîne | vrai | Match on multiple tokens in search property |
| !token | chaîne | vrai | Not match on multiple tokens in search property |
| recherche | chaîne | booléen | entier | flottant | date | vrai | Find objects matching 1 or more values |
| !in | chaîne | booléen | entier | flottant | date | vrai | Find objects not matching 1 or more values |

Operators will be applied as logical *and* query, if you need a *or*
query, you can have a look at our *in* filter (also have a look at the
section below). The filtering mechanism allows for recursion. See below
for some examples.

Obtenir des éléments de données avec la propriété ID1 ou ID2 :

    /api/dataElements?filter=id:eq:ID1&filter=id:eq:ID2

Get all data elements which have the dataSet with id ID1:

    /api/dataElements?filter=dataSetElements.dataSet.id:eq:ID1

Get all data elements with aggregation operator "sum" and value type
"int":

    /api/dataElements.json?filter=aggregationOperator:eq:sum&filter=type:eq:int

You can do filtering within collections, e.g. to get data elements which
are members of the "ANC" data element group you can use the following
query using the id property of the associated data element groups:

    /api/dataElements.json?filter=dataElementGroups.id:eq:qfxEYY9xAl6

Étant donné que tous les opérateurs sont *et* par défaut, vous ne pouvez pas trouver un élément de données correspondant à plus d'un identifiant. Pour ce faire, vous pouvez utiliser l'opérateur *dans*.

    /api/dataElements.json?filter=id:in:[fbfJHSPpUQD,cYeuwXTCPkU]

### Opérateurs logiques { #webapi_metadata_logical_operator } 

Comme indiqué dans la section précédente, l'opérateur logique par défaut appliqué aux filtres est *ET*, ce qui signifie que tous les filtres d'objets doivent trouver une correspondance. Cependant, dans certains cas, l'utilisateur peut vouloir utiliser un seul filtre parmi plusieurs (par exemple le champ de l'identifiant et du code). Dans ce cas, il est possible de changer l'opérateur logique racine de *ET* à *OU* à l'aide du paramètre *rootJunction*.

Exemple : Filtrage normal où l'identifiant et le code doivent correspondre pour que le résultat soit renvoyé.

    /api/dataElements.json?filter=id:in:[id1,id2]&filter=code:eq:code1

Exemple : Filtrage où l'opérateur logique a été remplacé par OU, ce qui fait qu'un seul des filtres doit trouver une correspondance pour que le résultat soit renvoyé.

    /api/dataElements.json?filter=id:in:[id1,id2]&filter=code:eq:code1&rootJunction=OR

### Identifiable token filter { #identifiable-token-filter } 

Outre le filtrage spécifique basé sur les propriétés mentionné ci-dessus, nous disposons également d'un filtrage *ET* basé sur *token* à travers un ensemble de propriétés : identifiant, code et nom (ainsi que 'nom court' s'il est disponible). Ces propriétés sont généralement appelées *identifiables*. L'idée est de filtrer les métadonnées dont l'identifiant, le nom, le code ou le nom court contiennent des informations.

Exemple : Filtrage de tous les éléments de données contenant *2em* dans l'un des éléments suivants : identifiant, nom, code et nom court.

    /api/dataElements.json?filter=identifiable:token:2nd

Il est également possible de spécifier plusieurs valeurs de filtrage.

Exemple : Obtenir tous les éléments de données où *visite CPN* se trouve dans l'une des propriétés *identifiables*. Le système renvoie tous les éléments de données dans lesquels les deux unités lexicales (CPN et visite) se trouvent quelque part dans les propriétés identifiables.

    /api/dataElements.json?filter=identifiable:token:ANC visit

Il est également possible de combiner le filtre identifiable avec le filtre basé sur les propriétés et de s'attendre à ce que le paramètre *rootJunction* soit appliqué.

    /api/dataElements.json?filter=identifiable:token:ANC visit&filter=displayName:ilike:tt1

    /api/dataElements.json?filter=identifiable:token:ANC visit
      &filter=displayName:ilike:tt1&rootJunction=OR

## Metadata field filter { #webapi_metadata_field_filter } 

In many situations, the default views of the metadata can be too
verbose. A client might only need a few fields from each object and want
to remove unnecessary fields from the response. To discover which fields
are available for each object please see the *schema* section.

The format for include/exclude allows for infinite recursion. To filter
at the "root" level you can just use the name of the field,
i.e. `?fields=id,name` which would only display the `id` and
`name` fields for every object. For objects that are either collections or
complex objects with properties on their own, you can use the format
`?fields=id,name,dataSets[id,name]` which would return `id`, `name` of
the root, and the `id` and `name` of every data set on that object.
Negation can be done with the exclamation operator, and we have a set of
presets of field select. Both XML and JSON are supported.

**Exemple** : Obtenir l'`id` et le `nom` à partir de la ressource d'indicateurs :

    /api/indicators?fields=id,name

**Example**: Get `id` and `name` from dataElements, and `id` and `name`
from the dataSets on dataElements:

    /api/dataElements?fields=id,name,dataSets[id,name]

Pour exclure un champ de la sortie, vous pouvez utiliser l'opérateur d'exclamation `!`. Ceci est autorisé à n'importe quel emplacement dans la requête et cette propriété ne sera pas incluse tout simplement car elle pourrait avoir été insérée dans des options prédéfinies.

Quelques options prédéfinies (groupes de champs sélectionnés) sont disponibles et peuvent être appliqués à l'aide de l'opérateur `:`.

Tableau : Opérateurs de propriété

| Opérateur | Description |
|---|---|
| <field-name\> | Inclure la propriété avec le nom, si possible. |
| <object\>[<field-name\>, ...] | Inclut un champ dans une collection (qui s'appliquera à tous les objets de cette collection) ou dans un seul objet. |
| !<field-name\>, <object\>[!<field-name\> | Le nom du champ est exclu. Cet opérateur fonctionne également à l'intérieur des objets/collections. Vous pouvez l'utiliser avec une option prédéfinie pour inclure des champs. |
| \*, <object\>[\*] | Inclut tous les champs d'un objet spécifique. S'il est appliqué à une collection, tous les champs de tous les objets de cette collection seront inclus. |
| :<preset\> | Alias pour sélectionner plusieurs champs. Trois paramètres prédéfinis sont actuellement disponibles ; le tableau ci-dessous en fournit les descriptions. |

Tableau : Paramètres prédéfinies des champs

| Paramètre prédéfini | Description |
|---|---|
| tous | Tous les champs de l'objet |
| \* | Alias pour tous |
| identifiable | Inclut les champs pour l'identifiant, le nom, le code, la date de création et de la dernière mise à jour. |
| nommable | Inclut les champs pour l'identifiant, le nom, le nom court, le code, la description, la date de création et de la dernière mise à jour. |
| conservé | Renvoie toutes les propriétés conservées sur un objet ; ne tient pas compte du fait que l'objet soit le propriétaire de la relation ou non. |
| propriétaire | Renvoie toutes les propriétés conservées pour un objet, dans un contexte où cet objet est propriétaire de toutes les propriétés. Cette charge peut être utilisée pour effectuer une mise à jour via l'API. |

**Example**: Include all fields from dataSets except organisationUnits:

    /api/dataSets?fields=:all,!organisationUnits

**Exemple** : Inclure uniquement l'identifiant, le nom et la collection d'unités d'organisation d'un ensemble de données, mais exclure l'identifiant des unités d'organisation :

    /api/dataSets/BfMAe6Itzgt?fields=id,name,organisationUnits[:all,!id]

**Exemple** : Inclure les propriétés nommables de tous les indicateurs :

    /api/indicators.json?fields=:nameable

### Transformateurs de champ { #webapi_field_transformers } 

In DHIS2.17 we introduced field transformers, the idea is to allow
further customization of the properties on the server-side.

    /api/dataElements/ID?fields=id~rename(i),name~rename(n)

La propriété *id* sera renommée *i* et la propriété *nom* sera renommée *n*.

Multiple transformers can be used by repeating the transformer syntax:

    /api/dataElementGroups.json?fields=id,displayName,dataElements~isNotEmpty~rename(haveDataElements)

Tableau : Transformateurs disponibles

| Nom | Arguments | Description |
|---|---|---|
| taille || Donne la taille des chaînes (longueur) et des collections |
| isEmpty (est vide) || La chaîne ou la collection est vide |
| isNotEmpty (n'est pas vide) || La chaîne ou la collection n'est pas vide |
| renommer | Arg1 : nom | Renomme la propriété |
| pagination | Arg1 : page,Arg2 : taille de la page | Pages a collection, default pageSize is 50. |
| pluck | Arg1 facultatif : fieldName (nom du champ) | Convertit un tableau d'objets en un tableau comprenant un champ sélectionné de cet objet. Par défaut, le premier champ renvoyé par la collection est utilisé (normalement l'ID). |

#### Exemples { #webapi_field_transformers_examples } 

Examples of transformer usage.

```
/api/dataElements?fields=dataSets~size

/api/dataElements?fields=dataSets~isEmpty

/api/dataElements?fields=dataSets~isNotEmpty

/api/dataElements/ID?fields=id~rename(i),name~rename(n)

/api/dataElementGroups?fields=id,displayName,dataElements~paging(1;20)

# Include array with IDs of organisation units:
/api/categoryOptions.json?fields=id,organisationUnits~pluck

# Include array with names of organisation units (collection only returns field name):
/api/categoryOptions.json?fields=id,organisationUnits~pluck[name]
```

## Création, lecture, mise à jour, suppression et validation de métadonnées { #webapi_metadata_crud } 

Toutes les entités de métadonnées dans DHIS2 ont leur propre point d'extrémité API qui prend en charge les opérations *CRUD* (création, lecture, mise à jour et suppression). Les URL des points d'extrémité suivent le format suivant :

    /api/<entityName>

Le _nom de l'entité_ utilise la notation camel case. Par exemple, le point d'extrémité pour les _éléments de données_ est :

    /api/dataElements

### Création et mise à jour des paramètres { #webapi_metadata_create_update } 

Les paramètres de requête suivants sont disponibles pour tous les points d'extrémité de métadonnées.

Tableau : Filtres de requête disponibles

| Param | Type | Obligatoire | Options (par défaut en premier) | Description |
|---|---|---|---|---|
| preheatCache | booléen | faux | vrai &#124; faux | Activer/désactiver le préchauffage du cache-map. Cette option est activée par défaut. Si vous la désactivez, le temps de chargement initial de l'importateur sera beaucoup plus court (mais l'importation elle-même sera plus lente). Cette fonction est principalement utilisée lorsque vous avez un petit fichier XML/JSON à importer, et que vous ne voulez pas attendre le préchauffage du cache-map. |
| importStrategy (stratégie d'importation) | enum | faux | CRÉER_ET_METTRE À JOUR | CRÉER | METTRE À JOUR | SUPPRIMER | Stratégie d'importation à utiliser, voir ci-dessous pour plus d'informations. |
| mergeMode (mode de fusion) | enum | faux | REMPLACER, FUSIONNER | Stratégie de fusion des objets lors des mises à jour. REMPLACER va écraser la propriété avec la nouvelle valeur fournie ; FUSIONNER va définir la propriété si elle n'est pas nulle (seulement si la propriété a été fournie). |

### Création et mise à jour d'objets { #webapi_creating_updating_objects } 

Pour créer de nouveaux objets, vous devrez connaître le point d'extrémité, le format du type d'objet et vous assurer que vous disposez des autorisations nécessaires. À titre d'exemple, nous allons créer et mettre à jour une *constante*. Pour connaître le format, nous pouvons utiliser le nouveau point d'extrémité *schéma* pour obtenir la description du format. Nous allons donc commencer par l'obtention de cette information :

    http://<server>/api/schemas/constant.json

À partir de la sortie, vous pouvez voir que les autorités requises pour la création sont `F_CONSTANT_ADD`, et que les propriétés importantes sont : *nom* et *valeur*. En nous basant sur ces informations, nous pouvons créer une charge JSON et la sauvegarder dans un fichier appelé constant.json :

```json
{
  "name": "PI",
  "value": "3.14159265359"
}
```

Le même contenu qu'une charge XML :

```xml
<constant name="PI" xmlns="http://dhis2.org/schema/dxf/2.0">
  <value>3.14159265359</value>
</constant>
```

Nous sommes maintenant prêts à créer la nouvelle *constante* en envoyant une requête POST au point d'extrémité `constantes` avec la charge JSON, en utilisant le curl :

```bash
curl -d @constant.json "http://server/api/constants" -X POST
  -H "Content-Type: application/json" -u user:password
```

Exemple concret d'envoi de la constante au serveur de démonstration :

```bash
curl -d @constant.json "https://play.dhis2.org/api/constants" -X POST
  -H "Content-Type: application/json" -u admin:district
```

Si tout s'est bien passé, vous devriez obtenir le résultat suivant :

```json
{
  "status": "SUCCESS",
  "importCount": {
    "imported": 1,
    "updated": 0,
    "ignored": 0,
    "deleted": 0
  },
  "type": "Constant"
}
```

Le processus sera exactement le même pour la mise à jour, vous apportez vos modifications à la charge JSON/XML, vous trouvez l'*ID* de la constante, puis vous envoyez une requête PUT au point d'extrémité en incluant l'ID :

```bash
curl -X PUT -d @pi.json -H "Content-Type: application/json"
  -u user:password "http://server/api/constants/ID"
```

### Suppression d'objets { #webapi_deleting_objects } 

La suppression d'objets est très simple. Vous devez connaître l'*ID* et le point d'extrémité du type d'objet que vous voulez supprimer. Reprenons l'exemple de la dernière section et utilisons une *constante*. Supposons que l'identifiant soit *abc123*, tout ce que vous avez à faire est d'envoyer la requête DELETE (supprimer) au point d'extrémité + Id :

```bash
curl -X DELETE -u user:password "http://server/api/constants/ID"
```

Une suppression réussie doit renvoyer le statut HTTP 204 (pas de contenu).

### Ajout et suppression d'objets dans les collections { #webapi_adding_removing_objects_collections } 

La ressource des collections vous permet de modifier des collections d'objets.

#### Ajout ou suppression d'objets uniques{ #webapi_collections_adding_removing_single_objects } 

Pour ajouter ou supprimer des objets dans une collection d'objets, vous pouvez utiliser le modèle suivant :

    /api/{collection-object}/{collection-object-id}/{collection-name}/{object-id}

Vous devez utiliser la méthode POST pour ajouter un objet et la méthode DELETE pour le supprimer. Lorsqu'il existe une relation entre plusieurs objets, vous devez d'abord déterminer quel objet est propriétaire de la relation. Si cet objet n'est pas clairement identifiable, essayez les deux méthodes d'appel pour voir laquelle fonctionne.

Les éléments du modèle sont les suivants :

  - objet de la collection : Le type d'objets qui possède la collection que vous
    voulez modifier.

  - id de l'objet de collection : L'identifiant de l'objet qui possède la
    collection que vous voulez modifier.

  - nom de la collection : le nom de la collection que vous voulez modifier.

  - Identifiant d'objet : L'identifiant de l'objet que vous voulez ajouter ou supprimer
    de la collection.

Par exemple, pour supprimer un élément de données avec pour identifiant IDB d'un groupe d'éléments de données dont l'identifiant est IDA, vous pouvez effectuer une requête DELETE :

    DELETE /api/dataElementGroups/IDA/dataElements/IDB

Pour ajouter une option de catégorie avec pour identifiant IDB à une catégorie dont l'identifiant est IDA, vous pouvez effectuer une requête POST :

    POST /api/categories/IDA/categoryOptions/IDB

#### Ajout ou suppression de plusieurs objets { #webapi_collections_adding_removing_multiple_objects } 

Vous pouvez ajouter ou supprimer plusieurs objets d'une collection dans une même requête, en utilisant la charge suivante :

```json
{
  "identifiableObjects": [{
      "id": "IDA"
    }, {
      "id": "IDB"
    }, {
      "id": "IDC"
    }
  ]
}
```

Cette charge utile permet d'ajouter, de remplacer ou de supprimer des éléments :

*Ajouter des éléments:*

    POST /api/categories/IDA/categoryOptions

*Rempld'éléments:*

    PUT /api/categories/IDA/categoryOptions

*Supprimer des éléments :*

    DELETE /api/categories/IDA/categoryOptions

#### Ajout et suppression d'objets dans une même requête { #webapi_collections_adding_removing_objects_single_request } 

Vous pouvez ajouter et supprimer des objets d'une collection dans une même requête POST, en utilisant l'URL suivante :

    POST /api/categories/IDA/categoryOptions

Le format de la charge est le suivant :

```json
{
  "additions": [{
      "id": "IDA"
    }, {
      "id": "IDB"
    }, {
      "id": "IDC"
    }
  ],
  "deletions": [{
      "id": "IDD"
    }, {
      "id": "IDE"
    }, {
      "id": "IDF"
    }
  ]
}
```

### Validation des charges { #webapi_validating_payloads } 

DHIS 2 supports system wide validation of metadata payloads, which means
that create and update operations on the API endpoints will be checked for
valid payload before allowing changes to be made. To find out what validations
are in place for a specific endpoint, have a look at the `/api/schemas`
endpoint, i.e. to figure out which constraints a data element have, you
would go to `/api/schemas/dataElement`.

Vous pouvez également valider votre charge manuellement en l'envoyant au point d'extrémité du schéma approprié. Si vous vouliez valider la constante dans la section de création précédente, vous devriez l'envoyer comme ceci :

    POST /api/schemas/constant

Voici un exemple simple (sans validation) :

```bash
curl -X POST -d "{\"name\": \"some name\"}" -H "Content-Type: application/json"
  -u admin:district "https://play.dhis2.org/dev/api/schemas/dataElement"
```

Ce qui donnera le résultat suivant :

```json
[
   {
      "message" : "Required property missing.",
      "property" : "type"
   },
   {
      "property" : "aggregationOperator",
      "message" : "Required property missing."
   },
   {
      "property" : "domainType",
      "message" : "Required property missing."
   },
   {
      "property" : "shortName",
      "message" : "Required property missing."
   }
]
```

### Mises à jour partielles { #webapi_partial_updates } 

For our web api endpoints that deal with metadata, we support partial updates (PATCH) using the JSON Patch [standard](https://tools.ietf.org/html/rfc6902). The payload basically outlines a set of operation you want applied to a existing metadata object. For examples of JSON patch please see [jsonpatch.com](http://jsonpatch.com/), we support 3 operators: `add`, `remove` and `replace`.

Below is a few examples relevant to dhis2, please note that any update to a payload should be thought of as a HTTP PUT (i.e. any mutation must result in a valid PUT metadata payload).

The default `importReportMode` for JSON Patch is `ERRORS_NOT_OWNER` which means that if you try and update any property that is not owned by that particular object (for example trying to add a indicator group directly to an indicator) you will get an error.

As per the JSON Patch specification you must always use the mimetype `application/json-patch+json` when sending patches.

#### Exemples { #examples }

##### Mise à jour du nom et du type de valeur d'un élément de données { #update-name-and-value-type-of-data-element } 

```
PATCH /api/dataElements/{id}
```

```json
[
  {"op": "add", "path": "/name", "value": "New Name"},
  {"op": "add", "path": "/valueType", "value": "INTEGER"}
] 
```

##### Ajout d'un nouvel élément de données à un groupe d'éléments de données { #add-new-data-element-to-a-data-element-group } 

```
PATCH /api/dataElementGroups/{id}
```

```json
[
  {"op": "add", "path": "/dataElements/-", "value": {"id": "data-element-id"}}
]
```

##### Suppression de toutes les associations d'éléments de données d'un groupe d'éléments de données { #remove-all-data-element-associations-from-a-data-element-group } 

```
PATCH /api/dataElementGroups/{id}
```

```json
[
  {"op": "remove", "path": "/dataElements"}
]
```

##### Modification du domaine et du type de valeur d'un élément de données { #change-domain-and-value-type-of-a-data-element } 

```
PATCH /api/dataElements/{id}
```

```json
[
    {"op": "add", "path": "/domainType", "value": "TRACKER"},
    {"op": "add", "path": "/valueType", "value": "INTEGER"}
]
```

##### Suppression d'une unité d'organisation spécifique d'un groupe d'unité d'organisation { #remove-a-specific-orgunit-from-an-orgunit-group } 

```
PATCH /api/organisationUnitGroups/{id}
```

```json
[
  {"op": "remove", "path": "/organisationUnits/1"}
]
```


## Exportation de métadonnées { #webapi_metadata_export } 

Cette section décrit l'API de métadonnées qui est disponible ici : `/api/metadata`. Les représentations des ressources XML et JSON sont prises en charge.

    /api/metadata

Les paramètres les plus courants sont décrits dans le tableau "Paramètres d'exportation" ci-dessous. Vous pouvez également appliquer ceci à tous les types disponibles en utilisant `type:fields=<filter>` et `type:filter=<filter>`. Vous pouvez également activer/désactiver l'exportation de certains types à travers ceci : `type=true|false`.

Tableau : Paramètres d'exportation

| Nom | Options | Description |
|---|---|---|
| champs | Identique au filtre du champ de métadonnées | Filtre de champ par défaut à appliquer pour tous les types, la valeur par défaut est `:owner`. |
| filtre | Identique au filtre des objets de métadonnées | Filtre d'objets par défaut à appliquer pour tous les types. La valeur par défaut est `:none` (aucun). |
| Ordre | Identique à l'ordre des métadonnées | Ordre par défaut à appliquer à tous les types. La valeur par défaut est `name` si un nom est disponible, ou `created` sinon. |
| traduction | faux/vrai | Permet les traductions. Cette fonction est désactivée par défaut (dans d'autres points d'extrémité, elle est activée par défaut). |
| emplacement | <locale\> | Permet de passer de la langue de l'utilisateur à la langue que vous définissez. |
| defaults | INCLURE/EXCLURE | Permet de déterminer si l'objet de catégorie généré automatiquement doit être inclus ou non dans la charge. Si vous déplacez des métadonnées entre deux instances non synchronisées, vous pouvez définir ce paramètre sur EXCLURE afin de faciliter la gestion de ces objets générés. |
| skipSharing (ignorer le partage) | faux/vrai | L'activation de ce paramètre supprime les propriétés de partage des objets exportés. Il s'agit de *utilisateur*, *accès publique*, *accès des groupes d'utilisateurs*, *accès utilisateur*, et *accès externe*. |
| download | faux/vrai | L'activation de ce paramètre ajoutera l'en-tête HTTP Contenu-Disposition qui spécifie que les données doivent être traitées comme une pièce jointe et seront proposées par les navigateurs web sous forme de téléchargement. |

### Exemples d'exportation de métadonnées { #webapi_metadata_export_examples } 

Exporter toutes les métadonnées. Attention, la réponse peut être très volumineuse en fonction de la configuration des métadonnées :

    /api/metadata

Exporter toutes les métadonnées classées par ordre décroissant en prenant en compte la dernière mise à jour :

    /api/metadata?defaultOrder=lastUpdated:desc

Exporter uniquement les métadonnées qui contiennent des indicateurs et des groupes d'indicateurs :

    /api/metadata?indicators=true&indicatorGroups=true

Exporter l'identifiant et le nom d'affichage de tous les éléments de données, classés par nom d'affichage :

    /api/metadata?dataElements:fields=id,name&dataElements:order=displayName:desc

Exporter les éléments de données et les indicateurs dont le nom commence par "CPN" :

    /api/metadata?filter=name:^like:ANC&dataElements=true&indicators=true

### Exportation de métadonnées avec des dépendances { #webapi_dataset_program_export_dependencies } 

Lorsque vous voulez échanger des métadonnées avec un ensemble de données, un programme, une combinaison de catégories, un tableau de bord, un ensemble d'options ou un groupe d'éléments de données, d'une instance DHIS2 à une autre, six points d'extrémité dédiés sont disponibles :

```
/api/dataSets/{id}/metadata.json

/api/programs/{id}/metadata.json

/api/categoryCombos/{id}/metadata.json

/api/dashboards/{id}/metadata.json

/api/optionSets/{id}/metadata.json

/api/dataElementGroups/{id}/metadata.json
```

Ces éléments exportés peuvent ensuite être importés en utilisant ceci `/api/metadata`.

Ces points d'extrémité prennent également en charge les paramètres suivants :

Tableau : Paramètres d'exportation

| Nom | Options | Description |
|---|---|---|
| skipSharing (ignorer le partage) | faux/vrai | L'activation de ce paramètre supprime les propriétés de partage des objets exportés. Il s'agit de *utilisateur*, *accès publique*, *accès des groupes d'utilisateurs*, *accès utilisateur*, et *accès externe*. |
| download | faux/vrai | L'activation de ce paramètre ajoutera l'en-tête HTTP Contenu-Disposition qui spécifie que les données doivent être traitées comme une pièce jointe et seront proposées par les navigateurs web sous forme de téléchargement. |

## Importation de métadonnées { #webapi_metadata_import } 

Cette section décrit l'API d'importation des métadonnées. Les représentations des ressources XML et JSON sont prises en charge. Les métadonnées peuvent être importées à l'aide d'une requête *POST*.

    /api/metadata

L'importateur vous permet d'importer des charges de métadonnées qui peuvent inclure plusieurs entités et un nombre quelconque d'objets par entité. Les éléments de métadonnées exportés via l'API d'exportation de métadonnées peuvent être importés directement.

Le point d'extrémité de l'importation des métadonnées prend en charge une variété de paramètres, énumérés ci-dessous.

Tableau : Paramètres d'importation

| Nom | Options (la première est la valeur par défaut) | Description |
|---|---|---|
| Mode d'importation  | COMMIT, VALIDATE (commiter, valider) | Définit le mode d'importation général ; décide s'il faut `VALIDER` ou `COMMITER` les métadonnées. Cet paramètre fonctionne de la même manière que la fonction dryRun (essai). |
| identifiant | UID, CODE, AUTO | Définit le schéma d'identification à utiliser pour la mise en correspondance des références. Il faut d'abord essayer `UID`, puis `CODE` avant de passer à `AUTO`. |
| importReportMode (mode de rapport d'importation) | ERRORS, FULL, DEBUG (erreurs, plein, débogage) | Définit le mode de `rapport d'importation` ; contrôle ce qui est rapporté après l'importation. `ERRORS` n'inclut que les *rapports d'objets* pour les objets qui contiennent des erreurs. `FULL` renvoie un *rapport d'objet* pour tous les objets importés, et `DEBUG` renvoie la même chose plus un nom pour l'objet (si disponible). |
| preheatMode (mode préchauffage) | REFERENCE, ALL, NONE (référence, tous, aucun) | Définit le mode de préchauffage ; il est utilisé pour signaler si le préchauffage doit être fait pour `TOUS` (comme c'était le cas auparavant avec *preheatCache=true*) ou faire un scan plus intelligent des objets pour voir ce qu'il faut préchauffer (actuellement le paramètre par défaut). Il n'est pas recommandé de le définir sur `AUCUN`. |
| importStrategy (stratégie d'importation) | CRÉER_ET_METTRE À JOUR, CRÉER, METTRE À JOUR, SUPPRIMER | Définit la stratégie d'importation ; `CREATE_AND_UPDATE` essaiera de trouver une correspondance avec l'identifiant. Si aucune correspondance n'est trouvée, l'objet sera créé. |
| Mode atomique | ALL, NONE (tous, aucun) | Définit le mode atomique. Dans l'ancien importateur, nous faisions toujours une importation *best effort* (mode au mieux), ce qui signifie que même si certaines références n'existaient pas, l'importation se faisait quand même (par exemple, des éléments de données manquants dans un groupe d'éléments de données). Par défaut, le nouvel importateur ne permet pas cela et rejette les erreurs de validation. Définir le mode `NONE` (aucun) émulait l'ancien fonctionnement. |
| ~~mergeMode~~ (mode de fusion) | ~~REPLACE, MERGE~~ (remplacer, fusionner) | ~~Définit le mode de fusion. Lors des mises à jour nous avons deux façons de fusionner l'ancien objet avec le nouveau. Le mode `MERGE` ne remplacera l'ancienne propriété que si la nouvelle n'est pas nulle. Pour le mode `REPLACE`, toutes les propriétés sont remplacées qu'elles soient nulles ou non.~~ (*) |
| flushMode (mode de vidage) | AUTO, OBJET | Définit le mode de vidage, qui contrôle quand vider le cache interne. Il est *fortement* recommandé de maintenir ce mode sur `AUTO` (qui est le mode par défaut). N'utilisez `OBJECT` qu'à des fins de débogage, lorsque vous voyez des exceptions liées à l'hibernation et que vous voulez localiser l'emplacement exact où l'empilement se produit (l'hibernation ne se déclenche qu'au moment du vidage, il peut donc être difficile de savoir quel objet a eu des problèmes). | 
| skipSharing (ignorer le partage) | faux, vrai | Permet d'ignorer les propriétés de partage, d'éviter la fusion des éléments partagées lors des mises à jour et l'ajout d'un accès à un groupe d'utilisateurs lors de la création de nouveaux objets. |
| skipValidation (ignorer la validation) | faux, vrai | Permet d'ignorer la validation lors de l'importation. Ce paramètre n'est pas recommandé : `NOT RECOMMENDED`. |
| async | faux, vrai | Importation asynchrone ; la réponse est renvoyée immédiatement avec un en-tête *Emplacement* qui pointe vers l'emplacement du *rapport d'importation*. La charge contient également un objet json de la tâche créée. |
| inclusionStrategy (stratégie d'inclusion) | NON_NULL, ALWAYS, NON_EMPTY | *NON_NULL* inclut les propriétés qui ne sont pas nulles, *ALWAYS* inclut toutes les propriétés, *NON_EMPTY* inclut les propriétés qui ne sont pas vides (n'inclut pas les chaînes de longueur 0, les collections de taille 0, etc.) |
| userOverrideMode (utiliser le mode de remplacement) | AUCUN, ACTUEL, SÉLECTIONNÉ | Ceci vous permet de remplacer la propriété utilisateur de chaque objet que vous importez. Les options sont NONE (ne rien faire), CURRENT (utiliser l'utilisateur d'importation), SELECTED (sélectionner un utilisateur spécifique en utilisant overrideUser=X). |
| overrideUser (remplacer l'utilisateur) | ID de l'utilisateur | Si le mode de remplacement de l'utilisateur est sélectionné, utilisez ce paramètre pour sélectionner l'utilisateur avec lequel vous voulez effectuer le remplacement. |

> (*) Currently the `mergeMode=MERGE` option of the import service has limitations and doesn't support all objects. It doesn't work with some object types such as Embedded objects, or objects which are saved as JSONB format in database ( sharing, attributeValues, etc...). Fixing those issues are complicated and would just cause new issues. Therefore, this `mergedMode=MERGE` is deprecated and currently is not recommended to use. The update mode should always be mergedMode=REPLACE. We have developed a new [JSON Patch API](#webapi_partial_updates) which can be used as an alternative approach. This feature is introduced in 2.37 release.


Voici un exemple de charge d'importation de métadonnées. Vous remarquerez que chaque type d'entité possède sa propre propriété avec un tableau d'objets :

```json
{
  "dataElements": [
    {
      "name": "EPI - IPV 3 doses given",
      "shortName": "EPI - IPV 3 doses given",
      "aggregationType": "SUM",
      "domainType": "AGGREGATE",
      "valueType": "INTEGER_ZERO_OR_POSITIVE"
    },
    {
      "name": "EPI - IPV 4 doses given",
      "shortName": "EPI - IPV 4 doses given",
      "aggregationType": "SUM",
      "domainType": "AGGREGATE",
      "valueType": "INTEGER_ZERO_OR_POSITIVE"
    }
  ],
  "indicators": [
    {
      "name": "EPI - ADS stock used",
      "shortName": "ADS stock used",
      "numerator": "#{LTb8XeeqeqI}+#{Fs28ZQJET6V}-#{A3mHIZd2tPg}",
      "numeratorDescription": "ADS 0.05 ml used",
      "denominator": "1",
      "denominatorDescription": "1",
      "annualized": false,
      "indicatorType": {
        "id": "kHy61PbChXr"
      }
    }
  ]
}
```

Lors de l'envoi de cette charge au point d'extrémité des métadonnées, la réponse contiendra des informations sur les paramètres utilisés lors de l'importation et un récapitulatif par type d'entité, lequel contiendra le nombre d'objets créés, mis à jour, supprimés et ignorés :

```json
{
  "importParams": {
    "userOverrideMode": "NONE",
    "importMode": "COMMIT",
    "identifier": "UID",
    "preheatMode": "REFERENCE",
    "importStrategy": "CREATE_AND_UPDATE",
    "atomicMode": "ALL",
    "mergeMode": "REPLACE",
    "flushMode": "AUTO",
    "skipSharing": false,
    "skipTranslation": false,
    "skipValidation": false,
    "metadataSyncImport": false,
    "firstRowIsHeader": true,
    "username": "UNICEF_admin"
  },
  "status": "OK",
  "typeReports": [
    {
      "klass": "org.hisp.dhis.dataelement.DataElement",
      "stats": {
        "created": 2,
        "updated": 0,
        "deleted": 0,
        "ignored": 0,
        "total": 2
      }
    },
    {
      "klass": "org.hisp.dhis.indicator.Indicator",
      "stats": {
        "created": 1,
        "updated": 0,
        "deleted": 0,
        "ignored": 0,
        "total": 1
      }
    }
  ],
  "stats": {
    "created": 3,
    "updated": 0,
    "deleted": 0,
    "ignored": 0,
    "total": 3
  }
}
```


## Schéma { #webapi_schema } 

Pour effectuer une introspection sur tous les objets DXF 2 disponibles, vous pouvez utiliser une ressource disponible à l'adresse `/api/schemas`. Pour obtenir des ressources spécifiques, vous pouvez consulter `/api/schemas/<type>`.

Pour obtenir tous les schémas disponibles au format XML :

    GET /api/schemas.xml

Pour obtenir tous les schémas disponibles au format JSON :

    GET /api/schemas.json

Pour obtenir le schéma JSON d'une classe spécifique :

    GET /api/schemas/dataElement.json


## Icônes { #webapi_icons } 

DHIS2 includes a collection of icons that can be used to give visual
context to metadata. These icons can be accessed through the icons
resource.

    GET /api/icons

This endpoint returns a list of information about the available icons.
Each entry contains information about the icon, and a reference to the
actual icon.

```json
{
  key: "mosquito_outline",
  description: "Mosquito outline",
  keywords: [
    "malaria",
    "mosquito",
    "dengue"
  ],
  href: "<dhis server>/api/icons/mosquito_outline/icon.svg"
}
```

The keywords can be used to filter which icons to return. Passing a list
of keywords with the request will only return icons that match all the
keywords:

    GET /api/icons?keywords=shape,small

A list of all unique keywords can be found at the keywords resource:

    GET /api/icons/keywords

## Type de rendu { #webapi_render_type } 

Certains types de métadonnées ont une propriété appelée *renderType* (type de rendu). Cette propriété établit une correspondance entre un *appareil* et un *type de restitution* (renderingType). Les applications peuvent utiliser ces informations pour savoir comment l'objet doit être rendu sur un appareil spécifique. Par exemple, le rendu d'un élément de données sur un appareil mobile peut être différent de celui d'un ordinateur de bureau.

Il existe actuellement deux types de restitution :

1.  Restitution du type de valeur

2.  Restitution des sections d'étape de programme

Il existe également deux types d'appareils :

1.  MOBILE

2.  DESKTOP

Le tableau suivant énumère les types de métadonnées et de restitution disponibles.
La restitution du type de valeur a des contraintes supplémentaires basées sur la configuration des métadonnées. Elles seront présentées dans un second tableau.

Tableau : Aperçu des métadonnées et des types de restitution

| Type de métadonnées | Types de restitution disponibles |
|---|---|
| Section des étapes de programme | * LISTING (par défaut)<br> * SEQUENTIAL<br> * MATRIX |
| Élément de données | * DEFAULT<br> * DROPDOWN<br> * VERTICAL_RADIOBUTTONS<br> * HORIZONTAL_RADIOBUTTONS<br> * VERTICAL_CHECKBOXES<br> * HORIZONTAL_CHECKBOXES<br> * SHARED_HEADER_RADIOBUTTONS<br> * ICONS_AS_BUTTONS<br> * SPINNER<br> * ICON<br> * TOGGLE<br> * VALUE<br> * SLIDER<br> * LINEAR_SCALE |

Étant donné que la gestion de la restitution par défaut des éléments de données et des attributs d'entités suivies dépend du type de valeur de l'objet, il existe également un type DEFAULT pour indiquer au client qu'il doit être traité normalement. La section des étapes de programme est définie sur LISTING par défaut.

Tableau : Types de restitution autorisés en fonction des types de valeurs

| Type de valeur | L'objet est-il un ensemble d'options ? | Types de restitution autorisés |
|---|---|---|
| TRUE_ONLY (vrai uniquement) | Non | DEFAULT, VERTICAL_RADIOBUTTONS, HORIZONTAL_RADIOBUTTONS, VERTICAL_CHECKBOXES, HORIZONTAL_CHECKBOXES, TOGGLE |
| BOOLÉEN | Non ||
| - | Oui | DEFAULT, DROPDOWN, VERTICAL_RADIOBUTTONS, HORIZONTAL_RADIOBUTTONS, VERTICAL_CHECKBOXES, HORIZONTAL_CHECKBOXES, SHARED_HEADER_RADIOBUTTONS, ICONS_AS_BUTTONS, SPINNER, ICON |
| INTEGER | Non | DEFAULT, VALUE, SLIDER, LINEAR_SCALE, SPINNER |
| INTEGER_POSITIVE | Non ||
| INTEGER_NEGATIVE | Non ||
| INTEGER_ZERO_OR_POSITIVE | Non ||
| NUMBER | Non ||
| UNIT_INTERVAL | Non ||
| PERCENTAGE | Non ||

Vous pouvez également récupérer une référence complète du tableau précédent en utilisant le point d'extrémité suivant :

    GET /api/staticConfiguration/renderingOptions

Quelques propriétés supplémentaires peuvent être définies pour la restitution du type de valeur ; ce qui est souvent nécessaire lors de la restitution de certains types spécifiques :

Tableau : propriétés de l'objet renderType

| Propriété | Description | Type |
|---|---|---|
| type | Le type de restitution de l'objet, tel qu'indiqué dans le premier tableau. Cette propriété est la même pour le type de valeur et la section des étapes de programme, mais c'est la seule propriété disponible pour la section des étapes de programme. | Énumération (voir la liste dans le tableau des métadonnées et des types de restitution) |
| min | Uniquement pour la restitution du type de valeur ; il représente la valeur minimale que ce champ peut avoir. | Entier |
| max | Uniquement pour la restitution du type de valeur ; il représente la valeur maximale que ce champ peut avoir. | Entier |
| étape | Uniquement pour la restitution de type valeur ; il représente la taille des étapes que la valeur doit augmenter, par exemple pour SLIDER ou LINEAR_SCALE. | Entier |
| points décimaux | Uniquement pour la restitution du type de valeur ; il représente le nombre de points décimaux que la valeur doit utiliser. | Entier |

Le *type de restitution* peut être défini lors de la création ou de la mise à jour des métadonnées énumérées dans le premier tableau. Voici un exemple de charge pour le type de restitution de la section des étapes de programme :

```json
{
  "renderingType": {
    "type": "MATRIX"
  }
}
```

Pour les éléments de données et les attributs d'entités suivies :

```json
{
  "renderingType": {
    "type": "SLIDER",
    "min": 0,
    "max": 1000,
    "step": 50,
    "decimalPoints": 0
  }
}
```

## Style d'objet { #webapi_object_style } 

La plupart des métadonnées ont une propriété "style". Cette propriété peut être utilisée par les clients pour représenter l'objet d'une certaine manière. Les propriétés actuellement prises en charge par le style sont les suivantes :

Tableau : Propriétés du style

| Propriété | Description | Type |
|---|---|---|
| couleur | Une couleur, représentée par une valeur hexadécimale. | Chaîne (#000000) |
| icône | Une icône, représentée par un nom d'icône. | Chaîne |

Actuellement, il n'existe pas de liste officielle ni de bibliothèques d'icônes. Il revient donc au client de les fournir. La liste suivante présente tous les objets qui prennent en charge le style :

  - Élément de données

  - Option de catégorie d'éléments de données

  - Ensemble de données

  - Indicateur

  - Option

  - Programme

  - Indicateur du programme

  - Section du programme

  - Étape du programme

  - Section des étapes de programme

  - Relation (Tracker)

  - Attribut d’entité suivie

  - Type d'entité suivie

Lors de la création ou de la mise à jour de l'un de ces objets, vous pouvez inclure la charge suivante pour modifier le style :

```json
{
  "style": {
    "color": "#ffffff",
    "icon": "my-beautiful-icon"
  }
}
```

## Indicateurs { #webapi_indicators } 

Cette section décrit les indicateurs et les expressions d'indicateurs.

### Indicateurs agrégés { #webapi_aggregate_indicators } 

Pour récupérer les indicateurs, vous pouvez lancer une requête GET à la ressource des indicateurs comme suit :

    /api/indicators

Les indicateurs représentent des expressions qui peuvent être calculées et présentées sous forme de résultat. Les expressions des indicateurs sont divisées en un numérateur et un dénominateur. Les numérateurs et les dénominateurs sont des expressions mathématiques qui peuvent contenir des références à des éléments de données, à d'autres indicateurs, à des constantes et à des groupes d'unités d'organisation. Les variables seront remplacées par des valeurs de données lorsqu'elles seront utilisées, par exemple dans des rapports. Les variables autorisées dans les expressions sont décrites dans le tableau suivant.

Traduit avec DeepL.com (version gratuite)

Tableau : Variables d'indicateurs

| Variable | Objet | Description |
|---|---|---|
| #{<data-element-id\>.<category-option-combo-id\>.<attribute-option-combo-id\>} | Opérande de l'élément de données | Fait référence à la combinaison d'un élément de données agrégé et d'une combinaison d'options de catégorie. Les identifiants des combinaisons d'options de catégorie et d'attribut sont facultatifs et le symbole "\*" peut être utilisé pour indiquer n'importe quelle valeur. |
| #{<dataelement-id\>.<category-option-group-id\>.<attribute-option-combo-id\>} | Groupe d'options de catégorie | Fait référence à un élément de données agrégé et à un groupe d'options de catégorie, qui contient plusieurs combinaisons d'options de catégorie. |
| #{<data-element-id\>} | Élément de données agrégées | Fait référence à la valeur totale d'un élément de données agrégé pour toutes les combinaisons d'options de catégorie. |
| D{<program-id\>.<data-element-id\>} | Élément de données de programme | Fait référence à la valeur d'un élément de données Tracker au sein d'un programme. |
| A{<program-id\>.<attribute-id\>} | Attribut d'entité suivie d'un programme | Fait référence à la valeur d'un attribut d'entité suivie au sein d'un programme. |
| I{<program-indicator-id\>} | Indicateur de programme | Fait référence à la valeur d'un indicateur de programme. |
| R{<dataset-id\>.<metric\>} | Taux de déclaration | Fait référence à une mesure de taux de déclaration. La mesure peut être REPORTING_RATE (taux de déclaration), REPORTING_RATE_ON_TIME (taux de déclarations à temps), ACTUAL_REPORTS (rapports envoyés), ACTUAL_REPORTS_ON_TIME (rapports envoyés à temps), EXPECTED_REPORTS (rapports attendus). |
| C{<constant-id\>} | Constante | Fait référence à une valeur constante. |
| N{<indicator-id\>} | Indicateur | Fait référence à un indicateur existant. |
| OUG{<orgunitgroup-id\>} | Groupe d'unités d'organisation | Fait référence au nombre d'unités d'organisation présentes dans un groupe d'unités d'organisation. |

Dans un opérande d'élément de données ou dans un élément de données agrégé, les substitutions suivantes peuvent être effectuées :

| Élément | Valeur | Description |
|---|---|---|
| identifiant de l'élément de données (data-element-id) | identifiant de l'élément de données (data-element-id) | Un élément de données agrégé |
| identifiant de l'élément de données (data-element-id) | deGroup:data-element-group-id | Tous les éléments de données agrégés d'un groupe d'éléments de données |
| category-option-combo-id (identifiant de la combinaison d'options de catégorie) | category-option-combo-id (identifiant de la combinaison d'options de catégorie) | Une combinaison d'options de catégorie |
| category-option-combo-id (identifiant de la combinaison d'options de catégorie) | co:category-option-id | Toutes les combinaisons d'options de catégorie dans une option de catégorie |
| category-option-combo-id (identifiant de la combinaison d'options de catégorie) | coGroup:category-option-group-id | Toutes les combinaisons d'options de catégorie dans un groupe d'options de catégorie |
| category-option-combo-id (identifiant de la combinaison d'options de catégorie) | coGroup:co-group-id1&co-group-id2... | Toutes les combinaisons d'options de catégorie qui font partie de plusieurs groupes d'options de catégorie |

La syntaxe ressemble à ceci :

    #{<dataelement-id>.<catoptcombo-id>} + C{<constant-id>} + OUG{<orgunitgroup-id>}

Un exemple correspondant se présente comme suit :

    #{P3jJH5Tu5VC.S34ULMcHMca} + C{Gfd3ppDfq8E} + OUG{CXw2yu5fodb}

Pour les variables d'éléments de données, l'identifiant de la combinaison d'options de catégorie peut être omis. La variable va alors représenter le total pour l'élément de données, par exemple pour toutes les combinaisons d'options de catégorie. Exemple :

    #{P3jJH5Tu5VC} + 2

Les opérandes des éléments de données peuvent inclure toute combinaison d'options de catégorie et toute combinaison d'options d'attributs. Elles peuvent également utiliser des caractères génériques pour indiquer n'importe quelle valeur :

    #{P3jJH5Tu5VC.S34ULMcHMca} + #{P3jJH5Tu5VC.*.j8vBiBqGf6O} + #{P3jJH5Tu5VC.S34ULMcHMca.*}

Exemple d'utilisation d'un groupe d'éléments de données :

    #{deGroup:oDkJh5Ddh7d} + #{deGroup:GBHN1a1Jddh.j8vBiBqGf6O}

Exemple utilisant une option de catégorie, un groupe d'éléments de données et un groupe d'options de catégorie :

    #{P3jJH5Tu5VC.co:FbLZS3ueWbQ} + #{deGroup:GBHN1a1Jddh.coGroup:OK2Nr4wdfrZ.j8vBiBqGf6O}

Exemple d'utilisation de plusieurs groupes d'options de catégories :

    #{P3jJH5Tu5VC.coGroup:OK2Nr4wdfrZ&j3C417uW6J7&ddAo6zmIHOk}

Exemple utilisant un élément de données de programme et un attribut de programme :

    ( D{eBAyeGv0exc.vV9UWAZohSf} * A{IpHINAT79UW.cejWyOfXge6} ) / D{eBAyeGv0exc.GieVkTxp4HH}

Exemple combinant des indicateurs de programme et des indicateurs agrégés :

    I{EMOt6Fwhs1n} * 1000 / #{WUg3MYWQ7pt}

Exemple utilisant un taux de déclaration :

    R{BfMAe6Itzgt.REPORTING_RATE} * #{P3jJH5Tu5VC.S34ULMcHMca}

Un autre exemple de taux de déclaration qui utilise des rapports sur des ensembles de données et des rapports attendues :

    R{BfMAe6Itzgt.ACTUAL_REPORTS} / R{BfMAe6Itzgt.EXPECTED_REPORTS}

Exemple utilisant un indicateur existant :

    N{Rigf2d2Zbjp} * #{P3jJH5Tu5VC.S34ULMcHMca}

Les expressions peuvent être constituées de tout type d'expression mathématique valide, à titre d'exemple :

    ( 2 * #{P3jJH5Tu5VC.S34ULMcHMca} ) / ( #{FQ2o8UBlcrS.S34ULMcHMca} - 200 ) * 25

### ![](resources/images/pivot_table/table_layout.png) { #webapi_program_indicators } 

Pour récupérer les indicateurs de programme, vous pouvez effectuer une requête GET à la ressource des indicateurs de programme, comme suit :

    /api/programIndicators

Les indicateurs de programme peuvent contenir des informations collectées dans le cadre d'un programme. Les indicateurs ont une expression qui peut contenir des références à des éléments de données, des attributs, des constantes et des variables de programme. Les variables autorisées dans les expressions sont décrites dans le tableau suivant.



Tableau : Variables des indicateurs du programme

| Variable | Description |
|---|---|
| #{<programstage-id\>.<dataelement-id\>} | Fait référence à une combinaison entre l'étape de programme et l'identifiant de l'élément de données. |
| A{<attribute-id\>} | Fait référence à un attribut d'entité suivie. |
| V{<variable-id\>} | Fait référence à une variable de programme. |
| C{<constant-id\>} | Fait référence à une constante. |

La syntaxe ressemble à ceci :

    #{<programstage-id>.<dataelement-id>} + #{<attribute-id>} + V{<varible-id>} + C{<constant-id>}

Voici un exemple correspondant :

    #{A03MvHHogjR.a3kGcGDCuk6} + A{OvY4VVhSDeJ} + V{incident_date} + C{bCqvfPR02Im}

### Expressions { #webapi_expressions } 

Les expressions sont des formules mathématiques qui peuvent contenir des références à des éléments de données, des constantes et des groupes d'unités d'organisation. Pour valider une expression et en obtenir la description sous forme de texte, vous pouvez adresser une requête GET à la ressource des expressions :

    /api/expressions/description?expression=<expression-string>

La réponse suit le format standard des messages web JSON. La propriété *statut* indique le résultat de la validation et sera "OK" en cas de succès et "ERROR" en cas d'échec. La propriété *message* sera "Valid" (valide) si la validation réussit, et en cas d'échec, elle fournira une description textuelle de la raison de cet échec. La propriété *description* fournit une description textuelle de l'expression.

```json
{
  "httpStatus": "OK",
  "httpStatusCode": 200,
  "status": "OK",
  "message": "Valid",
  "description": "Acute Flaccid Paralysis"
}
```

## Les unités d’organisation { #webapi_organisation_units } 

La ressource *organisationUnits* suit les conventions standard des autres ressources de métadonnées présents dans DHIS2. Cette ressource prend en charge des paramètres de requête supplémentaires.

### Obtenir la liste des unités d'organisation { #webapi_list_of_organisation_units } 

Pour obtenir une liste des unités d'organisation, vous pouvez utiliser la ressource suivante :

    /api/33/organisationUnits

Tableau : Paramètres de requête des unités d'organisation

| Paramètre de requête | Options | Description |
|---|---|---|
| userOnly (utilisateur uniquement) | faux &#124; vrai | Unités d'organisation de saisie des données associées à l'utilisateur actuel. |
| userDataViewOnly | faux &#124; vrai | Unités d'organisation de visualisation de données associées à l'utilisateur actuel. |
| userDataViewFallback | faux &#124; vrai | Unités d'organisation de visualisation de données associées à l'utilisateur actuel, avec un retour aux unités d'organisation de saisie de données. |
| requête | chaîne | Requête sur les propriétés de nom, code et ID. |
| District | entier | Unités d'organisation au niveau spécifié de la hiérarchie. |
| maxLevel | entier | Unités d'organisation au niveau maximal ou à des niveaux plus élevés dans la hiérarchie. |
| withinUserHierarchy | faux &#124; vrai | Limite la recherche et l'extraction aux unités d'organisation qui se trouvent dans le champ de saisie de l'utilisateur. |
| withinUserSearchHierarchy | faux &#124; vrai | Limite la recherche et l'extraction aux unités d'organisation qui se trouvent dans le champ de recherche de l'utilisateur actuel. Remarque : Si "withinUserHierarchy" est défini sur "true", il devient prioritaire. |
| memberCollection | chaîne | Permet d'afficher le nombre de membres dans une collection ; renvoie au nom de la collection associée aux unités d'organisation. |
| memberObject | UID | Permet d'afficher le nombre de membres dans une collection ; renvoie à l'identifiant de l'objet qui fait partie de la collection. |

### Obtenir une unité d'organisation avec une sous-hiérarchie { #webapi_organisation_units_with_sub_hierarchy } 

Pour obtenir une unité d'organisation ainsi que les unités d'organisation présentes dans sa sous-hiérarchie, vous pouvez utiliser la ressource suivante.

    /api/33/organisationUnits/{id}

Tableau : Paramètres de l'unité d'organisation

| Paramètre de requête | Options | Description |
|---|---|---|
| Inclut les enfants | faux &#124; vrai | Inclut les subordonnées directs de l'unité d'organisation spécifiée, c'est-à-dire les unités qui lui sont directement inférieures dans la sous-hiérarchie. |
| includeDescendants | faux &#124; vrai | Inclut tous les descendants de l'unité d'organisation spécifiée, c'est-à-dire toutes les unités qui lui sont inférieures dans la hiérarchie. |
| includeAncestors | faux &#124; vrai | Inclut tous les ascendants de l'unité d'organisation spécifiée. |
| District | entier | Inclut les descendants de l'unité d'organisation spécifiée à un niveau précis de la sous-hiérarchie. Ce paramètre dépend de l'unité d'organisation, et commence par le premier niveau qui est directement inférieur à l'unité d'organisation. |

### Obtenir des unités d'organisation par option de catégorie{ #webapi_organisation_units_by_category_options }

Point d'extrémité conçu pour récupérer les associations entre les options de catégorie et les unités d'organisation. Ce point d'extrémité est le moyen idéal pour récupérer les associations entre les programmes et les unités d'organisation.

    /api/33/categoryOptions/orgUnits?categoryOptions={categoryOptionIdA},{categoryOptionIdB}

Les réponses auront le format suivant :

```json
{
  "<categoryOptionIdA>": [
    "<orgUnitUid>",
    "<orgUnitUid>"
  ],
  "<categoryOptionIdB>": [
    "<orgUnitUid>",
    "<orgUnitUid>"
  ],
  "<categoryOptionIdC>": []
}
```

Les options de catégorie accessibles à toutes les unités d'organisation sont renvoyées avec un tableau d'unités d'organisation vide (`[]`).

### Obtenir les unités d'organisation par programme { #webapi_organisation_units_by_programs } 

Point d'extrémité conçu pour récupérer les associations entre les programmes et les unités d'organisation. Ce point d'extrémité est le moyen idéal pour récupérer les associations entre les programmes et les unités d'organisation.

    /api/33/programs/orgUnits?programs={programIdA},{programIdB}

Les réponses auront le format suivant :

```json
{
  "<programIdA>": [
    "<orgUnitUid>",
    "<orgUnitUid>"
  ],
  "<programIdB>": [
    "<orgUnitUid>",
    "<orgUnitUid>"
  ],
  "<programIdC>": []
}
```

Les programmes accessibles à toutes les unités d'organisation sont renvoyées avec un tableau d'unités d'organisation vide (`[]`).

### Fractionner des unités d'organisation { #webapi_organisation_unit_split }

Le point d'extrémité de fractionnement des unités d'organisation vous permet de fractionner des unités d'organisation en un certain nombre d'unités d'organisation cibles.

#### Demande { #request } 

Fractionner des unités d'organisation à l'aide d'une requête POST :

```
POST /api/organisationUnits/split
```

La charge au format JSON ressemble à ceci :

```json
{
  "source": "rspjJHg4WY1",
  "targets": [
    "HT0w9YLMLyn",
    "rEpnzuNpRKM"
  ],
  "primaryTarget": "HT0w9YLMLyn",
  "deleteSource": true
}
```

Les propriétés JSON sont décrites dans le tableau suivant.

Tableau : Fractionnement des champs de la charge

| Champ         | Obligatoire | Valeur |
| ------------- | -------- |------ |
| source        | Oui      | Identifiant de l'unité d'organisation à fractionner (l'unité d'organisation source). |
| cibles       | Oui      | Tableau des identifiants des unités d'organisation qui seront le résultat du fractionnement de l'unité source (les unités d'organisation cibles). |
| primaryTarget | Non       | Identifiant de l'unité d'organisation vers laquelle transférer les données agrégées, les événements et les entités suivies associés à l'unité source. S'il n'est pas spécifié, la première cible sera utilisée. |
| deleteSource  | Non       | Détermine si l'unité d'organisation source doit être supprimée après l'opération. La valeur par défaut est `true` |

L'opération de fractionnement consiste à scinder l'unité d'organisation source en unités d'organisation cibles. Il est recommandé de créer de nouvelles unités d'organisation cibles avant d'effectuer le fractionnement, et de s'assurer au préalable qu'il n'existe pas de données agrégées pour les unités d'organisation cibles. Vous pouvez spécifier un nombre quelconque d'unités d'organisation cibles.

L'opération de fractionnement transfère toutes les associations de métadonnées de l'unité d'organisation source vers les unités d'organisation cibles. Cela inclut les ensembles de données, les programmes, les groupes d'unités d'organisation, les options de catégorie, les utilisateurs, les visualisations, les cartes et les rapports d'événements.

L'opération transfère tous les enregistrements de données de l'unité d'organisation source vers l'unité d'organisation spécifiée comme cible principale ou, si elle n'est pas spécifiée, vers la première unité d'organisation cible spécifiée. Cela inclut les valeurs de données agrégées, les enregistrements relatifs à l'approbation des données, les événements, les entités suivies, etc.

#### Validation { #validation } 

Les contraintes et les codes d'erreur suivants s'appliquent.

Tableau : Contraintes et codes d'erreur

| Code d'erreur | Description                                     |
| ---------- | ----------------------------------------------- |
| E1510      | L'unité d'organisation source doit être spécifiée               |
| E1511      | Au moins deux unités d'organisation cibles doivent être spécifiées |
| E1512      | L'unité d'organisation source ne peut pas être une unité d'organisation cible     |
| E1513      | La cible principale doit être spécifiée                |
| E1514      | La cible principale doit être une unité d'organisation cible        |
| E1515      | L'unité d'organisation cible n'existe pas                  |

### Merge organisation units { #webapi_organisation_unit_merge}

Le point d'extrémité de fusion des unités d'organisation vous permet de fusionner des unités d'organisation en une seule unité d'organisation cible.

#### Demande { #request } 

Fusionner des unités d'organisation à l'aide d'une requête POST :

```
POST /api/organisationUnits/merge
```

La charge au format JSON ressemble à ceci :

```json
{
  "sources": [
    "jNb63DIHuwU",
    "WAjjFMDJKcx"
  ],
  "target": "V9rfpjwHbYg",
  "dataValueMergeStrategy": "LAST_UPDATED",
  "dataApprovalMergeStrategy": "LAST_UPDATED",
  "deleteSources": true
}
```

Les propriétés JSON sont décrites dans le tableau suivant.

Tableau : Fusion des champs de la charge

| Champ                     | Obligatoire | Valeur |
| ------------------------- | -------- | ----- |
| sources                   | Oui      | Tableau des identifiants des unités d'organisation à fusionner (unités d'organisation source). |
| cible                    | Oui      | Identifiant de l'unité d'organisation qui sera le résultat de la fusion des unités source (l'unité d'organisation cible). |
| dataValueMergeStrategy    | Non       | Stratégie de fusion des valeurs de données. Options : `LAST_UPDATED` (par défaut), `DISCARD`. |
| dataApprovalMergeStrategy | Non       | Stratégie de fusion des enregistrements relatifs à l'approbation des données. Options : `LAST_UPDATED` (par défaut), `DISCARD`. |
| deleteSources             | Non       | Détermine si les unités d'organisation source doivent être supprimées après l'opération. La valeur par défaut est `true` |

L'opération de fusion consiste à combiner des unités d'organisation source pour former une seule unité cible. Il est recommandé de créer une nouvelle unité d'organisation cible avant de procéder à la fusion, et de s'assurer au préalable l'unité cible ne contient pas de données agrégées. Vous pouvez spécifier un nombre quelconque d'unités d'organisation source.

L'opération de fusion transfère toutes les associations de métadonnées des unités d'organisation sources vers l'unité d'organisation cible. Cela inclut les ensembles de données, les programmes, les groupes d'unités d'organisation, les options de catégorie, les utilisateurs, les visualisations, les cartes et les rapports d'événements. L'opération transfère également toutes les données d'événements et de tracker, telles que les événements, les inscriptions, l'historique de la propriété, la propriété des programmes et les entités suivies, vers l'unité d'organisation cible.

La stratégie de fusion des valeurs de données spécifiée définit la manière dont les valeurs de données sont traitées. Pour la stratégie `LAST_UPDATED`, les valeurs de données de toutes les unités d'organisation sources sont transférées vers l'unité d'organisation cible, et lorsque des valeurs existent pour les mêmes paramètres, c'est la dernière valeur mise à jour ou créée qui sera utilisée. Ceci permet d'éviter la répétition des données. Pour la stratégie `DISCARD`, les valeurs ne sont pas transférées vers l'unité d'organisation cible, mais elles sont simplement supprimées. La stratégie de fusion de l'approbation des données spécifiée définit la manière dont les enregistrements relatifs à l'approbation des données sont traités, et suit la même logique que les valeurs de données.

#### Validation { #validation } 

Les contraintes et les codes d'erreur suivants s'appliquent.

Tableau : Contraintes et codes d'erreur

| Code d'erreur | Description                                     |
| ---------- | ----------------------------------------------- |
| E1500      | Au moins deux unités d'organisation sources doivent être spécifiées |
| E1501      | L'unité d'organisation cible doit être spécifiée               |
| E1502      | L'unité d'organisation cible ne peut pas être une unité d'organisation source     |
| E1503      | L'unité d'organisation source n'existe pas                  |

## Ensembles de données { #webapi_data_sets } 

La ressource *dataSets* suit les conventions standard des autres ressources de métadonnées présents dans DHIS2. Cette ressource prend en charge des paramètres de requête supplémentaires.

    /api/33/dataSets

Pour récupérer la version d'un ensemble de données, vous pouvez envoyer une requête GET :

    GET /api/33/dataSets/<uid>/version

Pour augmenter (d'une unité) la version d'un ensemble de données, vous pouvez effectuer une requête POST :

    POST /api/33/dataSets/<uid>/version

### Modèle de notification d'un ensemble de données { #webapi_dataset_notifications } 

La ressource *modèles de notification des ensembles de données* suit les conventions standard des autres ressources de métadonnées présentes dans DHIS2.

    GET /api/33/dataSetNotficationTemplates

Pour récupérer un modèle de notification d'ensemble de données, vous pouvez effectuer une requête GET :

    GET /api/33/dataSetNotficationTemplates/<uid>

Pour ajouter un modèle de notification d'ensemble de données, vous pouvez effectuer une requête POST :

    POST /api/33/dataSetNotficationTemplates

Pour supprimer un modèle de notification d'ensemble de données, vous pouvez effectuer une requête DELETE :

    DELETE /api/33/dataSetNotficationTemplates/<uid>

Ci-dessous, un exemple de charge JSON :

```json
{
  "name": "dataSetNotificationTemplate1",
  "notificationTrigger": "COMPLETION",
  "relativeScheduledDays": 0,
  "notificationRecipient": "ORGANISATION_UNIT_CONTACT",
  "dataSets": [{
    "id": "eZDhcZi6FLP"
  }],
  "deliveryChannels": ["SMS"],
  "subjectTemplate": "V{data_name}",
  "messageTemplate": "V{data_name}V{complete_registration_period}",
  "sendStrategy": "SINGLE_NOTIFICATION"
}

```

## Niveaux d'unités d'organisation renseignés{ #webapi_filled_organisation_unit_levels } 

La ressource *filledOrganisationUnitLevels* fournit une liste ordonnée de niveaux d'unités d'organisation, où les niveaux générés sont introduits dans la liste pour remplir les positions pour lesquelles il n'existe pas de niveau.

    GET /api/33/filledOrganisationUnitLevels

Pour définir des niveaux d'unité d'organisation, vous pouvez envoyer une requête POST avec une charge JSON et un type de contenu `application/json` comme ceci :

```json
{
  "organisationUnitLevels": [{
    "name": "National",
    "level": 1,
    "offlineLevels": 3
  }, {
    "name": "District",
    "level": 2
  }, {
    "name": "Chiefdom",
    "level": 3
  }, {
    "name": "Facility",
    "level": 4
  }]
}
```

## Les prédicteurs { #webapi_predictors } 

Un prédicteur permet de générer des valeurs de données sur la base d'une expression.
Il peut être utilisé, par exemple, pour générer des cibles, des seuils ou des estimations de valeurs.

Pour récupérer les prédicteurs, vous pouvez effectuer une requête GET à la ressource des prédicteurs comme suit :

    /api/predictors

### Création d'un prédicteur { #webapi_create_predictor } 

Vous pouvez créer un prédicteur à l'aide d'une requête POST à la ressource des prédicteurs :

    POST /api/predictors

Voici un exemple de charge :

```json
{
  "id": "AG10KUJCrRk",
  "name": "Malaria Outbreak Threshold Predictor",
  "shortName": "Malaria Outbreak Predictor",
  "description": "Computes the threshold for potential malaria outbreaks based on the mean plus 1.5x the std dev",
  "output": {
    "id": "nXJJZNVAy0Y"
  },
  "generator": {
    "expression": "AVG(#{r6nrJANOqMw})+1.5*STDDEV(#{r6nrJANOqMw})",
    "description": "Maximum normal malaria case count",
    "missingValueStrategy": "NEVER_SKIP",
    "slidingWindow": false
  },
  "periodType": "Monthly",
  "sequentialSampleCount": 4,
  "sequentialSkipCount": 1,
  "annualSampleCount": 3,
  "organisationUnitLevels": [4]
}
```

L'élément de sortie fait référence à l'identifiant de l'élément de données pour lequel des valeurs de données prédites doivent être sauvegardées.
L'élément générateur fait référence à l'expression qui sera utilisée pour calculer les valeurs prédites.

### Expressions du prédicteur { #webapi_predictor_expressions } 

Un prédicteur possède toujours une expression génératrice qui décrit le mode de calcul de la valeur prédite. Le prédicteur peut également avoir une expression permettant de tester la fonction de saut, laquelle expression renvoie une valeur booléenne. Lorsque l'expression de test de saut est présente, elle est évaluée dans chacune des périodes échantillonnées pour déterminer si les valeurs de cette période doivent être ignorées.

Les variables suivantes peuvent être utilisées dans une expression génératrice ou dans une expression de test de saut :

| Variable    | Objet     | Description |
| ----------- | ---------- | ----------- |
| #{<dataelement-id>} | Élément de données agrégées | Fait référence à la valeur totale d'un élément de données agrégé pour toutes les combinaisons d'options de catégorie. |
| #{<dataelement-id>.<categoryoptcombo-id> | Opérande de l'élément de données | Fait référence à une combinaison entre un élément de données agrégé et une combinaison d'options de catégorie. |
| D{<program-id>.<dataelement-id>} | Élément de données de programme | Fait référence à la valeur d'un élément de données Tracker au sein d'un programme. |
| A{<program-id>.<attribute-id>} | Attribut d'entité suivie d'un programme | Fait référence à la valeur d'un attribut d'entité suivie au sein d'un programme. |
| I{<program-indicator-id>} | Indicateur de programme | Fait référence à la valeur d'un indicateur de programme. |
| R{<dataset-id>.<metric>} | Taux de déclaration | Fait référence à une mesure de taux de déclaration. La mesure peut être REPORTING_RATE (taux de déclaration), REPORTING_RATE_ON_TIME (taux de déclarations à temps), ACTUAL_REPORTS (rapports envoyés), ACTUAL_REPORTS_ON_TIME (rapports envoyés à temps), EXPECTED_REPORTS (rapports attendus). |
| C{<constant-id>} | Constante | Fait référence à une valeur constante. |
| OUG{<orgunitgroup-id>} | Groupe d'unités d'organisation | Fait référence au nombre d'unités d'organisation présentes dans un groupe d'unités d'organisation. |
| [days] | Nombre de jours | Le nombre de jours dans la période actuelle. |

### Génération de valeurs prédites { #webapi_generating_predicted_values } 

Pour exécuter tous les prédicteurs (générer des valeurs prédites), vous pouvez effectuer une requête POST à la ressource d'exécution :

    POST /api/predictors/run

Pour exécuter un seul prédicteur, vous pouvez envoyer une requête POST à la ressource d'exécution et préciser le prédicteur :

    POST /api/predictors/AG10KUJCrRk/run

## Règles du programme { #webapi_program_rules } 

Cette section traite de l'envoi et de la lecture des règles de programme et explique leur modèle de données. Les règles de programme permettent de configurer un fonctionnement dynamique au sein des programmes de DHIS2.

### Modèle de règles de programme { #webapi_program_rule_model } 

Le modèle de données des règles de programme se compose de variables de règles de programme (programRuleVariables), de règles de programme (programRules) et d'actions de règles de programme (programRuleActions). La règle de programme contient une expression - lorsque cette expression est définie sur "true" (vrai), les actions de règle de programme sous cette expression sont déclenchées. Les variables de règle de programme sont utilisées pour traiter les éléments de données, les valeurs de données des entités suivies et d'autres valeurs de données nécessaires à l'exécution des expressions. Toutes les règles d'un programme partagent la même bibliothèque de variables de règles, et une variable peut être utilisée dans les expressions de plusieurs règles.

![](resources/images/program_rules/program-rule-model.jpg)

#### Détails sur le modèle de règles de programme { #program-rule-model-details } 

Le tableau suivant donne un aperçu détaillé du modèle de règle de programme.

Tableau : Règle de programme

| nom | Description | Obligatoire |
|---|---|---|
| de paludisme) ». | Le programme dans lequel la règle est exécutée. | Obligatoire |
| nom | Le nom sous lequel la règle de programme sera affichée aux configurateurs de dhis2. Il n'est pas visible pour l'utilisateur final du programme. | Obligatoire |
| Description | La description de la règle de programme peut être utilisée par les configurateurs pour décrire la règle. Elle n'est pas visible pour l'utilisateur final du programme. | Obligatoire |
| Étape du programme | Si une étape de programme est définie pour une règle de programme, la règle ne sera évaluée qu'à l'intérieur de l'étape de programme spécifiée. | facultatif |
| condition | L'expression dont l'évaluation doit être définie sur "true" pour que la règle de programme déclenche les actions qu'elle contient. L'expression est écrite à l'aide d'opérateurs, d'appels de fonctions, de valeurs codées en dur, de constantes et de variables de règles de programme. `d2:hasValue('hemoglobin') && #{hemoglobin} <= 7 `| Obligatoire |
| priorité | La priorité d'exécution de la règle lorsque l'ordre des règles est important. 
Dans la plupart des cas, les règles ne dépendent pas de leur exécution avant ou après d'autres règles, et dans ces cas, la priorité d'exécution peut être omise. Si aucune priorité n'est définie pour une règle, celle-ci sera exécutée après toutes les règles pour lesquelles une priorité d'exécution a été définie. Si une priorité (integer) est définie, la règle la moins prioritaire sera exécutée avant les règles plus prioritaires. | facultatif |

#### Détails sur le modèle d'action de la règle de programme { #program-rule-action-model-details } 

Le tableau suivant donne un aperçu détaillé du modèle d'action de la règle de programme.

Tableau : Action de règle de programme

| nom | Description | Obligatoire |
|---|---|---|
| Règle de programme | La règle de programme qui est à l'origine de cette action. | Obligatoire |
| programRule- ActionType (règle de programme - type d'action) | Le type d'action à effectuer.<br> * `DISPLAYTEXT` - Affiche un texte dans un widget.<br> * `DISPLAYKEYVALUEPAIR` - Affiche une paire clé/valeur (comme un indicateur de programme) dans un widget.<br> * `HIDEFIELD` - Cache un élément de données ou un attribut d'entité suivie spécifiés.<br> - *content* (contenu) - s'il est défini, le texte contenu dans *content* sera affiché à l'utilisateur final si une valeur a été saisie dans un champ qui est maintenant sur le point d'être caché (et donc masqué). Si *content* n'est pas défini, un message standard sera affiché à l'utilisateur.<br> - *dataElement* (élément de données) - s'il est défini, l'action HIDEFIELD masquera cet élément de données lorsque la règle sera effective.<br> - *trackedEntityDataValue* (valeur de données de l'entité suivie) - si elle est définie, l'action HIDEFIELD masquera cette trackedEntityDataValue lorsque la règle sera effective.<br> * `HIDESECTION` - Cache une section spécifiée.<br> - *programStageSection* (section d'étape de programme) - doit être défini. Il s'agit de la section d'étape de programme qui sera masquée si la règle mère est effective.<br> * `ASSIGN` - Assigne une valeur à un élément de données (aide l'utilisateur à calculer une valeur ou à remplir une valeur évidente dans un emplacement spécifique)<br> - *content* - s'il est défini, la valeur contenue dans *data* est attribuée à cette variable. Si l'identifiant du contenu est défini, et qu'une variable est donc attribuée pour être utilisée dans d'autres règles, il est important d'attribuer également une *programRule.priority* (priorité de règle de programme) pour s'assurer que la règle avec une action ASSIGN s'exécute avant la règle qui évaluera à son tour la variable attribuée.<br> - *data* - doit être défini. Les données forment une expression qui est évaluée et assignée soit à une variable (#{myVariable}), soit à un élément de données, soit aux deux.<br> - *dataElement* - s'il est défini, la valeur contenue dans *data* est attribuée à cet élément de données.<br> Le contenu ou l'élément de données doit être défini pour que l'action ASSIGN soit effective.<br> * `SHOWWARNING` - Affiche un avertissement à l'utilisateur, sans l'empêcher de terminer l'événement ou l'enregistrement.<br> - *content* - s'il est défini, le contenu devient une partie statique qui sera affichée à la fin du message d'erreur.<br> - *data* - s'il est défini, les données vont former une expression qui sera évaluée et ajoutée à la fin du message d'avertissement.<br> - *dataElement* - s'il est défini, le message d'avertissement sera affiché à côté de cet élément de données.<br> - *trackedEntityAttribute* (attribut d'entité suivie) - s'il est défini, le message d'avertissement va s'afficher à côté de cet attribut d'entité suivie.<br> Il faudra spécifier soit l'élément de données, soit l'attribut de l'entité suivie.<br> * `SHOWERROR` - Affiche une erreur à l'utilisateur, l'empêchant de terminer l'événement ou l'enregistrement.<br> - *content* - s'il est défini, le contenu devient une partie statique qui sera affichée au début du message d'erreur.<br> - *data* - s'il est défini, les données forment une expression qui est évaluée et ajoutée à la fin du message d'erreur.<br> - *dataElement* - s'il est défini, le message d'erreur est relié à cet élément de données.<br> - *trackedEntityAttribute* - s'il est défini, le message d'erreur est relié à cet attribut d'entité suivie.<br> Il faudra spécifier soit l'élément de données, soit l'attribut d'entité suivie.<br> * `WARNINGONCOMPLETE` - Affiche un avertissement à l'utilisateur dans la boîte de dialogue "Complete form" (compléter le formulaire), mais permet à l'utilisateur de terminer l'événement.<br> - *content* - s'il est défini, le contenu devient une partie statique qui sera affichée à la fin du message d'erreur.<br> - *data* - s'il est défini, les données forment une expression qui est évaluée et ajoutée à la fin du message d'avertissement.<br> - *dataElement* - s'il est défini, le message d'avertissement est précédé du nom/nom du formulaire de l'élément de données.<br> * `ERRORONCOMPLETE` - Affiche une erreur à l'utilisateur dans une fenêtre modale lorsque l'utilisateur tente de terminer l'événement. Ceci empêche l'utilisateur de terminer l'événement.<br> - *content* - s'il est défini, le contenu devient une partie statique qui s'affiche au début du message d'erreur.<br> - *data* - s'il est défini, les données forment une expression qui est évaluée et ajoutée à la fin du message d'erreur.<br> - *dataElement* - s'il est défini, le message d'erreur est relié à cet élément de données.<br> * `CREATEEVENT` - Crée un événement dans la même inscription.<br> - *content* <br>- *data* - s'il est défini, il va contenir les valeurs de données à attribuer à l'événement créé. Le format est le suivant : <uid>:<valeur des données>. Lorsque plusieurs valeurs sont spécifiées, elles sont séparées par une virgule.<br>AcMrnleqHqc:100,AqK1IHqCkEE:'Polyhydramnios' - *programStage* - doit être défini ; il désigne l'étape de programme pour laquelle la règle doit créer un événement.<br> * `SETMANDATORYFIELD` - Définit un champ comme obligatoire.<br> - *dataElement* - s'il est défini, cet élément de données sera rendu obligatoire dans le formulaire de saisie de données.<br> - *trackedEntityAttribute* - S'il est défini, cet attribut d'entité suivie sera rendu obligatoire dans le formulaire d'enregistrement ou le profil.<br> * `SENDMESSAGE` - Pour envoyer un message à la fin d'un événement ou d'une inscription ou lors de la mise à jour d'une valeur de données.<br> - *messageTemplate* - s'il est défini, ce modèle sera envoyé par SMS ou EMAIL en fonction de la valeur du DeliveryChannel (canal d'envoi) dans le modèle de message.<br> * `SCHEDULEMESSAGE` - Permet de programmer un message à la fin d'un événement/d'une inscription ou lors de la mise à jour des données.<br> - *messageTemplate* - s'il est défini, ce modèle sera envoyé par SMS ou EMAIL en fonction de la valeur du DeliveryChannel dans le modèle de message.<br> - *Date d'envoi du message* - Il s'agit de l'expression qui sera utilisée pour évaluer la date programmée. Cette expression doit générer une date ; tout autre résultat sera rejeté et la notification ne sera pas programmée. | Obligatoire |
| emplacement | Utilisé pour les types d'action DISPLAYKEYVALUEPAIR et DISPLAYTEXT afin de désigner le widget dans lequel le texte ou la paire de valeurs clés seront affichés. Il est obligatoire pour DISPLAYKEYVALUEPAIR et DISPLAYTEXT. | Voir la description |
| contenu | Utilisé pour les messages de l'utilisateur dans les différentes actions. Consultez l'aperçu des types d'action pour obtenir une explication détaillée de son utilisation dans chacun des types d'action. Il est obligatoire pour SHOWWARNING, SHOWERROR, WARNINGONCOMPLETE, ERRORONCOMPLETE, DISPLAYTEXT et DISPLAYKEYVALUEPAIR  ; et facultatif pour HIDEFIELD et ASSIGN. | Voir la description |
| données | Utilisé pour les expressions dans les différentes actions. Consultez l'aperçu des types d'action pour obtenir une explication détaillée de son utilisation dans chacun des types d'action. Il est obligatoire pour ASSIGN ; et facultatif pour SHOWWARNING, SHOWERROR, WARNINGONCOMPLETE, ERRORONCOMPLETE, DISPLAYTEXT, CREATEEVENT et DISPLAYKEYVALUEPAIR. | Voir la description |
| élément de données | Utilisé pour relier les actions de règles aux éléments de données. Consultez l'aperçu des types d'action pour obtenir une explication détaillée de son utilisation dans chacun des types d'action. Il est facultatif pour SHOWWARNING, SHOWERROR, WARNINGONCOMPLETE, ERRORONCOMPLETE, ASSIGN et HIDEFIELD. | Voir la description |
| Entité suivie - Attribut | Utilisé pour relier les actions des règles aux attributs d'entités suivies. Consultez l'aperçu des types d'action pour obtenir une explication détaillée de son utilisation dans chacun des types d'action. Il est facultatif pour SHOWWARNING, SHOWERROR et HIDEFIELD. | Voir la description |
| option | Utilisé pour relier les actions des règles aux options. Consultez l'aperçu des types d'action pour obtenir une explication détaillée de leur utilisation dans chacun des types d'action. Il est facultatif pour HIDEOPTION | Voir la description |
| optionGroup (groupes d'options) | Utilisé pour relier les actions des règles aux groupes d'options. Consultez l'aperçu des type d'action pour obtenir une explication détaillée de son utilisation dans chacun des types d'action. Il est obligatoire pour SHOWOPTIONGROUP, HIDEOPTIONGROUP. | Voir la description |
| Étape du programme | Utilisée uniquement pour les actions de la règle CREATEEVENT. Elle est obligatoire pour CREATEEEVENT. | Voir la description |
| programStage- Section (étape de programme - section) | Utilisée uniquement pour les actions de la règle HIDESECTION. Elle est obligatoire pour HIDESECTION | Voir la description |

##### Validation des actions des règles de programme { #programruleaction-validation } 
Certaines validations ont été ajoutées au modèle des actions des règles de programme dans la version 2.37. L'objectif principal était d'empêcher l'utilisateur de créer des règles de programme erronées afin de maintenir la cohérence de la base de données. Ces validations dépendent du type d'action de la règle de programme. Chaque type d'action a sa propre validation. 

Tableau : Validations des actions des règles de programme

| nom | contrôle de validation de l'existence de l'identifiant |
|---|---|
|SENDMESSAGE| Identifiant du modèle de notification |
|SCHEDULEMESSAGE| Identifiant du modèle de notification |
|HIDESECTION| Identifiant de la section de l'étape de programme |
|HIDEPROGRAMSTAGE| Identifiant de l'étape de programme |
|HIDEFIELD| Élément de données ou Attribut d'entité suivie |
|HIDEOPTION| Identifiant de l'option |
|HIDEOPTIONGROUP| Identifiant du groupe d'options |
|SHOWOPTIONGROUP| Identifiant du groupe d'options |
|SETMANDATORYFIELD| Élément de données ou Attribut d'entité suivie |
|SHOWERROR| Toujours valide |
|SHOWWARNING| Toujours valide |
|DISPLAYTEXT| Élément de données ou Attribut d'entité suivie |
|DISPLAYKEYVALUEPAIR||
|ASSIGN| Élément de données ou Attribut d'entité suivie |
|WARNINGONCOMPLETE| Élément de données ou Attribut d'entité suivie |
|ERRORONCOMPLETE| Élément de données ou Attribut d'entité suivie |

En plus des validations ci-dessus, le champ `données` dans l'action de la règle de programme qui contient normalement une expression peut également être évalué en utilisant le point d'extrémité de l'api ci-dessous.

    POST /api/programRuleActions/data/expression/description?programId=<uid>


```json
{
  "condition": "1 + 1"
}
```

#### Détails sur le modèle de variables des règles de programme { #program-rule-variable-model-details } 

Le tableau suivant donne un aperçu détaillé du modèle de variables des règles de programme.

Tableau : Variable de règles de programme

| nom | Description | Obligatoire |
|---|---|---|
| nom | le nom de la variable de la règle de programme - ce nom est utilisé dans les expressions. #{myVariable} \> 5 | Obligatoire |
| sourceType (type de source) | Définit comment cette variable est renseignée avec les données de l'inscription et des événements.<br> * DATAELEMENT_NEWEST_EVENT_PROGRAM_STAGE - Dans la saisie Tracker, cette variable obtient la valeur la plus récente qui existe pour un élément de données, dans les événements d'une étape de programme donnée dans l'inscription actuelle. Dans la saisie Evénement, elle obtient la valeur la plus récente parmi les 10 événements les plus récents de l'unité d'organisation.<br> * DATAELEMENT_NEWEST_EVENT_PROGRAM - Dans la saisie Tracker, cette variable obtient la valeur la plus récente d'un élément de données pour toute l'inscription. Dans la saisie Evénement, elle obtient la valeur la plus récente parmi les 10 événements les plus récents de l'unité d'organisation.<br> * DATAELEMENT_CURRENT_EVENT - Obtient la valeur de l'élément de données en question dans l'événement en cours uniquement.<br> * DATAELEMENT_PREVIOUS_EVENT - Dans la saisie Tracker, cette variable obtient la valeur la plus récente parmi les événements du programme qui précède l'événement en cours. Dans la saisie Evénement, elle obtient la valeur la plus récente parmi les 10 événements précédents enregistrés dans l'unité d'organisation.<br> * CALCULATED_VALUE - Utilisée pour réserver un nom de variable qui sera attribué par une action de règle de programme ASSIGN.<br> * TEI_ATTRIBUTE - Obtient la valeur d'un attribut d'entité suivie spécifique. | Obligatoire |
| élément de données | Utilisé pour relier la variable de la règle de programme à un élément de données. Il est obligatoire pour tous les types de sources commençant par DATAELEMENT_. | Voir la description |
| Entité suivie - Attribut | Utilisé pour relier la variable de la règle de programme à un attribut d'entité suivie. Il est obligatoire pour le type de source TEI_ATTRIBUTE. | Voir la description |
| useCodeFor- OptionSet (utiliser le code pour - Ensemble d'options) | Si cette variable est cochée, elle sera remplie avec le code - et non le nom - de tout ensemble d'options qui lui relié. Par défaut, elle n'est pas cochée, ce qui signifie que c'est le nom de l'option est utilisé. ||
| Étape du programme | Utilisé pour spécifier une étape de programme précise à partir de laquelle la valeur de la variable de la règle de programme doit être récupérée. Il est obligatoire pour DATAELEMENT_NEWEST_EVENT_PROGRAM_STAGE. | Voir la description |

### Création de règles de programme { #webapi_creating_program_rules } 

- Pour effectuer des opérations CRUD, vous pouvez utiliser la ressource `programRules`, disponible dans l'API.

Pour récupérer la liste des règles de programmes, vous pouvez effectuer une requête GET comme suit :

    /api/programRules

Pour récupérer une seule règle de programme, vous pouvez effectuer une requête GET comme suit :

    /api/programRules/<program_rule_uid>

Pour sauvegarder ou ajouter une seule règle de programme, vous pouvez effectuer une requête POST comme suit :

    /api/programRules/<program_rule_uid>

Pour mettre à jour une seule règle de programme, vous pouvez effectuer une requête PUT comme suit :

    /api/programRules/<program_rule_uid>

Pour supprimer une seule règle de programme, vous pouvez effectuer une requête DELETE comme suit :

    /api/programRules/<program_rule_uid>

Pour récupérer la description de la condition de la règle de programme, vous pouvez effectuer une requête POST en fournissant la chaîne de la condition dans le corps de la requête.

    /api/programRules/condition/description?<program_rule_uid>

## Formulaires { #webapi_forms } 

Pour récupérer des informations sur un formulaire (qui correspond à un ensemble de données et à ses sections), vous pouvez interagir avec la ressource `form`. La réponse du formulaire est accessible en XML et JSON et fournira des informations sur chaque section (groupe) du formulaire ainsi que sur chaque champ de ces sections, y compris les étiquettes et les identifiants. En fournissant des identifiants de période et d'unité d'organisation, la réponse du formulaire sera constituée de valeurs de données.

Tableau : Paramètres de requête du formulaire

| Paramètre | Option | Description |
|---|---|---|
| pe | Période ISO | Période pour laquelle les valeurs de données du formulaire doivent être renseignées. |
| ou | UID | Unité d'organisation pour laquelle les valeurs de données du formulaire doivent être renseignées. |
| Métadonnées | faux &#124; vrai | Détermine s'il faut inclure ou non des métadonnées sur chaque élément de données des sections du formulaire. |

Pour récupérer le formulaire d'un ensemble de données, vous pouvez effectuer une requête GET comme suit :

    /api/dataSets/<dataset-id>/form.json

Pour récupérer le formulaire pour l'ensemble de données ayant l'identifiant "BfMAe6Itzgt" au format XML :

    /api/dataSets/BfMAe6Itzgt/form

Pour récupérer le formulaire en incluant les métadonnées, au format JSON :

    /api/dataSets/BfMAe6Itzgt/form.json?metaData=true

Pour récupérer le formulaire rempli avec les valeurs de données d'une période et d'une unité d'organisation spécifiques au format XML :

    /api/dataSets/BfMAe6Itzgt/form.xml?ou=DiszpKrYNg8&pe=201401

Cette ressource permet également de créer des formulaires de saisie de données personnalisés, directement pour un ensemble de données. Cela peut se faire à l'aide d'une requête POST ou PUT avec un contenu de type text/html où la charge est le balisage du formulaire personnalisé. En voici l'illustration :

```bash
curl -d @form.html "localhost/api/dataSets/BfMAe6Itzgt/form"
  -H "Content-Type:text/html" -u admin:district -X PUT
```

## Documents { #webapi_documents } 

Les références aux fichiers peuvent être stockées avec la ressource "document".



Tableau : Champs du document

| Nom du champ | Description |
|---|---|
| nom | nom unique du document |
| externe | drapeau identifiant l'emplacement du document. TRUE pour les fichiers externes, FALSE pour les fichiers internes. |
| url | l'emplacement du fichier. URL pour les fichiers externes. Identifiant de la ressource "fichier" pour les fichiers internes (voir [Ressources fichier](#webapi_file_resources)) |

Une requête GET au point d'extrémité des documents renverra tous les documents :

    /api/documents

Une requête POST au point d'extrémité des documents créera un nouveau document :

```bash
curl -X POST -d @document.json -H "Content-type: application/json"
  "http://dhis.domain/api/documents"
```

```json
{
  "name": "dhis home",
  "external": true,
  "url": "https://www.dhis2.org"
}
```

Une requête GET à laquelle est ajouté l'identifiant d'un document renverra des informations sur ce document. Une requête PUT au même point d'extrémité mettra à jour les champs du document :

    /api/documents/<documentId>

Ajouter */data* à la requête GET renverra le contenu réel du document :

    /api/documents/<documentId>/data

## Importation de métadonnées CSV { #webapi_csv_metadata_import } 

DHIS2 prend en charge l'importation de métadonnées au format CSV, telles que les éléments de données, les unités d'organisation et les règles de validation. Les propriétés des différents objets de métadonnées sont identifiées en fonction de l'ordre ou de l'index des colonnes (voir ci-dessous pour plus de détails). Vous pouvez omettre les propriétés d'objets ou les colonnes non nécessaires, mais puisque l'ordre des colonnes est important, une colonne vide doit être incluse. En d'autres termes, si vous voulez spécifier des propriétés ou des colonnes qui apparaissent tard dans l'ordre des colonnes, mais ne pas spécifier certaines colonnes qui apparaissent tôt dans l'ordre, vous pouvez inclure des colonnes vides pour elles.

La première ligne du fichier CSV est considérée comme un en-tête et est ignorée lors de l'importation. Le caractère _virgule_ doit être utilisé comme séparateur de texte. Le texte qui contient des virgules doit être placé entre _guillemets doubles_.

Pour télécharger des métadonnées au format CSV, vous pouvez envoyer une requête POST au point d'extrémité des métadonnées :

    POST /api/metadata?classKey=CLASS-KEY

Les types d'objets suivants sont pris en charge. Le paramètre de requête `classKey` est obligatoire et se trouve à côté de chaque type d'objet dans le tableau ci-dessous.

Tableau : Types d'objets et clés

| Type d'objet | Clé de classe |
|---|---|
| Éléments de données | DATA_ELEMENT |
| Groupes d'éléments de données | DATA_ELEMENT_GROUP |
| Les options de catégorie | CATEGORY_OPTION |
| Groupes d'options de catégorie | CATEGORY_OPTION_GROUP |
| Unités d’organisation | ORGANISATION_UNIT |
| Groupes d'unités d'organisation | ORGANISATION_UNIT_GROUP |
| Règles de validation | VALIDATION_RULE |
| Ensembles d'options | OPTION_SET |
| Les traductions | TRANSLATION |

> **Astuce**
>
> Si vous utilisez *curl*, l'option `--data-binary` doit être utilisée car elle préserve les sauts de ligne et les nouvelles lignes, ce qui est essentiel pour les données CSV.

Par exemple, pour télécharger un fichier d'éléments de données au format CSV avec `curl`, vous pouvez utiliser la commande suivante :

```bash
curl --data-binary @data_elements.csv "http://localhost/api/metadata?classKey=DATA_ELEMENT"
  -H "Content-Type:application/csv" -u admin:district
```

Les formats des types d'objets actuellement pris en charge pour l'importation en CSV sont énumérés dans les sections suivantes.

### Eléments de données { #webapi_csv_data_elements } 

Tableau : Format CSV des éléments de données

| Index | Colonne | Obligatoire | Valeur (par défaut en premier) | Description |
|---|---|---|---|---|
| 1 | Nom | Oui || Nom. Maximum 230 caractères. Unique. |
| 2 | UID | Non | UID | Identifiant stable. Exactement 11 caractères alphanumériques, commençant par une lettre. Généré par le système s'il n'est pas spécifié. |
| 3 | Code | Non || Code stable. Maximum 50 caractères. |
| 4 | Nom abrégé | Non | 50 premiers caractères du nom | S'il n'est pas spécifié, il est remplacé par les 50 premiers caractères du nom. Maximum 50 caractères. Unique. |
| 5 | Description | Non || Description en texte libre. |
| 6 | Nom du formulaire | Non || Maximum 230 caractères. |
| 7 | Type de domaine | Non | AGRÉGÉ | TRACKER | Type de domaine pour l'élément de données ; il peut s'agir du domaine Agrégé ou du Tracker. Maximum 16 caractères. |
| 8 | Type de valeur | Non | ENTIER | NOMBRE | UNITÉ_INTERVALLE | POURCENTAGE | ENTIER_POSITIF | ENTIER_NÉGATIF | ENTIER_ZÉRO_OU_POSITIF | FICHIER_RESSOURCE | COORDONNÉE | TEXTE | TEXTE_ LONG | LETTRE | NUMÉRO_DE TÉLÉPHONE | EMAIL | BOOLÉEN | VRAI_UNIQUEMENT | DATE | DATE ET HEURE | Type de valeur. Maximum 16 caractères. |
| 9 | Type d'agrégation | Non | SUM &#124; AVERAGE &#124; AVERAGE_SUM_ORG_UNIT &#124; COUNT &#124; STDDEV &#124; VARIANCE &#124; MIN &#124; MAX &#124; NONE | Type d'agrégation indiquant comment agréger les données dans les différentes dimensions. Maximum 16 caractères. |
| 10 | La combinaison de catégories | Non | UID | UID de la combinaison de catégories. La combinaison de catégories par défaut sera utilisée si aucune n'est spécifiée. |
| 11 | Url | Non || URL de la ressource de l'élément de données. Maximum 255 caractères. |
| 12 | Le zéro est significatif | Non | faux &#124; vrai | Indique si les valeurs nulles (zéro) seront stockées pour cet élément de données. |
| 13 | Ensemble d'options | Non | UID | UID de l'ensemble d'options à utiliser pour les données. |
| 14 | Ensemble d'options pour les commentaires | Non | UID | UID de l'ensemble d'options à utiliser pour les commentaires. |

Vous trouverez ci-dessous un exemple de fichier CSV pour les éléments de données. La première ligne sera toujours ignorée. Vous pouvez ignorer des colonnes et compter sur les valeurs par défaut utilisées par le système. Vous pouvez également ignorer les colonnes que vous n'utilisez pas et qui apparaissent à droite de celles

```csv
name,uid,code,shortname,description
"Women participated skill development training",,"D0001","Women participated in training"
"Women participated community organizations",,"D0002","Women participated in organizations"
```

### Les unités d’organisation { #webapi_csv_org_units } 

Tableau : Format CSV de l'unité d'organisation

| Index | Colonne | Obligatoire | Valeur (par défaut en premier) | Description |
|---|---|---|---|---|
| 1 | Nom | Oui || Nom. Maximum 230 caractères. Unique. |
| 2 | UID | Non | UID | Identifiant stable. Maximum 11 caractères. Il est généré par le système s'il n'est pas spécifié. |
| 3 | Code | Non || Code stable. Maximum 50 caractères. |
| 4 | Ascendant direct | Non | UID | UID de l'unité d'organisation mère. |
| 5 | Nom abrégé | Non | 50 premiers caractères du nom | S'il n'est pas spécifié, il est remplacé par les 50 premiers caractères du nom. Maximum 50 caractères. Unique. |
| 6 | Description | Non || Description en texte libre. |
| 7 | Date d'ouverture | Non | 1970-01-01 | Date d'ouverture de l'unité d'organisation au format AAAA-MM-JJ. |
| 8 | Date de clôture | Non || Date de fermeture de l'unité d'organisation au format AAAA-MM-JJ, ignorer si l'unité est actuellement ouverte. |
| 9 | Commentaire | Non || Commentaire en texte libre pour l'unité d'organisation. |
| 10 | Type de fonctionnalité | Non | NONE &#124; MULTI_POLYGON &#124; POLYGON &#124; POINT &#124; SYMBOL | Type d'élément géospatial. |
| 11 | Coordonnées | Non || Coordonnées utilisées pour l'analyse géospatiale au format Geo JSON. |
| 12 | URL | Non || URL de la ressource de l'unité d'organisation. Maximum 255 caractères. |
| 13 | Personne de contact | Non || Personne de contact pour l'unité d'organisation. Maximum 255 caractères. |
| 14 | Addresse | Non || Adresse de l'unité d'organisation. Maximum 255 caractères. |
| 15 | Adresses électronique | Non || Courriel de l'unité d'organisation. Maximum 150 caractères. |
| 16 | Numéro de téléphone | Non || Numéro de téléphone de l'unité d'organisation. Maximum 150 caractères. |

Voici un exemple d'importation d'unités d'organisation avec une unité mère, en utilisant des informations minimales :

```csv
name,uid,code,parent
"West province",,"WESTP","ImspTQPwCqd"
"East province",,"EASTP","ImspTQPwCqd"
```

### Règles de validation { #webapi_csv_validation_rules } 

Tableau : Format CSV de la règle de validation

| Index | Colonne | Obligatoire | Valeur (par défaut en premier) | Description |
|---|---|---|---|---|
| 1 | Nom | Oui || Nom. Maximum 230 caractères. Unique. |
| 2 | UID | Non | UID | Identifiant stable. Maximum 11 caractères. Il est généré par le système s'il n'est pas spécifié. |
| 3 | Code | Non || Code stable. Maximum 50 caractères |
| 4 | Description | Non || Description en texte libre. |
| 5 | Instruction | Non || Instruction en texte libre. |
| 6 | Importance | Non | MOYEN | ÉLEVÉ | FAIBLE | Importance de la règle de validation. |
| 7 | Type de règle (ignoré) | Non | VALIDATION | SURVEILLANCE | Type de règle de validation. |
| 8 | Opérateur | Non | égal_à | non_égal_à | supérieur_à | supérieur_ou_égal_à_ | inférieur_à | inférieur_ou_égal_à_ | paire_obligatoire | paire_exclusive | Opérateur d'expression. |
| 9 | Type de période | Non | Mensuel | Quotidien | Hebdomadaire | Trimestriel | Semestriel | Annuel | Type de période |
| 10 | Expression du côté gauche | Oui || Formule mathématique basée sur les UID des éléments de données et des combinaisons d'options. |
| 11 | Description de l'expression du côté gauche | Oui || Texte libre |
| 12 | Stratégie de la valeur manquante du côté gauche | Non | IGNORER_SI_UNE_VALEUR_EST MANQUANTE | IGNORER_SI_TOUTES_LES VALEURS_SONT MANQUANTES | NE JAMAIS_IGNORER  | Fonctionnement en cas de valeurs manquantes dans l'expression de gauche. |
| 13 | Expression du côté droit | Oui || Formule mathématique basée sur les UID des éléments de données et des combinaisons d'options. |
| 14 | Description de l'expression du côté droit | Oui || Texte libre |
| 15 | Stratégie de valeur manquante du côté droit | Non | IGNORER_SI_UNE_VALEUR_EST MANQUANTE | IGNORER_SI_TOUTES_LES VALEURS_SONT MANQUANTES | NE JAMAIS_IGNORER  | Fonctionnement en cas de valeurs manquantes dans l'expression de droite. |

### Ensembles d'options { #webapi_csv_option_sets } 

Tableau : Format CSV de l'ensemble d'options

| Index | Colonne | Obligatoire | Valeur (par défaut en premier) | Description |
|---|---|---|---|---|
| 1 | Nom de l'ensemble d'options | Oui || Nom. Maximum 230 caractères. Unique. Doit être répété pour chaque option. |
| 2 | UID de l'ensemble d'options | Non | UID | Identifiant stable. Maximum 11 caractères. Il est généré par le système si aucun n'est spécifié. Il doit être répété pour chaque option. |
| 3 | Code de l'ensemble d'options | Non || Code stable. Maximum 50 caractères. Il doit être répété pour chaque option. |
| 4 | Nom de l'option | Oui || Nom de l'option. Maximum 230 caractères. |
| 5 | UID de l'option | Non | UID | Identifiant stable. Maximum 11 caractères. Il est généré par le système s'il n'est pas spécifié. |
| 6 | Code de l'option | Oui || Code stable. Maximum 50 caractères. |

Le format des ensembles d'options est particulier. Les trois premières valeurs représentent un ensemble d'options. Les trois dernières valeurs représentent une option. Les trois premières valeurs représentant l'ensemble d'options doivent être répétées pour chaque option.

```csv
optionsetname,optionsetuid,optionsetcode,optionname,optionuid,optioncode
"Color",,"COLOR","Blue",,"BLUE"
"Color",,"COLOR","Green",,"GREEN"
"Color",,"COLOR","Yellow",,"YELLOW"
"Sex",,,"Male",,"MALE"
"Sex",,,"Female",,"FEMALE"
"Sex",,,"Unknown",,"UNKNOWN"
"Result",,,"High",,"HIGH"
"Result",,,"Medium",,"MEDIUM"
"Result",,,"Low",,"LOW"
"Impact","cJ82jd8sd32","IMPACT","Great",,"GREAT"
"Impact","cJ82jd8sd32","IMPACT","Medium",,"MEDIUM"
"Impact","cJ82jd8sd32","IMPACT","Poor",,"POOR"
```

### Groupe d'options { #option-group } 

Tableau : Format CSV du groupe d'options

| Index | Colonne | Obligatoire | Valeur (par défaut en premier) | Description |
|---|---|---|---|---|
| 1 | Nom du groupe d'options | Oui || Nom. Maximum 230 caractères. Unique. Doit être répété pour chaque option. |
| 2 | Uid du groupe d'options | Non || Identifiant stable. Maximum 11 caractères. Il est généré par le système si aucun n'est spécifié. Il doit être répété pour chaque option. |
| 3 | Code du groupe d'options | Non || Code stable. Maximum 50 caractères. Il doit être répété pour chaque option. |
| 4 | Nom court du groupe d'options | Oui || Nom court. Maximum 50 caractères. Unique. Doit être répété pour chaque option. |
| 5 | Uid de l'ensemble d'options | Oui || Identifiant stable. Maximum 11 caractères. Doit être répété pour chaque option. |
| 6 | Uid de l'option | Non || Identifiant stable. Maximum 11 caractères. |
| 7 | Code de l'option | Non || Code stable. Maximum 50 caractères. |

Exemple de charge CSV d'un groupe d'options

```csv
optionGroupName,optionGroupUid,optionGroupCode,optionGroupShortName,optionSetUid,optionUid,optionCode
optionGroupA,,,groupA,xmRubJIhmaK,,OptionA
optionGroupA,,,groupA,xmRubJIhmaK,,OptionB
optionGroupB,,,groupB,QYDAByFgTr1,,OptionC
```
### Ensemble de groupes d'options { #option-group-set } 



Tableau : Format CSV de l'ensemble de groupes d'options

| Index | Colonne | Obligatoire | Valeur (par défaut en premier) | Description |
|---|---|---|---|---|
| 1 | Nom de l'ensemble de groupes d'options | Oui || Nom. Maximum 230 caractères. Unique. Doit être répété pour chaque option. |
| 2 | Uid de l'ensemble de groupes d'options | Non || Identifiant stable. Maximum 11 caractères. Il est généré par le système si aucun n'est spécifié. Il doit être répété pour chaque option. |
| 3 | Code de l'ensemble de groupes d'options | Non || Code stable. Maximum 50 caractères. Il doit être répété pour chaque option. |
| 4 | Description de l'ensemble de groupes d'options | Non || Description. Doit être répétée pour chaque option. |
| 5 | Dimension de données | Non || VRAI, FAUX |
| 6 | Uid de l'ensemble d'options | Non || UID de l'ensemble d'options. Identifiant stable. Maximum 11 caractères. |

Exemple de charge CSV d'un ensemble de groupes d'options

```csv
name,uid,code,description,datadimension,optionsetuid
optiongroupsetA,,,,,xmRubJIhmaK
optiongroupsetB,,,,false,QYDAByFgTr1
```
Pour ajouter des groupes d'options à un ensemble de groupes d'options importé, suivez les mêmes étapes que pour l'importation de l'appartenance à une collection.

### Appartenance à une collection { #collection-membership } 

Outre l'importation d'objets, vous pouvez également choisir de n'importer que la relation groupe-membre entre un objet et un groupe. Actuellement, les paires de groupes et d'objets suivantes sont prises en charge

  - Groupe d'unités d'organisation - Unité d'organisation

  - Groupe d'éléments de données - Élément de données

  - Groupe d'indicateurs - Indicateur

  - Ensemble de groupes d'options - Groupe d'options

Le format CSV pour ces importations est le même



Tableau : Format CSV des membres d'une collection

| Index | Colonne | Obligatoire | Valeur (par défaut en premier) | Description |
|---|---|---|---|---|
| 1 | UID | Oui | UID | L'UID de la collection à laquelle ajouter un objet |
| 2 | UID | Oui | UID | L'UID de l'objet à ajouter à la collection |

### Autres objets { #webapi_csv_other_objects } 



Table: Data Element Group, Category Option, Category Option Group, Organisation Unit Group CSV Format

| Index | Colonne | Obligatoire | Valeur (par défaut en premier) | Description |
|---|---|---|---|---|
| 1 | Nom | Oui || Nom. Maximum 230 caractères. Unique. |
| 2 | UID | Non | UID | Identifiant stable. Maximum 11 caractères. Il est généré par le système si aucun n'est spécifié. |
| 3 | Code | Non || Code stable. Maximum 50 caractères. |
| 4 | Nom abrégé | Non || Nom court. 50 caractères maximum. |

Voici un exemple d'options de catégorie :

```csv
name,uid,code,shortname
"Male",,"MALE"
"Female",,"FEMALE"
```

## Objets supprimés { #webapi_deleted_objects } 

La ressource des objets supprimés fournit un journal des objets de métadonnées supprimés.

    /api/deletedObjects

Chaque fois qu'un objet de métadonnées est supprimé, un journal est conservé avec l'identifiant, le code, le type et l'heure de la suppression. Cette API est disponible à l'adresse `/api/deletedObjects`. Le filtrage des champs et des objets fonctionne de la même manière que pour les autres ressources de métadonnées.

Obtenir des objets supprimés de type éléments de données :

    GET /api/deletedObjects.json?klass=DataElement

Obtenir un objet de type indicateur qui a été supprimé dans la période allant de 2015 et plus :

    GET /api/deletedObjects.json?klass=Indicator&deletedAt=2015-01-01

## Favoris { #webapi_favorites } 

Certains types d'objets de métadonnées peuvent être marqués comme favoris pour l'utilisateur actuellement connecté. Cela s'applique actuellement aux tableaux de bord.

    /api/dashboards/<uid>/favorite

Pour faire d'un tableau de bord un favori, vous pouvez envoyer une requête *POST* (aucun type de contenu n'est requis) à une URL comme suit :

    /api/dashboards/iMnYyBfSxmM/favorite

Pour supprimer un tableau de bord en tant que favori, vous pouvez effectuer une requête *DELETE* en utilisant l'URL ci-dessus.

Le statut de favori apparaîtra comme un champ booléen *favori* sur l'objet (par exemple, le tableau de bord) dans la réponse de métadonnées.

## Abonnements { #webapi_subscription } 

A logged user can subscribe to certain types of objects. Currently
subscribable objects are those of type Chart, EventChart, EventReport,
Map, ReportTable and Visualization.

> **Note**
>
> The Chart and ReportTable objects are deprecated. Use Visualization instead.

Pour obtenir les abonnés d'un objet (un tableau contenant les UID), vous pouvez effectuer une requête *GET* comme suit :

    /api/<object-type>/<object-id>/subscribers

Voir l'exemple suivant :

    /api/charts/DkPKc1EUmC2/subscribers

Pour vérifier si l'utilisateur actuel est abonné à un objet (obtenir une valeur booléenne), vous pouvez effectuer un appel *GET* :

    /api/<object-type>/<object-id>/subscribed

Voir l'exemple suivant :

    /api/charts/DkPKc1EUmC2/subscribed

Pour s'abonner ou se désabonner d'un objet, effectuez une requête *POST/DELETE* (aucun type de contenu n'est requis) :

    /api/<object-type>/<object-id>/subscriber

## Ressources de fichiers { #webapi_file_resources } 

Les *Ressources de fichiers* sont des objets utilisés pour représenter et stocker du contenu binaire. L'objet *FileResource* (ressource de fichier) contient les métadonnées du fichier (nom, contenu-type, taille, etc.) ainsi qu'une clé permettant d'extraire le contenu à partir d'un magasin de fichiers externe à la base de données. L'objet *FileResource* est stocké dans la base de données comme n'importe quel autre objet, mais le contenu (fichier) est stocké ailleurs et peut être récupéré à l'aide de la référence du contenu *(storageKey)* ou clé de stockage.

    /api/fileResources

Le contenu des ressources de fichiers n'est pas directement accessible, mais il est référencé à partir d'autres objets (tels que les valeurs de données) pour stocker des données binaires d'une taille pratiquement illimitée.

Pour créer une ressource de fichier qui ne nécessite pas de valeur de données correspondante, envoyez une requête POST au point d'extrémité `/api/fileResources` avec un téléchargement en plusieurs parties :

```bash
curl "https://server/api/fileResources" -X POST
  -F "file=@/path/to/file/name-of-file.png"
```

Pour créer à la fois une ressource de fichier et une valeur de données qui fait référence au fichier, envoyez une requête POST au point d'extrémité `/api/dataValues/file` avec DHIS version 2.36 ou une version plus récente :

```bash
curl "https://server/api/dataValues/file?de=xPTAT98T2Jd
  &pe=201301&ou=DiszpKrYNg8&co=Prlt0C1RF0s" -X POST
  -F "file=@/path/to/file/name-of-file.png"
```

Pour le point d'extrémité `api/fileResources`, le seul paramètre de formulaire requis est *file*, qui correspond au fichier à télécharger. Pour le point d'extrémité `api/dataValues/file`, les paramètres requis sont les mêmes que pour une requête POST à `api/dataValues`, avec l'ajout de *file*.

Le nom de fichier et le type de contenu doivent également être inclus dans la requête, mais ils seront remplacés par des valeurs par défaut s'ils ne sont pas fournis.

Lorsque la création d'une ressource fichier est réussie, les données renvoyées contiennent un champ `response` qui contient à son tour `fileResource` comme suit :

```json
{
  "httpStatus": "Accepted",
  "httpStatusCode": 202,
  "status": "OK",
  "response": {
    "responseType": "FileResource",
    "fileResource": {
      "name": "name-of-file.png",
      "created": "2015-10-16T16:34:20.654+0000",
      "lastUpdated": "2015-10-16T16:34:20.667+0000",
      "externalAccess": false,
      "publicAccess": "--------",
      "user": { ... },
      "displayName": "name-of-file.png",
      "contentType": "image/png",
      "contentLength": 512571,
      "contentMd5": "4e1fc1c3f999e5aa3228d531e4adde58",
      "storageStatus": "PENDING",
      "id": "xm4JwRwke0i"
    }
  }
}
```

Notez la réponse *202 Accepted*, qui indique que la ressource renvoyée a été soumise à un traitement en arrière-plan (persistance vers le magasin de fichiers externe dans ce cas). Notez également le champ `storageStatus` qui indique si le contenu a été stocké ou non. À ce stade, la persistance vers le magasin externe n'est pas encore terminée (elle est probablement en train d'être téléchargée vers un magasin basé sur le cloud) comme le montre le statut `PENDING`.

Même si le contenu n'a pas encore été entièrement stocké, la ressource de fichier peut maintenant être utilisée, par exemple comme contenu référencé dans une valeur de données (voir [Travailler avec des valeurs de données de fichier](#datavalue_file)). Si nous avons besoin de vérifier le *storageStatus* mis à jour ou de récupérer les métadonnées du fichier, une requête peut être envoyée au point d'extrémité `fileResources`.

```bash
curl "https://server/api/fileResources/xm4JwRwke0i" -H "Accept: application/json"
```

Cette requête renverra l'objet `FileResource` comme le montre la réponse de l'exemple ci-dessus.

### Contraintes liées aux ressources de fichiers { #webapi_file_resources_constraints } 

  - Les ressources de fichiers *doivent* être référencées (attribuées) à partir d'un autre objet.
    afin d'être conservées à long terme. Un fichier de ressource qui est
    créé mais non référencé par un autre objet, par exemple une valeur de données, est
    est considérée comme étant en *staging*. Toutes les ressources de fichiers dans ce 
    état et datant de plus de *deux heures* seront marqués pour suppression.
    et seront retirées du système.

  - L'ID renvoyé par la création initiale de la ressource de fichier n'est pas
    récupérable à partir de tout autre emplacement, à moins que la ressource de fichier n'ait été
    été référencée (auquel cas l'ID sera stocké en tant que référence), 
    de sorte que sa perte nécessitera que la requête POST soit répétée et qu'un 
    nouvel objet soit créé. La ressource de fichier *orpheline* sera nettoyée automatiquement.
    automatiquement.

  - Les objets de ressources de fichiers sont *immuables*, ce qui signifie qu'ils ne peuvent pas être modifiés 
    et nécessitent plutôt la création d'une ressource entièrement nouvelle.

### Liste noire des ressources de fichiers { #file-resource-blocklist } 

Pour des raisons de sécurité, certains types de fichiers ne peuvent pas être téléchargés.

Les types de contenu suivants sont bloqués.

| Type de contenu | Type de contenu |
| ------------------------------------- | ---- |
| text/html                             | application/x-ms-dos-executable |
| text/css                              | application/vnd.microsoft.portable-executable |
| text/javascript                       | application/vnd.apple.installer+xml |
| font/otf                              | application/vnd.mozilla.xul+xml |
| application/x-shockwave-flash         | application/x-httpd-php  |
| application/vnd.debian.binary-package | application/x-sh |
| application/x-rpm                     | application/x-csh |
| application/java-archive              |  |

Les extensions de fichiers suivantes sont bloquées.

| Extension de fichier | Extension de fichier | Extension de fichier |
| ---- | ---- | ---- |
| html | deb  | xul  |
| htm  | rpm  | php  |
| css  | jar  | bin  |
| js   | jsp  | sh   |
| mjs  | exe  | csh  |
| otf  | msi  | bat  |
| swf  | mpkg |      |

## Versionnage des métadonnées { #webapi_metadata_versioning } 

Cette section explique les API de versionnage des métadonnées.

  - `/api/metadata/version`: This endpoint will return the current metadata
    du système sur lequel il est invoqué.



Tableau : Paramètres de requête

| Nom | Obligatoire | Description |
|---|---|---|
| nom de la version | faux | Si ce paramètre n'est pas spécifié, il renvoie la version actuelle du système ou, dans le cas contraire, les détails du nom de version utilisé comme paramètre. (le nom de la version utilise la syntaxe "Version_<id\>"). |

### Obtenir des exemples de versions de métadonnées { #webapi_metadata_versioning_examples } 

**Exemple:** Obtenir la version actuelle des métadonnées de ce système

Requête :

```
/api/metadata/version
```

Réponse :

```json
{
  "name": "Version_4",
  "created": "2016-06-30T06:01:28.684+0000",
  "lastUpdated": "2016-06-30T06:01:28.685+0000",
  "externalAccess": false,
  "displayName": "Version_4",
  "type": "BEST_EFFORT",
  "hashCode": "848bf6edbaf4faeb7d1a1169445357b0",
  "id": "Ayz2AEMB6ry"
}
```

**Exemple:** Obtenir les détails de la version portant le nom "Version_2".

Requête :

```
/api/metadata/version?versionName=Version_2
```

Réponse :

```json
{
  "name": "Version_2",
  "created": "2016-06-30T05:59:33.238+0000",
  "lastUpdated": "2016-06-30T05:59:33.239+0000",
  "externalAccess": false,
  "displayName": "Version_2",
  "type": "BEST_EFFORT",
  "hashCode": "8050fb1a604e29d5566675c86d02d10b",
  "id": "SaNyhusVxBG"
}
```

  - `/api/metadata/version/history`: This endpoint will return the list of all
    versions des métadonnées du système sur lequel il est appelé.



Tableau : Paramètres de requête

| Nom | Obligatoire | Description |
|---|---|---|
| baseline | faux | Si ce paramètre n'est pas spécifié, la liste de toutes les versions de métadonnées sera renvoyée. Dans le cas contraire, nous devons fournir un paramètre versionName de la forme "Version_<id\>". Il renverra alors la liste des versions présentes dans le système, qui ont été créées après que le nom de la version ait été fourni en tant que paramètre de la requête. |

### Get the list of all metadata versions { #webapi_get_list_of_metadata_versions } 

**Example:** Get the list of all versions in this system

Requête :

```
/api/metadata/version/history
```

Réponse :

```json
{
  "metadataversions": [{
    "name": "Version_1",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T05:54:41.139+0000",
    "id": "SjnhUp6r4hG",
    "hashCode": "fd1398ff7ec9fcfd5b59d523c8680798"
  }, {
    "name": "Version_2",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T05:59:33.238+0000",
    "id": "SaNyhusVxBG",
    "hashCode": "8050fb1a604e29d5566675c86d02d10b"
  }, {
    "name": "Version_3",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T06:01:23.680+0000",
    "id": "FVkGzSjAAYg",
    "hashCode": "70b779ea448b0da23d8ae0bd59af6333"
  }]
}
```

**Example:** Get the list of all versions in this system created after "Version_2"

Requête :

```
/api/metadata/version/history?baseline=Version_2
```

Réponse :

```json
{
  "metadataversions": [{
    "name": "Version_3",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T06:01:23.680+0000",
    "id": "FVkGzSjAAYg",
    "hashCode": "70b779ea448b0da23d8ae0bd59af6333"
  }, {
    "name": "Version_4",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T06:01:28.684+0000",
    "id": "Ayz2AEMB6ry",
    "hashCode": "848bf6edbaf4faeb7d1a1169445357b0"
  }]
 }
```

  - `/api/metadata/version/create`: This endpoint will create the metadata
    version for the version type as specified in the parameter.



Tableau : Paramètres de requête

| Nom | Obligatoire | Description |
|---|---|---|
| type | vrai | The type of metadata version which needs to be created.<br>  * BEST_EFFORT<br> * ATOMIC |

Users can select the type of metadata which needs to be created.
Metadata Version type governs how the importer should treat the given
version. This type will be used while importing the metadata. There are
two types of metadata.

  - *BEST_EFFORT*: This type suggests that missing references can be
    ignored and the importer can continue importing the metadata (e.g.
    missing data elements on a data element group import).

  - *ATOMIC*: This type ensures a strict type checking of the metadata
    references and the metadata import will fail if any of the references
    do not exist.

> **Note**
>
> It's recommended to have an ATOMIC type of versions to ensure that all
> systems (central and local) have the same metadata. Any missing
> reference is caught in the validation phase itself. Please see the
> importer details for a full explanation.

### Create metadata version { #webapi_create_metadata_version } 

**Example:** Create metadata version of type `BEST_EFFORT`

Requête :

```bash
curl -X POST -u admin:district "https://play.dhis2.org/dev/api/metadata/version/create?type=BEST_EFFORT"
```

Réponse :

```json
{
  "name": "Version_1",
  "created": "2016-06-30T05:54:41.139+0000",
  "lastUpdated": "2016-06-30T05:54:41.333+0000",
  "externalAccess": false,
  "publicAccess": "--------",
  "user": {
    "name": "John Traore",
    "created": "2013-04-18T17:15:08.407+0000",
    "lastUpdated": "2016-04-06T00:06:06.571+0000",
    "externalAccess": false,
    "displayName": "John Traore",
    "id": "xE7jOejl9FI"
  },
  "displayName": "Version_1",
  "type": "BEST_EFFORT",
  "hashCode": "fd1398ff7ec9fcfd5b59d523c8680798",
  "id": "SjnhUp6r4hG"
}
```

  - `/api/metadata/version/{versionName}/data`: This endpoint will download
    the actual metadata specific to the version name passed as path
    parameter.

  - `/api/metadata/version/{versionName}/data.gz`: This endpoint will download
    the actual metadata specific to the version name passed as path
    parameter in a compressed format (gzipped).



Table: Path parameters

| Nom | Obligatoire | Description |
|---|---|---|
| nom de la version | vrai | Path parameter of the form "Version_<id\>" so that the API downloads the specific version |

### Download version metadata { #webapi_download_version_metadata } 

**Example:** Get the actual metadata for "Version 5"

Requête :

```bash
curl -u admin:district "https://play.dhis2.org/dev/api/metadata/version/Version_5/data"
```

Réponse :

```json
{
  "date": "2016-06-30T06:10:23.120+0000",
  "dataElements": [
    {
      "code": "ANC 5th Visit",
      "created": "2016-06-30T06:10:09.870+0000",
      "lastUpdated": "2016-06-30T06:10:09.870+0000",
      "name": "ANC 5th Visit",
      "id": "sCuZKDsix7Y",
      "shortName": "ANC 5th Visit ",
      "aggregationType": "SUM",
      "domainType": "AGGREGATE",
      "zeroIsSignificant": false,
      "valueType": "NUMBER",
      "categoryCombo": {
        "id": "p0KPaWEg3cf"
      },
      "user": {
        "id": "xE7jOejl9FI"
      }
    }
  ]
}
```

## Metadata Synchronization { #webapi_metadata_synchronization } 

This section explains the Metadata Synchronization API available
starting 2.24

  - `/api/metadata/sync`: This endpoint performs metadata sync of the
    version name passed in the query parameter by downloading and
    importing the specified version from the remote server as defined in
    the settings app.



Tableau : Paramètres de requête

| Nom | Obligatoire | Description |
|---|---|---|
| nom de la version | vrai | versionName query parameter of the form "Version_<id\>" . The api downloads this version from the remote server and imports it in the local system. |

  - This API should be used with utmost care. Please note that there is
    an alternate way to achieve sync in a completely automated manner by
    leveraging the Metadata Sync Task from the "Data Administration"
    app. See Chapter 22, Section 22.17 of User Manual for more details
    regarding Metadata Sync Task.

  - This sync API can alternatively be used to sync metadata for the
    versions which have failed from the metadata sync scheduler. Due to
    its dependence on the given metadata version number, care should be
    taken for the order in which this gets invoked. E.g. If this api is
    used to sync some higher version from the central instance, then the
    sync might fail as the metadata dependencies are not present in the
    local instance.

  - Assume the local instance is at `Version_12` and if this endpoint is used
    to sync `Version_15` (of type `BEST_EFFORT`) from the central
    instance, the scheduler will start syncing metadata from
    `Version_16`. So the local instance will not have the metadata
    versions between `Version_12` and `Version_15`. You need to manually
    sync the missing versions using these endpoints only.

### Sync metadata version { #webapi_metadata_synchronization_version } 

**Example:** Sync Version_6 from central system to this system

Requête :

```bash
curl -u admin:district "https://play.dhis2.org/dev/api/metadata/sync?versionName=Version_6"
```

## Metadata repository { #webapi_metadata_repository } 

DHIS2 provides a metadata repository containing metadata packages with
various content. A metadata package is a DHIS2-compliant JSON document
which describes a set of metadata objects.

To retrieve an index over available metadata packages you can issue a
GET request to the *metadataRepo* resource:

    GET /api/synchronization/metadataRepo

A metadata package entry contains information about the package and a
URL to the relevant package. An index could look like this:

```json
{
  "packages": [
    {
      "id": "sierre-leone-demo",
      "name": "Sierra Leone demo",
      "description": "Sierra Leone demo database",
      "version": "0.1",
      "href": "https://dhis2.org/metadata-repo/221/sierra-leone-demo/metadata.json"
    },
    {
      "id": "trainingland-org-units",
      "name": "Trainingland organisation units",
      "description": "Trainingland organisation units with four levels",
      "version": "0.1",
      "href": "https://dhis2.org/metadata-repo/221/trainingland-org-units/metadata.json"
    }
  ]
}
```

A client can follow the URLs and install a metadata package through a
POST request with content type *text/plain* with the metadata package
URL as the payload to the *metadataPull* resource:

    POST /api/synchronization/metadataPull

An example curl command looks like this:

```bash
curl "localhost:8080/api/synchronization/metadataPull" -X POST
  -d "https://dhis2.org/metadata-repo/221/trainingland-org-units/metadata.json"
  -H "Content-Type:text/plain" -u admin:district
```

## Reference to createdBy User { #reference-to-createdby-user } 

Each object created in DHIS2 will have a property named `user` which is linked to `User` who created the object.

From version 2.36 we have changed the name of this property to `createdBy` to avoid confusion.

However, in order to keep the backwards compability, the legacy `user` property is still included in the payload and works normally as before.

```json
{
  "createdBy": {
      "displayName": "John Kamara",
      "name": "John Kamara",
      "id": "N3PZBUlN8vq",
      "username": "district"
  },
  "user": {
      "displayName": "John Kamara",
      "name": "John Kamara",
      "id": "N3PZBUlN8vq",
      "username": "district"
  }
}
```

## Metadata Proposal Workflow { #webapi_metadata_proposal_workflow }

The metadata proposal workflow endpoint allows for a workflow of proposing and accepting changes to metadata.

```
/api/metadata/proposals
```

### Propose a metadata change { #webapi_metadata_proposal_propose }

A proposal always targets a single metadata object using:

    POST /api/metadata/proposals

Depending on the payload the proposal could:

* Add a new metadata object.
* Update an existing metadata object references by ID.
* Remove an existing metadata object referenced by ID.

To propose adding a new metadata object send a JSON payload like the following:

```json
{
  "type": "ADD",
  "target": "ORGANISATION_UNIT",
  "change": {"name":"My Unit", "shortName":"MyOU", "openingDate": "2020-01-01"}
}
```
The `change` property contains the same JSON object that could directly be posted to the corresponding endpoint to create the object.

To propose updating an existing metadata object send a JSON payload like in the below example:

```json
{
  "type": "UPDATE",
  "target": "ORGANISATION_UNIT",
  "targetId": "<id>",
  "change": [
    { "op": "replace", "path": "/name", "value": "New name" }
  ]
}
```
The `targetId` refers to the object by its ID which should be updated. The `change` property here contains a JSON patch payload. This is the same
patch payload that could be posted to the corresponding endpoint to directly apply the update.

To propose the removal of an existing object send a payload like in the last example:

```json
{
  "type": "REMOVE",
  "target": "ORGANISATION_UNIT",
  "targetId": "<id>"
}
```
The `targetId` refers to the object  by its ID which should be removed. A free text `comment` can be added to any type of comment.

Only `target` type `ORGANISATION_UNIT` is supported currently.

### Accept a metadata change proposal { #webapi_metadata_proposal_accept }
To accept an open proposal use `POST` on the proposal resource

    POST /api/metadata/proposals/<uid>

When successful the status of the proposal changes to status `ACCEPTED`. Once accepted the proposal can no longer be rejected.

Should a proposal fail to apply it changes to status `NEEDS_UPDATE`. The `reason` field contains a summary of the failures when this information is 
available.

### Oppose a metadata change proposal { #webapi_metadata_proposal_oppose }
If a proposal isn't quite right and needs adjustment this can be indicated by opposing the proposal by sending a `PATCH` for the proposal resource

    PATCH /api/metadata/proposals/<uid>

Optionally a plain text body can be added to this to give a `reason` why the proposal got opposed.

A opposed proposal must be in state `PROPOSED` and will change to state `NEEDS_UPDATE`.

### Adjust a metadata change proposal { #webapi_metadata_proposal_adjust }
A proposal in state `NEEDS_UPDATE` needs to be adjusted before it can be accepted. To adjust the proposal a `PUT` request is made for the proposal's 
resource

    PUT /api/metadata/proposals/<uid>

Such an adjustment can either be made without a body or with a JSON body containing an object with the updated `change` and `targetId` for the 
adjustment:

```json
{
  "targetId": "<id>",
  "change": ...
}
```
The JSON type of the `change` value depends on the proposal `type` analogous to when a proposal is initially made.

### Reject a metadata change proposal { #webapi_metadata_proposal_reject }
To reject an open proposal use `DELETE` on the proposal resource

    DELETE /api/metadata/proposals/<uid>

This changes the status of the proposal conclusively to `REJECTED`. No further changes can be made to this proposal. It is kept as a documentation of the events.

### List metadata change proposals { #webapi_metadata_proposal_list }
All proposals can be listed:

    GET /api/metadata/proposals/

The result list can be filtered using the `filter` parameter.
For example, to list only accepted proposals use:

    GET /api/metadata/proposals?filter=status=ACCEPTED

Similarly to only show open proposals use:

    GET /api/metadata/proposals?filter=status=PROPOSED

Filters can also be applied to any field except `change`. Supported filter operators are those described in the Gist Metadata API. This also includes property transformers described for Gist API.

List of available fields are:

| Champ       | Description |
| ----------- | -------------------------------------------------------------- |
| identifiant          | unique identifier of the proposal |
| type        | `ADD` a new object, `UPDATE` an existing object, `REMOVE` an existing object |
| statut      | `PROPOSED` (open proposal), `ACCEPTED` (successful), `NEEDS_UPDATE` (accepting caused error or opposed), `REJECTED` |
| cible      | type of metadata object to add/update/remove; currently only `ORGANISATION_UNIT` |
| targetId    | UID of the updated or removed object, not defined for `ADD` |
| createdBy (créé par)   | the user that created the proposal |
| créé     | the date time when the proposal was created |
| finalisedBy | the user that accepted or rejected the proposal |
| finalised   | the date time when the proposal changed to a conclusive state of either accepted or rejected |
| commentaire     | optional plain text comment given for the initial proposal |
| raison      | optional plain text given when the proposal was opposed or the errors occurring when accepting a proposal failed | 
| change      | JSON object for `ADD` proposal, JSON array for `UPDATE` proposal, nothing for `REMOVE` proposal |

### Viewing metadata change proposals { #webapi_metadata_proposal_show }
Individual change proposals can be viewed using 

    GET /api/metadata/proposals/<uid>

The `fields` parameter can be used to narrow the fields included for the shown object. For example:

    GET /api/metadata/proposals/<uid>?fields=id,type,status,change

