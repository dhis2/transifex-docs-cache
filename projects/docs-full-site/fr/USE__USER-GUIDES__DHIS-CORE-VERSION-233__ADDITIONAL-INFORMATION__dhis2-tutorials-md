---
edit_url: "https://github.com/dhis2/dhis2-docs/blob/2.33/src/commonmark/en/content/user/dhis2-tutorials.md"
revision_date: '2019-02-11'
---

# Tutoriels sur le DHIS2 { #dhis2_tutorials } 

<!--DHIS2-SECTION-ID:dhis2_tutorials-->

## Créer des tableaux de bord à l'aide de l'application Tableau croisé dynamique { #create-scorecards-pivot-table } 

<!--DHIS2-SECTION-ID:create-scorecards-pivot-table-->

***Scorecards definition:** In public health settings such as Ministries
of Health, scorecards offer a useful and standardized method for
combining related indicators into one table. A scorecard gives an
overall view of the performance of a health program such as a
vaccination program, highlighting successes, weaknesses, and areas for
improvement Here's what a typical scorecard looks like:*

![](resources/images/tutorials/scorecards_pivot_result.png)

Ce tutoriel explique comment créer un tableau de bord dans l'application Tableau croisé dynamique de DHIS2. L'utilisation du tableau croisé dynamique pour la création d'un tableau de bord, par exemple, présente de nombreux avantages tels que :

  - Vous pouvez enregistrer la carte de pointage sur le tableau de bord et l'utiliser hors ligne.

  - Vous pouvez partager la carte de pointage avec d'autres utilisateurs de DHIS2.

Commençons donc !

### Créez une légende pour votre carte de pointage { #create-a-legend-for-your-scorecard } 

Tout d'abord, nous allons créer une légende de "feux" en 3 couleurs pour la carte de pointage. Avec ses trois couleurs de base, la carte de pointage devient facile à scanner et à comprendre.

1.  Ouvrez l'application **Maintenance**. Cliquez sur le menu dans le coin supérieur droit 
    et sélectionnez Maintenance dans la liste des applications. Vous pouvez également saisir les 
    premières lettres du mot maintenance dans le champ de recherche pour trouver 
    l'application.

    ![](resources/images/tutorials/scorecards_maintenance_app.png)

2.  Dans l'application Maintenance, faites défiler défiler au bas de la page jusqu'à 
    la section **Autres**.

3.  Allez sur **Legende** et cliquez sur le **+**.

    ![](resources/images/tutorials/scorecards_maintenance_legend.png)

4.  Dans la page **Gestion des légendes**, descendez au bas de la page 
    et créez une nouvelle légende en cliquant sur le bouton de couleur bleue +.

    ![](resources/images/tutorials/scorecards_maintenance_addbtn.png)

5.  Saisissez un nom pour la légende, par exemple "Feu tricolore", ainsi qu'une valeur de départ 
    et une valeur d'arrivée dans les champs. Les valeurs que vous saisissez ici dépendent des 
    notes de performance que vous souhaitez définir dans le tableau de performance.

6.  Remplacez **Nombre d'éléments de légende** par 3 pour afficher trois couleurs dans 
    le tableau de performances. Pour modifier les couleurs des éléments de la légende, cliquez sur le bouton de couleur bleue +, 
    puis modifiez les 
    couleurs.

    ![](resources/images/tutorials/scorecards_maintenance_legend_color.png)

### Créer une carte de pointage dans l'application Tableau croisé dynamique { #create-a-scorecard-in-the-pivot-table-app } 

1.  Ouvrez l'application **Tableau croisé dynamique** dans le coin supérieur droit du 
    tableau de bord. Vous pouvez également saisir les premières lettres de Tableau croisé dynamique dans 
    le champ de recherche.

2.  Allez à **Données** dans le volet de gauche et sélectionnez 
    **Indicateurs** dans la liste.

3.  Sélectionnez un **groupe d'indicateurs** tel que "ANC" dans la deuxième liste.

4.  À l'aide des flèches, sélectionnez le type d'indicateurs que vous souhaitez voir figurer 
    dans votre tableau de performance.

    ![](resources/images/tutorials/scorecards_pivot_indicators.png)

5.  Cliquez sur **Mise à jour**. Vous trouverez ce bouton dans le menu en haut de 
    l'espace de travail

6.  Allez dans **Périodes** et sélectionnez une période pour laquelle vous souhaitez afficher 
    des données. Dans cet exemple de "feux tricolores", nous utiliserons la section des périodes 
    relatives. Dans **Trimestres**, sélectionnez **Ce trimestre** et **Dernier 
    trimestre**. Décochez toutes les autres cases et cliquez sur **Mettre à jour**.

    ![](resources/images/tutorials/scorecards_pivot_period.png)

7.  Dans le même panneau de gauche allez sur **Unités d'organisation**, et cliquez sur 
    la flèche à côté du bouton d'engrenage.

8.  Sélectionnez **Sélectionner les niveaux**.

    ![](resources/images/tutorials/scorecards_pivot_orgunit_level.png)

9.  Sélectionnez **District** dans la liste (à côté du bouton d'engrenage). Cliquez sur 
    **Mettre à jour**.

    ![](resources/images/tutorials/scorecards_pivot_orgunit_level2.png)

Comme vous pouvez le voir, le tableau de performance commence à prendre forme dans 
l'espace de travail. Il reste maintenant à peaufiner l'aspect et la convivialité.

### Organiser la mise en page et l'affichage de votre carte de pointage { #organise-the-layout-and-display-of-your-scorecard } 

1.  Dans l'espace de travail, cliquez sur **Disposition**.

    ![](resources/images/tutorials/scorecards_pivot_layout.png)

2.  Dans **Disposition du tableau**, faites glisser **Unités d'organisation** jusqu'à la section **
    Dimensions des lignes**.

3.  Faites glisser **Données** dans la section **Dimensions de la colonne**.

4.  Dans le volet **Dimensions de la colonne**, faites glisser **Périodes** sous **Données**, 
    et cliquez sur **Mise à jour**.

5.  Dans l'espace de travail, cliquez sur **Options**.

    ![](resources/images/tutorials/scorecards_pivot_options.png)

6.  Allez dans **Données** et décochez toutes les cases.

7.  Accédez à **Style** \> **Ensemble de légende** et dans la liste, sélectionnez la 
    légende que vous avez créée dans l'application Maintenance. Dans cet exemple, nous 
    l'avons appelée Feu tricolore.

8.  Allez sur **Style** \> **Style d'affichage  des légendes** et sélectionnez **Couleur 
    de fond**.

9.  Cliquez sur **Mettre à jour**.

La carte de pointage est donc prête\ !


![](resources/images/tutorials/scorecards_pivot_result.png)

### Enregistrer et partager votre carte de pointage { #save-and-share-your-scorecard } 

1.  Dans l'espace de travail, allez au menu **Favoris**.

2.  Cliquez sur **Enregistrer sous**. Entrez un nom pour votre carte de pointage.

3.  Pour partager votre carte de pointage, sélectionnez **Favoris**.

4.  Saisissez le nom d'un groupe d'utilisateurs et cliquez sur **Sauvegarder**. Votre 
    tableau de performances peut être consulté par les personnes avec lesquelles vous partagez un tableau de bord.

## Travailler avec TextPattern { #working-with-textpattern } 

<!--DHIS2-SECTION-ID:working-with-textpattern-->

Le TextPattern a été introduit dans la version 2.29 de DHIS2, comme moyen de définir un 
modèle comprenant des variables, des valeurs générées et du texte brut, qui 
peut ensuite être généré en une valeur de texte. Le cas d'utilisation actuel de 
TextPattern est la génération automatique d'attributs pour les entités suivies 
où vous souhaitez générer par exemple des identifiants uniques basés sur un modèle 
spécifique.

Ce guide couvre à la fois les thèmes élémentaires et complexes permettant de travailler 
avec TextPattern, mais se focalise principalement sur la façon dont vous pouvez définir les 
TextPatterns et sur les limitations ainsi que mises en garde existantes.

### Syntaxe TextPattern { #textpattern-syntax } 

Un TextPattern est une séquence de *segments*, reliés entre eux par le caractère "+". Un 
segment a une notation spécifique et dans la plupart des cas un 
paramètre *format*, permettant de manipuler la valeur.

<table>
<caption>Segments TextPattern</caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 36%" />
<col style="width: 12%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th>Notation des segments</th>
<th>Description</th>
<th>Paramètre (format)</th>
<th>Exemple (segment → valeur d'entrée → résultat)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&quot;Texte simple&quot ;</td>
<td>Le segment de texte simple restera inchangé dans toutes les valeurs générées. Ce segment spécial est défini en mettant le texte entre deux doubles guillemets. Si votre modèle doit inclure des symboles de séparation comme un tiret, vous devez alors utiliser : &quot;-&quot ;.
<p>Le segment de texte simple permet également de mettre du texte en caractères de remplacement. Cela signifie que vous pouvez spécifier que certaines parties du segment de texte simple doivent être constituées d'un ensemble de caractères. Actuellement, vous pouvez utiliser 4 caractères spéciaux :</p>
<ul>
<li><p>\d (0-9)</p></li>
<li><p>\x (a-z)</p></li>
<li><p>\X (A-Z)</p></li>
<li><p>\w (a-zA-Z0-9)</p></li>
</ul></td>
<td>Aucun</td>
<td>&quot;Bonjour le monde&quot ; → Aucun → Bonjour le monde
<p>&quot;Bonjour \x\x\x&quot ; → &quot;Bonjour à vous&quot ; → Bonjour à vous</p>
<p>&quot;\d\d\d&quot; → &quot;123&quot; → 123</p></td>
</tr>
<tr class="even">
<td>CURRENT_DATE(format)</td>
<td>Le segment de la date du jour sera généré par le serveur au moment de la génération. Ceci est utile si vous voulez que vos modèles aient une contrainte de temps déconnectée du contexte. Vous ne devez pas l'utiliser si vous avez besoin de contrôler la date à injecter dans le modèle.</td>
<td>Format de la date</td>
<td>CURRENT_DATE(aaaa) → 01-01-2018 → 2018</td>
</tr>
<tr class="odd">
<td>ORG_UNIT_CODE(format)</td>
<td>Ce segment représente le code d'unité d'organisation associé à la génération.</td>
<td>Format du texte</td>
<td>ORG_UNIT_CODE(...) → OSLO → OSL</td>
</tr>
<tr class="even">
<td>ALÉATOIRE(format)</td>
<td>Les segments aléatoires seront remplacés par une valeur générée de façon aléatoire par le serveur en fonction du format. Les segments générés, comme Aléatoire, fondent leur caractère unique sur le reste du modèle. Cela signifie qu'une valeur aléatoire peut apparaître deux fois, tant que le reste du modèle est différent, ce qui signifie que le texte généré dans son ensemble sera unique.</td>
<td>Format de génération</td>
<td>ALÉATOIRE(X####) → Aucun → A1234</td>
</tr>
<tr class="odd">
<td>SÉQUENTIEL(format)</td>
<td>Les segments séquentiels seront remplacés par un nombre, basé sur une valeur de comptage sur le serveur. Les segments séquentiels commenceront à la valeur 1, et pour chaque valeur générée, ils seront comptés jusqu'à ce qu'il n'y ait plus de valeurs disponibles, en fonction du format. Comme pour les segments aléatoires, l'unicité est basée sur le reste du modèle, donc chaque version possible du modèle aura son propre compteur séquentiel commençant à 1.</td>
<td>Format de génération</td>
<td>&quot;A&quot;+SÉQUENTIEL(###) → Aucun → A001
<p>&quot;A&quot;-SÉQUENTIEL(###) → Aucun → A002</p>
<p>&quot;B&quot;-SÉQUENTIEL(###) → Aucun → B001</p>
<p>&quot;B&quot;-SÉQUENTIEL(###) → Aucun → B002</p></td>
</tr>
</tbody>
</table>

La plupart des segments ont un paramètre  *format *, sauf le segment de texte 
brut. Le tableau suivant énumère les formats disponibles, leur mode 
d'utilisation et des exemples de notations qui les utilisent.

<table>
<caption>Formats des paramètres</caption>
<colgroup>
<col style="width: 13%" />
<col style="width: 52%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th>Format</th>
<th>Description</th>
<th>Exemple</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Format des dates</td>
<td>Ce format est basé directement sur le SimpleDateFormat de java, ce qui signifie que tout modèle valable pour SimpleDateFormat sera valable comme format de date dans TextPattern</td>
<td>DATE_ACTUELLE(jj-MM-aaaa) → 31-12-2018
<p>DATE_ACTUELLE(MM-aaaa) → 12-2018</p></td>
</tr>
<tr class="even">
<td>Format du texte</td>
<td>Le format du texte permet une manipulation de base du texte. Si vous laissez le format vide, la valeur sera renvoyée sans modification, mais en utilisant "^", "." et "&#36 ;", vous pouvez modifier la valeur avant qu'elle ne soit renvoyée. Chaque "." représente un caractère, tandis que "^" représente le début du texte et "&#36 ;" la fin. Lorsque vous utilisez des formats, la valeur saisie doit être au moins de la même longueur que le format format.</td>
<td>
<p>CODE_ORG_UNIT(....) → OSLO</p>
<p>CODE_ORG_UNIT(..) → OS</p>
<p>CODE_ORG_UNIT(..&#36;) → LO</p>
<p>CODE_ORG_UNIT(^...&#36;) → OSLO</p>
<p>^....&#36; exigera que la valeur saisie soit strictement de 4 caractères.</p></td>
</tr>
<tr class="odd">
<td>Format de production</td>
<td>Le format de production accepte une combinaison d'un ou plusieurs des caractères suivants : &quot;#&quot;, &quot;X&quot;, &quot;x&quot; et &quot;*&quot;. Ils représentent respectivement un nombre (0-9), une lettre majuscule (A-Z), une lettre minuscule (a-z) ou l'un des éléments ci-dessus (0-9,a-z,A-Z). Le segment SÉQUENTIEL n'accepte que &quot;#&quot ;, puisqu'il ne génère que des nombres. Le nombre de caractères dans le format décide de la taille de la valeur générée. L'utilisation d'un seul &quot;#&quot ; ne permettra en d'autres termes que 10 valeurs (0-9), tandis que &quot;###&quot ; permettra 1000 valeurs (000-999). Les valeurs générées de façon SÉQUENTIELLE ont des zéros en tête, de sorte que la longueur de la valeur générée correspondra toujours à la longueur du format.</td>
<td>ALÉATOIRE(X###) → A123
<p>ALÉATOIRE(****) → 1AbC</p>
<p>SÉQUENTIEL(###) → 001</p>
<p>SÉQUENTIEL(######) → 000001</p></td>
</tr>
</tbody>
</table>

Quelques points importants à noter concernant les formats :

  - Le format de la date est très polyvalent, mais il faut être conscient des éléments de date ou d'heure 
    que l'on utilise. L'utilisation de composants inférieurs à un jour (par 
    exemple les heures ou les secondes) n'est pas recommandée, même s'ils sont disponibles.

  - Le format texte permet de marquer à la fois le début et la fin de la valeur 
    saisie, mais "^..." et "..." donneront en réalité exactement les mêmes 
    résultats. Le seul cas où il convient d'utiliser "^" est celui où l'on veut 
    imposer la longueur de la valeur saisie. Par exemple, "^....$" 
    acceptera OSLO, puisqu'il y a 4 caractères entre le début et la fin, mais 
    PARIS sera rejeté, puisqu'il a 5 caractères.

  - Lorsque le format texte est utilisé pour des valeurs uniques, comme le code de l'unité 
    d'organisation, assurez-vous que le format ne rompt pas l'unicité.
    (Exemple : CODE DE\_L'UNITÉ\_D'ORGANISATION(..) pour "PARIS" et "PANAMA CITY" renverrait 
    tous deux PA, ce qui signifie que ces deux unités d'organisation partageraient en 
    réalité les valeurs générées)

  - Le format de génération est le principal moyen de comprendre la capacité 
    de votre modèle. Assurez-vous que le format est suffisamment long pour couvrir plus de 
    valeurs que vous n'en avez besoin.

Pour terminer la section syntaxique du tutoriel, voici quelques 
exemples 
    de modèle de texte :

    CODE_D'UNITE_D'ORG(...) + "-" + DATE_ACTUELLE(yyyyww) + "-" + SÉQUENTIEL(#####)

Ce modèle aura 99999 valeurs possibles (dans un contexte SÉQUENTIEL. 00000 
n'est jamais utilisé puisque nous commençons à 1). En outre, le modèle restant 
changera pour chaque unité d'organisation différente générant des valeurs 
(CODE_D'UNITE_D'ORG) et pour chaque semaine (DATE_ACTUELLE(aaaaaww) représente 
l'année et la semaine). Cela signifie donc que chaque nouvelle semaine, chaque unité 
d'organisation aura 99999 nouvelles valeurs qu'elle pourra utiliser.

    "ABC_" + ALÉATOIRE(****)

Le segment de texte clair de ce modèle, ne fera aucune différence dans la 
capacité totale du modèle, mais le segment généré (ALÉATOIRE) 
permettra 14776336 valeurs possibles. La raison en est que \* 
peut être n'importe quel caractère parmi les 62 caractères disponibles (0-9, a-z, A-Z). 
Vous pouvez en savoir plus sur la compréhension de la capacité des modèles plus loin dans 
le tutoriel.

### Conception d'un modèle de texte pour la génération d'identifiants { #designing-textpattern-for-generating-ids } 

Un des cas d'utilisation du TextPattern est la génération d'identifiants uniques. Nous 
présenterons dans cette partie les lignes directrices ainsi que les problèmes courants liés à 
la conception de TextPatterns utilisés pour la génération des identifiants.

Un identifiant ne doit jamais contenir d'informations sensibles, ou des informations qui, 
combinées, permettent d'identifier un individu. Actuellement, TextPattern ne 
prend pas en charge les segments utilisant ce type de valeurs, mais pourrait toutefois le 
faire à l'avenir.

La liste ci-après met en évidence certaines des restrictions spécifiques 
aux TextPattern dont vous devez tenir compte lors de la conception d'un TextPattern pour les identifiants :

  - Assurez-vous que la capacité (nombre de valeurs possibles) du 
    TextPattern couvre votre cas d'utilisation. Il est préférable d'avoir plus de valeurs 
    possibles que d'en avoir moins. Les attributs d'entité suivis à l'aide de TextPattern 
    nécessitent qu'un seul segment généré soit présent dans le 
    TextPattern.

  - Un TextPattern est unique dans tout le système, mais seulement pour 
    l'objet qui l'utilise. En d'autres termes, si vous avez un seul attribut d'entité 
    suivie avec TextPattern, utilisé par plusieurs entités suivies (à ne pas 
    confondre avec les instances d'entités suivies), toutes les valeurs générées 
    seront partagées entre toutes les entités suivies utilisant l'attribut. Cela 
    signifie également que si vous avez deux attributs d'entités suivies avec la 
    même syntaxe TextPattern, chaque attribut pourra générer la 
    même valeur que l'autre, puisque l'unicité est basée sur l'attribut.

<!-- end list -->

  - Les segments SEQUENTIELS sont, dans la mise en œuvre, des nombres commençant par 
    1, croissant de 1 pour chaque valeur, de manière séquentielle jusqu'à ce qu'il n'y ait plus de valeurs 
    disponibles. Toutefois, dans la réalité, il est très probable que vous vous retrouviez avec des 
    lacunes lorsque les utilisateurs génèrent et réservent des valeurs qui ne sont jamais utilisées, ou 
    si un utilisateur envoie une valeur pour laquelle le segment SEQUENTIEL a une valeur plus élevée 
    que celle enregistrée sur le serveur.

  - L'implémentation actuelle repose sur l'envoi par l'utilisateur-client des 
    valeurs contenues dans le TextPattern lors de l'enregistrement d'une nouvelle valeur. Cela 
    signifie que la génération d'un identifiant correct dépend de l'utilisateur et 
    de l'utilisateur-client, qui doivent fournir les données correctes.

### Comprendre la capacité du TextPattern { #understanding-textpattern-capacity } 

La chose la plus importante à garder à l'esprit lors de la conception d'un TextPattern, 
est la capacité - c'est-à-dire le nombre total de valeurs potentielles qu'un 
TextPattern peut produire.

Avec la mise en œuvre actuelle de TextPattern, trois principaux 
facteurs déterminent la capacité :

1.  Capacité du segment généré dans le TextPattern

2.  La présence d'un segment DATE\_ACTUELLE

3.  La présence d'un segment CODE\_D'UNITE\_D'ORG

La présence d'un segment de date (comme DATE\_ACTUELLE) réinitialisera 
effectivement la capacité chaque fois que le segment change. Selon le format de la 
date, elle peut passer d'annuelle à quotidienne. **N.B. : si votre 
format de date ne contient pas d'année, le modèle se résoudra à la même 
valeur chaque année**. Cela qui signifie que les valeurs seront déjà utilisées. Par exemple, 
si votre TextPattern ressemble à ceci :

    DATE_ACTUELLE(ww) + "-" + ALEATOIRE(#)

Ce modèle vous donnera jusqu'à 10 valeurs uniques pour chaque semaine, mais 
après 1 an, DATE\_ACTUELLE(ww) sera la même que l'année dernière, et vous 
n'aurez pas de nouvelles valeurs disponibles. Si vous utilisez plutôt "yyyy-ww", il sera 
unique pour chaque année, chaque semaine.

Les codes des unités d'organisation rendront vos valeurs uniques pour chaque unité 
d'organisation différente, c'est-à-dire si vous avez un modèle de texte comme celui-ci :

    CODE_D'UNITE_D'ORG() + "-" + ALEATOIRE(#)

Ce modèle vous donnera 10 valeurs uniques pour chaque unité 
d'organisation différente.

#### Calcul de la capacité des segments générés { #calculating-capacity-for-generated-segments } 

Lors de la conception de TextPatterns, il est essentiel de comprendre comment 
calculer la capacité d'un TexPattern. Les segments générés seront la composante 
principale de tout TextPattern en termes de capacité, puis augmentés en fonction de 
la présence des segments CODE\_D'UNITE\_D'ORG ou DATE\_ACTUELLE.

Commençons par des segments SÉQUENTIELS. Chaque "\#" du format représente 
un nombre entre 0 et 9. Pour calculer la capacité totale, vous multipliez 
le nombre de valeurs possibles pour chaque "\#". Comme il s'agit toujours de 10 (0-9), 
le calcul est assez simple :

    SÉQUENTIEL(#) = 10 = 10
    SÉQUENTIEL(###) = 10 * 10 * 10 = 1000
    SÉQUENTIEL(#####) = 10 * 10 * 10 * 10 * 10 = 100000

Étant donné que les compteurs SEQUENTIELS du serveur commencent à 1 et non à 0, la 
capacité réelle est de 999, mais celle-ci est insignifiante dans la plupart des cas.

Dès que nous faisons intervenir l'ALÉATOIRE, le calcul devient un peu plus 
compliqué. Comme pour le SEQUENTIEL, un "\#" a 10 valeurs possibles. En 
outre, nous avons "X" et "x" avec 26 valeurs possibles chacun, ainsi que 
"\*" qui peut être l'une des précédentes, c'est-à-dire 62 (10+26+26) 
valeurs possibles.

Pour calculer la capacité, vous devez prendre chaque caractère dans votre 
format et le remplacer par le nombre de valeurs possibles, puis les multiplier 
tous ensemble comme nous l'avons fait au niveau de SEQUENTIEL :

    ALÉATOIRE(#) = 10 = 10
    ALÉATOIRE(X) = 26 = 26
    ALÉATOIRE(*) = 62 = 62

    ALÉATOIRE(X##) = 26 * 10 * 10 = 2600
    ALÉATOIRE(XXxx) = 26 * 26 * 26 * 26 = 456976

    ALÉATOIRE(***) = 62 * 62 * 62 = 238328

Comme vous pouvez le voir, les calculs deviennent un peu plus compliqués, mais en 
suivant cette formule, vous pouvez trouver le nombre de valeurs potentielles.

### Les segments aléatoires et pourquoi vous devriez les éviter { #random-segments-and-why-you-should-avoid-it } 

L'utilisation du segment aléatoire dans TextPattern a un coût caché à 
long terme, mais cela ne signifie pas que vous ne devez jamais l'utiliser. Cette section 
mettra en évidence les problèmes liés à l'utilisation du segment aléatoire et suggérera des 
moments où il pourrait être plus approprié de l'utiliser.

Cette section est justifée par un problème lié à la stratégie génération 
précédente, où vous n'aviez qu'une génération aléatoire. Après un certain temps, les 
instances utilisant cette fonctionnalité étaient en fait incapables de générer et de réserver 
de nouvelles valeurs, puisqu'il fallait trop de temps pour trouver les valeurs disponibles. 
Cette section examine certains des problèmes liés à la génération aléatoire ayant 
conduit à cette situation.

#### Générer des valeurs aléatoires { #generating-random-values } 

Avant d'utiliser le segment RANDOM dans votre TextPattern, vous devez considérer 
les problèmes suivants liés à l'utilisation de RANDOM :

  - La génération de valeurs à partir d'un TextPattern avec un segment RANDOM sera 
    plus complexe qu'avec d'autres TextPatterns

### Saisie de données pour les métadonnées basées sur le TextPattern { #data-entry-for-textpattern-based-metadata } 

Comme mentionné précédemment, les seules métadonnées qui supportent 
actuellement le TextPattern sont les attributs des entités suivies. Dans cette partie, nous 
allons décrire les différentes façons dont la saisie de données pour TextPattern fonctionne, en particulier 
pour les attributs des entités suivies.

#### Validation des valeurs à l'aide d'un modèle de texte { #validation-of-values-using-textpattern } 

Par défaut, toutes les valeurs envoyées au serveur pour les métadonnées à l'aide de 
TextPattern, seront validées. La validation peut être ignorée si nécessaire, mais 
vous devez toujours valider les données saisies dans des circonstances normales. La 
validation sera basée sur le TextPattern que vous avez défini et sera 
aussi stricte que possible :

  - Les segments de date doivent correspondre au même format que celui spécifié dans le 
    paramètre du segment

  - Les segments de texte clair doivent correspondre exactement

  - Les valeurs des segments de texte doivent être au moins aussi longues que la chaîne du format. 
    Si "^" et "$" sont présents, la valeur doit correspondre à la 
    longueur exacte.

  - Les valeurs de segments générées doivent correspondre exactement au format, caractère par 
    caractère.

Lorsque vous utilisez le serveur pour générer et réserver des valeurs pour la première fois, 
le serveur modifie les valeurs utilisées dans le TextPattern avant de les injecter, ce qui 
signifie que vous obtiendrez toujours une valeur valide lorsque vous la générerez sur le 
serveur.

Une dernière exception à la validation du TextPattern est faite pour un cas particulier : 
Si vous modifiez un TextPattern après avoir réservé des valeurs pour le modèle 
original, les valeurs envoyées au serveur et qui ne sont pas valides selon le nouveau 
TextPattern, seront toujours acceptées si celles-ci étaient déjà réservées.

#### Différents flux de saisie de données pour le TextPattern { #different-data-entry-flows-for-textpattern } 

Il existe actuellement 2 façons pour un client de stocker les valeurs des métadonnées 
TextPattern :

1.  Générer et réserver des valeurs (les applications devraient le faire pour vous)

2.  Stockage d'une valeur personnalisée

Le moyen préféré est de générer et de réserver les valeurs nécessaires (le 
nombre de valeurs générées et réservées est géré par l'application). Cela 
signifie que chaque fois que vous voyez et stockez une valeur, elle a été 
générée et réservée par le serveur, et sera donc valide.

L'autre façon peut s'avérer utile dans des cas spécifiques. L'utilisateur fournira 
la valeur lui-même et tant que la valeur fournie est valable pour le 
TextPattern, il peut y mettre ce qu'il veut. L'inconvénient de cette méthode est que 
vous pouvez utiliser des valeurs réservées par quelqu'un d'autre 
et si vous avez un segment SEQUENTIEL, le compteur ne sera donc pas mis à jour.
