---
edit_url: "https://github.com/dhis2/dhis2-docs/blob/2.33/src/commonmark/en/content/user/dhis2-tutorials.md"
revision_date: '2019-02-11'
---

# Tutoriels sur le DHIS2 { #dhis2_tutorials } 

<!--DHIS2-SECTION-ID:dhis2_tutorials-->

## Créer des tableaux de bord à l'aide de l'application Tableau croisé dynamique { #create-scorecards-pivot-table } 

<!--DHIS2-SECTION-ID:create-scorecards-pivot-table-->

***Scorecards definition:** In public health settings such as Ministries
of Health, scorecards offer a useful and standardized method for
combining related indicators into one table. A scorecard gives an
overall view of the performance of a health program such as a
vaccination program, highlighting successes, weaknesses, and areas for
improvement Here's what a typical scorecard looks like:*

![](resources/images/tutorials/scorecards_pivot_result.png)

Ce tutoriel explique comment créer un tableau de bord dans l'application Tableau croisé dynamique de DHIS2. L'utilisation du tableau croisé dynamique pour la création d'un tableau de bord, par exemple, présente de nombreux avantages tels que :

  - Vous pouvez enregistrer la carte de pointage sur le tableau de bord et l'utiliser hors ligne.

  - Vous pouvez partager la carte de pointage avec d'autres utilisateurs de DHIS2.

Commençons donc !

### Créez une légende pour votre carte de pointage { #create-a-legend-for-your-scorecard } 

Tout d'abord, nous allons créer une légende de "feux" en 3 couleurs pour la carte de pointage. Avec ses trois couleurs de base, la carte de pointage devient facile à scanner et à comprendre.

1.  Open the **Maintenance** app. Click the menu in the top right corner
    and select Maintenance from the list of apps. You can also type the
    first letters of the word maintenance in the search field to find
    the app.

    ![](resources/images/tutorials/scorecards_maintenance_app.png)

2.  In the Maintenance app, scroll to the bottom of the page right down
    to the **Other** section.

3.  Allez sur **Legende** et cliquez sur le **+**.

    ![](resources/images/tutorials/scorecards_maintenance_legend.png)

4.  In the **Legend Management** page, scroll to the bottom of the page
    and create a new legend by clicking the blue + button.

    ![](resources/images/tutorials/scorecards_maintenance_addbtn.png)

5.  Enter a name for the legend such as “Traffic light”, a start value
    and an end value in the fields. The values you enter here depend on
    the performance ratings you wish to set for the scorecard.

6.  Change **Number of legend items** to 3 to display three colors in
    the scorecard. To change the legend item colors, click the blue +
    button and then edit the
    colors.

    ![](resources/images/tutorials/scorecards_maintenance_legend_color.png)

### Créer une carte de pointage dans l'application Tableau croisé dynamique { #create-a-scorecard-in-the-pivot-table-app } 

1.  Open the **Pivot Table** app from the top right menu of the
    dashboard. You can also enter the first letters of Pivot Table in
    the search field.

2.  Allez à **Données** dans le volet de gauche et sélectionnez 
    **Indicateurs** dans la liste.

3.  Sélectionnez un **groupe d'indicateurs** tel que "ANC" dans la deuxième liste.

4.  À l'aide des flèches, sélectionnez le type d'indicateurs que vous souhaitez voir figurer 
    dans votre tableau de performance.

    ![](resources/images/tutorials/scorecards_pivot_indicators.png)

5.  Cliquez sur **Mise à jour**. Vous trouverez ce bouton dans le menu en haut de 
    l'espace de travail

6.  Go to **Periods** and select a period for which you want to display
    data. In this “traffic light” example, we’ll use the relative period
    section. In **Quarters**, select **This quarter**and **Last
    quarter**. Clear any other checkboxes and click **Update**.

    ![](resources/images/tutorials/scorecards_pivot_period.png)

7.  Dans le même panneau de gauche allez sur **Unités d'organisation**, et cliquez sur 
    la flèche à côté du bouton d'engrenage.

8.  Sélectionnez **Sélectionner les niveaux**.

    ![](resources/images/tutorials/scorecards_pivot_orgunit_level.png)

9.  Sélectionnez **District** dans la liste (à côté du bouton d'engrenage). Cliquez sur 
    **Mettre à jour**.

    ![](resources/images/tutorials/scorecards_pivot_orgunit_level2.png)

Comme vous pouvez le voir, le tableau de performance commence à prendre forme dans 
l'espace de travail. Il reste maintenant à peaufiner l'aspect et la convivialité.

### Organiser la mise en page et l'affichage de votre carte de pointage { #organise-the-layout-and-display-of-your-scorecard } 

1.  Dans l'espace de travail, cliquez sur **Disposition**.

    ![](resources/images/tutorials/scorecards_pivot_layout.png)

2.  Dans **Disposition du tableau**, faites glisser **Unités d'organisation** jusqu'à la section **
    Dimensions des lignes**.

3.  Faites glisser **Données** dans la section **Dimensions de la colonne**.

4.  Dans le volet **Dimensions de la colonne**, faites glisser **Périodes** sous **Données**, 
    et cliquez sur **Mise à jour**.

5.  Dans l'espace de travail, cliquez sur **Options**.

    ![](resources/images/tutorials/scorecards_pivot_options.png)

6.  Allez dans **Données** et décochez toutes les cases.

7.  Go to **Style** \> **Legend set** and from the list, select the
    legend you created in the Maintenance app. In this example, we
    called it Traffic light.

8.  Allez sur **Style** \> **Style d'affichage  des légendes** et sélectionnez **Couleur 
    de fond**.

9.  Cliquez sur **Mettre à jour**.

La carte de pointage est donc prête\ !


![](resources/images/tutorials/scorecards_pivot_result.png)

### Enregistrer et partager votre carte de pointage { #save-and-share-your-scorecard } 

1.  Dans l'espace de travail, allez au menu **Favoris**.

2.  Cliquez sur **Enregistrer sous**. Entrez un nom pour votre carte de pointage.

3.  Pour partager votre carte de pointage, sélectionnez **Favoris**.

4.  Enter the name of a user group name, and click **Save**. Your
    scorecard can be viewed by people that you share a dashboard with.

## Travailler avec TextPattern { #working-with-textpattern } 

<!--DHIS2-SECTION-ID:working-with-textpattern-->

Le TextPattern a été introduit dans la version 2.29 de DHIS2, comme moyen de définir un 
modèle comprenant des variables, des valeurs générées et du texte brut, qui 
peut ensuite être généré en une valeur de texte. Le cas d'utilisation actuel de 
TextPattern est la génération automatique d'attributs pour les entités suivies 
où vous souhaitez générer par exemple des identifiants uniques basés sur un modèle 
spécifique.

Ce guide couvre à la fois les thèmes élémentaires et complexes permettant de travailler 
avec TextPattern, mais se focalise principalement sur la façon dont vous pouvez définir les 
TextPatterns et sur les limitations ainsi que mises en garde existantes.

### Syntaxe TextPattern { #textpattern-syntax } 

Un TextPattern est une séquence de *segments*, reliés entre eux par le caractère "+". Un 
segment a une notation spécifique et dans la plupart des cas un 
paramètre *format*, permettant de manipuler la valeur.

<table>
<caption>Segments TextPattern</caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 36%" />
<col style="width: 12%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th>Notation des segments</th>
<th>Description</th>
<th>Paramètre (format)</th>
<th>Exemple (segment → valeur d'entrée → résultat)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&quot;Texte simple&quot ;</td>
<td>Le segment de texte simple restera inchangé dans toutes les valeurs générées. Ce segment spécial est défini en mettant le texte entre deux doubles guillemets. Si votre modèle doit inclure des symboles de séparation comme un tiret, vous devez alors utiliser : &quot;-&quot ;.
<p>Le segment de texte simple permet également de mettre du texte en caractères de remplacement. Cela signifie que vous pouvez spécifier que certaines parties du segment de texte simple doivent être constituées d'un ensemble de caractères. Actuellement, vous pouvez utiliser 4 caractères spéciaux :</p>
<ul>
<li><p>\d (0-9)</p></li>
<li><p>\x (a-z)</p></li>
<li><p>\X (A-Z)</p></li>
<li><p>\w (a-zA-Z0-9)</p></li>
</ul></td>
<td>Aucun</td>
<td>&quot;Bonjour le monde&quot ; → Aucun → Bonjour le monde
<p>&quot;Bonjour \x\x\x&quot ; → &quot;Bonjour à vous&quot ; → Bonjour à vous</p>
<p>&quot;\d\d\d&quot; → &quot;123&quot; → 123</p></td>
</tr>
<tr class="even">
<td>CURRENT_DATE(format)</td>
<td>Le segment de la date du jour sera généré par le serveur au moment de la génération. Ceci est utile si vous voulez que vos modèles aient une contrainte de temps déconnectée du contexte. Vous ne devez pas l'utiliser si vous avez besoin de contrôler la date à injecter dans le modèle.</td>
<td>Format de la date</td>
<td>CURRENT_DATE(aaaa) → 01-01-2018 → 2018</td>
</tr>
<tr class="odd">
<td>ORG_UNIT_CODE(format)</td>
<td>Ce segment représente le code d'unité d'organisation associé à la génération.</td>
<td>Format du texte</td>
<td>ORG_UNIT_CODE(...) → OSLO → OSL</td>
</tr>
<tr class="even">
<td>ALÉATOIRE(format)</td>
<td>Les segments aléatoires seront remplacés par une valeur générée de façon aléatoire par le serveur en fonction du format. Les segments générés, comme Aléatoire, fondent leur caractère unique sur le reste du modèle. Cela signifie qu'une valeur aléatoire peut apparaître deux fois, tant que le reste du modèle est différent, ce qui signifie que le texte généré dans son ensemble sera unique.</td>
<td>Format de génération</td>
<td>ALÉATOIRE(X####) → Aucun → A1234</td>
</tr>
<tr class="odd">
<td>SÉQUENTIEL(format)</td>
<td>Les segments séquentiels seront remplacés par un nombre, basé sur une valeur de comptage sur le serveur. Les segments séquentiels commenceront à la valeur 1, et pour chaque valeur générée, ils seront comptés jusqu'à ce qu'il n'y ait plus de valeurs disponibles, en fonction du format. Comme pour les segments aléatoires, l'unicité est basée sur le reste du modèle, donc chaque version possible du modèle aura son propre compteur séquentiel commençant à 1.</td>
<td>Format de génération</td>
<td>&quot;A&quot;+SÉQUENTIEL(###) → Aucun → A001
<p>&quot;A&quot;-SÉQUENTIEL(###) → Aucun → A002</p>
<p>&quot;B&quot;-SÉQUENTIEL(###) → Aucun → B001</p>
<p>&quot;B&quot;-SÉQUENTIEL(###) → Aucun → B002</p></td>
</tr>
</tbody>
</table>

La plupart des segments ont un paramètre  *format *, sauf le segment de texte 
brut. Le tableau suivant énumère les formats disponibles, leur mode 
d'utilisation et des exemples de notations qui les utilisent.

<table>
<caption>Formats des paramètres</caption>
<colgroup>
<col style="width: 13%" />
<col style="width: 52%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th>Format</th>
<th>Description</th>
<th>Exemple</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Format des dates</td>
<td>Ce format est basé directement sur le SimpleDateFormat de java, ce qui signifie que tout modèle valable pour SimpleDateFormat sera valable comme format de date dans TextPattern</td>
<td>DATE_ACTUELLE(jj-MM-aaaa) → 31-12-2018
<p>DATE_ACTUELLE(MM-aaaa) → 12-2018</p></td>
</tr>
<tr class="even">
<td>Format du texte</td>
<td>Le format du texte permet une manipulation de base du texte. Si vous laissez le format vide, la valeur sera renvoyée sans modification, mais en utilisant "^", "." et "&#36 ;", vous pouvez modifier la valeur avant qu'elle ne soit renvoyée. Chaque "." représente un caractère, tandis que "^" représente le début du texte et "&#36 ;" la fin. Lorsque vous utilisez des formats, la valeur saisie doit être au moins de la même longueur que le format format.</td>
<td>
<p>CODE_ORG_UNIT(....) → OSLO</p>
<p>CODE_ORG_UNIT(..) → OS</p>
<p>CODE_ORG_UNIT(..&#36;) → LO</p>
<p>CODE_ORG_UNIT(^...&#36;) → OSLO</p>
<p>^....&#36; exigera que la valeur saisie soit strictement de 4 caractères.</p></td>
</tr>
<tr class="odd">
<td>Format de production</td>
<td>Le format de production accepte une combinaison d'un ou plusieurs des caractères suivants : &quot;#&quot;, &quot;X&quot;, &quot;x&quot; et &quot;*&quot;. Ils représentent respectivement un nombre (0-9), une lettre majuscule (A-Z), une lettre minuscule (a-z) ou l'un des éléments ci-dessus (0-9,a-z,A-Z). Le segment SÉQUENTIEL n'accepte que &quot;#&quot ;, puisqu'il ne génère que des nombres. Le nombre de caractères dans le format décide de la taille de la valeur générée. L'utilisation d'un seul &quot;#&quot ; ne permettra en d'autres termes que 10 valeurs (0-9), tandis que &quot;###&quot ; permettra 1000 valeurs (000-999). Les valeurs générées de façon SÉQUENTIELLE ont des zéros en tête, de sorte que la longueur de la valeur générée correspondra toujours à la longueur du format.</td>
<td>ALÉATOIRE(X###) → A123
<p>ALÉATOIRE(****) → 1AbC</p>
<p>SÉQUENTIEL(###) → 001</p>
<p>SÉQUENTIEL(######) → 000001</p></td>
</tr>
</tbody>
</table>

Quelques points importants à noter concernant les formats :

  - Date format is very versatile, but be aware of which date or time
    components you are using. Using components smaller than a day (For
    example hours or seconds) is not recommended, even though available.

  - Text format allows for marking both the start and end of the input
    value, but "^..." and "..." will in reality give exactly the same
    results. The only time you would want to use "^" is when you want to
    enforce the length of the input value. For example, "^....$" will
    accept OSLO, since its 4 characters between the start and end, but
    PARIS will be rejected, since it has 5 characters.

  - When text format is used for unique values, like organisation unit
    code, make sure that the format does not break the uniqueness.
    (Example: ORG\_UNIT\_CODE(..) for "PARIS" and "PANAMA CITY" would
    both return PA, which means these two organisation units would in
    reality share generated values)

  - Generation format is the primary way to understanding the capacity
    of your pattern. Make sure the format is long enough to cover more
    values than you need.

Pour terminer la section syntaxique du tutoriel, voici quelques 
exemples 
    de modèle de texte :

    CODE_D'UNITE_D'ORG(...) + "-" + DATE_ACTUELLE(yyyyww) + "-" + SÉQUENTIEL(#####)

Ce modèle aura 99999 valeurs possibles (dans un contexte SÉQUENTIEL. 00000 
n'est jamais utilisé puisque nous commençons à 1). En outre, le modèle restant 
changera pour chaque unité d'organisation différente générant des valeurs 
(CODE_D'UNITE_D'ORG) et pour chaque semaine (DATE_ACTUELLE(aaaaaww) représente 
l'année et la semaine). Cela signifie donc que chaque nouvelle semaine, chaque unité 
d'organisation aura 99999 nouvelles valeurs qu'elle pourra utiliser.

    "ABC_" + ALÉATOIRE(****)

Le segment de texte clair de ce modèle, ne fera aucune différence dans la 
capacité totale du modèle, mais le segment généré (ALÉATOIRE) 
permettra 14776336 valeurs possibles. La raison en est que \* 
peut être n'importe quel caractère parmi les 62 caractères disponibles (0-9, a-z, A-Z). 
Vous pouvez en savoir plus sur la compréhension de la capacité des modèles plus loin dans 
le tutoriel.

### Conception d'un modèle de texte pour la génération d'identifiants { #designing-textpattern-for-generating-ids } 

Un des cas d'utilisation du TextPattern est la génération d'identifiants uniques. Nous 
présenterons dans cette partie les lignes directrices ainsi que les problèmes courants liés à 
la conception de TextPatterns utilisés pour la génération des identifiants.

Un identifiant ne doit jamais contenir d'informations sensibles, ou des informations qui, 
combinées, permettent d'identifier un individu. Actuellement, TextPattern ne 
prend pas en charge les segments utilisant ce type de valeurs, mais pourrait toutefois le 
faire à l'avenir.

La liste ci-après met en évidence certaines des restrictions spécifiques 
aux TextPattern dont vous devez tenir compte lors de la conception d'un TextPattern pour les identifiants :

  - Make sure the capacity (number of possible values) of the
    TextPattern covers your use-case. It's better to have more values
    than needed than less. Tracked entity attributes using TextPattern
    will require that a single generated segment is present in the
    TextPattern.

  - A TextPattern is unique in the entire system, but only for the
    object using it. In other words, if you have a single tracked entity
    attribute with TextPattern, used by multiple Tracked entities (Not
    to be mistaken for tracked entity instances), all values generated
    will be shared between all traced entities using the attribute. This
    also means that if you have two tracked entity attributes with the
    same TextPattern syntax, each attribute will be able to generate the
    same value as the other, since uniqueness is based on the attribute.

<!-- end list -->

  - SEQUENTIAL segments are in the implementation numbers starting from
    1, increasing by 1 for each value, sequentially until no more values
    are available. However, in reality you will most likely end up with
    gaps when users generate and reserve values that is never used, or
    if a user sends in a value where the SEQUENTIAL segment has a higher
    value than recorded on the server.

  - The current implementation relies on the user-client to send in the
    values contained in the TextPattern when storing a new value. That
    means generating a correct id is depending on the user, and
    user-client, to provide the correct data.

### Comprendre la capacité du TextPattern { #understanding-textpattern-capacity } 

La chose la plus importante à garder à l'esprit lors de la conception d'un TextPattern, 
est la capacité - c'est-à-dire le nombre total de valeurs potentielles qu'un 
TextPattern peut produire.

Avec la mise en œuvre actuelle de TextPattern, trois principaux 
facteurs déterminent la capacité :

1.  Capacité du segment généré dans le TextPattern

2.  La présence d'un segment DATE\_ACTUELLE

3.  La présence d'un segment CODE\_D'UNITE\_D'ORG

La présence d'un segment de date (comme DATE\_ACTUELLE) réinitialisera 
effectivement la capacité chaque fois que le segment change. Selon le format de la 
date, elle peut passer d'annuelle à quotidienne. **N.B. : si votre 
format de date ne contient pas d'année, le modèle se résoudra à la même 
valeur chaque année**. Cela qui signifie que les valeurs seront déjà utilisées. Par exemple, 
si votre TextPattern ressemble à ceci :

    DATE_ACTUELLE(ww) + "-" + ALEATOIRE(#)

Ce modèle vous donnera jusqu'à 10 valeurs uniques pour chaque semaine, mais 
après 1 an, DATE\_ACTUELLE(ww) sera la même que l'année dernière, et vous 
n'aurez pas de nouvelles valeurs disponibles. Si vous utilisez plutôt "yyyy-ww", il sera 
unique pour chaque année, chaque semaine.

Les codes des unités d'organisation rendront vos valeurs uniques pour chaque unité 
d'organisation différente, c'est-à-dire si vous avez un modèle de texte comme celui-ci :

    CODE_D'UNITE_D'ORG() + "-" + ALEATOIRE(#)

Ce modèle vous donnera 10 valeurs uniques pour chaque unité 
d'organisation différente.

#### Calcul de la capacité des segments générés { #calculating-capacity-for-generated-segments } 

Lors de la conception de TextPatterns, il est essentiel de comprendre comment 
calculer la capacité d'un TexPattern. Les segments générés seront la composante 
principale de tout TextPattern en termes de capacité, puis augmentés en fonction de 
la présence des segments CODE\_D'UNITE\_D'ORG ou DATE\_ACTUELLE.

Commençons par des segments SÉQUENTIELS. Chaque "\#" du format représente 
un nombre entre 0 et 9. Pour calculer la capacité totale, vous multipliez 
le nombre de valeurs possibles pour chaque "\#". Comme il s'agit toujours de 10 (0-9), 
le calcul est assez simple :

    SÉQUENTIEL(#) = 10 = 10
    SÉQUENTIEL(###) = 10 * 10 * 10 = 1000
    SÉQUENTIEL(#####) = 10 * 10 * 10 * 10 * 10 = 100000

Étant donné que les compteurs SEQUENTIELS du serveur commencent à 1 et non à 0, la 
capacité réelle est de 999, mais celle-ci est insignifiante dans la plupart des cas.

Dès que nous faisons intervenir l'ALÉATOIRE, le calcul devient un peu plus 
compliqué. Comme pour le SEQUENTIEL, un "\#" a 10 valeurs possibles. En 
outre, nous avons "X" et "x" avec 26 valeurs possibles chacun, ainsi que 
"\*" qui peut être l'une des précédentes, c'est-à-dire 62 (10+26+26) 
valeurs possibles.

Pour calculer la capacité, vous devez prendre chaque caractère dans votre 
format et le remplacer par le nombre de valeurs possibles, puis les multiplier 
tous ensemble comme nous l'avons fait au niveau de SEQUENTIEL :

    ALÉATOIRE(#) = 10 = 10
    ALÉATOIRE(X) = 26 = 26
    ALÉATOIRE(*) = 62 = 62

    ALÉATOIRE(X##) = 26 * 10 * 10 = 2600
    ALÉATOIRE(XXxx) = 26 * 26 * 26 * 26 = 456976

    ALÉATOIRE(***) = 62 * 62 * 62 = 238328

Comme vous pouvez le voir, les calculs deviennent un peu plus compliqués, mais en 
suivant cette formule, vous pouvez trouver le nombre de valeurs potentielles.

### Les segments aléatoires et pourquoi vous devriez les éviter { #random-segments-and-why-you-should-avoid-it } 

L'utilisation du segment aléatoire dans TextPattern a un coût caché à 
long terme, mais cela ne signifie pas que vous ne devez jamais l'utiliser. Cette section 
mettra en évidence les problèmes liés à l'utilisation du segment aléatoire et suggérera des 
moments où il pourrait être plus approprié de l'utiliser.

Cette section est justifée par un problème lié à la stratégie génération 
précédente, où vous n'aviez qu'une génération aléatoire. Après un certain temps, les 
instances utilisant cette fonctionnalité étaient en fait incapables de générer et de réserver 
de nouvelles valeurs, puisqu'il fallait trop de temps pour trouver les valeurs disponibles. 
Cette section examine certains des problèmes liés à la génération aléatoire ayant 
conduit à cette situation.

#### Générer des valeurs aléatoires { #generating-random-values } 

Avant d'utiliser le segment RANDOM dans votre TextPattern, vous devez considérer 
les problèmes suivants liés à l'utilisation de RANDOM :

  - La génération de valeurs à partir d'un TextPattern avec un segment RANDOM sera 
    plus complexe qu'avec d'autres TextPatterns

### Saisie de données pour les métadonnées basées sur le TextPattern { #data-entry-for-textpattern-based-metadata } 

Comme mentionné précédemment, les seules métadonnées qui supportent 
actuellement le TextPattern sont les attributs des entités suivies. Dans cette partie, nous 
allons décrire les différentes façons dont la saisie de données pour TextPattern fonctionne, en particulier 
pour les attributs des entités suivies.

#### Validation des valeurs à l'aide d'un modèle de texte { #validation-of-values-using-textpattern } 

By default, all values sent to the server for metadata using
TextPattern, will be validated. Validation can be skipped if needed, but
you should always validate input under normal circumstances. The
validation will be based on the TextPattern you have defined and will be
as strict as possible:

  - Date segments must match the same format as specified in the segment
    parameter

  - Les segments de texte clair doivent correspondre exactement

  - Text segments values must be at least as long as the format string.
    If both "^" and "$" is present, the value must match the exact
    length.

  - Generated segment values must match the format exactly, character by
    character.

When using the server to first generate and reserve values, the server
will modify the values used in the TextPattern before injecting them,
meaning you will always get a valid value when generating it on the
server.

A final exception to TextPattern validation is made for a special case:
If you change a TextPattern after reserving values for the original
pattern, values sent to the server that are invalid according to the new
TextPattern, will still be accepted if it was already reserved.

#### Différents flux de saisie de données pour le TextPattern { #different-data-entry-flows-for-textpattern } 

There is currently 2 ways a client can store values for TextPattern
metadata:

1.  Générer et réserver des valeurs (les applications devraient le faire pour vous)

2.  Stockage d'une valeur personnalisée

The preferred way, is to generate and reserve the needed values (The
number of values generated and reserved is handled by the app). That
means each time you are seeing and storing a value, it has been
generated and reserved by the server, and will be valid.

The other way might be useful in specific cases. The user will supply
the value themselves and as long as the value supplied is valid for the
TextPattern, they can put anything they want. The caveat of doing it
this way, is that you might use values that was reserved by someone else
and if you have a SEQUENTIAL segment, the counter will not be updated.
