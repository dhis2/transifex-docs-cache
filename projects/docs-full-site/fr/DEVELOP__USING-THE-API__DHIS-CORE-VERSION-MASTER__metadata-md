---
edit_url: "https://github.com/dhis2/dhis2-docs/blob/master/src/developer/web-api/metadata.md"
revision_date: '2024-07-12'
tags:
- Développement
- Version Master de DHIS2 Central
---

# Metadata { #webapi_metadata }

## Schémas d'identification { #webapi_identifier_schemes } 

Cette section explique le concept de schéma d'identification. Les schémas d'identification sont utilisés pour relier des objets de métadonnées à d'autres métadonnées lors de l'importation et également pour restituer les métadonnées lors des exportations. Tous les schémas ne fonctionnent pas avec tous les appels d'API, et tous les schémas ne peuvent pas être utilisés à la fois pour les entrées et les sorties. Cet aspect est abordé dans les sections où sont expliqués les différents points d'extrémité d'API.

Tous les types d'objets disponibles pour le schéma d'identification sont énumérés ci-dessous. Sont fournis les noms des propriétés à utiliser dans les requêtes :

  - idScheme

  - dataElementIdScheme (Schéma d'identifiant d'élément de données)

  - categoryOptionComboIdScheme (Schéma de l'identifiant de la combinaison d'options de catégorie)

  - orgUnitIdScheme (Schéma de l'identifiant de l'unité d'organisation)

  - programIdScheme (Schéma d'identification du programme)

  - programmeStageIdScheme (Schéma d'identification de l'étape de programme)

  - trackedEntityIdScheme (schéma d'identification de l'entité suivie)

  - trackedEntityAttributeIdScheme (schéma d'identification de l'attribut d'entité suivie)

Le schéma d'identification général (idScheme) s'applique à tous les types d'objets. Il peut être remplacé par des types d'objets spécifiques.

Le schéma par défaut pour tous les paramètres est UID (identifiants stables de DHIS2). Les schémas d'identification pris en charge sont décrits dans le tableau ci-dessous.

Tableau : Valeurs du schéma

| Schéma | Description |
|---|---|
| ID, UID | Correspondance avec l'identifiant permanent DHIS2. il s'agit du schéma d'identification par défaut. |
| CODE | Correspondre avec le code DHIS2, principalement utilisé pour échanger des données avec un système externe. |
| NOM | Correspondre avec le nom DHIS2. Notez que c'est l'élément disponible en tant que *object.name* (nom de l'objet) qui est utilisé, et non le nom traduit. Notez également que les noms ne sont pas toujours uniques et que, dans ce cas, ils ne peuvent pas être utilisés. |
| ATTRIBUT:ID | Correspondre avec l'attribut de métadonnées. Cet attribut doit être assigné au type avec lequel vous établissez la correspondance, d'autant plus que la propriété unique est définie sur  *true*. Cette fonctionnalité permet principalement d'échanger des données avec des systèmes externes. Il présente certains avantages par rapport à *CODE* puisque plusieurs attributs peuvent être ajoutés. Il peut donc se synchroniser avec plus d'un système. |

Notez que les schémas d'identification ne constituent pas une fonctionnalité indépendante, mais ils doivent être utilisés en combinaison avec des ressources telles que l'importation de valeurs de données, l'importation de métadonnées et l'importation GeoJson.

Par exemple, pour spécifier CODE comme schéma d'identification général et le remplacer par UID pour le schéma d'identification de l'unité d'organisation, vous pouvez utiliser les requêtes suivantes : 

    ?idScheme=CODE&orgUnitIdScheme=UID

Autre exemple, pour spécifier un attribut pour le schéma d'identification de l'unité d'organisation, un code pour le schéma d'identification de l'élément de données et utiliser le schéma d'identification par défaut UID pour tous les autres objets, vous pouvez utiliser les paramètres suivants :

    ?orgUnitIdScheme=ATTRIBUTE:j38fk2dKFsG&dataElementIdScheme=CODE

## Navigation dans l'API Web { #webapi_browsing_the_web_api } 

Le point d'entrée pour naviguer dans l'API Web est `/api`. Cette ressource fournit des liens vers toutes les ressources disponibles. Quatre formats de représentation sont systématiquement disponibles pour toutes les ressources : HTML, XML, JSON et JSONP. D'autres formats sont disponibles pour des ressources comme MS Excel, PDF, CSV et PNG. Pour explorer l'API à partir d'un navigateur web, accédez au point d'entrée `/api` et suivez les liens vers la ressource que vous recherchez, par exemple `/api/dataElements`. Pour toutes les ressources qui renvoient une liste d'éléments, certains paramètres de requête peuvent être utilisés pour modifier la réponse :

Tableau : Paramètres de requête

| Paramètre | Valeurs des options | Option par défaut | Description |
|---|---|---|---|
| pagination | vrai &#124; faux | vrai | Indique s'il faut renvoyer les listes d'éléments sous forme de pages. |
| page | nombre | 1 | Définit le numéro de page à renvoyer. |
| taille de la page | nombre | 50 | Définit le nombre d'éléments à renvoyer pour chaque page. |
| Ordre | property:asc/iasc/desc/idesc || Ordonne la sortie dans un ordre spécifique. Seules les propriétés qui sont à la fois persistantes et simples (pas de collections, d'identifiants d'objets, etc.) sont prises en charge. iasc et idesc sont des tris insensibles à la casse. Si vous souhaitez trier plusieurs propriétés, séparez-les par une virgule.  |

Voici un exemple de comment ces paramètres peuvent être utilisés pour obtenir une liste complète de groupes d'éléments de données dans un format de réponse XML :

    /api/dataElementGroups.xml?links=false&paging=false

Vous pouvez rechercher des éléments à partir de la propriété "nom" au lieu de renvoyer toute une liste d'éléments à l'aide de la variable de requête *query*. Dans cet exemple, nous recherchons tous les éléments de données dont le nom contient le mot "anémie" :

    /api/dataElements?query=anaemia

Vous pouvez obtenir des pages spécifiques et des tailles de page pour des objets en utilisant la requête suivante :

    /api/dataElements.json?page=2&pageSize=20

Vous pouvez désactiver complètement la pagination à l'aide de cette requête :

    /api/indicatorGroups.json?paging=false

Pour que le résultat soit ordonné selon une propriété spécifique :

    /api/indicators.json?order=shortName:desc

Pour que le résultat soit d'abord ordonné selon la propriété créée "date et heure" (ordre décroissant), puis selon la propriété "nom" (ordre croissant) :

    /api/indicators.json?order=created:desc,name:asc

La ressource *identifiableObjects* vous permet de rechercher tout objet à partir de son identifiant, quel que soit son type :

    /api/identifiableObjects/<id>

### Traduction { #webapi_translation } 

DHIS2 propose des traductions pour le contenu de la base de données, notamment les éléments de données, les indicateurs et les programmes. Tous les objets de métadonnées qui figurent dans l'API Web ont des propriétés destinées à être utilisées pour l'affichage et l'interface utilisateur. Il s'agit entre autres de *displayName* (nom d'affichage), *displayShortName* (nom d'affichage court), *displayDescription* (description de l'affichage) et *displayFormName* (nom du formulaire d'affichage). Ces propriétés sont utilisées pour les éléments de données et les attributs d'entités suivies.

Tableau : Options de traduction

| Paramètre | Valeurs | Description |
|---|---|---|
| traduction | vrai &#124; faux | Traduire les propriétés display\* dans les sorties de métadonnée (displayName, displayShortName, displayDescription, et displayFormName pour les éléments de données et les attributs d'entités suivies). La valeur par défaut est "true". |
| emplacement | Emplacement à utiliser | Traduire les métadonnées dans une langue donnée (nécessite que la traduction soit définie sur 'vrai'). |

### API de traduction { #webapi_translation_api } 

Les traductions d'un objet sont rendues comme faisant partie de l'objet lui-même dans le tableau *traductions*. Le tableau *traductions* qui figure dans les charges JSON/XML est normalement préfiltré pour vous, ce qui signifie qu'il ne peut pas être utilisé directement pour importer/exporter des traductions (car cela aurait pour effet de remplacer les langues autres que celles des utilisateurs actuellement connectés).

Exemple d'élément de données dont le tableau de traduction est filtré sur la langue de l'utilisateur :

```json
{
  "id": "FTRrcoaog83",
  "displayName": "Accute French",
  "translations": [
    {
      "property": "SHORT_NAME",
      "locale": "fr",
      "value": "Accute French"
    },
    {
      "property": "NAME",
      "locale": "fr",
      "value": "Accute French"
    }
  ]
}
```

Exemple d'élément de données dont les traductions sont désactivées :

```json
{
  "id": "FTRrcoaog83",
  "displayName": "Accute Flaccid Paralysis (Deaths < 5 yrs)",
  "translations": [
    {
      "property": "FORM_NAME",
      "locale": "en_FK",
      "value": "aa"
    },
    {
      "property": "SHORT_NAME",
      "locale": "en_GB",
      "value": "Accute Flaccid Paral"
    },
    {
      "property": "SHORT_NAME",
      "locale": "fr",
      "value": "Accute French"
    },
    {
      "property": "NAME",
      "locale": "fr",
      "value": "Accute French"
    },
    {
      "property": "NAME",
      "locale": "en_FK",
      "value": "aa"
    },
    {
      "property": "DESCRIPTION",
      "locale": "en_FK",
      "value": "aa"
    }
  ]
}
```

Notez que même si vous obtenez un résultat non filtré, et que vous utilisez le type de point d'extrémité approprié, c'est-à-dire `/api/dataElements`, nous n'autorisons pas les mises à jour, car cela pourrait facilement entraîner des erreurs et remplacer les autres langues disponibles.

Pour lire et mettre à jour les traductions, vous pouvez utiliser le point d'extrémité spécial "traductions" pour chaque ressource d'objet. Vous pouvez y accéder en utilisant *GET* ou *PUT* sur le point d'extrémité `/api/<object-type>/<object-id>/translations` approprié.

Par exemple, pour un élément de données dont l'identifiant est  `FTRrcoaog83`, vous pouvez utiliser `/api/dataElements/FTRrcoaog83/translations` pour obtenir les traductions et les mettre à jour. Les champs disponibles sont `property` avec les options *NOM*, *NOM_COURT*, *NOM DU_FORMULAIRE*, *DESCRIPTION*, `locale` qui prend en charge tout ID de langue valide et la propriété traduite `value`.

Exemple de propriété NOM pour la langue française :

```json
{
  "property": "NAME",
  "locale": "fr",
  "value": "Paralysie Flasque Aiguë (Décès <5 ans)"
}
```

Cette charge est ensuite ajoutée à un tableau de traduction et renvoyée au point d'extrémité approprié :

```json
{
  "translations": [
    {
      "property": "NAME",
      "locale": "fr",
      "value": "Paralysie Flasque Aiguë (Décès <5 ans)"
    }
  ]
}
```

Pour un élément de données dont l'ID est *FTRrcoaog83*, vous pouvez effectuer une requête *PUT* comme suit : `/api/dataElements/FTRrcoaog83/translations`. Assurez-vous d'envoyer toutes les traductions disponibles pour cet objet et pas seulement pour une langue (sinon vous risquez de remplacer les langues existantes par d'autres langues).

Le code de statut sera `204 No Content` si la valeur de données a été sauvegardée ou mise à jour avec succès, ou `404 Not Found` si une erreur de validation s'est produite (par exemple, plus d'un `NOM_COURT` pour la même `langue`).


### Versions de l'API Web { #webapi_api_versions } 

L'API Web est versionnée à partir de DHIS 2.25. La version de l'API suit la numérotation des versions majeures de DHIS2. Par exemple, la version de l'API pour DHIS 2.33 est `33`.

Vous pouvez accéder à une version spécifique de l'API en incluant le numéro de version après `/api`, comme dans l'exemple suivant :

    /api/33/dataElements

Si vous omettez la partie version de l'URL, le système utilisera la version actuelle de l'API. Par exemple, pour DHIS 2.25, si vous omettez la partie de l'API, le système utilisera la version 25 de l'API. Lors du développement de clients API, il est recommandé d'utiliser des versions API explicites (plutôt que d'omettre la version de l'API), car cela protégera le client contre les modifications imprévues de l'API.

Les trois dernières versions de l'API seront prises en charge. Par exemple, la version 2.27 de DHIS va prendre en charge les versions 27, 26 et 25 de l'API.

Notez que le modèle de métadonnées n'est pas versionné et que des changements peuvent survenir, par exemple dans les associations entre objets. Ces changements seront documentés dans les notes de mise à jour de la version principale de DHIS2.

## Filtre sur les objets de métadonnées { #webapi_metadata_object_filter } 

Pour filtrer les métadonnées, plusieurs opérations de filtrage peuvent être appliquées à la liste de métadonnées renvoyée. Le format du filtre lui-même est simple et suit le modèle *propriété:opérateur:valeur*, où *propriété* est la propriété des métadonnées sur lesquelles vous voulez effectuer le filtrage, *opérateur* est l'opérateur de comparaison que vous voulez utiliser et *valeur* est la valeur à vérifier (tous les opérateurs ne requièrent pas de valeur). 

Veuillez consulter la section *schéma* pour savoir quelles propriétés sont disponibles. En plus des propriétés listées, les filtres peuvent s'appliquer à des valeurs d'attributs personnalisés où l'ID de l'attribut est utilisé comme nom de propriété.

Le filtrage récursif, c'est-à-dire le filtrage sur des objets associés ou une collection d'objets, est également possible.

Tableau : Opérateurs disponibles

| Opérateur | Les types | Valeur requise | Description |
|---|---|---|---|
| eq | chaîne | booléen | entier | flottant | énumération | collection (vérification de la taille) | date | vrai | Égalité |
| !eq | chaîne | booléen | entier | flottant | énumération | collection (vérification de la taille) | date | vrai | Inégalité |
| ieq | chaîne  | vrai  | Case insensitive string, match exact |
| ne | chaîne | booléen | entier | flottant | énumération | collection (vérification de la taille) | date | vrai | Inégalité |
| like | chaîne | vrai | Chaîne sensible à la casse ; peut correspondre avec tout élément |
| !like | chaîne | vrai | Chaîne sensible à la casse ; ne peut pas correspondre avec tous les éléments |
| $like | chaîne | vrai | Chaîne sensible à la casse ; début de la correspondance |
| !$like | chaîne | vrai | Chaîne sensible à la casse, pas de début de correspondance |
| like$ | chaîne | vrai | Chaîne sensible à la casse ; fin de la correspondance |
| !like$ | chaîne | vrai | Case sensitive string, not match end |
| ilike | chaîne | vrai | Chaîne insensible à la casse ; peut correspondre avec tout élément |
| !ilike | chaîne | vrai | Chaîne insensible à la casse ; ne peut pas correspondre avec tous les éléments |
| $ilike | chaîne | vrai | Chaîne insensible à la casse ; début de la correspondance |
| !$ilike | chaîne | vrai | Chaîne insensible à la casse, pas de début de correspondance |
| ilike$ | chaîne | vrai | Case insensitive string, match end |
| !ilike$ | chaîne | vrai | Case insensitive string, not match end |
| gt | chaîne | booléen | entier | flottant | collection (vérification de la taille) | date | vrai | Supérieur à |
| ge | chaîne | booléen | entier | flottant | collection (vérification de la taille) | date | vrai | Supérieur ou égal |
| lt | chaîne | booléen | entier | flottant | collection (vérification de la taille) | date | vrai | Inférieur à |
| le | chaîne | booléen | entier | flottant | collection (vérification de la taille) | date | vrai | inférieur ou égal |
| nulle | tous | faux | La propriété est nulle |
| !null | tous | faux | La propriété n'est pas nulle |
| vide | collection | faux | La collection est vide |
| jeton | chaîne | vrai | Match on multiple tokens in search property |
| !token | chaîne | vrai | Not match on multiple tokens in search property |
| dans | chaîne | booléen | entier | flottant | date | vrai | Find objects matching 1 or more values |
| !in | chaîne | booléen | entier | flottant | date | vrai | Find objects not matching 1 or more values |

Les opérateurs sont appliqués sous la forme d'une requête logique *et*. Si vous avez besoin d'une requête *ou*, vous pouvez consulter le filtre *dans* et la section ci-dessous. Le mécanisme de filtrage permet la récursivité. Des exemples sont donnés ci-dessous.

Obtenir des éléments de données avec la propriété ID1 ou ID2 :

    /api/dataElements?filter=id:eq:ID1&filter=id:eq:ID2

Get data elements, ignoring case, with name property MyDataElement:

    /api/dataElements?filter=name:ieq:mydataelement

Obtenir tous les éléments de données qui ont un ensemble de données avec l'identifiant ID1 :

    /api/dataElements?filter=dataSetElements.dataSet.id:eq:ID1

Obtenir tous les éléments de données avec l'opérateur d'agrégation *somme* et le type de valeur *int* :

    /api/dataElements.json?filter=aggregationOperator:eq:sum&filter=type:eq:int

Vous pouvez effectuer un filtrage à l'intérieur des collections. Par exemple, pour obtenir les éléments de données qui font partie du groupe d'éléments de données * CPN*, vous pouvez utiliser la requête suivante en utilisant la propriété d'identification (id) des groupes d'éléments de données qui lui sont associés :

    /api/dataElements.json?filter=dataElementGroups.id:eq:qfxEYY9xAl6

Pour obtenir des éléments de données ayant une valeur d'attribut particulière pour un attribut de métadonnées, un filtre peut être spécifié pour l'ID de l'attribut et la valeur de l'attribut en utilisant la même syntaxe que celle de la requête de collection  :

    /api/dataElements.json?filter=attributeValues.attribute.id:eq:n2xYlNbsfko&filter=attributeValues.value:eq:AFP

Obtenir les éléments de données pour lesquels une option a été définie :

    /api/dataElements?filter=optionSet:!null

Étant donné que tous les opérateurs sont *et* par défaut, vous ne pouvez pas trouver un élément de données correspondant à plus d'un identifiant. Pour ce faire, vous pouvez utiliser l'opérateur *dans*.

    /api/dataElements.json?filter=id:in:[fbfJHSPpUQD,cYeuwXTCPkU]

### Opérateurs logiques { #webapi_metadata_logical_operator } 

Comme indiqué dans la section précédente, l'opérateur logique par défaut appliqué aux filtres est *ET*, ce qui signifie que tous les filtres d'objets doivent trouver une correspondance. Cependant, dans certains cas, l'utilisateur peut vouloir utiliser un seul filtre parmi plusieurs (par exemple le champ de l'identifiant et du code). Dans ce cas, il est possible de changer l'opérateur logique racine de *ET* à *OU* à l'aide du paramètre *rootJunction*.

Exemple : Filtrage normal où l'identifiant et le code doivent correspondre pour que le résultat soit renvoyé.

    /api/dataElements.json?filter=id:in:[id1,id2]&filter=code:eq:code1

Exemple : Filtrage où l'opérateur logique a été remplacé par OU, ce qui fait qu'un seul des filtres doit trouver une correspondance pour que le résultat soit renvoyé.

    /api/dataElements.json?filter=id:in:[id1,id2]&filter=code:eq:code1&rootJunction=OR

### Identifiable token filter { #identifiable-token-filter } 

Outre le filtrage spécifique basé sur les propriétés mentionné ci-dessus, nous disposons également d'un filtrage *ET* basé sur *token* à travers un ensemble de propriétés : identifiant, code et nom (ainsi que 'nom court' s'il est disponible). Ces propriétés sont généralement appelées *identifiables*. L'idée est de filtrer les métadonnées dont l'identifiant, le nom, le code ou le nom court contiennent des informations.

Exemple : Filtrage de tous les éléments de données contenant *2em* dans l'un des éléments suivants : identifiant, nom, code et nom court.

    /api/dataElements.json?filter=identifiable:token:2nd

Il est également possible de spécifier plusieurs valeurs de filtrage.

Exemple : Obtenir tous les éléments de données où *visite CPN* se trouve dans l'une des propriétés *identifiables*. Le système renvoie tous les éléments de données dans lesquels les deux unités lexicales (CPN et visite) se trouvent quelque part dans les propriétés identifiables.

    /api/dataElements.json?filter=identifiable:token:ANC visit

Il est également possible de combiner le filtre identifiable avec le filtre basé sur les propriétés et de s'attendre à ce que le paramètre *rootJunction* soit appliqué.

    /api/dataElements.json?filter=identifiable:token:ANC visit&filter=displayName:ilike:tt1

    /api/dataElements.json?filter=identifiable:token:ANC visit
      &filter=displayName:ilike:tt1&rootJunction=OR

### Filtre indexable uniquement pour les attributs d'entité suivie { #indexable-only-filter-for-tracked-entity-attributes } 

Pour les attributs d'entités suivies, il existe un filtre spécial qui s'ajoute aux capacités de filtrage mentionnées précédemment. Certains attributs d'entités suivies se prêtent à la création d'un index trigramme afin d'améliorer les performances de recherche. En utilisant le paramètre *indexableOnly* défini sur "vrai", les résultats peuvent être filtrés pour inclure uniquement les attributs indexables par trigramme.

Exemple : Obtenir tous les attributs d'entités suivies indexables.

    /api/trackedEntityAttributtes.json?indexableOnly=true

Des filtres supplémentaires ainsi que le paramètre `indexableOnly` peuvent être spécifiés.

Exemple : Obtenir tous les attributs d'entités suivies où *CPN* se trouve dans l'une des propriétés *nom*. Le système renvoie les attributs d'entités suivies dont le nom correspond au mot-clé fourni et indique si l'attribut est indexable.

    /api/trackedEntityAttributtes.json?filter=name:like:ANC&indexableOnly=true

## Metadata field filter { #webapi_metadata_field_filter } 

Dans de nombreuses situations, les visualisations par défaut des métadonnées peuvent être trop détaillées. Un client peut juste avoir besoin de quelques champs de chaque objet et vouloir supprimer les champs inutiles de la réponse. Pour connaître les champs disponibles pour chaque objet, veuillez consulter la section *schéma*. En plus des propriétés énumérées, il est possible d'inclure des attributs personnalisés pour les objets de premier niveau en utilisant l'identifiant de l'attribut comme nom de propriété.

Le format inclure/exclure permet une récursivité illimitée. Pour effectuer un filtrage au niveau de la "racine", vous pouvez simplement utiliser le nom du champ, c'est-à-dire  `?fields=id,name` qui n'affichera que les champs `idendifiant` et `nom` pour chaque objet. Pour les objets qui sont soit des collections, soit des objets complexes avec des propriétés indépendantes, vous pouvez utiliser le format `?fields=id,name,dataSets[id,name]` qui renverra l'`identifiant`, le `nom` de la racine, ainsi que l'`identifiant` et le `nom` de chaque ensemble de données sur cet objet. Vous pouvez effectuer une négation à l'aide de l'opérateur d'exclamation, et nous disposons d'options prédéfinies pour le remplissage des champs. Les formats XML et JSON sont acceptés.

**Exemple** : Obtenir l'`id` et le `nom` à partir de la ressource d'indicateurs :

    /api/indicators?fields=id,name

**Exemple** : Obtenir l'`id` et le `nom` des éléments de données, et l'`id` et le `nom` des ensembles de données associés :

    /api/dataElements?fields=id,name,dataSets[id,name]

**Exemple** : Obtenir l'`id`, le `nom` et la valeur d'un attribut défini par l'utilisateur avec l'ID `DnrLSdo4hMl`, pour les unités d'organisation :

    /api/organisationUnits?fields=id,name,DnrLSdo4hMl

L'attribut est alors inclus en tant que propriété `DnrLSdo4hMl` de chaque objet correspondant dans la réponse. Il peut être renommé à l'aide du transformateur `rename` (renommer) tel que présenté dans la section suivante.

Pour exclure un champ de la sortie, vous pouvez utiliser l'opérateur d'exclamation `!`. Ceci est autorisé à n'importe quel emplacement dans la requête et cette propriété ne sera pas incluse tout simplement car elle pourrait avoir été insérée dans des options prédéfinies.

Quelques options prédéfinies (groupes de champs sélectionnés) sont disponibles et peuvent être appliqués à l'aide de l'opérateur `:`.

Tableau : Opérateurs de propriété

| Opérateur | Description |
|---|---|
| <field-name\> | Inclure la propriété avec le nom, si possible. |
| <object\>[<field-name\>, ...] | Inclut un champ dans une collection (qui s'appliquera à tous les objets de cette collection) ou dans un seul objet. |
| !<field-name\>, <object\>[!<field-name\> | Le nom du champ est exclu. Cet opérateur fonctionne également à l'intérieur des objets/collections. Vous pouvez l'utiliser avec une option prédéfinie pour inclure des champs. |
| \*, <object\>[\*] | Inclut tous les champs d'un objet spécifique. S'il est appliqué à une collection, tous les champs de tous les objets de cette collection seront inclus. |
| :<preset\> | Alias pour sélectionner plusieurs champs. Trois paramètres prédéfinis sont actuellement disponibles ; le tableau ci-dessous en fournit les descriptions. |

Tableau : Paramètres prédéfinies des champs

| Paramètre prédéfini | Description |
|---|---|
| tous | Tous les champs de l'objet |
| \* | Alias pour tous |
| identifiable | Inclut les champs pour l'identifiant, le nom, le code, la date de création et de la dernière mise à jour. |
| nommable | Inclut les champs pour l'identifiant, le nom, le nom court, le code, la description, la date de création et de la dernière mise à jour. |
| conservé | Renvoie toutes les propriétés conservées sur un objet ; ne tient pas compte du fait que l'objet soit le propriétaire de la relation ou non. |
| propriétaire | Renvoie toutes les propriétés conservées pour un objet, dans un contexte où cet objet est propriétaire de toutes les propriétés. Cette charge peut être utilisée pour effectuer une mise à jour via l'API. |

**Exemple** : Inclure tous les champs des ensembles de données à l'exception des unités d'organisation :

    /api/dataSets?fields=:all,!organisationUnits

**Exemple** : Inclure uniquement l'identifiant, le nom et la collection d'unités d'organisation d'un ensemble de données, mais exclure l'identifiant des unités d'organisation :

    /api/dataSets/BfMAe6Itzgt?fields=id,name,organisationUnits[:all,!id]

**Exemple** : Inclure les propriétés nommables de tous les indicateurs :

    /api/indicators.json?fields=:nameable

### Transformateurs de champ { #webapi_field_transformers } 

Les transformations de champs peuvent être utilisées pour transformer des propriétés. La syntaxe est décrite ci-dessous.

    /api/dataElements/ID?fields=id~rename(i),name~rename(n)

La propriété *id* sera renommée *i* et la propriété *nom* sera renommée *n*.

Plusieurs transformateurs peuvent être appliqués à une même propriété. Pour ce faire, il suffit de répéter l'opérateur de transformation :

    /api/dataElementGroups.json?fields=id,displayName,dataElements~isNotEmpty~rename(haveDataElements)

Les opérateurs de transformation pris en charge sont décrits dans le tableau ci-dessous.

Tableau : Transformateurs disponibles

| Nom | Arguments | Description |
|---|---|---|
| taille || Donne la taille des chaînes (longueur) et des collections |
| isEmpty (est vide) || La chaîne ou la collection est vide |
| isNotEmpty (n'est pas vide) || La chaîne ou la collection n'est pas vide |
| renommer | Arg1 : nom | Renomme la propriété |
| pagination | Arg1 : page,Arg2 : taille de la page | Pages a collection, default pageSize is 50. |
| pluck | Arg1 facultatif : fieldName (nom du champ) | Convertit un tableau d'objets en un tableau comprenant un champ sélectionné de cet objet. Par défaut, le premier champ renvoyé par la collection est utilisé (normalement l'ID). |
| keyBy | Arg1 facultatif : fieldName (nom du champ) | Convertit un tableau d'objets en un objet où le nom du champ (id par défaut) est utilisé comme clé. Cela peut être utile pour des recherches rapides en JavaScript, par exemple |

#### Exemples { #webapi_field_transformers_examples } 

Des exemples d'utilisation de transformateurs sont présentés ci-dessous.

Obtenir la taille d'une collection :

    /api/dataElements?fields=dataSets~size

Teste si une collection est vide :

    /api/dataElements?fields=dataSets~isEmpty

Teste si une collection n'est pas vide :

    /api/dataElements?fields=dataSets~isNotEmpty

Renommer les propriétés :

    /api/dataElements/ID?fields=id~rename(i),name~rename(n)

Appliquer la pagination à une collection :

    /api/dataElementGroups?fields=id,displayName,dataElements~paging(1;20)

Obtenir un tableau contenant les identifiants des unités d'organisation :

    /api/categoryOptions.json?fields=id,organisationUnits~pluck

Obtenir un tableau contenant les noms des unités d'organisation :

    /api/categoryOptions.json?fields=id,organisationUnits~pluck[name]

Key the dataElements array by the `id` field:

    /api/dataElementGroups.json?fields=id,name,dataElements~keyBy[id,name,valueType]

Key the dataElements array by the `valueType` field, since multiple hits this will results in arrays (of data elements):

    /api/dataElementGroups.json?fields=id,name,dataElements~keyBy(valueType)[id,name,valueType]

## Création, lecture, mise à jour, suppression et validation de métadonnées { #webapi_metadata_crud } 

Toutes les entités de métadonnées dans DHIS2 ont leur propre point d'extrémité API qui prend en charge les opérations *CRUD* (création, lecture, mise à jour et suppression). Les URL des points d'extrémité suivent le format suivant :

    /api/<entityName>

Le _nom de l'entité_ utilise la notation camel case. Par exemple, le point d'extrémité pour les _éléments de données_ est :

    /api/dataElements

>**_NOTE:_** Lors de la mise à jour des objets, toutes les valeurs des propriétés existantes seront écrasées, même si la nouvelle valeur est nulle. Veuillez utiliser l'[API de patch JSON](#webapi_partial_updates) si vous souhaitez effectuer une mise à jour partielle d'un objet.

### Création et mise à jour des paramètres { #webapi_metadata_create_update } 

Les paramètres de requête suivants sont disponibles pour tous les points d'extrémité de métadonnées.

Tableau : Filtres de requête disponibles

| Param | Type | Obligatoire | Options (par défaut en premier) | Description |
|---|---|---|---|---|
| preheatCache | booléen | faux | vrai &#124; faux | Activer/désactiver le préchauffage du cache-map. Cette option est activée par défaut. Si vous la désactivez, le temps de chargement initial de l'importateur sera beaucoup plus court (mais l'importation elle-même sera plus lente). Cette fonction est principalement utilisée lorsque vous avez un petit fichier XML/JSON à importer, et que vous ne voulez pas attendre le préchauffage du cache-map. |
| importStrategy (stratégie d'importation) | enum | faux | CRÉER_ET_METTRE À JOUR | CRÉER | METTRE À JOUR | SUPPRIMER | Stratégie d'importation à utiliser, voir ci-dessous pour plus d'informations. |

### Création et mise à jour d'objets { #webapi_creating_updating_objects } 

Pour créer de nouveaux objets, vous devrez connaître le point d'extrémité, le format du type d'objet et vous assurer que vous disposez des autorisations nécessaires. À titre d'exemple, nous allons créer et mettre à jour une *constante*. Pour connaître le format, nous pouvons utiliser le nouveau point d'extrémité *schéma* pour obtenir la description du format. Nous allons donc commencer par l'obtention de cette information :

    http://<server>/api/schemas/constant.json

À partir de la sortie, vous pouvez voir que les autorités requises pour la création sont `F_CONSTANT_ADD`, et que les propriétés importantes sont : *nom* et *valeur*. En nous basant sur ces informations, nous pouvons créer une charge JSON et la sauvegarder dans un fichier appelé constant.json :

```json
{
  "name": "PI",
  "value": "3.14159265359"
}
```

Le même contenu qu'une charge XML :

```xml
<constant name="PI" xmlns="http://dhis2.org/schema/dxf/2.0">
  <value>3.14159265359</value>
</constant>
```

Nous sommes maintenant prêts à créer la nouvelle *constante* en envoyant une requête POST au point d'extrémité `constantes` avec la charge JSON, en utilisant le curl :

```bash
curl -d @constant.json "http://server/api/constants" -X POST
  -H "Content-Type: application/json" -u user:password
```

Exemple concret d'envoi de la constante au serveur de démonstration :

```bash
curl -d @constant.json "https://play.dhis2.org/api/constants" -X POST
  -H "Content-Type: application/json" -u admin:district
```

Si tout s'est bien passé, vous devriez obtenir le résultat suivant :

```json
{
  "status": "SUCCESS",
  "importCount": {
    "imported": 1,
    "updated": 0,
    "ignored": 0,
    "deleted": 0
  },
  "type": "Constant"
}
```

Le processus sera exactement le même pour la mise à jour, vous apportez vos modifications à la charge JSON/XML, vous trouvez l'*ID* de la constante, puis vous envoyez une requête PUT au point d'extrémité en incluant l'ID :

```bash
curl -X PUT -d @pi.json -H "Content-Type: application/json"
  -u user:password "http://server/api/constants/ID"
```

### Suppression d'objets { #webapi_deleting_objects } 

La suppression d'objets est très simple. Vous devez connaître l'*ID* et le point d'extrémité du type d'objet que vous voulez supprimer. Reprenons l'exemple de la dernière section et utilisons une *constante*. Supposons que l'identifiant soit *abc123*, tout ce que vous avez à faire est d'envoyer la requête DELETE (supprimer) au point d'extrémité + Id :

```bash
curl -X DELETE -u user:password "http://server/api/constants/ID"
```

Une suppression réussie doit renvoyer le statut HTTP 204 (pas de contenu).

### Ajout et suppression d'objets dans les collections { #webapi_adding_removing_objects_collections } 

La ressource des collections vous permet de modifier des collections d'objets.

#### Ajout ou suppression d'objets uniques{ #webapi_collections_adding_removing_single_objects } 

Pour ajouter ou supprimer des objets dans une collection d'objets, vous pouvez utiliser le modèle suivant :

    /api/{collection-object}/{collection-object-id}/{collection-name}/{object-id}

Vous devez utiliser la méthode POST pour ajouter un objet et la méthode DELETE pour le supprimer. Lorsqu'il existe une relation entre plusieurs objets, vous devez d'abord déterminer quel objet est propriétaire de la relation. Si cet objet n'est pas clairement identifiable, essayez les deux méthodes d'appel pour voir laquelle fonctionne.

Les éléments du modèle sont les suivants :

  - objet de la collection : Le type d'objets qui possède la collection que vous
    voulez modifier.

  - id de l'objet de collection : L'identifiant de l'objet qui possède la
    collection que vous voulez modifier.

  - nom de la collection : le nom de la collection que vous voulez modifier.

  - Identifiant d'objet : L'identifiant de l'objet que vous voulez ajouter ou supprimer
    de la collection.

Par exemple, pour supprimer un élément de données avec pour identifiant IDB d'un groupe d'éléments de données dont l'identifiant est IDA, vous pouvez effectuer une requête DELETE :

    DELETE /api/dataElementGroups/IDA/dataElements/IDB

Pour ajouter une option de catégorie avec pour identifiant IDB à une catégorie dont l'identifiant est IDA, vous pouvez effectuer une requête POST :

    POST /api/categories/IDA/categoryOptions/IDB

#### Ajout ou suppression de plusieurs objets { #webapi_collections_adding_removing_multiple_objects } 

Vous pouvez ajouter ou supprimer plusieurs objets d'une collection dans une même requête, en utilisant la charge suivante :

```json
{
  "identifiableObjects": [{
      "id": "IDA"
    }, {
      "id": "IDB"
    }, {
      "id": "IDC"
    }
  ]
}
```

Cette charge utile permet d'ajouter, de remplacer ou de supprimer des éléments :

*Ajouter des éléments:*

    POST /api/categories/IDA/categoryOptions

*Rempld'éléments:*

    PUT /api/categories/IDA/categoryOptions

*Supprimer des éléments :*

    DELETE /api/categories/IDA/categoryOptions

#### Ajout et suppression d'objets dans une même requête { #webapi_collections_adding_removing_objects_single_request } 

Vous pouvez ajouter et supprimer des objets d'une collection dans une même requête POST, en utilisant l'URL suivante :

    POST /api/categories/IDA/categoryOptions

Le format de la charge est le suivant :

```json
{
  "additions": [{
      "id": "IDA"
    }, {
      "id": "IDB"
    }, {
      "id": "IDC"
    }
  ],
  "deletions": [{
      "id": "IDD"
    }, {
      "id": "IDE"
    }, {
      "id": "IDF"
    }
  ]
}
```

### Validation des charges { #webapi_validating_payloads } 

DHIS 2 permet de valider des métadonnées à l'échelle du système, ce qui signifie que les opérations de création et de mise à jour sur les points d'extrémité d'API devront être valides avant que les modifications ne soient autorisées. Pour connaître les validations disponibles pour un point d'extrémité spécifique, consultez ce point d'extrémité : `/api/schemas`. C'est-à-dire que pour connaître les contraintes d'un élément de données, vous devez vous rendre dans `/api/schemas/dataElement`.

Vous pouvez également valider votre charge manuellement en l'envoyant au point d'extrémité du schéma approprié. Si vous vouliez valider la constante dans la section de création précédente, vous devriez l'envoyer comme ceci :

    POST /api/schemas/constant

Voici un exemple simple (sans validation) :

```bash
curl -X POST -d "{\"name\": \"some name\"}" -H "Content-Type: application/json"
  -u admin:district "https://play.dhis2.org/dev/api/schemas/dataElement"
```

Ce qui donnera le résultat suivant :

```json
[
   {
      "message" : "Required property missing.",
      "property" : "type"
   },
   {
      "property" : "aggregationOperator",
      "message" : "Required property missing."
   },
   {
      "property" : "domainType",
      "message" : "Required property missing."
   },
   {
      "property" : "shortName",
      "message" : "Required property missing."
   }
]
```

### Mises à jour partielles { #webapi_partial_updates } 

Nos points d'extrémité d'API qui traitent les métadonnées permettent des mises à jour partielles (PATCH) à l'aide du patch JSON [standard] (https://tools.ietf.org/html/rfc6902). La charge décrit essentiellement un ensemble d'opérations que vous voulez appliquer à un objet de métadonnées existant. Pour plus de détails et d'exemples sur le patch JSON, voir [jsonpatch.com](http://jsonpatch.com/). Trois opérateurs sont pris en charge : `add`, `remove` et `replace` (ajouter, supprimer et remplacer).

Vous trouverez ci-dessous quelques exemples concernant DHIS2. Notez que toute mise à jour d'une charge doit être considérée comme une opération HTTP PUT, c'est-à-dire que toute modification doit aboutir à une charge de métadonnées PUT valide.

Le `importReportMode` (mode de rapport d'importation) par défaut pour le patch JSON est `ERRORS_NOT_OWNER`, ce qui signifie que si vous essayez de mettre à jour une propriété qui n'appartient pas à l'objet traité (par exemple si vous essayez d'ajouter un groupe d'indicateurs directement à un indicateur), vous obtiendrez une erreur.

Conformément à la spécification des patchs JSON, vous devez toujours utiliser le type MIME `application/json-patch+json` lorsque vous envoyez des patchs.

#### Exemples { #examples }

##### Mise à jour du nom et du type de valeur d'un élément de données { #update-name-and-value-type-of-data-element } 

```
PATCH /api/dataElements/{id}
```

```json
[
  {"op": "add", "path": "/name", "value": "New Name"},
  {"op": "add", "path": "/valueType", "value": "INTEGER"}
] 
```

##### Ajout d'un nouvel élément de données à un groupe d'éléments de données { #add-new-data-element-to-a-data-element-group } 

```
PATCH /api/dataElementGroups/{id}
```

```json
[
  {"op": "add", "path": "/dataElements/-", "value": {"id": "data-element-id"}}
]
```

##### Suppression de toutes les associations d'éléments de données d'un groupe d'éléments de données { #remove-all-data-element-associations-from-a-data-element-group } 

```
PATCH /api/dataElementGroups/{id}
```

```json
[
  {"op": "remove", "path": "/dataElements"}
]
```

##### Modification du domaine et du type de valeur d'un élément de données { #change-domain-and-value-type-of-a-data-element } 

```
PATCH /api/dataElements/{id}
```

```json
[
    {"op": "add", "path": "/domainType", "value": "TRACKER"},
    {"op": "add", "path": "/valueType", "value": "INTEGER"}
]
```

##### Suppression d'une unité d'organisation spécifique d'un groupe d'unité d'organisation { #remove-a-specific-orgunit-from-an-orgunit-group } 

```
PATCH /api/organisationUnitGroups/{id}
```

```json
[
  {"op": "remove", "path": "/organisationUnits/1"}
]
```

#### Blocage de l'ajout d'un groupe d'éléments de données à élément de données { #blocked-add-dataelementgroup-to-dataelement } 

```
PATCH /api/dataElements/{id}?importReportMode=ERRORS_NOT_OWNER
```

```json
[
    {"op": "add", "path": "/dataElementGroups/-", "value": {"id": "data-element-group-id"}}
]
```

#### Blocage de la mise à jour du nom du groupe d'élément =s de données dans l'élément de données { #blocked-update-name-of-dataelementgroup-in-dataelement } 

```
PATCH /api/dataElements/{id}?importReportMode=ERRORS_NOT_OWNER
```

```json
[
    {"op": "add", "path": "/dataElementGroups/0", "value": {"name": "new-name"}}
]
```
#### Remove collection item by id { #remove-collection-item-by-id } 

```
PATCH /api/dataSets/{id}?importReportMode=ERRORS_NOT_OWNER
```

```json
[
    {"op": "remove-by-id", "path": "/organisationUnits", "id": "u6CvKyF0Db5"}
]
```

#### Demande de patch avec avec un chemin d'accès invalide { #patch-request-with-invalid-path } 
Si la propriété `path` (chemin d'accès) est invalide ou n'existe pas, le service de patchs renvoie une erreur comme dans l'exemple suivant


```
PATCH /api/dataSets/{id}?importReportMode=ERRORS_NOT_OWNER
```

```json
[
    {"op": "remove-by-id", "path": "/test", "id": "u6CvKyF0Db5"}
]
```
Réponse
```json
{
    "httpStatus": "Bad Request",
    "httpStatusCode": 400,
    "status": "ERROR",
    "message": "Invalid path /test"
}
```

### Exportation des métadonnées par CSV{ #webapi_metadata_csv_export } 

Le filtrage des champs fonctionne presque de la même manière pour le CSV (notez que l'utilisation du CSV sur le point d'extrémité `/api/metadata` n'est pas possible), mais la transformation des champs n'est pas encore prise en charge.

Pour les points d'extrémité qui acceptent le CSV (par exemple nos points d'extrémité de métadonnées `/api/dataElements` et `/api/organisationUnits`) vous pouvez soit utiliser l'en-tête `Accept` avec la valeur `text/csv` ou utiliser l'extension `.csv`. Sachez que nous ne prenons pas en charge les objets complexes, seulement les collections d'objets avec identifiant (une liste d'UID sera donc renvoyée).

| Nom | Options | Description |
|---|---|---|
| champs | Identique au filtre de champ de métadonnées (avec les restrictions mentionnées ci-dessus) | Le filtre par défaut est `id,displayName`. |
| skipHeader (ignorer l'en-tête) | faux/vrai | Détermine si l'en-tête (avec les noms des colonnes) doit être inclus ou non
| séparateur | Valeur par défaut : `.` | Séparateur de colonnes
| arraySeparator | Valeur par défaut : `;` | Si l'un des champs est une collection d'objets d'identification, ce séparateur va se positionner entre tous les UID.

#### Exemples { #examples }

#### Obtenir tous les éléments de données, y compris leurs associations de groupes { #get-all-data-elements-including-their-group-associations } 

```
/api/dataElements.csv?fields=id,displayName,dataElementGroups
```

#### Obtenir toutes les unités d'organisation, y compris la géométrie (qui sera ignorée) { #get-all-org-units-including-geometry-which-will-get-ignored } 

```
/api/organisationUnits.csv?fields=id,displayName,organisationUnitGroups,geometry
```

## Exportation de métadonnées { #webapi_metadata_export } 

Cette section décrit l'API de métadonnées qui est disponible ici : `/api/metadata`. Les représentations des ressources XML et JSON sont prises en charge.

    /api/metadata

Les paramètres les plus courants sont décrits dans le tableau "Paramètres d'exportation" ci-dessous. Vous pouvez également appliquer ceci à tous les types disponibles en utilisant `type:fields=<filter>` et `type:filter=<filter>`. Vous pouvez également activer/désactiver l'exportation de certains types à travers ceci : `type=true|false`.

Tableau : Paramètres d'exportation

| Nom | Options | Description |
|---|---|---|
| champs | Identique au filtre du champ de métadonnées | Filtre de champ par défaut à appliquer pour tous les types, la valeur par défaut est `:owner`. |
| filtre | Identique au filtre des objets de métadonnées | Filtre d'objets par défaut à appliquer pour tous les types. La valeur par défaut est `:none` (aucun). |
| Ordre | Identique à l'ordre des métadonnées | Ordre par défaut à appliquer à tous les types. La valeur par défaut est `name` si un nom est disponible, ou `created` sinon. |
| traduction | faux/vrai | Permet les traductions. Cette fonction est désactivée par défaut (dans d'autres points d'extrémité, elle est activée par défaut). |
| emplacement | <locale\> | Permet de passer de la langue de l'utilisateur à la langue que vous définissez. |
| defaults | INCLURE/EXCLURE | Permet de déterminer si l'objet de catégorie généré automatiquement doit être inclus ou non dans la charge. Si vous déplacez des métadonnées entre deux instances non synchronisées, vous pouvez définir ce paramètre sur EXCLURE afin de faciliter la gestion de ces objets générés. |
| skipSharing (ignorer le partage) | faux/vrai | L'activation de ce paramètre supprime les propriétés de partage des objets exportés. Il s'agit de *utilisateur*, *accès publique*, *accès des groupes d'utilisateurs*, *accès utilisateur*, et *accès externe*. |
| download | faux/vrai | L'activation de ce paramètre ajoutera l'en-tête HTTP Contenu-Disposition qui spécifie que les données doivent être traitées comme une pièce jointe et seront proposées par les navigateurs web sous forme de téléchargement. |

### Exemples d'exportation de métadonnées { #webapi_metadata_export_examples } 

Exporter toutes les métadonnées. Attention, la réponse peut être très volumineuse en fonction de la configuration des métadonnées :

    /api/metadata

Exporter toutes les métadonnées classées par ordre décroissant en prenant en compte la dernière mise à jour :

    /api/metadata?defaultOrder=lastUpdated:desc

Exporter uniquement les métadonnées qui contiennent des indicateurs et des groupes d'indicateurs :

    /api/metadata?indicators=true&indicatorGroups=true

Exporter l'identifiant et le nom d'affichage de tous les éléments de données, classés par nom d'affichage :

    /api/metadata?dataElements:fields=id,name&dataElements:order=displayName:desc

Exporter les éléments de données et les indicateurs dont le nom commence par "CPN" :

    /api/metadata?filter=name:^like:ANC&dataElements=true&indicators=true

### Exportation de métadonnées avec des dépendances { #webapi_dataset_program_export_dependencies } 

Lorsque vous voulez échanger des métadonnées avec un ensemble de données, un programme, une combinaison de catégories, un tableau de bord, un ensemble d'options ou un groupe d'éléments de données, d'une instance DHIS2 à une autre, six points d'extrémité dédiés sont disponibles :

```
/api/dataSets/{id}/metadata.json

/api/programs/{id}/metadata.json

/api/categoryCombos/{id}/metadata.json

/api/dashboards/{id}/metadata.json

/api/optionSets/{id}/metadata.json

/api/dataElementGroups/{id}/metadata.json
```

Ces éléments exportés peuvent ensuite être importés en utilisant ceci `/api/metadata`.

Ces points d'extrémité prennent également en charge les paramètres suivants :

Tableau : Paramètres d'exportation

| Nom | Options | Description |
|---|---|---|
| skipSharing (ignorer le partage) | faux/vrai | L'activation de ce paramètre supprime les propriétés de partage des objets exportés. Il s'agit de *utilisateur*, *accès publique*, *accès des groupes d'utilisateurs*, *accès utilisateur*, et *accès externe*. |
| download | faux/vrai | L'activation de ce paramètre ajoutera l'en-tête HTTP Contenu-Disposition qui spécifie que les données doivent être traitées comme une pièce jointe et seront proposées par les navigateurs web sous forme de téléchargement. |

## Importation de métadonnées { #webapi_metadata_import } 

Cette section décrit l'API d'importation des métadonnées. Les représentations des ressources XML et JSON sont prises en charge. Les métadonnées peuvent être importées à l'aide d'une requête *POST*.

    /api/metadata

L'importateur vous permet d'importer des charges de métadonnées qui peuvent inclure plusieurs entités et un nombre quelconque d'objets par entité. Les éléments de métadonnées exportés via l'API d'exportation de métadonnées peuvent être importés directement.

Le point d'extrémité de l'importation des métadonnées prend en charge une variété de paramètres, énumérés ci-dessous.

Tableau : Paramètres d'importation

| Nom | Options (la première est la valeur par défaut) | Description |
|---|---|---|
| Mode d'importation  | COMMIT, VALIDATE (commiter, valider) | Définit le mode d'importation général ; décide s'il faut `VALIDER` ou `COMMITER` les métadonnées. Cet paramètre fonctionne de la même manière que la fonction dryRun (essai). |
| identifiant | UID, CODE, AUTO | Définit le schéma d'identification à utiliser pour la mise en correspondance des références. Il faut d'abord essayer `UID`, puis `CODE` avant de passer à `AUTO`. |
| importReportMode (mode de rapport d'importation) | ERRORS, FULL, DEBUG (erreurs, plein, débogage) | Définit le mode de `rapport d'importation` ; contrôle ce qui est rapporté après l'importation. `ERRORS` n'inclut que les *rapports d'objets* pour les objets qui contiennent des erreurs. `FULL` renvoie un *rapport d'objet* pour tous les objets importés, et `DEBUG` renvoie la même chose plus un nom pour l'objet (si disponible). |
| preheatMode (mode préchauffage) | REFERENCE, ALL, NONE (référence, tous, aucun) | Définit le mode de préchauffage ; il est utilisé pour signaler si le préchauffage doit être fait pour `TOUS` (comme c'était le cas auparavant avec *preheatCache=true*) ou faire un scan plus intelligent des objets pour voir ce qu'il faut préchauffer (actuellement le paramètre par défaut). Il n'est pas recommandé de le définir sur `AUCUN`. |
| importStrategy (stratégie d'importation) | CRÉER_ET_METTRE À JOUR, CRÉER, METTRE À JOUR, SUPPRIMER | Définit la stratégie d'importation ; `CREATE_AND_UPDATE` essaiera de trouver une correspondance avec l'identifiant. Si aucune correspondance n'est trouvée, l'objet sera créé. |
| Mode atomique | ALL, NONE (tous, aucun) | Définit le mode atomique. Dans l'ancien importateur, nous faisions toujours une importation *best effort* (mode au mieux), ce qui signifie que même si certaines références n'existaient pas, l'importation se faisait quand même (par exemple, des éléments de données manquants dans un groupe d'éléments de données). Par défaut, le nouvel importateur ne permet pas cela et rejette les erreurs de validation. Définir le mode `NONE` (aucun) émulait l'ancien fonctionnement. |
| flushMode (mode de vidage) | AUTO, OBJET | Définit le mode de vidage, qui contrôle quand vider le cache interne. Il est *fortement* recommandé de maintenir ce mode sur `AUTO` (qui est le mode par défaut). N'utilisez `OBJECT` qu'à des fins de débogage, lorsque vous voyez des exceptions liées à l'hibernation et que vous voulez localiser l'emplacement exact où l'empilement se produit (l'hibernation ne se déclenche qu'au moment du vidage, il peut donc être difficile de savoir quel objet a eu des problèmes). | 
| skipSharing (ignorer le partage) | faux, vrai | Permet d'ignorer les propriétés de partage, d'éviter la fusion des éléments partagées lors des mises à jour et l'ajout d'un accès à un groupe d'utilisateurs lors de la création de nouveaux objets. |
| skipValidation (ignorer la validation) | faux, vrai | Permet d'ignorer la validation lors de l'importation. Ce paramètre n'est pas recommandé : `NOT RECOMMENDED`. |
| async | faux, vrai | Importation asynchrone ; la réponse est renvoyée immédiatement avec un en-tête *Emplacement* qui pointe vers l'emplacement du *rapport d'importation*. La charge contient également un objet json de la tâche créée. |
| inclusionStrategy (stratégie d'inclusion) | NON_NULL, ALWAYS, NON_EMPTY | *NON_NULL* inclut les propriétés qui ne sont pas nulles, *ALWAYS* inclut toutes les propriétés, *NON_EMPTY* inclut les propriétés qui ne sont pas vides (n'inclut pas les chaînes de longueur 0, les collections de taille 0, etc.) |
| userOverrideMode (utiliser le mode de remplacement) | AUCUN, ACTUEL, SÉLECTIONNÉ | Ceci vous permet de remplacer la propriété utilisateur de chaque objet que vous importez. Les options sont NONE (ne rien faire), CURRENT (utiliser l'utilisateur d'importation), SELECTED (sélectionner un utilisateur spécifique en utilisant overrideUser=X). |
| overrideUser (remplacer l'utilisateur) | ID de l'utilisateur | Si le mode de remplacement de l'utilisateur est sélectionné, utilisez ce paramètre pour sélectionner l'utilisateur avec lequel vous voulez effectuer le remplacement. |

> **REMARQUE** Lors de la mise à jour des objets, toutes les valeurs des propriétés seront écrasées même si les nouvelles valeurs sont `null`. Veuillez utiliser [JSON Patch API](#webapi_partial_updates) si vous voulez faire une mise à jour partielle d'un objet.


Voici un exemple de charge d'importation de métadonnées. Vous remarquerez que chaque type d'entité possède sa propre propriété avec un tableau d'objets :

```json
{
  "dataElements": [
    {
      "name": "EPI - IPV 3 doses given",
      "shortName": "EPI - IPV 3 doses given",
      "aggregationType": "SUM",
      "domainType": "AGGREGATE",
      "valueType": "INTEGER_ZERO_OR_POSITIVE"
    },
    {
      "name": "EPI - IPV 4 doses given",
      "shortName": "EPI - IPV 4 doses given",
      "aggregationType": "SUM",
      "domainType": "AGGREGATE",
      "valueType": "INTEGER_ZERO_OR_POSITIVE"
    }
  ],
  "indicators": [
    {
      "name": "EPI - ADS stock used",
      "shortName": "ADS stock used",
      "numerator": "#{LTb8XeeqeqI}+#{Fs28ZQJET6V}-#{A3mHIZd2tPg}",
      "numeratorDescription": "ADS 0.05 ml used",
      "denominator": "1",
      "denominatorDescription": "1",
      "annualized": false,
      "indicatorType": {
        "id": "kHy61PbChXr"
      }
    }
  ]
}
```

Lors de l'envoi de cette charge au point d'extrémité des métadonnées, la réponse contiendra des informations sur les paramètres utilisés lors de l'importation et un récapitulatif par type d'entité, lequel contiendra le nombre d'objets créés, mis à jour, supprimés et ignorés :

```json
{
  "importParams": {
    "userOverrideMode": "NONE",
    "importMode": "COMMIT",
    "identifier": "UID",
    "preheatMode": "REFERENCE",
    "importStrategy": "CREATE_AND_UPDATE",
    "atomicMode": "ALL",
    "flushMode": "AUTO",
    "skipSharing": false,
    "skipTranslation": false,
    "skipValidation": false,
    "metadataSyncImport": false,
    "firstRowIsHeader": true,
    "username": "UNICEF_admin"
  },
  "status": "OK",
  "typeReports": [
    {
      "klass": "org.hisp.dhis.dataelement.DataElement",
      "stats": {
        "created": 2,
        "updated": 0,
        "deleted": 0,
        "ignored": 0,
        "total": 2
      }
    },
    {
      "klass": "org.hisp.dhis.indicator.Indicator",
      "stats": {
        "created": 1,
        "updated": 0,
        "deleted": 0,
        "ignored": 0,
        "total": 1
      }
    }
  ],
  "stats": {
    "created": 3,
    "updated": 0,
    "deleted": 0,
    "ignored": 0,
    "total": 3
  }
}
```

## GeoJSON import <!-- DHIS2-EDIT:https://github.com/dhis2/dhis2-docs/edit/master/src/developer/web-api/geo-json.md --> { #geojson-import } 

L'importation GeoJSON est utilisée pour relier les données géométriques aux unités d'organisation.

Pour une importation en masse, il faut un fichier GeoJSON avec une collection d'éléments.
Chaque élément de la collection a besoin d'une référence à l'unité d'organisation à laquelle il doit être relié.

Par défaut, la géométrie du fichier est stockée en tant que propriété `geometry` d'une unité d'organisation. Pour stocker des géométries supplémentaires, des attributs de type `GEOJSON` peuvent être créés. Lorsque des attributs sont utilisés, toutes les géométries d'un fichier sont stockées pour le même attribut qui est fourni avec un paramètre supplémentaire `attributeId`.

### Importation de données en masse avec GeoJSON { #webapi_geojson_bulk_import }

Tableau : Paramètres d'importation

| Nom              | Type                           | Par défaut | Description                                                                                                                       |
|-------------------|--------------------------------|---|-----------------------------------------------------------------------------------------------------------------------------------|
| `geoJsonId`       | `booléen`                      | `vrai` | Si le paramètre est défini sur `true`, la propriété `id` des éléments GeoJSON est censée contenir l'identifiant de l'unité d'organisation.                        |
| `geoJsonProperty` | `Chaîne`                       | _non défini_ | Si `geoJsonId` est défini sur `false`, ce paramètre nomme la propriété dans les `properties` de l'élément GeoJSON qui contient l'identifiant de l'unité d'organisation. |
| `orgUnitProperty` | `enum`: [`id`, `code`, `name`] | `id` | La propriété de l'unité d'organisation à laquelle se réfèrent les identifiants utilisés dans le fichier GeoJSON.                             |
| `attributeId`     | `Chaîne` | _non défini_ | Lorsqu'elle est définie, la géométrie est stockée en tant que valeur de l'attribut référencé par l'ID.                                                       |
| `dryRun`          | `booléen` | `faux` | Si le paramètre est défini sur `true`, l'importation est traitée sans que les unités d'organisation ne soient mis à jour. |
| `async`           | `booléen` | `faux` | Lorsque le paramètre est défini sur `true`, l'importation est traitée de manière asynchrone. |

Uasge:

    POST /api/organisationUnits/geometry

Le corps du message est le fichier GeoJSON. Le type de contenu doit être `application/json` ou `application/geo+json`. Le fichier peut être compressé en `.zip` ou `.gzip`.

Par exemple, un fichier par défaut dans lequel `id` est utilisé pour faire référence à l'identifiant d'une unité d'organisation a la structure suivante :

```json
{ 
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "id": "O6uvpzGd5pu",
      "geometry": { ... }
    },
    ...
  ]
}
```

Un fichier dans lequel une propriété d'élément est utilisée pour faire référence au code de l'unité d'organisation devrait avoir la structure suivante :

```json
{ 
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "properties": { "code": "OU1_CODE" },
      "geometry": { ... }
    },
    ...
  ]
}
```
Les `coordonnées` d'une `géométrie` peuvent être des paires ou des triplets.
Si une troisième dimension est présente, elle est supprimée lors de l'importation.

Une `geometry` peut également être `null` pour effacer ou supprimer efficacement la géométrie pour des unités d'organisation spécifiques. Il existe une API spéciale de suppression en masse ; elle est décrite dans la section suivante.

Lorsqu'elle est exécutée de manière synchrone, un rapport d'importation est renvoyé directement.
Le code de statut HTTP est toujours `OK`, le `status` dans le message indique si toutes les lignes ont été importées avec succès.
Les statistiques sur le nombre de lignes importées, contenues dans le rapport donnent des informations supplémentaires :

* `imported` : nombre d'unités d'organisation qui ont été mises à jour avec succès avec une géométrie qui n'en avait pas pour la propriété mise à jour.
* `updated` : nombre d'unités d'organisation qui ont été mises à jour avec succès avec une géométrie qui avait déjà une valeur pour la propriété mise à jour.
* `ignored` : nombre d'unités d'organisation qui n'ont pas été mises à jour
* `deleted` : nombre d'unités d'organisation qui ont été mises à jour avec succès avec une géométrie _vide_.

Lorsque l'importation est exécutée de manière asynchrone, la requête renvoie immédiatement le statut `OK` de même que la réponse de configuration de la tâche qui contient une référence relative au point d'extrémité de la tâche qui permet de suivre le statut de l'importation asynchrone. Voici un exemple :

    /api/system/tasks/GEOJSON_IMPORT/{job-id}

Le récapitulatif renvoyé directement pour une exécution synchrone est disponible à l'adresse suivante :

    /api/system/taskSummaries/GEOJSON_IMPORT/{job-id}

dès que l'importation est terminée.

### Suppression de données en masse avec GeoJSON { #webapi_geojson_bulk_deletion }
Pour effacer ou désactiver les données `geometry` pour toutes les unités d'organisation, utilisez :

    DELETE /api/organisationUnits/geometry

Pour effacer ou désactiver les données géométriques d'un attribut `GEOJSON` spécifique pour toutes les unités d'organisation :

    DELETE /api/organisationUnits/geometry?attributeId={attr-id}

Le nettoyage se fait toujours de façon synchrone et renvoie un rapport similaire à celui de l'importation en masse.
Il ne prend en charge aucun autre paramètre. Aucun `essai` ne peut être effectué.
Pour effectuer un nettoyage en masse, l'utilisateur doit disposer de l'autorité `F_PERFORM_MAINTENANCE`.

### Importation de données à titre individuel avec GeoJSON { #webapi_geojson_single_import }
L'importation unique permet de mettre à jour la géométrie d'une seule unité d'organisation.

    POST /api/organisationUnits/{id}/geometry

Le corps du message ne contient que la valeur GeoJSON `geometry`, par exemple :
```json
{
  "type": "Polygon",
  "coordinates": [...]
}
```
L'importation unique ne prend en charge que les paramètres `attributeId` et `dryRun`.

### Suppression de données uniques avec GeoJSON { #webapi_geojson_single_deletion }
Pour effacer les données GeoJSON de la `géométrie` d'une seule unité d'organisation, utilisez ceci :

    DELETE /api/organisationUnits/{id}/geometry

De même, pour effacer une valeur d'attribut `GEOJSON` pour une seule unité d'organisation, utilisez ceci :

    DELETE /api/organisationUnits/{id}/geometry?attributeId={attr-id}

Le nettoyage se fait toujours de manière synchrone et renvoie un rapport similaire à celui d'une importation simple.
Le paramètre `dry-run` est également pris en charge. L'utilisateur qui effectue l'opération doit disposer de l'autorité qui lui permet de modifier l'unité d'organisation cible.



## Schéma { #webapi_schema } 

Pour effectuer une introspection sur tous les objets DXF 2 disponibles, vous pouvez utiliser une ressource disponible à l'adresse `/api/schemas`. Pour obtenir des ressources spécifiques, vous pouvez consulter `/api/schemas/<type>`.

Pour obtenir tous les schémas disponibles au format XML :

    GET /api/schemas.xml

Pour obtenir tous les schémas disponibles au format JSON :

    GET /api/schemas.json

Pour obtenir le schéma JSON d'une classe spécifique :

    GET /api/schemas/dataElement.json


## Icônes { #webapi_icons } 

DHIS2 dispose d'une collection d'icônes qui peuvent être utilisées pour donner un contexte visuel aux métadonnées. Il existe deux types d'icônes :
  - Icônes par défaut : elles sont préinstallées dans l'application et ne peuvent ni être modifiées, ni être supprimées.
  - Icônes personnalisées : elles peuvent être créées, mises à jour et supprimées à volonté.

Ces deux types sont accessibles via la ressource "icônes".

    GET /api/icons

Ce point d'extrémité renvoie une liste d'informations sur les icônes par défaut et les icônes personnalisées disponibles. Par défaut, la clé, la description, les mots-clés et la href sont inclus dans la réponse. Mais le paramètre "champs" peut être utilisé pour modifier ce comportement.

```json
{
  key: "mosquito_outline",
  description: "Mosquito outline",
  keywords: [
    "malaria",
    "mosquito",
    "dengue"
  ],
  "created": "2024-02-12T09:50:11.794",
  "lastUpdated": "2024-02-12T09:50:11.794",
  href: "<dhis server>/api/icons/mosquito_outline/icon.svg"
}
```

Il est également possible d'obtenir directement une icône spécifique en la filtrant par sa clé. Dans l'exemple ci-dessous, la clé est mosquito_outline.

    GET /api/icons/mosquito_outline

### Opérations sur les icônes personnalisées { #webapi_icons_custom }

Une liste d'icônes personnalisées peut être récupérée sur la base de quelques paramètres de requête.

    GET /api/icons?type=CUSTOM

|Paramètre de requête|Type|Valeurs autorisées|Description ;|
|---|---|---|---|
|`type`|`Text`| DEFAULT,CUSTOM,ALL (par défaut, personnalisées, toutes) |Type d'icônes à récupérer. La valeur par défaut est TOUS|
|`keys`|`Text`| | Liste des clés pour lesquelles des icônes personnalisées doivent être récupérées | 
|`keywords`|`Text`| | Liste des mots clés pour lesquelles des icônes personnalisées doivent être récupérées| 
|`search`|`Text`| | Recherche d'un texte donné dans les clés et les mots-clés des icônes, et récupération de toutes les icônes qui contiennent ce texte dans leur clé ou leurs mots-clés.| 
|`createdStartDate`|`Date`| | Point de départ de la date de création|
|`createdEndDate`|`Date`| | Point final de la date de création| 
|`lastUpdatedStartDate`|`Date`| | Point de départ de la dernière date de mise à jour| 
|`lastUpdatedEndDate`|`Date`| | Point final de la dernière date de mise à jour| 


#### Paramètres de requête pour la pagination { #request-parameters-for-pagination }

|Paramètre de requête|Type|Valeurs autorisées|Description ;|
|---|---|---|---|
|`page`|`Entier`| Tout entier positif |Numéro de page à renvoyer. La valeur par défaut est 1 si rien n'est fourni.|
|`taille de la page`|`Entier`| Tout entier positif |Taille de la page. La valeur par défaut est 50. |
|`paging`|`Booléen`| `vrai`, `faux` |Indique si la pagination doit être ignorée et si toutes les lignes doivent être renvoyées. La valeur par défaut est `true`, ce qui signifie que par défaut toutes les requêtes sont paginées, sauf si  `paging=false` (c'est-à-dire si le paramètre "pagination" est défini sur "faux")|

#### Paramètres de requête pour la mise en ordre{ #request-parameters-for-ordering } 

|Paramètre de requête|Type|Valeurs autorisées|Description ;|
|---|---|---|---|
|`ordre`|`Text`| created:desc | Liste de paires de noms de propriétés et de directions de tri séparées par des virgules, au format propName:sortDirection. Par défaut, les icônes sont ordonnées comme suit : key:asc|


#### Paramètre de requête pour filtrer les réponses { #request-parameter-to-filter-responses } 

Les points d'extrémité acceptent un paramètre `fields` qui contrôle les champs qui seront renvoyés dans la réponse JSON. Le paramètre `fields` accepte une liste de noms de champs séparés par des virgules. Si rien n'est spécifié, les champs par défaut seront utilisés. 

`key,keywords,description,fileResourceUid,createdByUserUid,href`

Vous pouvez télécharger une ressource d'icône personnalisée en fournissant la clé d'icône suivante :

    GET /api/icons/{key}/icon

Des icônes personnalisées peuvent être créées, modifiées et supprimées.
Pour créer une icône personnalisée, utilisez la ressource ci-dessous.

    POST /api/icons

Elle attend une charge contenant la clé de l'icône, la description, la liste des mots-clés et l'identifiant de la ressource du fichier à relier aux données.

```json
{
    "key": "iconKey",
    "description": "description",
    "keywords": ["keyword 1","keyword 2"],
    "fileResourceUid": "ARsqBjfB2cf"
}
```

Seules les icônes personnalisées peuvent être mises à jour à l'aide de la ressource ci-dessous. 

    PUT /api/icons

Avec la charge suivante, la description et les mots-clés de l'icône seront mis à jour.

```json
{
    "key": "iconKey",
    "description": "new description",
    "keywords": ["new keyword 1", "new keyword 2"] 
}
```

Il est également possible de ne mettre à jour qu'un seul des deux éléments. Cela signifie que si nous voulons mettre à jour la description tout en gardant les mots-clés tels qu'ils sont, nous n'aurons qu'à fournir la clé de l'icône et le champ json de la description. Le même procédé s'applique dans l'autre sens, pour mettre à jour les mots-clés et laisser la description initiale intacte.

Seules les icônes personnalisées peuvent être supprimées à l'aide de la ressource ci-dessous.

    DELETE /api/icons/{icon_key}


## Type de rendu { #webapi_render_type } 

Certains types de métadonnées ont une propriété appelée *renderType* (type de rendu). Cette propriété établit une correspondance entre un *appareil* et un *type de restitution* (renderingType). Les applications peuvent utiliser ces informations pour savoir comment l'objet doit être rendu sur un appareil spécifique. Par exemple, le rendu d'un élément de données sur un appareil mobile peut être différent de celui d'un ordinateur de bureau.

Il existe actuellement deux types de restitution :

1.  Restitution du type de valeur

2.  Restitution des sections d'étape de programme

Il existe également deux types d'appareils :

1.  MOBILE

2.  DESKTOP

Le tableau suivant énumère les types de métadonnées et de restitution disponibles.
La restitution du type de valeur a des contraintes supplémentaires basées sur la configuration des métadonnées. Elles seront présentées dans un second tableau.

Tableau : Aperçu des métadonnées et des types de restitution

| Type de métadonnées | Types de restitution disponibles |
|---|---|
| Section des étapes de programme | * LISTING (par défaut)<br> * SEQUENTIAL<br> * MATRIX |
| Élément de données | * DEFAULT<br> * DROPDOWN<br> * VERTICAL_RADIOBUTTONS<br> * HORIZONTAL_RADIOBUTTONS<br> * VERTICAL_CHECKBOXES<br> * HORIZONTAL_CHECKBOXES<br> * SHARED_HEADER_RADIOBUTTONS<br> * ICONS_AS_BUTTONS<br> * SPINNER<br> * ICON<br> * TOGGLE<br> * VALUE<br> * SLIDER<br> * LINEAR_SCALE<br> * AUTOCOMPLETE<br> * QR_CODE<br> * BAR_CODE<br> * GS1_DATAMATRIX |

Étant donné que la gestion de la restitution par défaut des éléments de données et des attributs d'entités suivies dépend du type de valeur de l'objet, il existe également un type DEFAULT pour indiquer au client qu'il doit être traité normalement. La section des étapes de programme est définie sur LISTING par défaut.

Tableau : Types de restitution autorisés en fonction des types de valeurs

| le type de valeur ;               | L'objet est-il un ensemble d'options ? | Types de restitution autorisés |
|--------------------------|---|---|
| TRUE_ONLY (vrai uniquement)                | Non | DEFAULT, VERTICAL_RADIOBUTTONS, HORIZONTAL_RADIOBUTTONS, VERTICAL_CHECKBOXES, HORIZONTAL_CHECKBOXES, TOGGLE |
| BOOLÉEN                  | Non ||
| -                        | Oui | DEFAULT, DROPDOWN, VERTICAL_RADIOBUTTONS, HORIZONTAL_RADIOBUTTONS, VERTICAL_CHECKBOXES, HORIZONTAL_CHECKBOXES, SHARED_HEADER_RADIOBUTTONS, ICONS_AS_BUTTONS, SPINNER, ICON |
| INTEGER                  | Non | DEFAULT, VALUE, SLIDER, LINEAR_SCALE, SPINNER |
| TEXT                     | Non | DEFAULT, VALUE, AUTOCOMPLETE, QR_CODE, BAR_CODE, GS1_DATAMATRIX |
| INTEGER_POSITIVE         | Non ||
| INTEGER_NEGATIVE         | Non ||
| INTEGER_ZERO_OR_POSITIVE | Non ||
| NUMBER                   | Non ||
| UNIT_INTERVAL            | Non ||
| PERCENTAGE               | Non ||

Vous pouvez également récupérer une référence complète du tableau précédent en utilisant le point d'extrémité suivant :

    GET /api/staticConfiguration/renderingOptions

Quelques propriétés supplémentaires peuvent être définies pour la restitution du type de valeur ; ce qui est souvent nécessaire lors de la restitution de certains types spécifiques :

Tableau : propriétés de l'objet renderType

| Propriété | Description ; | Type |
|---|---|---|
| type | Le type de restitution de l'objet, tel qu'indiqué dans le premier tableau. Cette propriété est la même pour le type de valeur et la section des étapes de programme, mais c'est la seule propriété disponible pour la section des étapes de programme. | Énumération (voir la liste dans le tableau des métadonnées et des types de restitution) |
| min | Uniquement pour la restitution du type de valeur ; il représente la valeur minimale que ce champ peut avoir. | Entier |
| max | Uniquement pour la restitution du type de valeur ; il représente la valeur maximale que ce champ peut avoir. | Entier |
| étape | Uniquement pour la restitution de type valeur ; il représente la taille des étapes que la valeur doit augmenter, par exemple pour SLIDER ou LINEAR_SCALE. | Entier |
| points décimaux | Uniquement pour la restitution du type de valeur ; il représente le nombre de points décimaux que la valeur doit utiliser. | Entier |

Le *type de restitution* peut être défini lors de la création ou de la mise à jour des métadonnées énumérées dans le premier tableau. Voici un exemple de charge pour le type de restitution de la section des étapes de programme :

```json
{
  "renderingType": {
    "type": "MATRIX"
  }
}
```

Pour les éléments de données et les attributs d'entités suivies :

```json
{
  "renderingType": {
    "type": "SLIDER",
    "min": 0,
    "max": 1000,
    "step": 50,
    "decimalPoints": 0
  }
}
```

## Style d'objet { #webapi_object_style } 

La plupart des métadonnées ont une propriété "style". Cette propriété peut être utilisée par les clients pour représenter l'objet d'une certaine manière. Les propriétés actuellement prises en charge par le style sont les suivantes :

Tableau : Propriétés du style

| Propriété | Description ; | Type |
|---|---|---|
| couleur | Une couleur, représentée par une valeur hexadécimale. | Chaîne (#000000) |
| icône | Une icône, représentée par un nom d'icône. | Chaîne |

Actuellement, il n'existe pas de liste officielle ni de bibliothèques d'icônes. Il revient donc au client de les fournir. La liste suivante présente tous les objets qui prennent en charge le style :

  - Élément de données

  - Option de catégorie d'éléments de données

  - Ensemble de données

  - Indicateur

  - Option

  - Programme

  - Indicateur du programme

  - Section du programme

  - Étape du programme

  - Section des étapes de programme

  - Relation (Tracker)

  - Attribut d’entité suivie

  - Type d'entité suivie

Lors de la création ou de la mise à jour de l'un de ces objets, vous pouvez inclure la charge suivante pour modifier le style :

```json
{
  "style": {
    "color": "#ffffff",
    "icon": "my-beautiful-icon"
  }
}
```

## Éléments de donnée { #data-elements } 

### Merge data elements { #data_element_merge }

> **Caution**
>
> Merging DataElements should be carried out with the utmost care. Particular attention
> should be given to the merging of data values that have data element references involved in the
> merge. Knowing the potential side effects of a merge should be fully understood before performing
> the merge. The merging of DataElements has far-reaching effects. The information below
> will try to help show what's involved in a DataElement merge. A DataElement merge
> touches all the major parts of the system (metadata, data, tracker, analytics and audit).
> 
> System performance may be impacted if the source DataElements are linked to large amounts of Data/Audit records particularly.

The data element merge endpoint allows you to merge a number of data elements (sources) into a target data element.

#### Autorisation { #authorisation } 

The main authority required to perform a data element merge is `F_DATA_ELEMENT_MERGE`.  
Other authorities required relate to the general sharing and access of data elements, `F_DATAELEMENT_PUBLIC_ADD` and `F_DATAELEMENT_DELETE`.

#### Requête { #request } 

Merge data elements with a POST request:

```
POST /api/dataElements/merge
```

La charge au format JSON ressemble à ceci :

```json
{
  "sources": [
    "jNb63DIHuwU",
    "WAjjFMDJKcx"
  ],
  "target": "V9rfpjwHbYg",
  "deleteSources": true,
  "dataMergeStrategy": "DISCARD"
}
```

Les propriétés JSON sont décrites dans le tableau suivant.

Tableau : Fusion des champs de la charge

| Champ             | Obligatoire | Valeur                                                                                                                                                                                   |
|-------------------|----------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| sources           | Oui      | Array of identifiers of the data elements to merge (the source data elements)                                                                                                           |
| cible            | Oui      | Identifier of the data element to merge the sources into (the target data element)                                                                                                      |
| deleteSources     | Non       | Whether to delete the source data elements after the operation. Default is false. If true is chosen, then all source audit records will also be deleted.                                |
| dataMergeStrategy | Oui      | How to handle merging of data values. Options are 'DISCARD' or 'LAST_UPDATED'. DISCARD will delete all source data values. LAST_UPDATED will use the data value which was last updated. |

The merge operation will merge the source data elements into the target data element. One or many source data elements can be specified. Only one target should be specified.

The merge operation will transfer all source data element metadata associations to the target data element.
The following metadata get updated:


| Métadonnées                          | Propriété                  | Mesure prise               |
|-----------------------------------|---------------------------|----------------------------|
| DataDimensionItem                 | dataElement               | set to target              |
| EventVisualization                | dataElementValueDimension | set to target              |
| ProgramStageDataElement           | dataElement               | set to target              |
| ProgramNotificationTemplate       | recipientDataElement      | set to target              |
| Variable de règle de programme               | dataElement               | set to target              |
| ProgramRuleAction                 | dataElement               | set to target              |
| TrackedEntityDataElementDimension | dataElement               | set to target              |
| MinMaxDataElement                 | dataElement               | set to target              |
| SMSCode                           | dataElement               | set to target              |
| SMSCode                           | dataElement               | set to target              |
| Prédicteur                         | output                    | set to target              |
| DataSetElement                    | dataElement               | set to target              |
| DataElementOperand                | dataElement               | set to target              |
| ProgramStageDataElement           | dataElements              | remove sources, add target |
| Section                           | dataElements              | remove sources, add target |
| DataElementGroup                  | membres                   | remove sources, add target |
| Événement                             | eventDataValues           | remove sources, add target |
| Indicateur                         | numérateur                 | replace source with target |
| Indicateur                         | dénominateur               | replace source with target |
| Prédicteur                         | generator                 | replace source with target |
| Prédicteur                         | sampleSkipTest            | replace source with target |
| Formulaire de saisie de données                     | code html                  | replace source with target |
| Indicateur de programme                  | expression                | replace source with target |
| Indicateur de programme                  | filter                    | replace source with target |
| DataValue                         | dataElement               |                            |


| Données                            | Propriété        | Mesure prise                                                                                                                                                                                             |
|---------------------------------|-----------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Événement                           | eventDataValues | action based on merge strategy (DISCARD / LAST_UPDATED). DISCARD will delete all source event data values. LAST_UPDATED will use the event data value which was last updated, when more than one exists. |
| DataValue                       | dataElement     | action based on merge strategy (DISCARD / LAST_UPDATED). DISCARD will delete all source data values. LAST_UPDATED will use the data value which was last updated, when more than one exists.             |
| TrackedEntityDataValueChangeLog |                 | deleted if sources are being deleted, otherwise no action.                                                                                                                                               |
| DataValueAudit                  |                 | deleted if sources are being deleted, otherwise no action.                                                                                                                                               |


#### Validation { #validation } 

Les contraintes et les codes d'erreur suivants s'appliquent.

Tableau : Contraintes et codes d'erreur

| Code d'erreur | Description                                                                                                                                 |
|------------|---------------------------------------------------------------------------------------------------------------------------------------------|
| E1550      | At least one source data element must be specified                                                                                          |
| E1551      | Target data element must be specified                                                                                                       |
| E1552      | Target data element cannot be a source indicator                                                                                            |
| E1553      | Source/Target data element does not exist: `{uid}`                                                                                          |
| E1554      | All source ValueTypes must match target ValueType: `ValueType`. Other ValueTypes found: `ValueType`                                         |
| E1555      | All source DataElementDomains must match target DataElementDomain: `DataElementDomain`. Other DataElementDomains found: `DataElementDomain` |
| E1556      | dataMergeStrategy field must be specified. With value `DISCARD` or `LAST_UPDATED`                                                           |

#### Database constraints { #database-constraints } 
There are unique constraints in place that can prevent a successful merge. These constraints are set by DHIS2 in order to maintain a logical domain model.    
Below are a list of the known database unique key constraints at the time of writing. For example, you
can only have 1 data set element with the same dataset and data element.

Table: Database table unique key constraints

| Table                   | Unique key constraint                     |
|-------------------------|-------------------------------------------|
| minmaxdataelement       | orgunit, dataelement, categoryoptioncombo |
| programstagedataelement | programstage, dataelement                 |
| datasetelement          | dataset, dataelement                      |


#### Réponse { #response } 
##### Succès { #success } 
Voici un exemple de réponse après une opération réussie :

```json
{
    "httpStatus": "OK",
    "httpStatusCode": 200,
    "status": "OK",
    "response": {
        "mergeReport": {
            "mergeErrors": [],
            "mergeType": "DATA_ELEMENT",
            "sourcesDeleted": [
                "vQ0dGV9EDrw"
            ],
            "message": "DATA_ELEMENT merge complete"
        }
    }
}
```

##### Failure { #failure } 
Voici un exemple de réponse après une opération erronée :

```json
{
    "httpStatus": "Conflict",
    "httpStatusCode": 409,
    "status": "WARNING",
    "message": "One or more errors occurred, please see full details in merge report.",
    "response": {
        "mergeReport": {
            "mergeErrors": [
                {
                    "message": "At least one source data element must be specified",
                    "errorCode": "E1550",
                    "args": []
                },
                {
                    "message": "Target data element does not exist: `abcdefg1221`",
                    "errorCode": "E1553",
                    "args": [
                        "Target",
                        "abcdefg1221"
                    ]
                }
            ],
            "mergeType": "DATA_ELEMENT",
            "sourcesDeleted": [],
            "message": "DATA_ELEMENT merge has errors"
        }
    }
}
```

Another sample validation error response:

```json
{
    "httpStatus": "Conflict",
    "httpStatusCode": 409,
    "status": "WARNING",
    "message": "One or more errors occurred, please see full details in merge report.",
    "response": {
        "mergeReport": {
            "mergeErrors": [
                {
                    "message": "All source ValueTypes must match target ValueType: `TEXT`. Other ValueTypes found: `NUMBER`",
                    "errorCode": "E1554",
                    "args": []
                }
            ],
            "mergeType": "DATA_ELEMENT",
            "sourcesDeleted": [],
            "message": "DATA_ELEMENT merge has errors"
        }
    }
}
```

A database constraint sample error response:

```json
{
  "httpStatus": "Conflict",
  "httpStatusCode": 409,
  "status": "ERROR",
  "message": "ERROR: duplicate key value violates unique constraint \"minmaxdataelement_unique_key\"\n  Detail: Key (sourceid, dataelementid, categoryoptioncomboid)=(193236, 1148617, 167661) already exists."
}
```

## Indicateurs { #webapi_indicators } 

Cette section décrit les indicateurs et les expressions d'indicateurs.

### Indicateurs agrégés { #webapi_aggregate_indicators } 

Pour récupérer les indicateurs, vous pouvez lancer une requête GET à la ressource des indicateurs comme suit :

    /api/indicators

Les indicateurs représentent des expressions qui peuvent être calculées et présentées sous forme de résultat. Les expressions des indicateurs sont divisées en un numérateur et un dénominateur. Les numérateurs et les dénominateurs sont des expressions mathématiques qui peuvent contenir des références à des éléments de données, à d'autres indicateurs, à des constantes et à des groupes d'unités d'organisation. Les variables seront remplacées par des valeurs de données lorsqu'elles seront utilisées, par exemple dans des rapports. Les variables autorisées dans les expressions sont décrites dans le tableau suivant.

Traduit avec DeepL.com (version gratuite)

Tableau : Variables d'indicateurs

| Variable | Objet | Description |
|---|---|---|
| #{<data-element-id\>.<category-option-combo-id\>.<attribute-option-combo-id\>} | Opérande de l'élément de données | Fait référence à la combinaison d'un élément de données agrégé et d'une combinaison d'options de catégorie. Les identifiants des combinaisons d'options de catégorie et d'attribut sont facultatifs et le symbole "\*" peut être utilisé pour indiquer n'importe quelle valeur. |
| #{<dataelement-id\>.<category-option-group-id\>.<attribute-option-combo-id\>} | Groupe d'options de catégorie | Fait référence à un élément de données agrégé et à un groupe d'options de catégorie, qui contient plusieurs combinaisons d'options de catégorie. |
| #{<data-element-id\>} | Élément de données agrégé | Fait référence à la valeur totale d'un élément de données agrégé pour toutes les combinaisons d'options de catégorie. |
| D{<program-id\>.<data-element-id\>} | Élément de données de programme | Fait référence à la valeur d'un élément de données Tracker au sein d'un programme. |
| A{<program-id\>.<attribute-id\>} | Attribut d'entité suivie d'un programme | Fait référence à la valeur d'un attribut d'entité suivie au sein d'un programme. |
| I{<program-indicator-id\>} | Indicateur de programme | Fait référence à la valeur d'un indicateur de programme. |
| R{<dataset-id\>.<metric\>} | Taux de déclaration | Fait référence à une mesure de taux de déclaration. La mesure peut être REPORTING_RATE (taux de déclaration), REPORTING_RATE_ON_TIME (taux de déclarations à temps), ACTUAL_REPORTS (rapports envoyés), ACTUAL_REPORTS_ON_TIME (rapports envoyés à temps), EXPECTED_REPORTS (rapports attendus). |
| C{<constant-id\>} | Constante | Fait référence à une valeur constante. |
| N{<indicator-id\>} | Indicateur | Fait référence à un indicateur existant. |
| OUG{<orgunitgroup-id\>} | Groupe d'unités d'organisation | Fait référence au nombre d'unités d'organisation présentes dans un groupe d'unités d'organisation. |

Dans un opérande d'élément de données ou dans un élément de données agrégé, les substitutions suivantes peuvent être effectuées :

| Élément | Valeur | Description |
|---|---|---|
| data-element-id | data-element-id | Un élément de données agrégé |
| data-element-id | deGroup:data-element-group-id | Tous les éléments de données agrégés d'un groupe d'éléments de données |
| category-option-combo-id | category-option-combo-id | Une combinaison d'options de catégorie |
| category-option-combo-id | co:category-option-id | Toutes les combinaisons d'options de catégorie dans une option de catégorie |
| category-option-combo-id | coGroup:category-option-group-id | Toutes les combinaisons d'options de catégorie dans un groupe d'options de catégorie |
| category-option-combo-id | coGroup:co-group-id1&co-group-id2... | Toutes les combinaisons d'options de catégorie qui font partie de plusieurs groupes d'options de catégorie |

La syntaxe ressemble à ceci :

    #{<dataelement-id>.<catoptcombo-id>} + C{<constant-id>} + OUG{<orgunitgroup-id>}

Voici un exemple correspondant :

    #{P3jJH5Tu5VC.S34ULMcHMca} + C{Gfd3ppDfq8E} + OUG{CXw2yu5fodb}

Pour les variables d'éléments de données, l'identifiant de la combinaison d'options de catégorie peut être omis. La variable va alors représenter le total pour l'élément de données, par exemple pour toutes les combinaisons d'options de catégorie. Exemple :

    #{P3jJH5Tu5VC} + 2

Les opérandes des éléments de données peuvent inclure toute combinaison d'options de catégorie et toute combinaison d'options d'attributs. Elles peuvent également utiliser des caractères génériques pour indiquer n'importe quelle valeur :

    #{P3jJH5Tu5VC.S34ULMcHMca} + #{P3jJH5Tu5VC.*.j8vBiBqGf6O} + #{P3jJH5Tu5VC.S34ULMcHMca.*}

Exemple utilisant un groupe d'éléments de données :

    #{deGroup:oDkJh5Ddh7d} + #{deGroup:GBHN1a1Jddh.j8vBiBqGf6O}

Exemple utilisant une option de catégorie, un groupe d'éléments de données et un groupe d'options de catégorie :

    #{P3jJH5Tu5VC.co:FbLZS3ueWbQ} + #{deGroup:GBHN1a1Jddh.coGroup:OK2Nr4wdfrZ.j8vBiBqGf6O}

Exemple utilisant plusieurs groupes d'options de catégories :

    #{P3jJH5Tu5VC.coGroup:OK2Nr4wdfrZ&j3C417uW6J7&ddAo6zmIHOk}

Exemple utilisant un élément de données de programme et un attribut de programme :

    ( D{eBAyeGv0exc.vV9UWAZohSf} * A{IpHINAT79UW.cejWyOfXge6} ) / D{eBAyeGv0exc.GieVkTxp4HH}

Exemple combinant des indicateurs de programme et des indicateurs agrégés :

    I{EMOt6Fwhs1n} * 1000 / #{WUg3MYWQ7pt}

Exemple utilisant un taux de déclaration :

    R{BfMAe6Itzgt.REPORTING_RATE} * #{P3jJH5Tu5VC.S34ULMcHMca}

Un autre exemple de taux de déclaration qui utilise des rapports sur des ensembles de données et des rapports attendus :

    R{BfMAe6Itzgt.ACTUAL_REPORTS} / R{BfMAe6Itzgt.EXPECTED_REPORTS}

Exemple utilisant un indicateur existant :

    N{Rigf2d2Zbjp} * #{P3jJH5Tu5VC.S34ULMcHMca}

Les expressions peuvent être constituées de tout type d'expression mathématique valide, à titre d'exemple :

    ( 2 * #{P3jJH5Tu5VC.S34ULMcHMca} ) / ( #{FQ2o8UBlcrS.S34ULMcHMca} - 200 ) * 25

### Indicateurs de programme { #webapi_program_indicators } 

Pour récupérer les indicateurs de programme, vous pouvez effectuer une requête GET à la ressource des indicateurs de programme, comme suit :

    /api/programIndicators

Les indicateurs de programme peuvent contenir des informations collectées dans le cadre d'un programme. Les indicateurs ont une expression qui peut contenir des références à des éléments de données, des attributs, des constantes et des variables de programme. Les variables autorisées dans les expressions sont décrites dans le tableau suivant.



Tableau : Variables des indicateurs de programme

| Variable | Description |
|---|---|
| #{<programstage-id\>.<dataelement-id\>} | Fait référence à une combinaison entre l'étape de programme et l'identifiant de l'élément de données. |
| A{<attribute-id\>} | Fait référence à un attribut d'entité suivie. |
| V{<variable-id\>} | Fait référence à une variable de programme. |
| C{<constant-id\>} | Fait référence à une constante. |

La syntaxe ressemble à ceci :

    #{<programstage-id>.<dataelement-id>} + #{<attribute-id>} + V{<varible-id>} + C{<constant-id>}

Voici un exemple correspondant :

    #{A03MvHHogjR.a3kGcGDCuk6} + A{OvY4VVhSDeJ} + V{incident_date} + C{bCqvfPR02Im}

### Expressions { #webapi_expressions } 

Les expressions sont des formules mathématiques qui peuvent contenir des références à des éléments de données, des constantes et des groupes d'unités d'organisation. Pour valider une expression et en obtenir la description sous forme de texte, vous pouvez adresser une requête GET à la ressource des expressions :

    /api/expressions/description?expression=<expression-string>

La réponse suit le format standard des messages web JSON. La propriété *statut* indique le résultat de la validation et sera "OK" en cas de succès et "ERROR" en cas d'échec. La propriété *message* sera "Valid" (valide) si la validation réussit, et en cas d'échec, elle fournira une description textuelle de la raison de cet échec. La propriété *description* fournit une description textuelle de l'expression.

```json
{
  "httpStatus": "OK",
  "httpStatusCode": 200,
  "status": "OK",
  "message": "Valid",
  "description": "Acute Flaccid Paralysis"
}
```

### Fusionner les indicateurs { #webapi_indicator_merge }

Le point d'extrémité de la fusion des indicateurs vous permet de fusionner des indicateurs (sources) en un seul indicateur cible.

#### Autorisation { #authorisation } 

Vous devez disposer de l'autorité `F_INDICATOR_MERGE` pour pouvoir fusionner des indicateurs.

#### Requête { #request } 

Fusionner des indicateurs à l'aide d'une requête POST :

```
POST /api/indicators/merge
```

La charge au format JSON ressemble à ceci :

```json
{
  "sources": [
    "jNb63DIHuwU",
    "WAjjFMDJKcx"
  ],
  "target": "V9rfpjwHbYg",
  "deleteSources": true
}
```

Les propriétés JSON sont décrites dans le tableau suivant.

Tableau : Fusion des champs de la charge

| Champ         | Obligatoire | Valeur                                                                         |
|---------------|----------|-------------------------------------------------------------------------------|
| sources       | Oui      | Tableau des identifiants des indicateurs à fusionner (les indicateurs sources)       |
| cible        | Oui      | Identifiant de l'indicateur dans lequel les sources doivent être fusionnées (l'indicateur cible)  |
| deleteSources | Non       | Détermine si les indicateurs source doivent être supprimés après l'opération. La valeur par défaut est "false" |

L'opération de fusion permet de fusionner les indicateurs sources dans l'indicateur cible. Un ou plusieurs indicateurs sources peuvent être spécifiés. Un seul indicateur cible doit être spécifiée.

L'opération de fusion transfère toutes les associations de métadonnées de l'indicateur source vers l'indicateur cible. 
Les métadonnées suivantes sont mises à jour :


| Métadonnées            | Propriété                                   | Mesure prise                                                                |
|---------------------|--------------------------------------------|-----------------------------------------------------------------------------|
| Groupe d'indicateurs       | membres                                    | Indicateur source supprimé, indicateur cible ajouté                            |
| Ensemble de données             | indicateurs                                 | Indicateur source supprimé, indicateur cible ajouté                            |
| Élément dimensionnel de données | n/a                                        | Tous les éléments de données associés à des sources seront reliés à la cible.           |
| Section             | indicateurs                                 | Indicateur source supprimé, indicateur cible ajouté                            |
| Configuration       | Indicateurs infrastructurels (Groupe d'indicateurs) | Indicateur source supprimé, indicateur cible ajouté                            |
| Indicateur           | numérateur / dénominateur                    | Remplace toute référence source par la référence cible                      |
| Formulaire de saisie de données       | code html                                   | Remplace toute référence source par la référence cible                      |
| Visualisation       | triage                                    | Remplace toute référence source par la référence cible en tant que dimension de tri |


#### Validation { #validation } 

Les contraintes et les codes d'erreur suivants s'appliquent.

Tableau : Contraintes et codes d'erreur

| Code d'erreur | Description ;                                     |
|------------|-------------------------------------------------|
| E1540      | Au moins un indicateur source doit être spécifié |
| E1541      | L'indicateur cible doit être spécifié              |
| E1542      | L'indicateur cible ne peut pas être un indicateur source   |
| E1543      | L'indicateur source/cible n'existe pas : `{uid}` |

#### Réponse { #response } 
##### Succès { #success } 
Voici un exemple de réponse après une opération réussie :

```json
{
    "httpStatus": "OK",
    "httpStatusCode": 200,
    "status": "OK",
    "response": {
        "mergeReport": {
            "mergeErrors": [],
            "mergeType": "INDICATOR",
            "sourcesDeleted": [
                "vQ0dGV9EDrw"
            ],
            "message": "INDICATOR merge complete"
        }
    }
}
```

Voici un exemple de réponse après une opération erronée :

```json
{
    "httpStatus": "Conflict",
    "httpStatusCode": 409,
    "status": "WARNING",
    "message": "One or more errors occurred, please see full details in merge report.",
    "response": {
        "mergeReport": {
            "mergeErrors": [
                {
                    "message": "At least one source indicator must be specified",
                    "errorCode": "E1540",
                    "args": []
                },
                {
                    "message": "Target indicator does not exist: `abcdefg1221`",
                    "errorCode": "E1543",
                    "args": [
                        "Target",
                        "abcdefg1221"
                    ]
                }
            ],
            "mergeType": "INDICATOR",
            "sourcesDeleted": [],
            "message": "INDICATOR merge has errors"
        }
    }
}
```

## Types d'indicateurs { #webapi_indicator_types}

### Fusionner les types d'indicateurs { #webapi_indicator_type_merge}

Le point d'extrémité de la fusion des types d'indicateur vous permet de fusionner des types d'indicateurs en un seul type d'indicateur cible.

#### Autorisation { #authorisation } 

Vous devez disposer de l'autorité  `F_INDICATOR_TYPE_MERGE` pour pouvoir fusionner des types d'indicateur.

#### Requête { #request } 

Fusionner des types d'indicateur à l'aide d'une requête POST :

```
POST /api/indicatorTypes/merge
```

La charge au format JSON ressemble à ceci :

```json
{
  "sources": [
    "jNb63DIHuwU",
    "WAjjFMDJKcx"
  ],
  "target": "V9rfpjwHbYg",
  "deleteSources": true
}
```

Les propriétés JSON sont décrites dans le tableau suivant.

Tableau : Fusion des champs de la charge

| Champ         | Obligatoire | Valeur                                                                                   |
|---------------|----------|-----------------------------------------------------------------------------------------|
| sources       | Oui      | Tableau des identifiants des types d'indicateurs à fusionner (les types d'indicateurs source).      |
| cible        | Oui      | Identifiant du type d'indicateur dans lequel les sources doivent être fusionnées (le type d'indicateur cible). |
| deleteSources | Non       | Détermine si les types d'indicateurs source doivent être supprimés après l'opération. La valeur par défaut est "false"     |

L'opération de fusion permet de fusionner les types d'indicateur source dans le type d'indicateur cible. Un ou plusieurs types d'indicateur source peuvent être spécifiés. Un seul type d'indicateur cible doit être spécifiée.

L'opération de fusion combine toutes les associations de métadonnées de l'indicateur et les types d'indicateur source, et le tout est transféré vers le type d'indicateur cible.

#### Validation { #validation } 

Les contraintes et les codes d'erreur suivants s'appliquent.

Tableau : Contraintes et codes d'erreur

| Code d'erreur | Description                                             |
|------------|---------------------------------------------------------|
| E1530      | Au moins un type d'indicateur source doit être spécifié    |
| E1531      | Le type d'indicateur cible doit être spécifié                 |
| E1532      | Le type d'indicateur cible ne peut pas être un type d'indicateur source |
| E1533      | Le type d'indicateur source/cible n'existe pas : `{uid}`    |

#### Réponse { #response } 
##### Succès { #success } 
Voici un exemple de réponse après une opération réussie :

```json
{
    "httpStatus": "OK",
    "httpStatusCode": 200,
    "status": "OK",
    "response": {
        "mergeReport": {
            "mergeErrors": [],
            "mergeType": "INDICATOR_TYPE",
            "sourcesDeleted": [
                "vQ0dGV9EDrw"
            ],
            "message": "INDICATOR_TYPE merge complete"
        }
    }
}
```

Voici un exemple de réponse après une opération erronée :

```json
{
    "httpStatus": "Conflict",
    "httpStatusCode": 409,
    "status": "WARNING",
    "message": "One or more errors occurred, please see full details in merge report.",
    "response": {
        "mergeReport": {
            "mergeErrors": [
                {
                    "message": "At least one source indicator type must be specified",
                    "errorCode": "E1530",
                    "args": []
                },
                {
                    "message": "Target indicator type does not exist: `abcdefg1221`",
                    "errorCode": "E1533",
                    "args": [
                        "Target",
                        "abcdefg1221"
                    ]
                }
            ],
            "mergeType": "INDICATOR_TYPE",
            "sourcesDeleted": [],
            "message": "INDICATOR_TYPE merge has errors"
        }
    }
}
```

## Les unités d’organisation { #webapi_organisation_units } 

La ressource *organisationUnits* suit les conventions standard des autres ressources de métadonnées présents dans DHIS2. Cette ressource prend en charge des paramètres de requête supplémentaires.

### Obtenir la liste des unités d'organisation { #webapi_list_of_organisation_units } 

Pour obtenir une liste des unités d'organisation, vous pouvez utiliser la ressource suivante :

    /api/33/organisationUnits

Tableau : Paramètres de requête des unités d'organisation

| Paramètre de requête | Options | Description |
|---|---|---|
| userOnly | faux | vrai | Unités d'organisation de saisie de données associées à l'utilisateur actuel. |
| userDataViewOnly | faux | vrai | Unités d'organisation de visualisation de données associées à l'utilisateur actuel. |
| userDataViewFallback | faux | vrai | Unités d'organisation de visualisation de données associées à l'utilisateur actuel, avec un retour aux unités d'organisation de saisie de données. |
| query | chaîne | Requête sur les propriétés de nom, code et ID. |
| niveau | entier | Unités d'organisation au niveau spécifié de la hiérarchie. |
| maxLevel | entier | Unités d'organisation au niveau maximal ou à des niveaux plus élevés dans la hiérarchie. |
| withinUserHierarchy | faux | vrai | Limite la recherche et l'extraction aux unités d'organisation qui se trouvent dans le champ de saisie de l'utilisateur. |
| withinUserSearchHierarchy | faux | vrai | Limite la recherche et l'extraction aux unités d'organisation qui se trouvent dans le champ de recherche de l'utilisateur actuel. Remarque : Si "withinUserHierarchy" est défini sur "true", il devient prioritaire. |
| memberCollection | chaîne | Permet d'afficher le nombre de membres dans une collection ; renvoie au nom de la collection associée aux unités d'organisation. |
| memberObject | UID | Permet d'afficher le nombre de membres dans une collection ; renvoie à l'identifiant de l'objet qui fait partie de la collection. |

### Obtenir une unité d'organisation avec une sous-hiérarchie { #webapi_organisation_units_with_sub_hierarchy } 

Pour obtenir une unité d'organisation ainsi que les unités d'organisation présentes dans sa sous-hiérarchie, vous pouvez utiliser la ressource suivante.

    /api/33/organisationUnits/{id}

Tableau : Paramètres de l'unité d'organisation

| Paramètre de requête | Options | Description |
|---|---|---|
| includeChildren | faux | vrai | Inclut les subordonnées directs de l'unité d'organisation spécifiée, c'est-à-dire les unités qui lui sont directement inférieures dans la sous-hiérarchie. |
| includeDescendants | faux | vrai | Inclut tous les descendants de l'unité d'organisation spécifiée, c'est-à-dire toutes les unités qui lui sont inférieures dans la hiérarchie. |
| includeAncestors | faux | vrai | Inclut tous les ascendants de l'unité d'organisation spécifiée. |
| niveau | entier | Inclut les descendants de l'unité d'organisation spécifiée à un niveau précis de la sous-hiérarchie. Ce paramètre dépend de l'unité d'organisation, et commence par le premier niveau qui est directement inférieur à l'unité d'organisation. |

### Obtenir des unités d'organisation par option de catégorie{ #webapi_organisation_units_by_category_options }

Point d'extrémité conçu pour récupérer les associations entre les options de catégorie et les unités d'organisation. Ce point d'extrémité est le moyen idéal pour récupérer les associations entre les programmes et les unités d'organisation.

    /api/33/categoryOptions/orgUnits?categoryOptions={categoryOptionIdA},{categoryOptionIdB}

Les réponses auront le format suivant :

```json
{
  "<categoryOptionIdA>": [
    "<orgUnitUid>",
    "<orgUnitUid>"
  ],
  "<categoryOptionIdB>": [
    "<orgUnitUid>",
    "<orgUnitUid>"
  ],
  "<categoryOptionIdC>": []
}
```

Les options de catégorie accessibles à toutes les unités d'organisation sont renvoyées avec un tableau d'unités d'organisation vide (`[]`).

### Obtenir les unités d'organisation par programme { #webapi_organisation_units_by_programs } 

Point d'extrémité conçu pour récupérer les associations entre les programmes et les unités d'organisation. Ce point d'extrémité est le moyen idéal pour récupérer les associations entre les programmes et les unités d'organisation.

    /api/33/programs/orgUnits?programs={programIdA},{programIdB}

Les réponses auront le format suivant :

```json
{
  "<programIdA>": [
    "<orgUnitUid>",
    "<orgUnitUid>"
  ],
  "<programIdB>": [
    "<orgUnitUid>",
    "<orgUnitUid>"
  ],
  "<programIdC>": []
}
```

Les programmes accessibles à toutes les unités d'organisation sont renvoyées avec un tableau d'unités d'organisation vide (`[]`).

### Fractionner des unités d'organisation { #webapi_organisation_unit_split }

Le point d'extrémité de fractionnement des unités d'organisation vous permet de fractionner des unités d'organisation en un certain nombre d'unités d'organisation cibles.

#### Requête { #request } 

Fractionner des unités d'organisation à l'aide d'une requête POST :

```
POST /api/organisationUnits/split
```

La charge au format JSON ressemble à ceci :

```json
{
  "source": "rspjJHg4WY1",
  "targets": [
    "HT0w9YLMLyn",
    "rEpnzuNpRKM"
  ],
  "primaryTarget": "HT0w9YLMLyn",
  "deleteSource": true
}
```

Les propriétés JSON sont décrites dans le tableau suivant.

Tableau : Fractionnement des champs de la charge

| Champ         | Obligatoire | Valeur |
| ------------- | -------- |------ |
| source        | Oui      | Identifiant de l'unité d'organisation à fractionner (l'unité d'organisation source). |
| cibles       | Oui      | Tableau des identifiants des unités d'organisation qui seront le résultat du fractionnement de l'unité source (les unités d'organisation cibles). |
| primaryTarget | Non       | Identifiant de l'unité d'organisation vers laquelle transférer les données agrégées, les événements et les entités suivies associés à l'unité source. S'il n'est pas spécifié, la première cible sera utilisée. |
| deleteSource  | Non       | Détermine si l'unité d'organisation source doit être supprimée après l'opération. La valeur par défaut est `true` |

L'opération de fractionnement consiste à scinder l'unité d'organisation source en unités d'organisation cibles. Il est recommandé de créer de nouvelles unités d'organisation cibles avant de procéder au fractionnement, et de s'assurer au préalable les unités cibles ne contiennent pas de données agrégées. Vous pouvez spécifier un nombre quelconque d'unités d'organisation cibles.

L'opération de fractionnement transfère toutes les associations de métadonnées de l'unité d'organisation source vers les unités d'organisation cibles. Cela inclut les ensembles de données, les programmes, les groupes d'unités d'organisation, les options de catégorie, les utilisateurs, les visualisations, les cartes et les rapports d'événements.

L'opération transfère tous les enregistrements de données de l'unité d'organisation source vers l'unité d'organisation spécifiée comme cible principale ou, si elle n'est pas spécifiée, vers la première unité d'organisation cible spécifiée. Cela inclut les valeurs de données agrégées, les enregistrements relatifs à l'approbation des données, les événements, les entités suivies, etc.

#### Validation { #validation } 

Les contraintes et les codes d'erreur suivants s'appliquent.

Tableau : Contraintes et codes d'erreur

| Code d'erreur | Description                                     |
| ---------- | ----------------------------------------------- |
| E1510      | L'unité d'organisation source doit être spécifiée               |
| E1511      | Au moins deux unités d'organisation cibles doivent être spécifiées |
| E1512      | L'unité d'organisation source ne peut pas être une unité d'organisation cible     |
| E1513      | La cible principale doit être spécifiée                |
| E1514      | La cible principale doit être une unité d'organisation cible        |
| E1515      | L'unité d'organisation cible n'existe pas                  |

### Merge organisation units { #webapi_organisation_unit_merge}

Le point d'extrémité de fusion des unités d'organisation vous permet de fusionner des unités d'organisation en une seule unité d'organisation cible.

#### Requête { #request } 

Fusionner des unités d'organisation à l'aide d'une requête POST :

```
POST /api/organisationUnits/merge
```

La charge au format JSON ressemble à ceci :

```json
{
  "sources": [
    "jNb63DIHuwU",
    "WAjjFMDJKcx"
  ],
  "target": "V9rfpjwHbYg",
  "dataValueMergeStrategy": "LAST_UPDATED",
  "dataApprovalMergeStrategy": "LAST_UPDATED",
  "deleteSources": true
}
```

Les propriétés JSON sont décrites dans le tableau suivant.

Tableau : Fusion des champs de la charge

| Champ                     | Obligatoire | Valeur |
| ------------------------- | -------- | ----- |
| sources                   | Oui      | Tableau des identifiants des unités d'organisation à fusionner (unités d'organisation source). |
| cible                    | Oui      | Identifiant de l'unité d'organisation qui sera le résultat de la fusion des unités source (l'unité d'organisation cible). |
| dataValueMergeStrategy    | Non       | Stratégie de fusion des valeurs de données. Options : `LAST_UPDATED` (par défaut), `DISCARD`. |
| dataApprovalMergeStrategy | Non       | Stratégie de fusion des enregistrements relatifs à l'approbation des données. Options : `LAST_UPDATED` (par défaut), `DISCARD`. |
| deleteSources             | Non       | Détermine si les unités d'organisation source doivent être supprimées après l'opération. La valeur par défaut est `true` |

L'opération de fusion consiste à combiner des unités d'organisation source pour former une seule unité cible. Il est recommandé de créer une nouvelle unité d'organisation cible avant de procéder à la fusion, et de s'assurer au préalable l'unité cible ne contient pas de données agrégées. Vous pouvez spécifier un nombre quelconque d'unités d'organisation source.

L'opération de fusion transfère toutes les associations de métadonnées des unités d'organisation sources vers l'unité d'organisation cible. Cela inclut les ensembles de données, les programmes, les groupes d'unités d'organisation, les options de catégorie, les utilisateurs, les visualisations, les cartes et les rapports d'événements. L'opération transfère également toutes les données d'événements et de tracker, telles que les événements, les inscriptions, l'historique de la propriété, la propriété des programmes et les entités suivies, vers l'unité d'organisation cible.

La stratégie de fusion des valeurs de données spécifiée définit la manière dont les valeurs de données sont traitées. Pour la stratégie `LAST_UPDATED`, les valeurs de données de toutes les unités d'organisation sources sont transférées vers l'unité d'organisation cible, et lorsque des valeurs existent pour les mêmes paramètres, c'est la dernière valeur mise à jour ou créée qui sera utilisée. Ceci permet d'éviter la répétition des données. Pour la stratégie `DISCARD`, les valeurs ne sont pas transférées vers l'unité d'organisation cible, mais elles sont simplement supprimées. La stratégie de fusion de l'approbation des données spécifiée définit la manière dont les enregistrements relatifs à l'approbation des données sont traités, et suit la même logique que les valeurs de données.

#### Validation { #validation } 

Les contraintes et les codes d'erreur suivants s'appliquent.

Tableau : Contraintes et codes d'erreur

| Code d'erreur | Description                                     |
| ---------- | ----------------------------------------------- |
| E1500      | Au moins deux unités d'organisation sources doivent être spécifiées |
| E1501      | L'unité d'organisation cible doit être spécifiée               |
| E1502      | L'unité d'organisation cible ne peut pas être une unité d'organisation source     |
| E1503      | L'unité d'organisation source n'existe pas                  |

## Ensembles de données { #webapi_data_sets } 

La ressource *dataSets* suit les conventions standard des autres ressources de métadonnées présents dans DHIS2. Cette ressource prend en charge des paramètres de requête supplémentaires.

    /api/33/dataSets

Pour récupérer la version d'un ensemble de données, vous pouvez effectuer une requête GET :

    GET /api/33/dataSets/<uid>/version

Pour augmenter (d'une unité) la version d'un ensemble de données, vous pouvez effectuer une requête POST :

    POST /api/33/dataSets/<uid>/version

### Modèle de notification des ensembles de données { #webapi_dataset_notifications } 

La ressource *modèles de notification des ensembles de données* suit les conventions standard des autres ressources de métadonnées présentes dans DHIS2.

    GET /api/33/dataSetNotficationTemplates

Pour récupérer un modèle de notification d'ensemble de données, vous pouvez effectuer une requête GET :

    GET /api/33/dataSetNotficationTemplates/<uid>

Pour ajouter un modèle de notification d'ensemble de données, vous pouvez effectuer une requête POST :

    POST /api/33/dataSetNotficationTemplates

Pour supprimer un modèle de notification d'ensemble de données, vous pouvez effectuer une requête DELETE :

    DELETE /api/33/dataSetNotficationTemplates/<uid>

Ci-dessous, un exemple de charge JSON :

```json
{
  "name": "dataSetNotificationTemplate1",
  "dataSetNotificationTrigger": "DATA_SET_COMPLETION",
  "relativeScheduledDays": 0,
  "notificationRecipient": "ORGANISATION_UNIT_CONTACT",
  "dataSets": [{
    "id": "eZDhcZi6FLP"
  }],
  "deliveryChannels": ["SMS","EMAIL"],
  "subjectTemplate": "V{data_set_name}",
  "messageTemplate": "V{data_set_name}V{registration_period}",
  "sendStrategy": "SINGLE_NOTIFICATION"
}

```

`notificationRecipient` peut être l'un des éléments suivants :
- `USER_GROUP` pour les messages internes
- `ORGANISATION_UNIT_CONTACT` pour les messages externes


## Niveaux d'unités d'organisation remplis{ #webapi_filled_organisation_unit_levels } 

La ressource *filledOrganisationUnitLevels* fournit une liste ordonnée de niveaux d'unités d'organisation, où les niveaux générés sont introduits dans la liste pour remplir les positions pour lesquelles il n'existe pas de niveau.

    GET /api/33/filledOrganisationUnitLevels

Pour définir des niveaux d'unité d'organisation, vous pouvez envoyer une requête POST avec une charge JSON et un type de contenu `application/json` comme ceci :

```json
{
  "organisationUnitLevels": [{
    "name": "National",
    "level": 1,
    "offlineLevels": 3
  }, {
    "name": "District",
    "level": 2
  }, {
    "name": "Chiefdom",
    "level": 3
  }, {
    "name": "Facility",
    "level": 4
  }]
}
```

## Les prédicteurs { #webapi_predictors } 

Un prédicteur permet de générer des valeurs de données sur la base d'une expression.
Il peut être utilisé, par exemple, pour générer des cibles, des seuils ou des estimations de valeurs.

Pour récupérer les prédicteurs, vous pouvez effectuer une requête GET à la ressource des prédicteurs comme suit :

    /api/predictors

### Création d'un prédicteur { #webapi_create_predictor } 

Vous pouvez créer un prédicteur à l'aide d'une requête POST à la ressource des prédicteurs :

    POST /api/predictors

Voici un exemple de charge :

```json
{
  "id": "AG10KUJCrRk",
  "name": "Malaria Outbreak Threshold Predictor",
  "shortName": "Malaria Outbreak Predictor",
  "description": "Computes the threshold for potential malaria outbreaks based on the mean plus 1.5x the std dev",
  "output": {
    "id": "nXJJZNVAy0Y"
  },
  "generator": {
    "expression": "AVG(#{r6nrJANOqMw})+1.5*STDDEV(#{r6nrJANOqMw})",
    "description": "Maximum normal malaria case count",
    "missingValueStrategy": "NEVER_SKIP",
    "slidingWindow": false
  },
  "periodType": "Monthly",
  "sequentialSampleCount": 4,
  "sequentialSkipCount": 1,
  "annualSampleCount": 3,
  "organisationUnitLevels": [4]
}
```

L'élément de sortie fait référence à l'identifiant de l'élément de données pour lequel des valeurs de données prédites doivent être sauvegardées.
L'élément générateur fait référence à l'expression qui sera utilisée pour calculer les valeurs prédites.

### Expressions du prédicteur { #webapi_predictor_expressions } 

Un prédicteur possède toujours une expression génératrice qui décrit le mode de calcul de la valeur prédite. Le prédicteur peut également avoir une expression permettant de tester la fonction de saut, laquelle expression renvoie une valeur booléenne. Lorsque l'expression de test de saut est présente, elle est évaluée dans chacune des périodes échantillonnées afin de déterminer si les valeurs de cette période doivent être ignorées.

Les variables suivantes peuvent être utilisées dans une expression génératrice ou dans une expression de test de saut :

| Variable    | Objet     | Description |
| ----------- | ---------- | ----------- |
| #{<dataelement-id>} | Élément de données agrégé | Fait référence à la valeur totale d'un élément de données agrégé pour toutes les combinaisons d'options de catégorie. |
| #{<dataelement-id>.<categoryoptcombo-id> | Opérande de l'élément de données | Fait référence à une combinaison entre un élément de données agrégé et une combinaison d'options de catégorie. |
| D{<program-id>.<dataelement-id>} | Élément de données de programme | Fait référence à la valeur d'un élément de données Tracker au sein d'un programme. |
| A{<program-id>.<attribute-id>} | Attribut d'entité suivie d'un programme | Fait référence à la valeur d'un attribut d'entité suivie au sein d'un programme. |
| I{<program-indicator-id>} | Indicateur de programme | Fait référence à la valeur d'un indicateur de programme. |
| R{<dataset-id>.<metric>} | Taux de déclaration | Fait référence à une mesure de taux de déclaration. La mesure peut être REPORTING_RATE (taux de déclaration), REPORTING_RATE_ON_TIME (taux de déclarations à temps), ACTUAL_REPORTS (rapports envoyés), ACTUAL_REPORTS_ON_TIME (rapports envoyés à temps), EXPECTED_REPORTS (rapports attendus). |
| C{<constant-id>} | Constante | Fait référence à une valeur constante. |
| OUG{<orgunitgroup-id>} | Groupe d'unités d'organisation | Fait référence au nombre d'unités d'organisation présentes dans un groupe d'unités d'organisation. |
| [days] | Nombre de jours | Le nombre de jours dans la période actuelle. |

### Génération de valeurs prédites { #webapi_generating_predicted_values } 

Pour exécuter tous les prédicteurs (générer des valeurs prédites), vous pouvez envoyer une requête POST à la ressource d'exécution :

    POST /api/predictors/run

Pour exécuter un seul prédicteur, vous pouvez envoyer une requête POST à la ressource d'exécution et préciser le prédicteur :

    POST /api/predictors/AG10KUJCrRk/run

## Règles de programme { #webapi_program_rules } 

Cette section traite de l'envoi et de la lecture des règles de programme et explique leur modèle de données. Les règles de programme permettent de configurer un fonctionnement dynamique au sein des programmes de DHIS2.

### Modèle de règles de programme { #webapi_program_rule_model } 

Le modèle de données des règles de programme se compose de variables de règles de programme (programRuleVariables), de règles de programme (programRules) et d'actions de règles de programme (programRuleActions). La règle de programme contient une expression - lorsque cette expression est définie sur "true" (vrai), les actions de règle de programme sous cette expression sont déclenchées. Les variables de règle de programme sont utilisées pour traiter les éléments de données, les valeurs de données des entités suivies et d'autres valeurs de données nécessaires à l'exécution des expressions. Toutes les règles d'un programme partagent la même bibliothèque de variables de règles, et une variable peut être utilisée dans les expressions de plusieurs règles.

![](resources/images/program_rules/program-rule-model.jpg)

#### Détails sur le modèle de règles de programme { #program-rule-model-details } 

Le tableau suivant donne un aperçu détaillé du modèle de règle de programme.

Tableau : Règle de programme

| name | description | Obligatoire |
|---|---|---|
| program | Le programme dans lequel la règle est exécutée. | Obligatoire |
| name | Le nom sous lequel la règle de programme sera affichée aux configurateurs de dhis2. Il n'est pas visible pour l'utilisateur final du programme. | Obligatoire |
| description | La fonction de description de la règle de programme peut être utilisée par les configurateurs pour décrire la règle. Cette description n'est pas visible pour l'utilisateur final du programme. | Obligatoire |
| programStage | Si une étape de programme est définie pour une règle de programme, la règle ne sera évaluée qu'à l'intérieur de l'étape de programme spécifiée. | facultatif |
| condition | L'expression dont l'évaluation doit être définie sur "true" pour que la règle de programme déclenche les actions qu'elle contient. L'expression est écrite à l'aide d'opérateurs, d'appels de fonctions, de valeurs codées en dur, de constantes et de variables de règles de programme. `d2:hasValue('hemoglobin') && #{hemoglobin} <= 7 `| Obligatoire |
| priorité | La priorité d'exécution de la règle lorsque l'ordre des règles est important. 
Dans la plupart des cas, les règles ne dépendent pas de leur exécution avant ou après d'autres règles, et dans ces cas, la priorité d'exécution peut être omise. Si aucune priorité n'est définie pour une règle, celle-ci sera exécutée après toutes les règles pour lesquelles une priorité d'exécution a été définie. Si une priorité (integer) est définie, la règle la moins prioritaire sera exécutée avant les règles plus prioritaires. | facultatif |

#### Détails sur le modèle d'actions des règles de programme { #program-rule-action-model-details } 

Le tableau suivant donne un aperçu détaillé du modèle d'actions des règles de programme.

Tableau : Action de règle de programme

| name | description | Obligatoire |
|---|---|---|
| Règle de programme | La règle de programme qui est à l'origine de cette action. | Obligatoire |
| programRule- ActionType (règle de programme - type d'action) | Le type d'action à effectuer.<br> * `DISPLAYTEXT` - Affiche un texte dans un widget.<br> * `DISPLAYKEYVALUEPAIR` - Affiche une paire clé/valeur (comme un indicateur de programme) dans un widget.<br> * `HIDEFIELD` - Cache un élément de données ou un attribut d'entité suivie spécifiés.<br> - *content* (contenu) - s'il est défini, le texte contenu dans *content* sera affiché à l'utilisateur final si une valeur a été saisie dans un champ qui est maintenant sur le point d'être caché (et donc masqué). Si *content* n'est pas défini, un message standard sera affiché à l'utilisateur.<br> - *dataElement* (élément de données) - s'il est défini, l'action HIDEFIELD masquera cet élément de données lorsque la règle sera effective.<br> - *trackedEntityDataValue* (valeur de données de l'entité suivie) - si elle est définie, l'action HIDEFIELD masquera cette trackedEntityDataValue lorsque la règle sera effective.<br> * `HIDESECTION` - Cache une section spécifiée.<br> - *programStageSection* (section d'étape de programme) - doit être défini. Il s'agit de la section d'étape de programme qui sera masquée si la règle mère est effective.<br> * `ASSIGN` - Assigne une valeur à un élément de données (aide l'utilisateur à calculer une valeur ou à remplir une valeur évidente dans un emplacement spécifique)<br> - *content* - s'il est défini, la valeur contenue dans *data* est attribuée à cette variable. Si l'identifiant du contenu est défini, et qu'une variable est donc attribuée pour être utilisée dans d'autres règles, il est important d'attribuer également une *programRule.priority* (priorité de règle de programme) pour s'assurer que la règle avec une action ASSIGN s'exécute avant la règle qui évaluera à son tour la variable attribuée.<br> - *data* - doit être défini. Les données forment une expression qui est évaluée et assignée soit à une variable (#{myVariable}), soit à un élément de données, soit aux deux.<br> - *dataElement* - s'il est défini, la valeur contenue dans *data* est attribuée à cet élément de données.<br> Le contenu ou l'élément de données doit être défini pour que l'action ASSIGN soit effective.<br> * `SHOWWARNING` - Affiche un avertissement à l'utilisateur, sans l'empêcher de terminer l'événement ou l'enregistrement.<br> - *content* - s'il est défini, le contenu devient une partie statique qui sera affichée à la fin du message d'erreur.<br> - *data* - s'il est défini, les données vont former une expression qui sera évaluée et ajoutée à la fin du message d'avertissement.<br> - *dataElement* - s'il est défini, le message d'avertissement sera affiché à côté de cet élément de données.<br> - *trackedEntityAttribute* (attribut d'entité suivie) - s'il est défini, le message d'avertissement va s'afficher à côté de cet attribut d'entité suivie.<br> Il faudra spécifier soit l'élément de données, soit l'attribut de l'entité suivie.<br> * `SHOWERROR` - Affiche une erreur à l'utilisateur, l'empêchant de terminer l'événement ou l'enregistrement.<br> - *content* - s'il est défini, le contenu devient une partie statique qui sera affichée au début du message d'erreur.<br> - *data* - s'il est défini, les données forment une expression qui est évaluée et ajoutée à la fin du message d'erreur.<br> - *dataElement* - s'il est défini, le message d'erreur est relié à cet élément de données.<br> - *trackedEntityAttribute* - s'il est défini, le message d'erreur est relié à cet attribut d'entité suivie.<br> Il faudra spécifier soit l'élément de données, soit l'attribut d'entité suivie.<br> * `WARNINGONCOMPLETE` - Affiche un avertissement à l'utilisateur dans la boîte de dialogue "Complete form" (compléter le formulaire), mais permet à l'utilisateur de terminer l'événement.<br> - *content* - s'il est défini, le contenu devient une partie statique qui sera affichée à la fin du message d'erreur.<br> - *data* - s'il est défini, les données forment une expression qui est évaluée et ajoutée à la fin du message d'avertissement.<br> - *dataElement* - s'il est défini, le message d'avertissement est précédé du nom/nom du formulaire de l'élément de données.<br> * `ERRORONCOMPLETE` - Affiche une erreur à l'utilisateur dans une fenêtre modale lorsque l'utilisateur tente de terminer l'événement. Ceci empêche l'utilisateur de terminer l'événement.<br> - *content* - s'il est défini, le contenu devient une partie statique qui s'affiche au début du message d'erreur.<br> - *data* - s'il est défini, les données forment une expression qui est évaluée et ajoutée à la fin du message d'erreur.<br> - *dataElement* - s'il est défini, le message d'erreur est relié à cet élément de données.<br> * `CREATEEVENT` - Crée un événement dans la même inscription.<br> - *content* <br>- *data* - s'il est défini, il va contenir les valeurs de données à attribuer à l'événement créé. Le format est le suivant : <uid\>:<valeur de données\>. Lorsque plusieurs valeurs sont spécifiées, elles sont séparées par une virgule.<br>AcMrnleqHqc:100,AqK1IHqCkEE:'Polyhydramnios' - *programStage* - doit être défini ; il désigne l'étape de programme pour laquelle la règle doit créer un événement.<br> * `SETMANDATORYFIELD` - Définit un champ comme obligatoire.<br> - *dataElement* - s'il est défini, cet élément de données sera rendu obligatoire dans le formulaire de saisie de données.<br> - *trackedEntityAttribute* - S'il est défini, cet attribut d'entité suivie sera rendu obligatoire dans le formulaire d'enregistrement ou le profil.<br> * `SENDMESSAGE` - Pour envoyer un message à la fin d'un événement ou d'une inscription ou lors de la mise à jour d'une valeur de données.<br> - *messageTemplate* - s'il est défini, ce modèle sera envoyé par SMS ou EMAIL en fonction de la valeur du DeliveryChannel (canal d'envoi) dans le modèle de message.<br> * `SCHEDULEMESSAGE` - Permet de programmer un message à la fin d'un événement/d'une inscription ou lors de la mise à jour des données.<br> - *messageTemplate* - s'il est défini, ce modèle sera envoyé par SMS ou EMAIL en fonction de la valeur du DeliveryChannel dans le modèle de message.<br> - *Date d'envoi du message* - Il s'agit de l'expression qui sera utilisée pour évaluer la date programmée. Cette expression doit générer une date ; tout autre résultat sera rejeté et la notification ne sera pas programmée. | Obligatoire |
| emplacement | Utilisée pour les types d'action DISPLAYKEYVALUEPAIR et DISPLAYTEXT afin de désigner le widget dans lequel le texte ou la paire de valeurs clés seront affichés. Elle est obligatoire pour DISPLAYKEYVALUEPAIR et DISPLAYTEXT. | Voir la description |
| contenu | Utilisée pour les messages de l'utilisateur dans les différentes actions. Consultez l'aperçu des types d'action pour obtenir une explication détaillée de son utilisation dans chacun des types d'action. Elle est obligatoire pour SHOWWARNING, SHOWERROR, WARNINGONCOMPLETE, ERRORONCOMPLETE, DISPLAYTEXT et DISPLAYKEYVALUEPAIR  ; et facultative pour HIDEFIELD et ASSIGN. | Voir la description |
| données | Utilisée pour les expressions dans les différentes actions. Consultez l'aperçu des types d'action pour obtenir une explication détaillée de son utilisation dans chacun des types d'action. Elle est obligatoire pour ASSIGN ; et facultative pour SHOWWARNING, SHOWERROR, WARNINGONCOMPLETE, ERRORONCOMPLETE, DISPLAYTEXT, CREATEEVENT et DISPLAYKEYVALUEPAIR. | Voir la description |
| dataElement | Utilisée pour relier les actions des règles aux éléments de données. Consultez l'aperçu des types d'action pour obtenir une explication détaillée de son utilisation dans chacun des types d'action. Elle est facultative pour SHOWWARNING, SHOWERROR, WARNINGONCOMPLETE, ERRORONCOMPLETE, ASSIGN et HIDEFIELD. | Voir la description |
| Entité suivie - Attribut | Utilisée pour relier les actions des règles aux attributs d'entités suivies. Consultez l'aperçu des types d'action pour obtenir une explication détaillée de son utilisation dans chacun des types d'action. Elle est facultative pour SHOWWARNING, SHOWERROR et HIDEFIELD. | Voir la description |
| option | Utilisée pour relier les actions des règles aux options. Consultez l'aperçu des types d'action pour obtenir une explication détaillée de leur utilisation dans chacun des types d'action. Elle est facultative pour HIDEOPTION | Voir la description |
| optionGroup (groupes d'options) | Utilisée pour relier les actions des règles aux groupes d'options. Consultez l'aperçu des type d'action pour obtenir une explication détaillée de son utilisation dans chacun des types d'action. Elle est obligatoire pour SHOWOPTIONGROUP, HIDEOPTIONGROUP. | Voir la description |
| programStage | Utilisée uniquement pour les actions de la règle CREATEEVENT. Elle est obligatoire pour CREATEEEVENT. | Voir la description |
| programStage- Section (étape de programme - section) | Utilisée uniquement pour les actions de la règle HIDESECTION. Elle est obligatoire pour HIDESECTION | Voir la description |

##### Validation des actions des règles de programme { #programruleaction-validation } 
Certaines validations ont été ajoutées au modèle des actions des règles de programme dans la version 2.37. L'objectif principal était d'empêcher l'utilisateur de créer des règles de programme erronées afin de maintenir la cohérence de la base de données. Ces validations dépendent du type d'action de la règle de programme. Chaque type d'action a sa propre validation. 

Tableau : Validations des actions des règles de programme

| name | contrôle de validation de l'existence de l'identifiant |
|---|---|
|SENDMESSAGE| Identifiant du modèle de notification |
|SCHEDULEMESSAGE| Identifiant du modèle de notification |
|HIDESECTION| Identifiant de la section de l'étape de programme |
|HIDEPROGRAMSTAGE| Identifiant de l'étape de programme |
|HIDEFIELD| Élément de données ou Attribut d'entité suivie |
|HIDEOPTION| Identifiant de l'option |
|HIDEOPTIONGROUP| Identifiant du groupe d'options |
|SHOWOPTIONGROUP| Identifiant du groupe d'options |
|SETMANDATORYFIELD| Élément de données ou Attribut d'entité suivie |
|SHOWERROR| Toujours valide |
|SHOWWARNING| Toujours valide |
|DISPLAYTEXT| Élément de données ou Attribut d'entité suivie |
|DISPLAYKEYVALUEPAIR||
|ASSIGN| Élément de données ou Attribut d'entité suivie |
|WARNINGONCOMPLETE| Élément de données ou Attribut d'entité suivie |
|ERRORONCOMPLETE| Élément de données ou Attribut d'entité suivie |

En plus des validations ci-dessus, le champ `données` dans l'action de la règle de programme qui contient normalement une expression peut également être évalué en utilisant le point d'extrémité de l'api ci-dessous.

    POST /api/programRuleActions/data/expression/description?programId=<uid>


```json
{
  "condition": "1 + 1"
}
```

#### Détails sur le modèle de variables des règles de programme { #program-rule-variable-model-details } 

Le tableau suivant donne un aperçu détaillé du modèle de variables des règles de programme.

Tableau : Variable de règles de programme

| name | description | Obligatoire |
|---|---|---|
| name | le nom de la variable de la règle de programme - ce nom est utilisé dans les expressions. #{myVariable} \> 5 | Obligatoire |
| sourceType (type de source) | Définit comment cette variable est renseignée avec les données de l'inscription et des événements.<br> * DATAELEMENT_NEWEST_EVENT_PROGRAM_STAGE - Dans la saisie Tracker, cette variable obtient la valeur la plus récente qui existe pour un élément de données, dans les événements d'une étape de programme donnée dans l'inscription actuelle. Dans la saisie Evénement, elle obtient la valeur la plus récente parmi les 10 événements les plus récents de l'unité d'organisation.<br> * DATAELEMENT_NEWEST_EVENT_PROGRAM - Dans la saisie Tracker, cette variable obtient la valeur la plus récente d'un élément de données pour toute l'inscription. Dans la saisie Evénement, elle obtient la valeur la plus récente parmi les 10 événements les plus récents de l'unité d'organisation.<br> * DATAELEMENT_CURRENT_EVENT - Obtient la valeur de l'élément de données en question dans l'événement en cours uniquement.<br> * DATAELEMENT_PREVIOUS_EVENT - Dans la saisie Tracker, cette variable obtient la valeur la plus récente parmi les événements du programme qui précède l'événement en cours. Dans la saisie Evénement, elle obtient la valeur la plus récente parmi les 10 événements précédents enregistrés dans l'unité d'organisation.<br> * CALCULATED_VALUE - Utilisée pour réserver un nom de variable qui sera attribué par une action de règle de programme ASSIGN.<br> * TEI_ATTRIBUTE - Obtient la valeur d'un attribut d'entité suivie spécifique. | Obligatoire |
| Type de valeur | Le paramètre valueType (type de valeur) définit le type de valeur que cette variable de règle de programme peut contenir. Sa valeur dépend du paramètre sourceType (type de la source). Si la source est un élément de données ou un attribut d'entité suivie <br>, le type de valeur sera dérivé du type de valeur de la source. Lorsque le type de la source est CALCULATED_VALUE, alors le type de valeur doit être fourni par l'utilisateur, sinon il sera par défaut <br>ValueType.TEXT.| Obligatoire
| dataElement | Utilisé pour relier la variable de la règle de programme à un élément de données. Il est obligatoire pour tous les types de sources commençant par DATAELEMENT_. | Voir la description |
| Entité suivie - Attribut | Utilisé pour relier la variable de la règle de programme à un attribut d'entité suivie. Il est obligatoire pour le type de source TEI_ATTRIBUTE. | Voir la description |
| useCodeFor- OptionSet (utiliser le code pour - Ensemble d'options) | Si ce paramètre est coché, la variable sera remplie avec le code - et non le nom - de tout ensemble d'options qui lui relié. Par défaut, le paramètre n'est pas coché, ce qui signifie que c'est le nom de l'option qui est utilisé. ||
| programStage | Utilisé pour spécifier une étape de programme précise à partir de laquelle la valeur de la variable de la règle de programme doit être récupérée. Il est obligatoire pour DATAELEMENT_NEWEST_EVENT_PROGRAM_STAGE. | Voir la description |

### Création de règles de programme { #webapi_creating_program_rules } 

- Pour effectuer des opérations CRUD, vous pouvez utiliser la ressource `programRules`, disponible dans l'API.

Pour récupérer la liste des règles de programmes, vous pouvez effectuer une requête GET comme suit :

    /api/programRules

Pour récupérer une seule règle de programme, vous pouvez effectuer une requête GET comme suit :

    /api/programRules/<program_rule_uid>

Pour sauvegarder ou ajouter une seule règle de programme, vous pouvez effectuer une requête POST comme suit :

    /api/programRules/<program_rule_uid>

Pour mettre à jour une seule règle de programme, vous pouvez effectuer une requête PUT comme suit :

    /api/programRules/<program_rule_uid>

Pour supprimer une seule règle de programme, vous pouvez effectuer une requête DELETE comme suit :

    /api/programRules/<program_rule_uid>

Pour récupérer la description de la condition de la règle de programme, vous pouvez effectuer une requête POST en fournissant la chaîne de la condition dans le corps de la requête.

    /api/programRules/condition/description?<program_rule_uid>

## Formulaires { #webapi_forms } 

Pour récupérer des informations sur un formulaire (qui correspond à un ensemble de données et à ses sections), vous pouvez interagir avec la ressource `form`. La réponse du formulaire est accessible en XML et JSON et fournira des informations sur chaque section (groupe) du formulaire ainsi que sur chaque champ de ces sections, y compris les étiquettes et les identifiants. En fournissant des identifiants de période et d'unité d'organisation, la réponse du formulaire sera constituée de valeurs de données.

Tableau : Paramètres de requête du formulaire

| Paramètre | Option | Description |
|---|---|---|
| pe | Période ISO | Période pour laquelle les valeurs de données du formulaire doivent être renseignées. |
| ou | UID | Unité d'organisation pour laquelle les valeurs de données du formulaire doivent être renseignées. |
| Métadonnées | faux | vrai | Détermine s'il faut inclure ou non des métadonnées sur chaque élément de données des sections du formulaire. |

Pour récupérer le formulaire d'un ensemble de données, vous pouvez effectuer une requête GET comme suit :

    /api/dataSets/<dataset-id>/form.json

Pour récupérer le formulaire pour l'ensemble de données ayant l'identifiant "BfMAe6Itzgt" au format XML :

    /api/dataSets/BfMAe6Itzgt/form

Pour récupérer le formulaire en incluant les métadonnées, au format JSON :

    /api/dataSets/BfMAe6Itzgt/form.json?metaData=true

Pour récupérer le formulaire rempli avec les valeurs de données d'une période et d'une unité d'organisation spécifiques au format XML :

    /api/dataSets/BfMAe6Itzgt/form.xml?ou=DiszpKrYNg8&pe=201401

Cette ressource permet également de créer des formulaires de saisie de données personnalisés, directement pour un ensemble de données. Cela peut se faire à l'aide d'une requête POST ou PUT avec un contenu de type text/html où la charge est le balisage du formulaire personnalisé. En voici l'illustration :

```bash
curl -d @form.html "localhost/api/dataSets/BfMAe6Itzgt/form"
  -H "Content-Type:text/html" -u admin:district -X PUT
```

## Documents { #webapi_documents } 

Les références aux fichiers peuvent être stockées avec la ressource "document".



Tableau : Champs du document

| Nom du champ | Description |
|---|---|
| name | nom unique du document |
| externe | drapeau identifiant l'emplacement du document. TRUE pour les fichiers externes, FALSE pour les fichiers internes. |
| url | l'emplacement du fichier. URL pour les fichiers externes. Identifiant de la ressource "fichier" pour les fichiers internes (voir [Ressources fichier](#webapi_file_resources)) |

Une requête GET au point d'extrémité des documents renverra tous les documents :

    /api/documents

Une requête POST au point d'extrémité des documents créera un nouveau document :

```bash
curl -X POST -d @document.json -H "Content-type: application/json"
  "http://dhis.domain/api/documents"
```

```json
{
  "name": "dhis home",
  "external": true,
  "url": "https://www.dhis2.org"
}
```

Une requête GET à laquelle est ajouté l'identifiant d'un document renverra des informations sur ce document. Une requête PUT au même point d'extrémité mettra à jour les champs du document :

    /api/documents/<documentId>

Ajouter */data* à la requête GET renverra le contenu réel du document :

    /api/documents/<documentId>/data

## Importation de métadonnées en CSV { #webapi_csv_metadata_import } 

DHIS2 prend en charge l'importation de métadonnées au format CSV, telles que les éléments de données, les unités d'organisation et les règles de validation. Les propriétés des différents objets de métadonnées sont identifiées en fonction de l'ordre ou de l'index des colonnes (voir ci-dessous pour plus de détails). Vous pouvez omettre les propriétés d'objets ou les colonnes non nécessaires, mais puisque l'ordre des colonnes est important, une colonne vide doit être incluse. En d'autres termes, si vous voulez spécifier des propriétés ou des colonnes qui apparaissent tard dans l'ordre des colonnes, mais ne pas spécifier certaines colonnes qui apparaissent tôt dans l'ordre, vous pouvez inclure des colonnes vides pour elles.

La première ligne du fichier CSV est considérée comme un en-tête et est ignorée lors de l'importation. Le caractère _virgule_ doit être utilisé comme séparateur de texte. Le texte qui contient des virgules doit être placé entre _guillemets_.

Pour télécharger des métadonnées au format CSV, vous pouvez envoyer une requête POST au point d'extrémité des métadonnées :

    POST /api/metadata?classKey=CLASS-KEY

Les types d'objets suivants sont pris en charge. Le paramètre de requête `classKey` (clé class) est obligatoire et se trouve à côté de chaque type d'objet dans le tableau ci-dessous.

Tableau : Types d'objets et clés

| Type d'objet | Clé class |
|---|---|
| Éléments de données | DATA_ELEMENT |
| Groupes d'éléments de données | DATA_ELEMENT_GROUP |
| Options de catégorie | CATEGORY_OPTION |
| Groupes d'options de catégorie | CATEGORY_OPTION_GROUP |
| Unités d’organisation | ORGANISATION_UNIT |
| Groupes d'unités d'organisation | ORGANISATION_UNIT_GROUP |
| Règles de validation | VALIDATION_RULE |
| Ensembles d'options | OPTION_SET |
| Traductions | TRANSLATION |

> **Astuce**
>
> Si vous utilisez *curl*, l'option `--data-binary` doit être utilisée car elle préserve les sauts de ligne et les nouvelles lignes, ce qui est essentiel pour les données CSV.

Par exemple, pour télécharger un fichier d'éléments de données au format CSV avec `curl`, vous pouvez utiliser la commande suivante :

```bash
curl --data-binary @data_elements.csv "http://localhost/api/metadata?classKey=DATA_ELEMENT"
  -H "Content-Type:application/csv" -u admin:district
```

Les formats des types d'objets actuellement pris en charge pour l'importation en CSV sont répertoriés dans les sections suivantes.

### Eléments de données { #webapi_csv_data_elements } 

Tableau : Format CSV des éléments de données

| Index | Colonne | Obligatoire | Valeur (par défaut en premier) | Description |
|---|---|---|---|---|
| 1 | Nom | Oui || Nom. Maximum 230 caractères. Unique. |
| 2 | UID | Non | UID | Identifiant stable. Exactement 11 caractères alphanumériques, commençant par une lettre. Il est généré par le système s'il n'est pas spécifié. |
| 3 | Code | Non || Code stable. Maximum 50 caractères. |
| 4 | Nom court | Non | 50 premiers caractères du nom | S'il n'est pas spécifié, il est remplacé par les 50 premiers caractères du nom. Maximum 50 caractères. Unique. |
| 5 | Description | Non || Description en texte libre. |
| 6 | Nom du formulaire | Non || Maximum 230 caractères. |
| 7 | Type de domaine | Non | AGRÉGÉ | TRACKER | Type de domaine pour l'élément de données ; il peut s'agir du domaine Agrégé ou du Tracker. Maximum 16 caractères. |
| 8 | Type de valeur | Non | ENTIER | NOMBRE | UNITÉ_INTERVALLE | POURCENTAGE | ENTIER_POSITIF | ENTIER_NÉGATIF | ENTIER_ZÉRO_OU_POSITIF | FICHIER_RESSOURCE | COORDONNÉE | TEXTE | TEXTE_ LONG | LETTRE | NUMÉRO_DE TÉLÉPHONE | EMAIL | BOOLÉEN | VRAI_UNIQUEMENT | DATE | DATE ET HEURE | Type de valeur. Maximum 16 caractères. |
| 9 | Type d'agrégation | Non | SOMME | MOYENNE | MOYENNE_DE LA SOMME_DES UNITÉS_D'ORGANISATION | NOMBRE | ÉCART-TYPE | VARIANCE | MIN | MAX | AUCUN | Type d'agrégation indiquant comment agréger les données dans les différentes dimensions. Maximum 16 caractères. |
| 10 | Combinaison de catégories | Non | UID | UID de la combinaison de catégories. La combinaison de catégories par défaut sera utilisée si aucune n'est spécifiée. |
| 11 | Url | Non || URL de la ressource de l'élément de données. Maximum 255 caractères. |
| 12 | Le zéro est significatif | Non | faux | vrai | Indique si les valeurs nulles (zéro) seront stockées pour cet élément de données. |
| 13 | Ensemble d'options | Non | UID | UID de l'ensemble d'options à utiliser pour les données. |
| 14 | Ensemble d'options pour les commentaires | Non | UID | UID de l'ensemble d'options à utiliser pour les commentaires. |

Vous trouverez ci-dessous un exemple de fichier CSV pour les éléments de données. La première ligne sera toujours ignorée. Vous pouvez ignorer des colonnes et compter sur les valeurs par défaut utilisées par le système. Vous pouvez également ignorer les colonnes que vous n'utilisez pas

```csv
name,uid,code,shortname,description
"Women participated skill development training",,"D0001","Women participated in training"
"Women participated community organizations",,"D0002","Women participated in organizations"
```

### Les unités d’organisation { #webapi_csv_org_units } 

Tableau : Format CSV de l'unité d'organisation

| Index | Colonne | Obligatoire | Valeur (par défaut en premier) | Description |
|---|---|---|---|---|
| 1 | Nom | Oui || Nom. Maximum 230 caractères. Unique. |
| 2 | UID | Non | UID | Identifiant stable. Maximum 11 caractères. Il est généré par le système si aucun n'est spécifié. |
| 3 | Code | Non || Code stable. Maximum 50 caractères. |
| 4 | Parent | Non | UID | UID de l'unité d'organisation mère. |
| 5 | Nom court | Non | 50 premiers caractères du nom | S'il n'est pas spécifié, il est remplacé par les 50 premiers caractères du nom. Maximum 50 caractères. Unique. |
| 6 | Description ; | Non || Description en texte libre. |
| 7 | Date d'ouverture | Non | 1970-01-01 | Date d'ouverture de l'unité d'organisation au format AAAA-MM-JJ. |
| 8 | Date de fermeture | Non || Date de fermeture de l'unité d'organisation au format AAAA-MM-JJ, ignorer si l'unité est actuellement ouverte. |
| 9 | Commentaire | Non || Commentaire en texte libre pour l'unité d'organisation. |
| 10 | Type d'élément | Non | AUCUN | MULTI_POLYGONE | POLYGONE | POINT | SYMBOLE | Type d'élément géospatial. |
| 11 | Coordonnées | Non || Coordonnées utilisées pour l'analyse géospatiale au format Geo JSON. |
| 12 | URL | Non || URL de la ressource de l'unité d'organisation. Maximum 255 caractères. |
| 13 | Personne de contact | Non || Personne de contact pour l'unité d'organisation. Maximum 255 caractères. |
| 14 | Addresse | Non || Adresse de l'unité d'organisation. Maximum 255 caractères. |
| 15 | Adresses électronique | Non || Courriel de l'unité d'organisation. Maximum 150 caractères. |
| 16 | Numéro de téléphone | Non || Numéro de téléphone de l'unité d'organisation. Maximum 150 caractères. |

Voici un exemple d'importation d'unités d'organisation avec une unité mère, en utilisant des informations minimales :

```csv
name,uid,code,parent
"West province",,"WESTP","ImspTQPwCqd"
"East province",,"EASTP","ImspTQPwCqd"
```

### Règles de validation { #webapi_csv_validation_rules } 

Tableau : Format CSV de la règle de validation

| Index | Colonne | Obligatoire | Valeur (par défaut en premier) | Description |
|---|---|---|---|---|
| 1 | Nom | Oui || Nom. Maximum 230 caractères. Unique. |
| 2 | UID | Non | UID | Identifiant stable. Maximum 11 caractères. Il est généré par le système si aucun n'est spécifié. |
| 3 | Code | Non || Code stable. Maximum 50 caractères |
| 4 | Description | Non || Description en texte libre. |
| 5 | Instruction | Non || Instruction en texte libre. |
| 6 | Importance | Non | MOYENNE | ÉLEVÉE | FAIBLE | Importance de la règle de validation. |
| 7 | Type de règle (ignoré) | Non | VALIDATION | SURVEILLANCE | Type de règle de validation. |
| 8 | Opérateur | Non | égal_à | non_égal_à | supérieur_à | supérieur_ou_égal_à_ | inférieur_à | inférieur_ou_égal_à_ | paire_obligatoire | paire_exclusive | Opérateur d'expression. |
| 9 | Type de période | Non | Mensuel | Quotidien | Hebdomadaire | Trimestriel | Semestriel | Annuel | Type de période |
| 10 | Expression du côté gauche | Oui || Formule mathématique basée sur les UID des éléments de données et des combinaisons d'options. |
| 11 | Description de l'expression du côté gauche | Oui || Texte libre |
| 12 | Stratégie de valeur manquante du côté gauche | Non | IGNORER_SI_UNE_VALEUR_EST MANQUANTE | IGNORER_SI_TOUTES_LES VALEURS_SONT MANQUANTES | NE JAMAIS_IGNORER  | Fonctionnement en cas de valeurs manquantes dans l'expression de gauche. |
| 13 | Expression du côté droit | Oui || Formule mathématique basée sur les UID des éléments de données et des combinaisons d'options. |
| 14 | Description de l'expression du côté droit | Oui || Texte libre |
| 15 | Stratégie de valeur manquante du côté droit | Non | IGNORER_SI_UNE_VALEUR_EST MANQUANTE | IGNORER_SI_TOUTES_LES VALEURS_SONT MANQUANTES | NE JAMAIS_IGNORER  | Fonctionnement en cas de valeurs manquantes dans l'expression de droite. |

### Ensembles d'options { #webapi_csv_option_sets } 

Tableau : Format CSV de l'ensemble d'options

| Index | Colonne | Obligatoire | Valeur (par défaut en premier) | Description |
|---|---|---|---|---|
| 1 | Nom de l'ensemble d'options | Oui || Nom. Maximum 230 caractères. Unique. Doit être répété pour chaque option. |
| 2 | UID de l'ensemble d'options | Non | UID | Identifiant stable. Maximum 11 caractères. Il est généré par le système si aucun n'est spécifié. Il doit être répété pour chaque option. |
| 3 | Code de l'ensemble d'options | Non || Code stable. Maximum 50 caractères. Il doit être répété pour chaque option. |
| 4 | Nom de l'option | Oui || Nom de l'option. Maximum 230 caractères. |
| 5 | UID de l'option | Non | UID | Identifiant stable. Maximum 11 caractères. Il est généré par le système si aucun n'est spécifié. |
| 6 | Code de l'option | Oui || Code stable. Maximum 50 caractères. |

Le format des ensembles d'options est particulier. Les trois premières valeurs représentent un ensemble d'options. Les trois dernières valeurs représentent une option. Les trois premières valeurs représentant l'ensemble d'options doivent être répétées pour chaque option.

```csv
optionsetname,optionsetuid,optionsetcode,optionname,optionuid,optioncode
"Color",,"COLOR","Blue",,"BLUE"
"Color",,"COLOR","Green",,"GREEN"
"Color",,"COLOR","Yellow",,"YELLOW"
"Sex",,,"Male",,"MALE"
"Sex",,,"Female",,"FEMALE"
"Sex",,,"Unknown",,"UNKNOWN"
"Result",,,"High",,"HIGH"
"Result",,,"Medium",,"MEDIUM"
"Result",,,"Low",,"LOW"
"Impact","cJ82jd8sd32","IMPACT","Great",,"GREAT"
"Impact","cJ82jd8sd32","IMPACT","Medium",,"MEDIUM"
"Impact","cJ82jd8sd32","IMPACT","Poor",,"POOR"
```

### Groupe d'options { #option-group } 

Tableau : Format CSV du groupe d'options

| Index | Colonne | Obligatoire | Valeur (par défaut en premier) | Description |
|---|---|---|---|---|
| 1 | Nom du groupe d'options | Oui || Nom. Maximum 230 caractères. Unique. Doit être répété pour chaque option. |
| 2 | Uid du groupe d'options | Non || Identifiant stable. Maximum 11 caractères. Il est généré par le système si aucun n'est spécifié. Il doit être répété pour chaque option. |
| 3 | Code du groupe d'options | Non || Code stable. Maximum 50 caractères. Il doit être répété pour chaque option. |
| 4 | Nom court du groupe d'options | Oui || Nom court. Maximum 50 caractères. Unique. Doit être répété pour chaque option. |
| 5 | Uid de l'ensemble d'options | Oui || Identifiant stable. Maximum 11 caractères. Doit être répété pour chaque option. |
| 6 | Uid de l'option | Non || Identifiant stable. Maximum 11 caractères. |
| 7 | Code de l'option | Non || Code stable. Maximum 50 caractères. |

Exemple de charge CSV d'un groupe d'options

```csv
optionGroupName,optionGroupUid,optionGroupCode,optionGroupShortName,optionSetUid,optionUid,optionCode
optionGroupA,,,groupA,xmRubJIhmaK,,OptionA
optionGroupA,,,groupA,xmRubJIhmaK,,OptionB
optionGroupB,,,groupB,QYDAByFgTr1,,OptionC
```
### Ensemble de groupes d'options { #option-group-set } 



Tableau : Format CSV de l'ensemble de groupes d'options

| Index | Colonne | Obligatoire | Valeur (par défaut en premier) | Description |
|---|---|---|---|---|
| 1 | Nom de l'ensemble de groupes d'options | Oui || Nom. Maximum 230 caractères. Unique. Doit être répété pour chaque option. |
| 2 | Uid de l'ensemble de groupes d'options | Non || Identifiant stable. Maximum 11 caractères. Il est généré par le système si aucun n'est spécifié. Il doit être répété pour chaque option. |
| 3 | Code de l'ensemble de groupes d'options | Non || Code stable. Maximum 50 caractères. Il doit être répété pour chaque option. |
| 4 | Description de l'ensemble de groupes d'options | Non || Description. Doit être répétée pour chaque option. |
| 5 | Dimension de données | Non || VRAI, FAUX |
| 6 | Uid de l'ensemble d'options | Non || UID de l'ensemble d'options. Identifiant stable. Maximum 11 caractères. |

Exemple de charge CSV d'un ensemble de groupes d'options

```csv
name,uid,code,description,datadimension,optionsetuid
optiongroupsetA,,,,,xmRubJIhmaK
optiongroupsetB,,,,false,QYDAByFgTr1
```
Pour ajouter des groupes d'options à un ensemble de groupes d'options importé, suivez les mêmes étapes que pour l'importation de l'appartenance à une collection.

### Indicateurs { #webapi_csv_indicators } 

Tableau : Format CSV de l'indicateur

| Index | Colonne | Obligatoire | Valeur (par défaut en premier) | Description |
|---|---|---|---|---|
| 1 | Nom | Oui || Nom. Maximum 230 caractères. Unique. |
| 2 | UID | Non | UID | Identifiant stable. Exactement 11 caractères alphanumériques, commençant par une lettre. Il est généré par le système s'il n'est pas spécifié. |
| 3 | Code | Non || Code stable. Maximum 50 caractères. |
| 4 | Nom court | Oui | 50 premiers caractères du nom | S'il n'est pas spécifié, il est remplacé par les 50 premiers caractères du nom. Maximum 50 caractères. Unique. |
| 5 | dénominateur | Oui || Expression de l'indicateur. |
| 6 | Description du dénominateur | Non || Maximum 230 caractères. |
| 5 | numérateur | Oui || Expression de l'indicateur. |
| 6 | Description du numérateur | Non || Maximum 230 caractères. |
| 6 | annualisé | Oui ||  VRAI, FAUX |
| 6 | décimales | Non || Nombre de décimales à utiliser pour la valeur de l'indicateur. Si ce paramètre est "null", la valeur par défaut sera utilisée.
| 6 | Type d'indicateur | Oui || UID | UID du type d'indicateur.

Vous trouverez ci-dessous un exemple de fichier CSV pour les indicateurs. La première ligne sera toujours ignorée. Vous pouvez ignorer des colonnes et compter sur les valeurs par défaut utilisées par le système. Vous pouvez également ignorer les colonnes que vous n'utilisez pas

```csv
Name,UID,Code,Description,shortName,denominator,denominatorDescription,numerator,numeratorDescription,annualized,decimals,indicatorType
Indicator A,yiAKjiZVoOU,CodeA,Indicator A description,Indicator A shortname,#{fbfJHSPpUQD},denominatorDescription,#{h0xKKjijTdI},numeratorDescription,false,2,sqGRzCziswD
Indicator B,Uvn6LCg7dVU,CodeB,Indicator B description,Indicator B shortname,#{fbfJHSPpUQD},denominatorDescription,#{h0xKKjijTdI},numeratorDescription,false,2,sqGRzCziswD
```

### Appartenance à une collection { #collection-membership } 

Outre l'importation d'objets, vous pouvez également choisir de n'importer que la relation groupe-membre entre un objet et un groupe. Actuellement, les paires de groupes et d'objets suivantes sont prises en charge

  - Groupe d'unités d'organisation - Unité d'organisation

  - Groupe d'éléments de données - Élément de données

  - Groupe d'indicateurs - Indicateur

  - Ensemble de groupes d'options - Groupe d'options

Le format CSV pour ces importations est le même



Tableau : Format CSV des membres d'une collection

| Index | Colonne | Obligatoire | Valeur (par défaut en premier) | Description |
|---|---|---|---|---|
| 1 | UID | Oui | UID | L'UID de la collection à laquelle ajouter un objet |
| 2 | UID | Oui | UID | L'UID de l'objet à ajouter à la collection |

### Groupe d'options de catégorie { #category-option-group } 

| Index | Colonne | Obligatoire | Valeur (par défaut en premier) | Description |
|---|---|---|---|---|
| 1 | Nom | Oui || Nom. Maximum 230 caractères. Unique. |
| 2 | UID | Non | UID | Identifiant stable. Maximum 11 caractères. Il est généré par le système si aucun n'est spécifié. |
| 3 | Code | Non || Code stable. Maximum 50 caractères. |
| 4 | Nom court | Non || Nom court. 50 caractères maximum. |
| 5 | Type de dimension des données | Oui || Type de dimension des données. Il peut être une DÉSAGRÉGATION ou un ATTRIBUT |

### Autres objets { #webapi_csv_other_objects } 

Tableau : Groupe d'éléments de données, option de catégorie, groupe d'unités d'organisation, Format CSV

| Index | Colonne | Obligatoire | Valeur (par défaut en premier) | Description |
|---|---|---|---|---|
| 1 | Nom | Oui || Nom. Maximum 230 caractères. Unique. |
| 2 | UID | Non | UID | Identifiant stable. Maximum 11 caractères. Il est généré par le système si aucun n'est spécifié. |
| 3 | Code | Non || Code stable. Maximum 50 caractères. |
| 4 | Nom court | Non || Nom court. 50 caractères maximum. |

Voici un exemple d'options de catégorie :

```csv
name,uid,code,shortname
"Male",,"MALE"
"Female",,"FEMALE"
```

## Objets supprimés { #webapi_deleted_objects } 

La ressource des objets supprimés fournit un journal des objets de métadonnées qui ont été supprimés.

    /api/deletedObjects

Chaque fois qu'un objet de métadonnées est supprimé, un journal est conservé avec l'identifiant, le code, le type et l'heure de la suppression. Cette API est disponible à l'adresse `/api/deletedObjects`. Le filtrage des champs et des objets fonctionne de la même manière que pour les autres ressources de métadonnées.

Obtenir des objets supprimés de type éléments de données :

    GET /api/deletedObjects.json?klass=DataElement

Obtenir un objet de type indicateur qui a été supprimé dans la période de 2015 et plus :

    GET /api/deletedObjects.json?klass=Indicator&deletedAt=2015-01-01

## Favoris { #webapi_favorites } 

Certains types d'objets de métadonnées peuvent être marqués comme favoris pour l'utilisateur actuellement connecté. Cela s'applique actuellement aux tableaux de bord.

    /api/dashboards/<uid>/favorite

Pour faire d'un tableau de bord un favori, vous pouvez envoyer une requête *POST* (aucun type de contenu n'est requis) à une URL comme suit :

    /api/dashboards/iMnYyBfSxmM/favorite

Pour supprimer un tableau de bord en tant que favori, vous pouvez effectuer une requête *DELETE* en utilisant l'URL ci-dessus.

Le statut de favori apparaîtra comme un champ booléen *favori* sur l'objet (par exemple, le tableau de bord) dans la réponse de métadonnées.

## Abonnements { #webapi_subscription } 

Un utilisateur connecté peut s'abonner à certains types d'objets. Actuellement, les objets auxquels il est possible de s'abonner sont ceux de type EventChart (graphique d'événement), EventReport (rapport d'événement), Map (carte), Visualization (visualisation) et EventVisualization (visualisation d'événement).

> **Note**
>
> Les objets EventChart et EventReport sont obsolètes. Utilisez plutôt EventVisualization.

Pour connaître les abonnés d'un objet (obtenir un tableau contenant leurs identifiants d'utilisateurs), vous pouvez effectuer une requête *GET* comme suit :

    /api/<object-type>/<object-id>/subscribers

Voir l'exemple suivant :

    /api/visualizations/DkPKc1EUmC2/subscribers

Pour vérifier si l'utilisateur actuel est abonné à un objet (obtenir une valeur booléenne), vous pouvez effectuer un appel *GET* :

    /api/<object-type>/<object-id>/subscribed

Voir l'exemple suivant :

    /api/visualizations/DkPKc1EUmC2/subscribed

Pour s'abonner ou se désabonner d'un objet, effectuez une requête *POST/DELETE* (aucun type de contenu n'est requis) :

    /api/<object-type>/<object-id>/subscriber

## Ressources de fichiers { #webapi_file_resources } 

Les *Ressources de fichiers* sont des objets utilisés pour représenter et stocker du contenu binaire. L'objet *FileResource* (ressource de fichier) contient les métadonnées du fichier (nom, type de contenu, taille, etc.) ainsi qu'une clé permettant d'extraire le contenu à partir d'un magasin de fichiers externe à la base de données. L'objet *FileResource* est stocké dans la base de données comme n'importe quel autre objet, mais le contenu (fichier) est stocké ailleurs et peut être récupéré à l'aide de la référence du contenu *(storageKey)* ou clé de stockage.

    /api/fileResources

Le contenu des ressources de fichiers n'est pas directement accessible, mais il est référencé à partir d'autres objets (tels que les valeurs de données) pour stocker des données binaires d'une taille pratiquement illimitée.

Pour créer une ressource de fichier qui ne nécessite pas de valeur de données correspondante, envoyez une requête POST au point d'extrémité `/api/fileResources` avec un téléchargement en plusieurs parties :

```bash
curl "https://server/api/fileResources" -X POST
  -F "file=@/path/to/file/name-of-file.png"
```
L'`uid` d'une ressource de fichier peut être fourni lors de sa création, par exemple :
```bash
curl "https://server/api/fileResources?uid=0123456789x" -X POST
  -F "file=@/path/to/file/name-of-file.png"
```

Pour créer à la fois une ressource de fichier et une valeur de données qui fait référence au fichier, envoyez une requête POST au point d'extrémité `/api/dataValues/file` avec DHIS version 2.36 ou une version plus récente :

```bash
curl "https://server/api/dataValues/file?de=xPTAT98T2Jd
  &pe=201301&ou=DiszpKrYNg8&co=Prlt0C1RF0s" -X POST
  -F "file=@/path/to/file/name-of-file.png"
```

Pour le point d'extrémité `api/fileResources`, le seul paramètre de formulaire requis est *file*, qui correspond au fichier à télécharger. Pour le point d'extrémité `api/dataValues/file`, les paramètres requis sont les mêmes que pour une requête POST à `api/dataValues`, avec l'ajout de *file*.

Le nom de fichier et le type de contenu doivent également être inclus dans la requête, mais ils seront remplacés par des valeurs par défaut s'ils ne sont pas fournis.

Lorsque la création d'une ressource fichier est réussie, les données renvoyées contiennent un champ `response` qui contient à son tour `fileResource` comme suit :

```json
{
  "httpStatus": "Accepted",
  "httpStatusCode": 202,
  "status": "OK",
  "response": {
    "responseType": "FileResource",
    "fileResource": {
      "name": "name-of-file.png",
      "created": "2015-10-16T16:34:20.654+0000",
      "lastUpdated": "2015-10-16T16:34:20.667+0000",
      "externalAccess": false,
      "publicAccess": "--------",
      "user": { ... },
      "displayName": "name-of-file.png",
      "contentType": "image/png",
      "contentLength": 512571,
      "contentMd5": "4e1fc1c3f999e5aa3228d531e4adde58",
      "storageStatus": "PENDING",
      "id": "xm4JwRwke0i"
    }
  }
}
```

Notez la réponse *202 Accepted*, qui indique que la ressource renvoyée a été soumise à un traitement en arrière-plan (persistance vers le magasin de fichiers externe dans ce cas). Notez également le champ `storageStatus` qui indique si le contenu a été stocké ou non. À ce stade, la persistance vers le magasin externe n'est pas encore terminée (elle est probablement en train d'être téléchargée vers un magasin basé sur le cloud) comme le montre le statut `PENDING`.

Même si le contenu n'a pas encore été entièrement stocké, la ressource de fichier peut maintenant être utilisée, par exemple comme contenu référencé dans une valeur de données (voir [Travailler avec des valeurs de données de fichier](#datavalue_file)). Si nous avons besoin de vérifier le *storageStatus* mis à jour ou de récupérer les métadonnées du fichier, une requête peut être envoyée au point d'extrémité `fileResources`.

```bash
curl "https://server/api/fileResources/xm4JwRwke0i" -H "Accept: application/json"
```

Cette requête renverra l'objet `FileResource` comme le montre la réponse de l'exemple ci-dessus.

### Contraintes liées aux ressources de fichiers { #webapi_file_resources_constraints } 

  - Les ressources de fichiers *doivent* être référencées (attribuées) à partir d'un autre objet.
    afin d'être conservées à long terme. Une ressource de fichier qui est
    créée mais non référencée par un autre objet, par exemple une valeur de données, est
    est considérée comme étant en *staging*. Toutes les ressources de fichiers dans ce 
    état et datant de plus de *deux heures* seront marqués pour suppression 
    et seront retirées du système.

  - L'ID renvoyé par la création initiale de la ressource de fichier n'est pas 
    récupérable à partir d'un autre emplacement, sauf si la ressource de fichier a 
    été référencée (auquel cas l'ID sera stocké en tant que référence), 
    de sorte que sa perte nécessitera que la requête POST soit répétée et qu'un 
    nouvel objet soit créé. La ressource de fichier *orpheline* sera effacée 
    automatiquement.

  - Les objets de ressources de fichiers sont *immuables*, ce qui signifie qu'ils ne peuvent pas être modifiés 
    et nécessitent plutôt la création d'une ressource entièrement nouvelle.

### Liste noire des ressources de fichiers { #file-resource-blocklist } 

Pour des raisons de sécurité, certains types de fichiers ne peuvent pas être téléchargés.

Les types de contenu suivants sont bloqués.

| Type de contenu | Type de contenu |
| ------------------------------------- | ---- |
| text/html                             | application/x-ms-dos-executable |
| text/css                              | application/vnd.microsoft.portable-executable |
| text/javascript                       | application/vnd.apple.installer+xml |
| font/otf                              | application/vnd.mozilla.xul+xml |
| application/x-shockwave-flash         | application/x-httpd-php  |
| application/vnd.debian.binary-package | application/x-sh |
| application/x-rpm                     | application/x-csh |
| application/java-archive              |  |

Les extensions de fichiers suivantes sont bloquées.

| Extension de fichier | Extension de fichier | Extension de fichier |
| ---- | ---- | ---- |
| html | deb  | xul  |
| htm  | rpm  | php  |
| css  | jar  | bin  |
| js   | jsp  | sh   |
| mjs  | exe  | csh  |
| otf  | msi  | bat  |
| swf  | mpkg |      |

## Versionnage des métadonnées { #webapi_metadata_versioning } 

Cette section explique les API de versionnage des métadonnées.

  - `/api/metadata/version` : Ce point d'extrémité renvoie la version actuelle des métadonnées 
    du système sur lequel il est appelé.



Tableau : Paramètres de requête

| Nom | Obligatoire | Description |
|---|---|---|
| versionName | false | Si ce paramètre n'est pas spécifié, il renvoie la version actuelle du système ou, dans le cas contraire, les détails du nom de version utilisé comme paramètre. (le nom de la version utilise la syntaxe "Version_<id\>"). |

### Obtenir des exemples de versions de métadonnées { #webapi_metadata_versioning_examples } 

**Exemple:** Obtenir la version actuelle des métadonnées de ce système

Requête :

```
/api/metadata/version
```

Réponse :

```json
{
  "name": "Version_4",
  "created": "2016-06-30T06:01:28.684+0000",
  "lastUpdated": "2016-06-30T06:01:28.685+0000",
  "externalAccess": false,
  "displayName": "Version_4",
  "type": "BEST_EFFORT",
  "hashCode": "848bf6edbaf4faeb7d1a1169445357b0",
  "id": "Ayz2AEMB6ry"
}
```

**Exemple:** Obtenir les détails de la version portant le nom "Version_2".

Requête :

```
/api/metadata/version?versionName=Version_2
```

Réponse :

```json
{
  "name": "Version_2",
  "created": "2016-06-30T05:59:33.238+0000",
  "lastUpdated": "2016-06-30T05:59:33.239+0000",
  "externalAccess": false,
  "displayName": "Version_2",
  "type": "BEST_EFFORT",
  "hashCode": "8050fb1a604e29d5566675c86d02d10b",
  "id": "SaNyhusVxBG"
}
```

  - `/api/metadata/version/history` : Ce point d'extrémité renvoie la liste de toutes les
    versions des métadonnées du système sur lequel il est appelé.



Tableau : Paramètres de requête

| Nom | Obligatoire | Description |
|---|---|---|
| baseline | false | Si ce paramètre n'est pas spécifié, la liste de toutes les versions de métadonnées sera renvoyée. Dans le cas contraire, nous devons fournir un paramètre versionName de la forme "Version_<id\>". Il renverra alors la liste des versions présentes dans le système, qui ont été créées après que le nom de la version ait été fourni en tant que paramètre de la requête. |

### Obtenir la liste de toutes les versions de métadonnées { #webapi_get_list_of_metadata_versions } 

**Exemple:** Obtenir la liste de toutes les versions de ce système

Requête :

```
/api/metadata/version/history
```

Réponse :

```json
{
  "metadataversions": [{
    "name": "Version_1",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T05:54:41.139+0000",
    "id": "SjnhUp6r4hG",
    "hashCode": "fd1398ff7ec9fcfd5b59d523c8680798"
  }, {
    "name": "Version_2",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T05:59:33.238+0000",
    "id": "SaNyhusVxBG",
    "hashCode": "8050fb1a604e29d5566675c86d02d10b"
  }, {
    "name": "Version_3",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T06:01:23.680+0000",
    "id": "FVkGzSjAAYg",
    "hashCode": "70b779ea448b0da23d8ae0bd59af6333"
  }]
}
```

**Exemple :** Obtenir la liste de toutes les versions de ce système créées après "Version_2".

Requête :

```
/api/metadata/version/history?baseline=Version_2
```

Réponse :

```json
{
  "metadataversions": [{
    "name": "Version_3",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T06:01:23.680+0000",
    "id": "FVkGzSjAAYg",
    "hashCode": "70b779ea448b0da23d8ae0bd59af6333"
  }, {
    "name": "Version_4",
    "type": "BEST_EFFORT",
    "created": "2016-06-30T06:01:28.684+0000",
    "id": "Ayz2AEMB6ry",
    "hashCode": "848bf6edbaf4faeb7d1a1169445357b0"
  }]
 }
```

  - `/api/metadata/version/create` : Ce point d'extrémité va créer une version de métadonnées
    pour le type de version spécifié dans le paramètre.



Tableau : Paramètres de requête

| Nom | Obligatoire | Description |
|---|---|---|
| type | vrai | Le type de version de métadonnées à créer.<br> * BEST_EFFORT<br> * ATOMIQUE |

Les utilisateurs peuvent sélectionner le type de métadonnées à créer. Le type de version des métadonnées régit la manière dont l'importateur traite la version en question. Ce type sera utilisé lors de l'importation des métadonnées. Il existe deux types de métadonnées.

  - *BEST_EFFORT* : Ce type suggère que les références manquantes peuvent être
    ignorées et l'importateur peut continuer à importer les métadonnées (par exemple,
    les éléments de données manquants lors de l'importation d'un groupe d'éléments de données).

  - *ATOMIQUE* : Ce type garantit une vérification stricte des références de métadonnées 
    et l'importation des métadonnées échouera si l'une des références
    n'existe pas.

> **Remarque**
>
> Il est recommandé d'avoir un type de versions ATOMIQUE pour s'assurer que tous les systèmes (centraux et locaux) aient les mêmes métadonnées.
> Les références manquantes sont prises en compte dans la phase de validation elle-même. Veuillez consulter les
> détails de l'importateur pour obtenir une explication complète.
>

### Création d'une version de métadonnées { #webapi_create_metadata_version } 

**Exemple:** Créer une version de métadonnées du type `BEST_EFFORT`.

Requête :

```bash
curl -X POST -u admin:district "https://play.dhis2.org/dev/api/metadata/version/create?type=BEST_EFFORT"
```

Réponse :

```json
{
  "name": "Version_1",
  "created": "2016-06-30T05:54:41.139+0000",
  "lastUpdated": "2016-06-30T05:54:41.333+0000",
  "externalAccess": false,
  "publicAccess": "--------",
  "user": {
    "name": "John Traore",
    "created": "2013-04-18T17:15:08.407+0000",
    "lastUpdated": "2016-04-06T00:06:06.571+0000",
    "externalAccess": false,
    "displayName": "John Traore",
    "id": "xE7jOejl9FI"
  },
  "displayName": "Version_1",
  "type": "BEST_EFFORT",
  "hashCode": "fd1398ff7ec9fcfd5b59d523c8680798",
  "id": "SjnhUp6r4hG"
}
```

  - `/api/metadata/version/{versionName}/data` : Ce point d'extrémité va télécharger 
    les métadonnées spécifiques au nom de version utilisé comme paramètre du chemin d'accès 
     

  - `/api/metadata/version/{versionName}/data.gz`: Ce point d'extrémité va télécharger 
    les métadonnées spécifiques au nom de version utilisé comme paramètre du chemin d'accès 
    dans un format compressé (gzippé).



Tableau : Paramètres du chemin d'accès

| Nom | Obligatoire | Description |
|---|---|---|
| versionName | vrai | Paramètre de chemin d'accès de la forme "Version_<id\>" pour que l'API télécharge la version spécifique. |

### Téléchargement des métadonnées de la version { #webapi_download_version_metadata } 

**Exemple:** Obtenir les métadonnées pour la "Version 5"

Requête :

```bash
curl -u admin:district "https://play.dhis2.org/dev/api/metadata/version/Version_5/data"
```

Réponse :

```json
{
  "date": "2016-06-30T06:10:23.120+0000",
  "dataElements": [
    {
      "code": "ANC 5th Visit",
      "created": "2016-06-30T06:10:09.870+0000",
      "lastUpdated": "2016-06-30T06:10:09.870+0000",
      "name": "ANC 5th Visit",
      "id": "sCuZKDsix7Y",
      "shortName": "ANC 5th Visit ",
      "aggregationType": "SUM",
      "domainType": "AGGREGATE",
      "zeroIsSignificant": false,
      "valueType": "NUMBER",
      "categoryCombo": {
        "id": "p0KPaWEg3cf"
      },
      "user": {
        "id": "xE7jOejl9FI"
      }
    }
  ]
}
```

## Synchronisation des métadonnées { #webapi_metadata_synchronization } 

Cette section explique l'API de synchronisation des métadonnées disponible à partir de la version 2.24

  - `/api/metadata/sync` : Ce point d'extrémité effectue la synchronisation des métadonnées du 
    nom de la version utilisé dans le paramètre de requête. Cela se fait par le téléchargement et 
    l'importation de la version spécifiée à partir du serveur distant, tel que défini dans 
    l'application de paramétrage.



Tableau : Paramètres de requête

| Nom | Obligatoire | Description |
|---|---|---|
| versionName | vrai | Le paramètre de requête VersionName est de la forme "Version_<id\>" . L'api télécharge cette version depuis le serveur distant et l'importe dans le système local. |

  - Cette API doit être utilisée avec la plus grande prudence. Sachez qu'il existe 
    une autre façon d'effectuer la synchronisation de manière complètement automatisée en 
    s'appuyant sur la tâche de synchronisation des métadonnées à partir de l'application "Administration des données". 
    Voir le chapitre 22, section 22.17 du manuel de l'utilisateur pour plus de détails concernant la 
    tâche de synchronisation des métadonnées.

  - Cette API de synchronisation peut également être utilisée pour synchroniser les métadonnées pour les 
    versions qui ont échoué dans le planificateur de synchronisation des métadonnées. En raison 
    de sa dépendance à un numéro de version de métadonnées spécifique, il convient de faire 
    attention à l'ordre dans lequel cette API est appelée. Par exemple, si cette API est 
    utilisée pour synchroniser une version supérieure à partir de l'instance centrale, 
    la synchronisation peut échouer car les dépendances des métadonnées ne sont pas présentes dans 
    l'instance locale.

  - Supposons que l'instance locale soit à la `Version_12` et que ce point d'extrémité soit utilisé 
    pour synchroniser la `Version_15` (de type `BEST_EFFORT`) depuis l'instance centrale, 
    le planificateur commencera à synchroniser les métadonnées à partir de la 
    `Version_16`. Donc l'instance locale n'aura pas les versions 
    de métadonnées entre la `Version_12` et la `Version_15`. Vous devez synchroniser manuellement 
    les versions manquantes en utilisant uniquement ces points d'extrémité.

### Synchronisation d'une version de métadonnées { #webapi_metadata_synchronization_version } 

**Exemple:** Synchroniser la Version_6 du système central vers ce système

Requête :

```bash
curl -u admin:district "https://play.dhis2.org/dev/api/metadata/sync?versionName=Version_6"
```

## Référentiel de métadonnées { #webapi_metadata_repository } 

DHIS2 fournit un référentiel de métadonnées qui contient des packages de métadonnées avec différents contenus. Un package de métadonnées est un document JSON compatible avec DHIS2 qui décrit un ensemble d'objets de métadonnées.

Pour récupérer un index des packages de métadonnées disponibles, vous pouvez envoyer une requête GET à la ressource *metadataRepo* :

    GET /api/synchronization/metadataRepo

L'entrée d'un paquet de métadonnées contient des informations sur le package et une URL vers le package concerné. Un index pourrait ressembler à ceci :

```json
{
  "packages": [
    {
      "id": "sierre-leone-demo",
      "name": "Sierra Leone demo",
      "description": "Sierra Leone demo database",
      "version": "0.1",
      "href": "https://dhis2.org/metadata-repo/221/sierra-leone-demo/metadata.json"
    },
    {
      "id": "trainingland-org-units",
      "name": "Trainingland organisation units",
      "description": "Trainingland organisation units with four levels",
      "version": "0.1",
      "href": "https://dhis2.org/metadata-repo/221/trainingland-org-units/metadata.json"
    }
  ]
}
```

Un client peut suivre les URL et installer un package de métadonnées via une requête POST de type de contenu *text/plain* et avec le package de métadonnées utilisé comme charge de la ressource *metadataPull* :

    POST /api/synchronization/metadataPull

Voici un exemple de commande curl :

```bash
curl "localhost:8080/api/synchronization/metadataPull" -X POST
  -d "https://dhis2.org/metadata-repo/221/trainingland-org-units/metadata.json"
  -H "Content-Type:text/plain" -u admin:district
```


> **Remarque**
>
> L'URL fournie sera vérifiée par rapport à la propriété de configuration `system.remote_servers_allowed` dans le fichier `dhis.conf`.
> Si l'URL de base n'est pas l'un des serveurs configurés autorisés, l'opération ne sera pas autorisée. Voir l'exemple d'échec ci-dessous.  
> Quelques exemples où le jeu de configuration est `system.remote_servers_allowed=https://server1.org/,https://server2.org/`
> - fournir `https://server1.org/path/to/resource` -> l'opération sera acceptée
> - fournir `https://server2.org/resource/path` -> l'opération sera acceptée
> - fournir `https://oldserver.org/resource/path` -> l'opération sera rejetée
>
Exemple de réponse en cas d'échec

```json
 {
  "httpStatus": "Conflict",
  "httpStatusCode": 409,
  "status": "ERROR",
  "message": "Provided URL is not in the remote servers allowed list",
  "errorCode": "E1004"
}
```


## Référence à la création par l'utilisateur { #reference-to-created-by-user } 

Chaque objet créé dans DHIS2 aura une propriété `user` qui est liée à l'`utilisateur` qui a créé l'objet.

Depuis la version 2.36, nous avons changé le nom de cette propriété en `createdBy` pour éviter toute confusion.

Cependant, afin de conserver la compatibilité rétroactive, l'ancienne propriété `user` est toujours incluse dans la charge et fonctionne normalement comme auparavant.

```json
{
  "createdBy": {
      "displayName": "John Kamara",
      "name": "John Kamara",
      "id": "N3PZBUlN8vq",
      "username": "district"
  },
  "user": {
      "displayName": "John Kamara",
      "name": "John Kamara",
      "id": "N3PZBUlN8vq",
      "username": "district"
  }
}
```

## Propositions pour les métadonnées { #webapi_metadata_proposal_workflow }

Le point d'extrémité des propositions pour les métadonnées permet de proposer et d'accepter des modifications sur les métadonnées.

```
/api/metadata/proposals
```

### Proposition d'une modification sur des métadonnées { #webapi_metadata_proposal_propose }

Une proposition vise toujours un seul objet de métadonnées. La requête suivante peut être utilisée :

    POST /api/metadata/proposals

En fonction de la charge, la proposition peut :

* Ajouter un nouvel objet de métadonnées.
* Mettre à jour les références d'un objet de métadonnées existant par le biais de l'ID.
* Supprimer un objet de métadonnées existant référencé par un ID.

Pour proposer l'ajout d'un nouvel objet de métadonnées, envoyez une charge JSON comme celle-ci :

```json
{
  "type": "ADD",
  "target": "ORGANISATION_UNIT",
  "change": {"name":"My Unit", "shortName":"MyOU", "openingDate": "2020-01-01"}
}
```
La propriété `change` contient le même objet JSON qui peut être directement envoyé au point d'extrémité de création de l'objet.

Pour proposer la mise à jour d'un objet de métadonnées existant, envoyez une charge JSON comme dans l'exemple ci-dessous :

```json
{
  "type": "UPDATE",
  "target": "ORGANISATION_UNIT",
  "targetId": "<id>",
  "change": [
    {"op": "replace", "path": "/name", "value": "New name"}
  ]
}
```
La propriété `targetId` fait référence à l'ID de l'objet qui doit être mis à jour. La propriété `change` contient ici une charge de patch JSON. Il s'agit de la même charge de patch qui peut être envoyée au point d'extrémité correspondant pour appliquer directement la mise à jour.

Pour proposer la suppression d'un objet existant, envoyez une charge comme dans le dernier exemple :

```json
{
  "type": "REMOVE",
  "target": "ORGANISATION_UNIT",
  "targetId": "<id>"
}
```
La propriété `targetId` fait référence à l'ID de l'objet qui doit être supprimé. Un `commentaire` en texte libre peut être ajouté à n'importe quel type de commentaire.

Seul le type de `cible` `ORGANISATION_UNIT` est actuellement pris en charge.

### Acceptation d'une proposition de modification de métadonnées { #webapi_metadata_proposal_accept }
Pour accepter une proposition ouverte, envoyez une requête `POST` à la ressource des propositions.

    POST /api/metadata/proposals/<uid>

En cas de succès, le statut de la proposition passe à `ACCEPTED` (acceptée). Une fois acceptée, la proposition ne peut plus être rejetée.

Si une proposition ne s'applique pas, le statut passe à `NEEDS_UPDATE` (besoin de mise à jour). Le champ `reason` contient un résumé des échecs lorsque cette information est disponible.

### Refus d'une proposition de modification de métadonnées { #webapi_metadata_proposal_oppose }
Si une proposition n'est pas tout à fait correcte et doit être ajustée, vous pouvez effectuer une requête `PATCH` sur la ressource des propositions.

    PATCH /api/metadata/proposals/<uid>

En option, un texte simple peut être ajouté pour fournir une `raison` au refus de la proposition.

Une proposition refusée doit avoir au préalable le statut `PROPOSED` (proposée) avant de passer à `NEEDS_UPDATE`.

### Ajustement d'une proposition de modification de métadonnées { #webapi_metadata_proposal_adjust }
Une proposition au statut `NEEDS_UPDATE` doit être ajustée avant d'être acceptée. Pour ajuster la proposition, une requête `PUT` est faite pour la ressource.

    PUT /api/metadata/proposals/<uid>

Un tel ajustement peut être effectué soit sans corps, soit avec un corps JSON contenant un objet dont les propriétés `change` et `targetId` sont mises à jour pour l'ajustement :

```json
{
  "targetId": "<id>",
  "change": ...
}
```
Le type JSON de la valeur `change` dépend du `type` de la proposition, de la même manière que lorsqu'une proposition est initialement faite.

### Rejet d'une proposition de modification de métadonnées { #webapi_metadata_proposal_reject }
Pour rejeter une proposition ouverte, envoyez une requête `DELETE` à la ressource des propositions.

    DELETE /api/metadata/proposals/<uid>

Le statut de la proposition devient alors `REJECTED` (rejetée). Aucune autre modification ne peut être apportée à cette proposition. Elle est conservée comme documentation des événements.

### Listage des propositions de modification de métadonnées { #webapi_metadata_proposal_list }
Toutes les propositions peuvent être listées :

    GET /api/metadata/proposals/

La liste des résultats peut être filtrée à l'aide du paramètre `filter`. Par exemple, pour ne lister que les propositions acceptées, faites la requête suivante :

    GET /api/metadata/proposals?filter=status:eq:ACCEPTED

De même, pour ne montrer que les propositions ouvertes, utilisez ceci :

    GET /api/metadata/proposals?filter=status:eq:PROPOSED

Les filtres peuvent également être appliqués à n'importe quel champ, à l'exception du champ `change`. Les opérateurs de filtre pris en charge sont ceux décrits dans l'API Gist Metadata. Cela inclut également les transformateurs de propriétés décrits dans l'API Gist.

Voici une liste des champs disponibles :

| Champ       | Description |
| ----------- | -------------------------------------------------------------- |
| id          | identifiant unique de la proposition |
| type        | `ADD` (ajouter un nouvel objet, `UPDATE` (mettre à jour) un objet existant, `REMOVE` (supprimer) un objet existant |
| status      | `PROPOSED` (proposition ouverte), `ACCEPTED` (succès), `NEEDS_UPDATE` (l'acceptation à causé une erreur ou a été refusée), `REJECTED` (rejet) |
| cible      | type d'objet de métadonnées à ajouter/mettre à jour/supprimer. Actuellement, seul `ORGANISATION_UNIT` peut être utilisé. |
| targetId (id de la cible)    | UID de l'objet mis à jour ou supprimé. Il n'est pas défini pour la fonction `ADD` |
| createdBy (créé par)   | l'utilisateur qui a créé la proposition |
| created     | la date et l'heure de création de la proposition |
| finalisedBy | l'utilisateur qui a accepté ou rejeté la proposition |
| finalisé   | la date et l'heure auxquelles la proposition a été acceptée ou rejetée. |
| commentaire     | commentaire en texte simple facultatif donné pour la proposition initiale |
| raison      | texte simple facultatif fourni lorsque la proposition a été refusée ou que des erreurs sont survenues lors de l'acceptation d'une proposition | 
| change      | Objet JSON pour la proposition `ADD`, tableau JSON pour la proposition `UPDATE`, rien pour la proposition `REMOVE`. |

### Visualisation des propositions de modification de métadonnées { #webapi_metadata_proposal_show }
Les propositions de modification d'objets individuels peuvent être consultées à l'aide de 

    GET /api/metadata/proposals/<uid>

Le paramètre `fields` peut être utilisé pour restreindre les champs inclus dans l'objet affiché. Par exemple :

    GET /api/metadata/proposals/<uid>?fields=id,type,status,change

## Metadata Attribute Value Type and validations { #metadata-attribute-value-type-and-validations } 
| Type | Validation
|---| --- |
| TEXT | Aucun
| LONG_TEXT (texte long) | Aucun
| LETTRE | Longueur de la valeur = 1 ET il s'agit d'une lettre
| NUMÉRO_DE TÉLÉPHONE  | La validation est basée sur cette expression rationnelle `^[0-9+\\N-(\N-)#\N.\Ns\N/ext-]{6,50}$`. La longueur maximale est de 50.  <br /> Exemples : +4733987937, (+47) 3398 7937, (47) 3398 7937.123
| EMAIL | Format général des email : abc@email.com
| BOOLEAN | `vrai` or `faux`
| TRUE_ONLY (vrai uniquement) | N'accepte que `true`
| DATE | Utiliser le format `yyyy-MM-dd`
| DATETIME (date et heure) | Utiliser le format `yyyy-MM-dd HH:mm:ssZ` ou `yyyy-MM-dd 'T'HH:mm:ss`
| TEMPS | Utiliser le format `HH:mm`
| NUMBER | La valeur doit être numérique avec une longueur maximale = 250
| UNIT_INTERVAL | La valeur est numérique et comprise entre 0 et 1.
| PERCENTAGE | La valeur est un nombre compris entre 0 et 100.
| INTEGER | La valeur est un nombre entier
| INTEGER_POSITIVE | La valeur est un nombre entier positif
| INTEGER_NEGATIVE | La valeur est un nombre entier négatif
| INTEGER_ZERO_OR_POSITIVE | La valeur est un entier positif ou nul
| TRACKER_ASSOCIÉ | Aucun
| NOM D'UTILISATEUR | La valeur est un nom d'utilisateur pour un `utilisateur` existant
| COORDONNÉE | Aucun
| ORGANISATION_UNIT | La valeur est un UID valide d'une `unité d'organisation` existante
| RÉFÉRENCE | Aucun
| ÂGE | La valeur est une date de naissance. Utiliser le même format que pour le type DATE.
| URL | La valeur est une URL valide
| FILE_RESOURCE | La valeur est un UID valide d'une `ressource de fichier` existante
| IMAGE | La valeur est un UID valide d'une `ressource de fichier` existante
| GEOJSON |Suivre [Spécification GeoJson] (https://geojson.org)
| MULTI_TEXT | Aucun

## Copie de programmes { #copy-program } 

### Introduction { #introduction } 

Souvent, les utilisateurs veulent créer de nombreux `Programmes` qui partagent les mêmes caractéristiques. Au lieu de créer un nouveau `Programme` de A à Z, ils peuvent copier un `Programme` existant et lui apporter des modifications. 
En théorie, un `Programme` modèle peut être créé et être utilisé pour effectuer ces copies, ce qui peut également aider à rendre les `Programmes` cohérents.

### Informations sur l'API { #api-info } 

#### Point d'extrémité{ #endpoint } 

    POST /api/programs/{uid}/copy

Exemple avec un `Programme` dont l'`UID` est `Program123a`

    POST /api/programs/Program123a/copy

En cas de succès, la réponse contiendra un nouveau `UID` de `Programme` et ressemblera à ceci :

```json
{
    "httpStatus": "Created",
    "httpStatusCode": 201,
    "status": "OK",
    "message": "Program created: 'Program456b'"
}
```

La réponse contiendra également un en-tête `Location` (emplacement) avec un lien vers le `Programme` nouvellement créé. Par exemple, si le programme est exécuté localement, la valeur de `Location` sera `http://localhost:9090/api/programs/Program456b`.

#### Options de copie { #copy-options } 

L'API permet d'utiliser un préfixe personnalisé à titre facultatif, lequel sera ajouté aux propriétés suivantes.

| Objet           | Propriété  | Information                                     |
|------------------|-----------|------------------------------------------|
| Programme          | name      | Aider à identifier le nouveau programme            |
| Indicateur de programme | name      | Contrainte de base de données - doit être unique |
| Indicateur de programme | Nom court | Contrainte de base de données - doit être unique |

Dans cet exemple, lorsqu'un préfixe personnalisé est fourni, un `Programme` original portant le nom `Mon Programme Simple` sera copié dans un nouveau `Programme` portant le nom `mon préfixe Mon Programme Simple` 

Si aucune option de copie n'est envoyée dans l'appel API, alors le préfixe par défaut `Copy of ` (copie de) sera utilisé pour les propriétés ci-dessus. 
Pour envoyer un préfixe personnalisé, il suffit d'ajouter un paramètre de requête HTTP `prefix` comme suit : 

     POST /api/programs/{uid}/copy?prefix=my prefix 

> **Note**
>
> La base de données fixe des limites au nombre de caractères autorisés pour les propriétés. Au moment de la rédaction de ces propriétés, les limites seront indiquées dans le tableau ci-dessous. Gardez-les à l'esprit.

| Propriété  | limite de caractères |
|-----------|-----------------|
| name      | 230             |
| Nom court | 50              |

Si une propriété a dépassé sa limite de caractères, une message d'erreur sera renvoyée comme suit :

```json
{
    "httpStatus": "Conflict",
    "httpStatusCode": 409,
    "status": "ERROR",
    "message": "ERROR: value too long for type character varying(230)",
    "errorCode": "E1004"
}
```

Si l'utilisateur essaie de copier un programme qui n'est pas trouvé, une réponse de ce type sera renvoyée :
```json
{
    "httpStatus": "Not Found",
    "httpStatusCode": 404,
    "status": "ERROR",
    "message": "Program with id {uid} could not be found.",
    "errorCode": "E1005"
}
```

### Autorisation { #authorisation } 

#### Autorités { #authorities } 

Un `Utilisateur` aura besoin des autorisations suivantes pour pouvoir copier un `Programme` :

- F_PROGRAM_PUBLIC_ADD
- F_PROGRAM_INDICATOR_PUBLIC_ADD

#### Accès { #access } 

Un `Programme` doit avoir un des statuts suivants pour pouvoir être copié :

- Accès public en `lecture` et en `écriture`
- Un `Utilisateur` spécifique autorisé à partager les accès en `lecture` et en `écriture`.
- Un `utilisateur` faisant partie d'un `groupe d'utilisateurs` et qui est autorisé à partager les accès en `lecture` et en `écriture`.

Si un `utilisateur` n'a pas les bonnes autorisations, une réponse `Forbidden` (d'interdiction) est renvoyée comme suit :

```json
{
    "httpStatus": "Forbidden",
    "httpStatusCode": 403,
    "status": "ERROR",
    "message": "You don't have write permissions for Program Program123a",
    "errorCode": "E1006"
}
```

### Points à noter { #points-to-note } 

#### Copie profonde et copie superficielle { #deep-and-shallow-copy } 

Lorsqu'un `Programme` est copié, certaines propriétés du `Programme` nécessitent des types de copie différents. Il est important de savoir ce qui a été copié en profondeur et ce qui a été copié superficiellement.  
Tout d'abord, expliquons la différence entre la copie profonde et la copie superficielle dans ce contexte.  

##### Copie profonde { #deep-copy } 

Dans ce contexte, une copie profonde signifie qu'une instance entièrement nouvelle d'un `Programme` ou d'une propriété de `Programme` a été créée avec ses propres identifiants uniques. Il s'agit entre autres de :

- id
- uid  

Les copies profondes des propriétés de `programme` feront toutes partie de la copie du `programme` nouvellement créée.

##### Copie superficielle { #shallow-copy } 

Dans ce contexte, une copie superficielle signifie qu'une propriété de `programme` existante sera réutilisée par le `programme` ou la propriété de `programme` nouvellement créé(e).

#### Propriétés qui ont été copiées en profondeur { #properties-that-get-deep-copied } 

Toutes les propriétés ci-dessous ont été copiées en profondeur. Si une propriété ne figure pas dans ce tableau, cela signifie qu'elle a été copié superficiellement.

| Objet                         | Propriété de  |
|--------------------------------|--------------|
| Programme                        |              |
| Section de programme                 | Programme      |
| Indicateur de programme               | Programme      |
| Variable de règle de programme            | Programme      |
| Étape de programme                   | Programme      |
| Section d'une étape de programme            | Étape de programme |
| Élément de données d'une section d'étape de programme | Étape de programme |
| Inscription                     |              |

> **Remarque**
>
> Les propriétés suivantes ont été définies comme vides dans une première approche. Cette approche devrait permettre de simplifier les choses pour commencer.  

| Objet                        | Propriété          |
|-------------------------------|-------------------|
| Indicateur de programme              | groupes            |
| Section d'une étape de programme           | Indicateurs de programme |
| Inscription                    | events            |

